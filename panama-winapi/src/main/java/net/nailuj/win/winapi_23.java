// Generated by jextract

package net.nailuj.win;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class winapi_23 extends winapi_24 {

    winapi_23() {
        // Should not be called directly
    }

    private static class SetSystemPowerState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetSystemPowerState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static FunctionDescriptor SetSystemPowerState$descriptor() {
        return SetSystemPowerState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static MethodHandle SetSystemPowerState$handle() {
        return SetSystemPowerState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static MemorySegment SetSystemPowerState$address() {
        return SetSystemPowerState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static int SetSystemPowerState(int fSuspend, int fForce) {
        var mh$ = SetSystemPowerState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemPowerState", fSuspend, fForce);
            }
            return (int)mh$.invokeExact(fSuspend, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_POWER_STATUS {
     *     BYTE ACLineStatus;
     *     BYTE BatteryFlag;
     *     BYTE BatteryLifePercent;
     *     BYTE SystemStatusFlag;
     *     DWORD BatteryLifeTime;
     *     DWORD BatteryFullLifeTime;
     * } *LPSYSTEM_POWER_STATUS
     * }
     */
    public static final AddressLayout LPSYSTEM_POWER_STATUS = winapi.C_POINTER;

    private static class GetSystemPowerStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetSystemPowerStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static FunctionDescriptor GetSystemPowerStatus$descriptor() {
        return GetSystemPowerStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static MethodHandle GetSystemPowerStatus$handle() {
        return GetSystemPowerStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static MemorySegment GetSystemPowerStatus$address() {
        return GetSystemPowerStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static int GetSystemPowerStatus(MemorySegment lpSystemPowerStatus) {
        var mh$ = GetSystemPowerStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPowerStatus", lpSystemPowerStatus);
            }
            return (int)mh$.invokeExact(lpSystemPowerStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapUserPhysicalPagesScatter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("MapUserPhysicalPagesScatter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor MapUserPhysicalPagesScatter$descriptor() {
        return MapUserPhysicalPagesScatter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle MapUserPhysicalPagesScatter$handle() {
        return MapUserPhysicalPagesScatter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MemorySegment MapUserPhysicalPagesScatter$address() {
        return MapUserPhysicalPagesScatter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int MapUserPhysicalPagesScatter(MemorySegment VirtualAddresses, long NumberOfPages, MemorySegment PageArray) {
        var mh$ = MapUserPhysicalPagesScatter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapUserPhysicalPagesScatter", VirtualAddresses, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(VirtualAddresses, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateJobObjectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateJobObjectA$descriptor() {
        return CreateJobObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateJobObjectA$handle() {
        return CreateJobObjectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectA$address() {
        return CreateJobObjectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectA(MemorySegment lpJobAttributes, MemorySegment lpName) {
        var mh$ = CreateJobObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobObjectA", lpJobAttributes, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpJobAttributes, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenJobObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenJobObjectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenJobObjectA$descriptor() {
        return OpenJobObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenJobObjectA$handle() {
        return OpenJobObjectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectA$address() {
        return OpenJobObjectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenJobObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenJobObjectA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateJobSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateJobSet$descriptor() {
        return CreateJobSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static MethodHandle CreateJobSet$handle() {
        return CreateJobSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static MemorySegment CreateJobSet$address() {
        return CreateJobSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static int CreateJobSet(int NumJob, MemorySegment UserJobSet, int Flags) {
        var mh$ = CreateJobSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobSet", NumJob, UserJobSet, Flags);
            }
            return (int)mh$.invokeExact(NumJob, UserJobSet, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstVolumeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeA$descriptor() {
        return FindFirstVolumeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeA$handle() {
        return FindFirstVolumeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeA$address() {
        return FindFirstVolumeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeA(MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindFirstVolumeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeA", lpszVolumeName, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNextVolumeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeA$descriptor() {
        return FindNextVolumeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeA$handle() {
        return FindNextVolumeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeA$address() {
        return FindNextVolumeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeA(MemorySegment hFindVolume, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindNextVolumeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeA", hFindVolume, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolume, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeMountPointA$descriptor() {
        return FindFirstVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeMountPointA$handle() {
        return FindFirstVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointA$address() {
        return FindFirstVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointA(MemorySegment lpszRootPathName, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindFirstVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeMountPointA", lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeMountPointW$descriptor() {
        return FindFirstVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeMountPointW$handle() {
        return FindFirstVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointW$address() {
        return FindFirstVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointW(MemorySegment lpszRootPathName, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindFirstVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeMountPointW", lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNextVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeMountPointA$descriptor() {
        return FindNextVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeMountPointA$handle() {
        return FindNextVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeMountPointA$address() {
        return FindNextVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeMountPointA(MemorySegment hFindVolumeMountPoint, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindNextVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeMountPointA", hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNextVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeMountPointW$descriptor() {
        return FindNextVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeMountPointW$handle() {
        return FindNextVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeMountPointW$address() {
        return FindNextVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeMountPointW(MemorySegment hFindVolumeMountPoint, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindNextVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeMountPointW", hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindVolumeMountPointClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindVolumeMountPointClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor FindVolumeMountPointClose$descriptor() {
        return FindVolumeMountPointClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static MethodHandle FindVolumeMountPointClose$handle() {
        return FindVolumeMountPointClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static MemorySegment FindVolumeMountPointClose$address() {
        return FindVolumeMountPointClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static int FindVolumeMountPointClose(MemorySegment hFindVolumeMountPoint) {
        var mh$ = FindVolumeMountPointClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindVolumeMountPointClose", hFindVolumeMountPoint);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeMountPointA$descriptor() {
        return SetVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static MethodHandle SetVolumeMountPointA$handle() {
        return SetVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static MemorySegment SetVolumeMountPointA$address() {
        return SetVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static int SetVolumeMountPointA(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName) {
        var mh$ = SetVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeMountPointA", lpszVolumeMountPoint, lpszVolumeName);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeMountPointW$descriptor() {
        return SetVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static MethodHandle SetVolumeMountPointW$handle() {
        return SetVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static MemorySegment SetVolumeMountPointW$address() {
        return SetVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static int SetVolumeMountPointW(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName) {
        var mh$ = SetVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeMountPointW", lpszVolumeMountPoint, lpszVolumeName);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor DeleteVolumeMountPointA$descriptor() {
        return DeleteVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static MethodHandle DeleteVolumeMountPointA$handle() {
        return DeleteVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static MemorySegment DeleteVolumeMountPointA$address() {
        return DeleteVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static int DeleteVolumeMountPointA(MemorySegment lpszVolumeMountPoint) {
        var mh$ = DeleteVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteVolumeMountPointA", lpszVolumeMountPoint);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeNameForVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetVolumeNameForVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumeNameForVolumeMountPointA$descriptor() {
        return GetVolumeNameForVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumeNameForVolumeMountPointA$handle() {
        return GetVolumeNameForVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumeNameForVolumeMountPointA$address() {
        return GetVolumeNameForVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumeNameForVolumeMountPointA(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = GetVolumeNameForVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeNameForVolumeMountPointA", lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetVolumePathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNameA$descriptor() {
        return GetVolumePathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumePathNameA$handle() {
        return GetVolumePathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumePathNameA$address() {
        return GetVolumePathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumePathNameA(MemorySegment lpszFileName, MemorySegment lpszVolumePathName, int cchBufferLength) {
        var mh$ = GetVolumePathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNameA", lpszFileName, lpszVolumePathName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszFileName, lpszVolumePathName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNamesForVolumeNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetVolumePathNamesForVolumeNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNamesForVolumeNameA$descriptor() {
        return GetVolumePathNamesForVolumeNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MethodHandle GetVolumePathNamesForVolumeNameA$handle() {
        return GetVolumePathNamesForVolumeNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MemorySegment GetVolumePathNamesForVolumeNameA$address() {
        return GetVolumePathNamesForVolumeNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static int GetVolumePathNamesForVolumeNameA(MemorySegment lpszVolumeName, MemorySegment lpszVolumePathNames, int cchBufferLength, MemorySegment lpcchReturnLength) {
        var mh$ = GetVolumePathNamesForVolumeNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNamesForVolumeNameA", lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
            }
            return (int)mh$.invokeExact(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTXA {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     LPCSTR lpSource;
     *     USHORT wProcessorArchitecture;
     *     LANGID wLangId;
     *     LPCSTR lpAssemblyDirectory;
     *     LPCSTR lpResourceName;
     *     LPCSTR lpApplicationName;
     *     HMODULE hModule;
     * } *PACTCTXA
     * }
     */
    public static final AddressLayout PACTCTXA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTXW {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     LPCWSTR lpSource;
     *     USHORT wProcessorArchitecture;
     *     LANGID wLangId;
     *     LPCWSTR lpAssemblyDirectory;
     *     LPCWSTR lpResourceName;
     *     LPCWSTR lpApplicationName;
     *     HMODULE hModule;
     * } *PACTCTXW
     * }
     */
    public static final AddressLayout PACTCTXW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PACTCTXA PACTCTX
     * }
     */
    public static final AddressLayout PACTCTX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTXA *PCACTCTXA
     * }
     */
    public static final AddressLayout PCACTCTXA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTXW *PCACTCTXW
     * }
     */
    public static final AddressLayout PCACTCTXW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCACTCTXA PCACTCTX
     * }
     */
    public static final AddressLayout PCACTCTX = winapi.C_POINTER;

    private static class CreateActCtxA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateActCtxA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static FunctionDescriptor CreateActCtxA$descriptor() {
        return CreateActCtxA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MethodHandle CreateActCtxA$handle() {
        return CreateActCtxA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxA$address() {
        return CreateActCtxA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxA(MemorySegment pActCtx) {
        var mh$ = CreateActCtxA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateActCtxA", pActCtx);
            }
            return (MemorySegment)mh$.invokeExact(pActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateActCtxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateActCtxW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static FunctionDescriptor CreateActCtxW$descriptor() {
        return CreateActCtxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MethodHandle CreateActCtxW$handle() {
        return CreateActCtxW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxW$address() {
        return CreateActCtxW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxW(MemorySegment pActCtx) {
        var mh$ = CreateActCtxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateActCtxW", pActCtx);
            }
            return (MemorySegment)mh$.invokeExact(pActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddRefActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddRefActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor AddRefActCtx$descriptor() {
        return AddRefActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle AddRefActCtx$handle() {
        return AddRefActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static MemorySegment AddRefActCtx$address() {
        return AddRefActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static void AddRefActCtx(MemorySegment hActCtx) {
        var mh$ = AddRefActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddRefActCtx", hActCtx);
            }
            mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReleaseActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor ReleaseActCtx$descriptor() {
        return ReleaseActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle ReleaseActCtx$handle() {
        return ReleaseActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static MemorySegment ReleaseActCtx$address() {
        return ReleaseActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static void ReleaseActCtx(MemorySegment hActCtx) {
        var mh$ = ReleaseActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseActCtx", hActCtx);
            }
            mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZombifyActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ZombifyActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor ZombifyActCtx$descriptor() {
        return ZombifyActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle ZombifyActCtx$handle() {
        return ZombifyActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static MemorySegment ZombifyActCtx$address() {
        return ZombifyActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static int ZombifyActCtx(MemorySegment hActCtx) {
        var mh$ = ZombifyActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZombifyActCtx", hActCtx);
            }
            return (int)mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ActivateActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ActivateActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static FunctionDescriptor ActivateActCtx$descriptor() {
        return ActivateActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static MethodHandle ActivateActCtx$handle() {
        return ActivateActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static MemorySegment ActivateActCtx$address() {
        return ActivateActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static int ActivateActCtx(MemorySegment hActCtx, MemorySegment lpCookie) {
        var mh$ = ActivateActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ActivateActCtx", hActCtx, lpCookie);
            }
            return (int)mh$.invokeExact(hActCtx, lpCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeactivateActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeactivateActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static FunctionDescriptor DeactivateActCtx$descriptor() {
        return DeactivateActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static MethodHandle DeactivateActCtx$handle() {
        return DeactivateActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static MemorySegment DeactivateActCtx$address() {
        return DeactivateActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static int DeactivateActCtx(int dwFlags, long ulCookie) {
        var mh$ = DeactivateActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeactivateActCtx", dwFlags, ulCookie);
            }
            return (int)mh$.invokeExact(dwFlags, ulCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrentActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static FunctionDescriptor GetCurrentActCtx$descriptor() {
        return GetCurrentActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static MethodHandle GetCurrentActCtx$handle() {
        return GetCurrentActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static MemorySegment GetCurrentActCtx$address() {
        return GetCurrentActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static int GetCurrentActCtx(MemorySegment lphActCtx) {
        var mh$ = GetCurrentActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentActCtx", lphActCtx);
            }
            return (int)mh$.invokeExact(lphActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
     *     ULONG cbSize;
     *     ULONG ulDataFormatVersion;
     *     PVOID lpData;
     *     ULONG ulLength;
     *     PVOID lpSectionGlobalData;
     *     ULONG ulSectionGlobalDataLength;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionTotalLength;
     *     HANDLE hActCtx;
     *     ULONG ulAssemblyRosterIndex;
     * } *PACTCTX_SECTION_KEYED_DATA_2600
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA_2600 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA_2600 *PCACTCTX_SECTION_KEYED_DATA_2600
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA_2600 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
     *     PVOID lpInformation;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionLength;
     *     PVOID lpSectionGlobalDataBase;
     *     ULONG ulSectionGlobalDataLength;
     * } *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA {
     *     ULONG cbSize;
     *     ULONG ulDataFormatVersion;
     *     PVOID lpData;
     *     ULONG ulLength;
     *     PVOID lpSectionGlobalData;
     *     ULONG ulSectionGlobalDataLength;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionTotalLength;
     *     HANDLE hActCtx;
     *     ULONG ulAssemblyRosterIndex;
     *     ULONG ulFlags;
     *     ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
     * } *PACTCTX_SECTION_KEYED_DATA
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA *PCACTCTX_SECTION_KEYED_DATA
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA = winapi.C_POINTER;

    private static class FindActCtxSectionStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindActCtxSectionStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionStringA$descriptor() {
        return FindActCtxSectionStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionStringA$handle() {
        return FindActCtxSectionStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MemorySegment FindActCtxSectionStringA$address() {
        return FindActCtxSectionStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionStringA(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpStringToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionStringA", dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindActCtxSectionStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindActCtxSectionStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionStringW$descriptor() {
        return FindActCtxSectionStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionStringW$handle() {
        return FindActCtxSectionStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MemorySegment FindActCtxSectionStringW$address() {
        return FindActCtxSectionStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionStringW(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpStringToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionStringW", dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindActCtxSectionGuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindActCtxSectionGuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionGuid$descriptor() {
        return FindActCtxSectionGuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionGuid$handle() {
        return FindActCtxSectionGuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MemorySegment FindActCtxSectionGuid$address() {
        return FindActCtxSectionGuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionGuid(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpGuidToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionGuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionGuid", dwFlags, lpExtensionGuid, ulSectionId, lpGuidToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpGuidToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
     *     HANDLE hActCtx;
     *     DWORD dwFlags;
     * } *PACTIVATION_CONTEXT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_BASIC_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
     *     HANDLE hActCtx;
     *     DWORD dwFlags;
     * } *PCACTIVATION_CONTEXT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_BASIC_INFORMATION = winapi.C_POINTER;

    private static class QueryActCtxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueryActCtxW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static FunctionDescriptor QueryActCtxW$descriptor() {
        return QueryActCtxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static MethodHandle QueryActCtxW$handle() {
        return QueryActCtxW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static MemorySegment QueryActCtxW$address() {
        return QueryActCtxW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static int QueryActCtxW(int dwFlags, MemorySegment hActCtx, MemorySegment pvSubInstance, int ulInfoClass, MemorySegment pvBuffer, long cbBuffer, MemorySegment pcbWrittenOrRequired) {
        var mh$ = QueryActCtxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryActCtxW", dwFlags, hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
            }
            return (int)mh$.invokeExact(dwFlags, hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSGetActiveConsoleSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("WTSGetActiveConsoleSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static FunctionDescriptor WTSGetActiveConsoleSessionId$descriptor() {
        return WTSGetActiveConsoleSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static MethodHandle WTSGetActiveConsoleSessionId$handle() {
        return WTSGetActiveConsoleSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static MemorySegment WTSGetActiveConsoleSessionId$address() {
        return WTSGetActiveConsoleSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static int WTSGetActiveConsoleSessionId() {
        var mh$ = WTSGetActiveConsoleSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSGetActiveConsoleSessionId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSGetServiceSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("WTSGetServiceSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static FunctionDescriptor WTSGetServiceSessionId$descriptor() {
        return WTSGetServiceSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static MethodHandle WTSGetServiceSessionId$handle() {
        return WTSGetServiceSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static MemorySegment WTSGetServiceSessionId$address() {
        return WTSGetServiceSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static int WTSGetServiceSessionId() {
        var mh$ = WTSGetServiceSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSGetServiceSessionId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSIsServerContainer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR    );

        public static final MemorySegment ADDR = winapi.findOrThrow("WTSIsServerContainer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static FunctionDescriptor WTSIsServerContainer$descriptor() {
        return WTSIsServerContainer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static MethodHandle WTSIsServerContainer$handle() {
        return WTSIsServerContainer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static MemorySegment WTSIsServerContainer$address() {
        return WTSIsServerContainer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static byte WTSIsServerContainer() {
        var mh$ = WTSIsServerContainer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSIsServerContainer");
            }
            return (byte)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveProcessorGroupCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetActiveProcessorGroupCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static FunctionDescriptor GetActiveProcessorGroupCount$descriptor() {
        return GetActiveProcessorGroupCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static MethodHandle GetActiveProcessorGroupCount$handle() {
        return GetActiveProcessorGroupCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static MemorySegment GetActiveProcessorGroupCount$address() {
        return GetActiveProcessorGroupCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static short GetActiveProcessorGroupCount() {
        var mh$ = GetActiveProcessorGroupCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveProcessorGroupCount");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMaximumProcessorGroupCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetMaximumProcessorGroupCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static FunctionDescriptor GetMaximumProcessorGroupCount$descriptor() {
        return GetMaximumProcessorGroupCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static MethodHandle GetMaximumProcessorGroupCount$handle() {
        return GetMaximumProcessorGroupCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static MemorySegment GetMaximumProcessorGroupCount$address() {
        return GetMaximumProcessorGroupCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static short GetMaximumProcessorGroupCount() {
        var mh$ = GetMaximumProcessorGroupCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMaximumProcessorGroupCount");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveProcessorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_SHORT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetActiveProcessorCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static FunctionDescriptor GetActiveProcessorCount$descriptor() {
        return GetActiveProcessorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static MethodHandle GetActiveProcessorCount$handle() {
        return GetActiveProcessorCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static MemorySegment GetActiveProcessorCount$address() {
        return GetActiveProcessorCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static int GetActiveProcessorCount(short GroupNumber) {
        var mh$ = GetActiveProcessorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveProcessorCount", GroupNumber);
            }
            return (int)mh$.invokeExact(GroupNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMaximumProcessorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_SHORT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetMaximumProcessorCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static FunctionDescriptor GetMaximumProcessorCount$descriptor() {
        return GetMaximumProcessorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static MethodHandle GetMaximumProcessorCount$handle() {
        return GetMaximumProcessorCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static MemorySegment GetMaximumProcessorCount$address() {
        return GetMaximumProcessorCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static int GetMaximumProcessorCount(short GroupNumber) {
        var mh$ = GetMaximumProcessorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMaximumProcessorCount", GroupNumber);
            }
            return (int)mh$.invokeExact(GroupNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProcessorNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_CHAR,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumaProcessorNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProcessorNode$descriptor() {
        return GetNumaProcessorNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProcessorNode$handle() {
        return GetNumaProcessorNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProcessorNode$address() {
        return GetNumaProcessorNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static int GetNumaProcessorNode(byte Processor, MemorySegment NodeNumber) {
        var mh$ = GetNumaProcessorNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProcessorNode", Processor, NodeNumber);
            }
            return (int)mh$.invokeExact(Processor, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeNumberFromHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumaNodeNumberFromHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaNodeNumberFromHandle$descriptor() {
        return GetNumaNodeNumberFromHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaNodeNumberFromHandle$handle() {
        return GetNumaNodeNumberFromHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static MemorySegment GetNumaNodeNumberFromHandle$address() {
        return GetNumaNodeNumberFromHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaNodeNumberFromHandle(MemorySegment hFile, MemorySegment NodeNumber) {
        var mh$ = GetNumaNodeNumberFromHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeNumberFromHandle", hFile, NodeNumber);
            }
            return (int)mh$.invokeExact(hFile, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProcessorNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumaProcessorNodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProcessorNodeEx$descriptor() {
        return GetNumaProcessorNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProcessorNodeEx$handle() {
        return GetNumaProcessorNodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProcessorNodeEx$address() {
        return GetNumaProcessorNodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaProcessorNodeEx(MemorySegment Processor, MemorySegment NodeNumber) {
        var mh$ = GetNumaProcessorNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProcessorNodeEx", Processor, NodeNumber);
            }
            return (int)mh$.invokeExact(Processor, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeProcessorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_CHAR,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumaNodeProcessorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static FunctionDescriptor GetNumaNodeProcessorMask$descriptor() {
        return GetNumaNodeProcessorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static MethodHandle GetNumaNodeProcessorMask$handle() {
        return GetNumaNodeProcessorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static MemorySegment GetNumaNodeProcessorMask$address() {
        return GetNumaNodeProcessorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static int GetNumaNodeProcessorMask(byte Node, MemorySegment ProcessorMask) {
        var mh$ = GetNumaNodeProcessorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeProcessorMask", Node, ProcessorMask);
            }
            return (int)mh$.invokeExact(Node, ProcessorMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaAvailableMemoryNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_CHAR,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumaAvailableMemoryNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static FunctionDescriptor GetNumaAvailableMemoryNode$descriptor() {
        return GetNumaAvailableMemoryNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MethodHandle GetNumaAvailableMemoryNode$handle() {
        return GetNumaAvailableMemoryNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MemorySegment GetNumaAvailableMemoryNode$address() {
        return GetNumaAvailableMemoryNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static int GetNumaAvailableMemoryNode(byte Node, MemorySegment AvailableBytes) {
        var mh$ = GetNumaAvailableMemoryNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaAvailableMemoryNode", Node, AvailableBytes);
            }
            return (int)mh$.invokeExact(Node, AvailableBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaAvailableMemoryNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_SHORT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumaAvailableMemoryNodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static FunctionDescriptor GetNumaAvailableMemoryNodeEx$descriptor() {
        return GetNumaAvailableMemoryNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MethodHandle GetNumaAvailableMemoryNodeEx$handle() {
        return GetNumaAvailableMemoryNodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MemorySegment GetNumaAvailableMemoryNodeEx$address() {
        return GetNumaAvailableMemoryNodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static int GetNumaAvailableMemoryNodeEx(short Node, MemorySegment AvailableBytes) {
        var mh$ = GetNumaAvailableMemoryNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaAvailableMemoryNodeEx", Node, AvailableBytes);
            }
            return (int)mh$.invokeExact(Node, AvailableBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProximityNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumaProximityNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProximityNode$descriptor() {
        return GetNumaProximityNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProximityNode$handle() {
        return GetNumaProximityNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProximityNode$address() {
        return GetNumaProximityNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static int GetNumaProximityNode(int ProximityId, MemorySegment NodeNumber) {
        var mh$ = GetNumaProximityNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProximityNode", ProximityId, NodeNumber);
            }
            return (int)mh$.invokeExact(ProximityId, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegisterApplicationRecoveryCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterApplicationRecoveryCallback$descriptor() {
        return RegisterApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegisterApplicationRecoveryCallback$handle() {
        return RegisterApplicationRecoveryCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegisterApplicationRecoveryCallback$address() {
        return RegisterApplicationRecoveryCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static int RegisterApplicationRecoveryCallback(MemorySegment pRecoveyCallback, MemorySegment pvParameter, int dwPingInterval, int dwFlags) {
        var mh$ = RegisterApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterApplicationRecoveryCallback", pRecoveyCallback, pvParameter, dwPingInterval, dwFlags);
            }
            return (int)mh$.invokeExact(pRecoveyCallback, pvParameter, dwPingInterval, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("UnregisterApplicationRecoveryCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static FunctionDescriptor UnregisterApplicationRecoveryCallback$descriptor() {
        return UnregisterApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static MethodHandle UnregisterApplicationRecoveryCallback$handle() {
        return UnregisterApplicationRecoveryCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static MemorySegment UnregisterApplicationRecoveryCallback$address() {
        return UnregisterApplicationRecoveryCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static int UnregisterApplicationRecoveryCallback() {
        var mh$ = UnregisterApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterApplicationRecoveryCallback");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterApplicationRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegisterApplicationRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterApplicationRestart$descriptor() {
        return RegisterApplicationRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegisterApplicationRestart$handle() {
        return RegisterApplicationRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegisterApplicationRestart$address() {
        return RegisterApplicationRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static int RegisterApplicationRestart(MemorySegment pwzCommandline, int dwFlags) {
        var mh$ = RegisterApplicationRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterApplicationRestart", pwzCommandline, dwFlags);
            }
            return (int)mh$.invokeExact(pwzCommandline, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterApplicationRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("UnregisterApplicationRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static FunctionDescriptor UnregisterApplicationRestart$descriptor() {
        return UnregisterApplicationRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static MethodHandle UnregisterApplicationRestart$handle() {
        return UnregisterApplicationRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static MemorySegment UnregisterApplicationRestart$address() {
        return UnregisterApplicationRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static int UnregisterApplicationRestart() {
        var mh$ = UnregisterApplicationRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterApplicationRestart");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetApplicationRecoveryCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static FunctionDescriptor GetApplicationRecoveryCallback$descriptor() {
        return GetApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static MethodHandle GetApplicationRecoveryCallback$handle() {
        return GetApplicationRecoveryCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static MemorySegment GetApplicationRecoveryCallback$address() {
        return GetApplicationRecoveryCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static int GetApplicationRecoveryCallback(MemorySegment hProcess, MemorySegment pRecoveryCallback, MemorySegment ppvParameter, MemorySegment pdwPingInterval, MemorySegment pdwFlags) {
        var mh$ = GetApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetApplicationRecoveryCallback", hProcess, pRecoveryCallback, ppvParameter, pdwPingInterval, pdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, pRecoveryCallback, ppvParameter, pdwPingInterval, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetApplicationRestartSettings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetApplicationRestartSettings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static FunctionDescriptor GetApplicationRestartSettings$descriptor() {
        return GetApplicationRestartSettings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static MethodHandle GetApplicationRestartSettings$handle() {
        return GetApplicationRestartSettings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static MemorySegment GetApplicationRestartSettings$address() {
        return GetApplicationRestartSettings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static int GetApplicationRestartSettings(MemorySegment hProcess, MemorySegment pwzCommandline, MemorySegment pcchSize, MemorySegment pdwFlags) {
        var mh$ = GetApplicationRestartSettings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetApplicationRestartSettings", hProcess, pwzCommandline, pcchSize, pdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, pwzCommandline, pcchSize, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ApplicationRecoveryInProgress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ApplicationRecoveryInProgress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static FunctionDescriptor ApplicationRecoveryInProgress$descriptor() {
        return ApplicationRecoveryInProgress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static MethodHandle ApplicationRecoveryInProgress$handle() {
        return ApplicationRecoveryInProgress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static MemorySegment ApplicationRecoveryInProgress$address() {
        return ApplicationRecoveryInProgress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static int ApplicationRecoveryInProgress(MemorySegment pbCancelled) {
        var mh$ = ApplicationRecoveryInProgress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ApplicationRecoveryInProgress", pbCancelled);
            }
            return (int)mh$.invokeExact(pbCancelled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ApplicationRecoveryFinished {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ApplicationRecoveryFinished");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static FunctionDescriptor ApplicationRecoveryFinished$descriptor() {
        return ApplicationRecoveryFinished.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static MethodHandle ApplicationRecoveryFinished$handle() {
        return ApplicationRecoveryFinished.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static MemorySegment ApplicationRecoveryFinished$address() {
        return ApplicationRecoveryFinished.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static void ApplicationRecoveryFinished(int bSuccess) {
        var mh$ = ApplicationRecoveryFinished.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ApplicationRecoveryFinished", bSuccess);
            }
            mh$.invokeExact(bSuccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_BASIC_INFO {
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     DWORD FileAttributes;
     * } *PFILE_BASIC_INFO
     * }
     */
    public static final AddressLayout PFILE_BASIC_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STANDARD_INFO {
     *     LARGE_INTEGER AllocationSize;
     *     LARGE_INTEGER EndOfFile;
     *     DWORD NumberOfLinks;
     *     BOOLEAN DeletePending;
     *     BOOLEAN Directory;
     * } *PFILE_STANDARD_INFO
     * }
     */
    public static final AddressLayout PFILE_STANDARD_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_NAME_INFO {
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_NAME_INFO
     * }
     */
    public static final AddressLayout PFILE_NAME_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_CASE_SENSITIVE_INFO {
     *     ULONG Flags;
     * } *PFILE_CASE_SENSITIVE_INFO
     * }
     */
    public static final AddressLayout PFILE_CASE_SENSITIVE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_RENAME_INFO {
     *     union {
     *         BOOLEAN ReplaceIfExists;
     *         DWORD Flags;
     *     };
     *     HANDLE RootDirectory;
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_RENAME_INFO
     * }
     */
    public static final AddressLayout PFILE_RENAME_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ALLOCATION_INFO {
     *     LARGE_INTEGER AllocationSize;
     * } *PFILE_ALLOCATION_INFO
     * }
     */
    public static final AddressLayout PFILE_ALLOCATION_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_END_OF_FILE_INFO {
     *     LARGE_INTEGER EndOfFile;
     * } *PFILE_END_OF_FILE_INFO
     * }
     */
    public static final AddressLayout PFILE_END_OF_FILE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STREAM_INFO {
     *     DWORD NextEntryOffset;
     *     DWORD StreamNameLength;
     *     LARGE_INTEGER StreamSize;
     *     LARGE_INTEGER StreamAllocationSize;
     *     WCHAR StreamName[1];
     * } *PFILE_STREAM_INFO
     * }
     */
    public static final AddressLayout PFILE_STREAM_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_COMPRESSION_INFO {
     *     LARGE_INTEGER CompressedFileSize;
     *     WORD CompressionFormat;
     *     UCHAR CompressionUnitShift;
     *     UCHAR ChunkShift;
     *     UCHAR ClusterShift;
     *     UCHAR Reserved[3];
     * } *PFILE_COMPRESSION_INFO
     * }
     */
    public static final AddressLayout PFILE_COMPRESSION_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ATTRIBUTE_TAG_INFO {
     *     DWORD FileAttributes;
     *     DWORD ReparseTag;
     * } *PFILE_ATTRIBUTE_TAG_INFO
     * }
     */
    public static final AddressLayout PFILE_ATTRIBUTE_TAG_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_DISPOSITION_INFO {
     *     BOOLEAN DeleteFileA;
     * } *PFILE_DISPOSITION_INFO
     * }
     */
    public static final AddressLayout PFILE_DISPOSITION_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_DISPOSITION_INFO_EX {
     *     DWORD Flags;
     * } *PFILE_DISPOSITION_INFO_EX
     * }
     */
    public static final AddressLayout PFILE_DISPOSITION_INFO_EX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_BOTH_DIR_INFO {
     *     DWORD NextEntryOffset;
     *     DWORD FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     DWORD FileAttributes;
     *     DWORD FileNameLength;
     *     DWORD EaSize;
     *     CCHAR ShortNameLength;
     *     WCHAR ShortName[12];
     *     LARGE_INTEGER FileId;
     *     WCHAR FileName[1];
     * } *PFILE_ID_BOTH_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_BOTH_DIR_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_FULL_DIR_INFO {
     *     ULONG NextEntryOffset;
     *     ULONG FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     ULONG FileAttributes;
     *     ULONG FileNameLength;
     *     ULONG EaSize;
     *     WCHAR FileName[1];
     * } *PFILE_FULL_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_FULL_DIR_INFO = winapi.C_POINTER;
    private static final int IoPriorityHintVeryLow = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintVeryLow = 0
     * }
     */
    public static int IoPriorityHintVeryLow() {
        return IoPriorityHintVeryLow;
    }
    private static final int IoPriorityHintLow = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintLow = 1
     * }
     */
    public static int IoPriorityHintLow() {
        return IoPriorityHintLow;
    }
    private static final int IoPriorityHintNormal = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintNormal = 2
     * }
     */
    public static int IoPriorityHintNormal() {
        return IoPriorityHintNormal;
    }
    private static final int MaximumIoPriorityHintType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.MaximumIoPriorityHintType = 3
     * }
     */
    public static int MaximumIoPriorityHintType() {
        return MaximumIoPriorityHintType;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_IO_PRIORITY_HINT_INFO {
     *     PRIORITY_HINT PriorityHint;
     * } *PFILE_IO_PRIORITY_HINT_INFO
     * }
     */
    public static final AddressLayout PFILE_IO_PRIORITY_HINT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ALIGNMENT_INFO {
     *     ULONG AlignmentRequirement;
     * } *PFILE_ALIGNMENT_INFO
     * }
     */
    public static final AddressLayout PFILE_ALIGNMENT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STORAGE_INFO {
     *     ULONG LogicalBytesPerSector;
     *     ULONG PhysicalBytesPerSectorForAtomicity;
     *     ULONG PhysicalBytesPerSectorForPerformance;
     *     ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
     *     ULONG Flags;
     *     ULONG ByteOffsetForSectorAlignment;
     *     ULONG ByteOffsetForPartitionAlignment;
     * } *PFILE_STORAGE_INFO
     * }
     */
    public static final AddressLayout PFILE_STORAGE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_INFO {
     *     ULONGLONG VolumeSerialNumber;
     *     FILE_ID_128 FileId;
     * } *PFILE_ID_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_EXTD_DIR_INFO {
     *     ULONG NextEntryOffset;
     *     ULONG FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     ULONG FileAttributes;
     *     ULONG FileNameLength;
     *     ULONG EaSize;
     *     ULONG ReparsePointTag;
     *     FILE_ID_128 FileId;
     *     WCHAR FileName[1];
     * } *PFILE_ID_EXTD_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_EXTD_DIR_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_REMOTE_PROTOCOL_INFO {
     *     USHORT StructureVersion;
     *     USHORT StructureSize;
     *     ULONG Protocol;
     *     USHORT ProtocolMajorVersion;
     *     USHORT ProtocolMinorVersion;
     *     USHORT ProtocolRevision;
     *     USHORT Reserved;
     *     ULONG Flags;
     *     struct {
     *         ULONG Reserved[8];
     *     } GenericReserved;
     *     union {
     *         struct {
     *             struct {
     *                 ULONG Capabilities;
     *             } Server;
     *             struct {
     *                 ULONG Capabilities;
     *                 ULONG ShareFlags;
     *             } Share;
     *         } Smb2;
     *         ULONG Reserved[16];
     *     } ProtocolSpecific;
     * } *PFILE_REMOTE_PROTOCOL_INFO
     * }
     */
    public static final AddressLayout PFILE_REMOTE_PROTOCOL_INFO = winapi.C_POINTER;

    private static class GetFileInformationByHandleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileInformationByHandleEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static FunctionDescriptor GetFileInformationByHandleEx$descriptor() {
        return GetFileInformationByHandleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MethodHandle GetFileInformationByHandleEx$handle() {
        return GetFileInformationByHandleEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MemorySegment GetFileInformationByHandleEx$address() {
        return GetFileInformationByHandleEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static int GetFileInformationByHandleEx(MemorySegment hFile, int FileInformationClass, MemorySegment lpFileInformation, int dwBufferSize) {
        var mh$ = GetFileInformationByHandleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileInformationByHandleEx", hFile, FileInformationClass, lpFileInformation, dwBufferSize);
            }
            return (int)mh$.invokeExact(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileInformationByName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileInformationByName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByName(PCWSTR FileName, FILE_INFO_BY_NAME_CLASS FileInformationClass, PVOID FileInfoBuffer, ULONG FileInfoBufferSize)
     * }
     */
    public static FunctionDescriptor GetFileInformationByName$descriptor() {
        return GetFileInformationByName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByName(PCWSTR FileName, FILE_INFO_BY_NAME_CLASS FileInformationClass, PVOID FileInfoBuffer, ULONG FileInfoBufferSize)
     * }
     */
    public static MethodHandle GetFileInformationByName$handle() {
        return GetFileInformationByName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByName(PCWSTR FileName, FILE_INFO_BY_NAME_CLASS FileInformationClass, PVOID FileInfoBuffer, ULONG FileInfoBufferSize)
     * }
     */
    public static MemorySegment GetFileInformationByName$address() {
        return GetFileInformationByName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileInformationByName(PCWSTR FileName, FILE_INFO_BY_NAME_CLASS FileInformationClass, PVOID FileInfoBuffer, ULONG FileInfoBufferSize)
     * }
     */
    public static int GetFileInformationByName(MemorySegment FileName, int FileInformationClass, MemorySegment FileInfoBuffer, int FileInfoBufferSize) {
        var mh$ = GetFileInformationByName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileInformationByName", FileName, FileInformationClass, FileInfoBuffer, FileInfoBufferSize);
            }
            return (int)mh$.invokeExact(FileName, FileInformationClass, FileInfoBuffer, FileInfoBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FileIdType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.FileIdType = 0
     * }
     */
    public static int FileIdType() {
        return FileIdType;
    }
    private static final int ObjectIdType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.ObjectIdType = 1
     * }
     */
    public static int ObjectIdType() {
        return ObjectIdType;
    }
    private static final int ExtendedFileIdType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.ExtendedFileIdType = 2
     * }
     */
    public static int ExtendedFileIdType() {
        return ExtendedFileIdType;
    }
    private static final int MaximumFileIdType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.MaximumFileIdType = 3
     * }
     */
    public static int MaximumFileIdType() {
        return MaximumFileIdType;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _FILE_ID_TYPE {
     *     FileIdType,
     *     ObjectIdType,
     *     ExtendedFileIdType,
     *     MaximumFileIdType
     * } *PFILE_ID_TYPE
     * }
     */
    public static final AddressLayout PFILE_ID_TYPE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct FILE_ID_DESCRIPTOR {
     *     DWORD dwSize;
     *     FILE_ID_TYPE Type;
     *     union {
     *         LARGE_INTEGER FileId;
     *         GUID ObjectId;
     *         FILE_ID_128 ExtendedFileId;
     *     };
     * } *LPFILE_ID_DESCRIPTOR
     * }
     */
    public static final AddressLayout LPFILE_ID_DESCRIPTOR = winapi.C_POINTER;

    private static class OpenFileById {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenFileById");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor OpenFileById$descriptor() {
        return OpenFileById.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle OpenFileById$handle() {
        return OpenFileById.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenFileById$address() {
        return OpenFileById.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenFileById(MemorySegment hVolumeHint, MemorySegment lpFileId, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwFlagsAndAttributes) {
        var mh$ = OpenFileById.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileById", hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateSymbolicLinkA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkA$descriptor() {
        return CreateSymbolicLinkA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CreateSymbolicLinkA$handle() {
        return CreateSymbolicLinkA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CreateSymbolicLinkA$address() {
        return CreateSymbolicLinkA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static byte CreateSymbolicLinkA(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags) {
        var mh$ = CreateSymbolicLinkA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkA", lpSymlinkFileName, lpTargetFileName, dwFlags);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateSymbolicLinkW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkW$descriptor() {
        return CreateSymbolicLinkW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CreateSymbolicLinkW$handle() {
        return CreateSymbolicLinkW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CreateSymbolicLinkW$address() {
        return CreateSymbolicLinkW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static byte CreateSymbolicLinkW(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags) {
        var mh$ = CreateSymbolicLinkW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkW", lpSymlinkFileName, lpTargetFileName, dwFlags);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryActCtxSettingsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueryActCtxSettingsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static FunctionDescriptor QueryActCtxSettingsW$descriptor() {
        return QueryActCtxSettingsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static MethodHandle QueryActCtxSettingsW$handle() {
        return QueryActCtxSettingsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static MemorySegment QueryActCtxSettingsW$address() {
        return QueryActCtxSettingsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static int QueryActCtxSettingsW(int dwFlags, MemorySegment hActCtx, MemorySegment settingsNameSpace, MemorySegment settingName, MemorySegment pvBuffer, long dwBuffer, MemorySegment pdwWrittenOrRequired) {
        var mh$ = QueryActCtxSettingsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryActCtxSettingsW", dwFlags, hActCtx, settingsNameSpace, settingName, pvBuffer, dwBuffer, pdwWrittenOrRequired);
            }
            return (int)mh$.invokeExact(dwFlags, hActCtx, settingsNameSpace, settingName, pvBuffer, dwBuffer, pdwWrittenOrRequired);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateSymbolicLinkTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkTransactedA$descriptor() {
        return CreateSymbolicLinkTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateSymbolicLinkTransactedA$handle() {
        return CreateSymbolicLinkTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateSymbolicLinkTransactedA$address() {
        return CreateSymbolicLinkTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static byte CreateSymbolicLinkTransactedA(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags, MemorySegment hTransaction) {
        var mh$ = CreateSymbolicLinkTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkTransactedA", lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateSymbolicLinkTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkTransactedW$descriptor() {
        return CreateSymbolicLinkTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateSymbolicLinkTransactedW$handle() {
        return CreateSymbolicLinkTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateSymbolicLinkTransactedW$address() {
        return CreateSymbolicLinkTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static byte CreateSymbolicLinkTransactedW(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags, MemorySegment hTransaction) {
        var mh$ = CreateSymbolicLinkTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkTransactedW", lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplacePartitionUnit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReplacePartitionUnit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static FunctionDescriptor ReplacePartitionUnit$descriptor() {
        return ReplacePartitionUnit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static MethodHandle ReplacePartitionUnit$handle() {
        return ReplacePartitionUnit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static MemorySegment ReplacePartitionUnit$address() {
        return ReplacePartitionUnit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static int ReplacePartitionUnit(MemorySegment TargetPartition, MemorySegment SparePartition, int Flags) {
        var mh$ = ReplacePartitionUnit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplacePartitionUnit", TargetPartition, SparePartition, Flags);
            }
            return (int)mh$.invokeExact(TargetPartition, SparePartition, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddSecureMemoryCacheCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddSecureMemoryCacheCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static FunctionDescriptor AddSecureMemoryCacheCallback$descriptor() {
        return AddSecureMemoryCacheCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MethodHandle AddSecureMemoryCacheCallback$handle() {
        return AddSecureMemoryCacheCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MemorySegment AddSecureMemoryCacheCallback$address() {
        return AddSecureMemoryCacheCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static int AddSecureMemoryCacheCallback(MemorySegment pfnCallBack) {
        var mh$ = AddSecureMemoryCacheCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddSecureMemoryCacheCallback", pfnCallBack);
            }
            return (int)mh$.invokeExact(pfnCallBack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveSecureMemoryCacheCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveSecureMemoryCacheCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static FunctionDescriptor RemoveSecureMemoryCacheCallback$descriptor() {
        return RemoveSecureMemoryCacheCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MethodHandle RemoveSecureMemoryCacheCallback$handle() {
        return RemoveSecureMemoryCacheCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MemorySegment RemoveSecureMemoryCacheCallback$address() {
        return RemoveSecureMemoryCacheCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static int RemoveSecureMemoryCacheCallback(MemorySegment pfnCallBack) {
        var mh$ = RemoveSecureMemoryCacheCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveSecureMemoryCacheCallback", pfnCallBack);
            }
            return (int)mh$.invokeExact(pfnCallBack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CopyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static FunctionDescriptor CopyContext$descriptor() {
        return CopyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static MethodHandle CopyContext$handle() {
        return CopyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static MemorySegment CopyContext$address() {
        return CopyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static int CopyContext(MemorySegment Destination, int ContextFlags, MemorySegment Source) {
        var mh$ = CopyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyContext", Destination, ContextFlags, Source);
            }
            return (int)mh$.invokeExact(Destination, ContextFlags, Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitializeContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static FunctionDescriptor InitializeContext$descriptor() {
        return InitializeContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static MethodHandle InitializeContext$handle() {
        return InitializeContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static MemorySegment InitializeContext$address() {
        return InitializeContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static int InitializeContext(MemorySegment Buffer, int ContextFlags, MemorySegment Context, MemorySegment ContextLength) {
        var mh$ = InitializeContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeContext", Buffer, ContextFlags, Context, ContextLength);
            }
            return (int)mh$.invokeExact(Buffer, ContextFlags, Context, ContextLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitializeContext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static FunctionDescriptor InitializeContext2$descriptor() {
        return InitializeContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static MethodHandle InitializeContext2$handle() {
        return InitializeContext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static MemorySegment InitializeContext2$address() {
        return InitializeContext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static int InitializeContext2(MemorySegment Buffer, int ContextFlags, MemorySegment Context, MemorySegment ContextLength, long XStateCompactionMask) {
        var mh$ = InitializeContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeContext2", Buffer, ContextFlags, Context, ContextLength, XStateCompactionMask);
            }
            return (int)mh$.invokeExact(Buffer, ContextFlags, Context, ContextLength, XStateCompactionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnabledXStateFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnabledXStateFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static FunctionDescriptor GetEnabledXStateFeatures$descriptor() {
        return GetEnabledXStateFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static MethodHandle GetEnabledXStateFeatures$handle() {
        return GetEnabledXStateFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static MemorySegment GetEnabledXStateFeatures$address() {
        return GetEnabledXStateFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static long GetEnabledXStateFeatures() {
        var mh$ = GetEnabledXStateFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnabledXStateFeatures");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetXStateFeaturesMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetXStateFeaturesMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static FunctionDescriptor GetXStateFeaturesMask$descriptor() {
        return GetXStateFeaturesMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static MethodHandle GetXStateFeaturesMask$handle() {
        return GetXStateFeaturesMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static MemorySegment GetXStateFeaturesMask$address() {
        return GetXStateFeaturesMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static int GetXStateFeaturesMask(MemorySegment Context, MemorySegment FeatureMask) {
        var mh$ = GetXStateFeaturesMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetXStateFeaturesMask", Context, FeatureMask);
            }
            return (int)mh$.invokeExact(Context, FeatureMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocateXStateFeature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LocateXStateFeature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static FunctionDescriptor LocateXStateFeature$descriptor() {
        return LocateXStateFeature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MethodHandle LocateXStateFeature$handle() {
        return LocateXStateFeature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MemorySegment LocateXStateFeature$address() {
        return LocateXStateFeature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MemorySegment LocateXStateFeature(MemorySegment Context, int FeatureId, MemorySegment Length) {
        var mh$ = LocateXStateFeature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocateXStateFeature", Context, FeatureId, Length);
            }
            return (MemorySegment)mh$.invokeExact(Context, FeatureId, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetXStateFeaturesMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetXStateFeaturesMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static FunctionDescriptor SetXStateFeaturesMask$descriptor() {
        return SetXStateFeaturesMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static MethodHandle SetXStateFeaturesMask$handle() {
        return SetXStateFeaturesMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static MemorySegment SetXStateFeaturesMask$address() {
        return SetXStateFeaturesMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static int SetXStateFeaturesMask(MemorySegment Context, long FeatureMask) {
        var mh$ = SetXStateFeaturesMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetXStateFeaturesMask", Context, FeatureMask);
            }
            return (int)mh$.invokeExact(Context, FeatureMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadEnabledXStateFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetThreadEnabledXStateFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD64 GetThreadEnabledXStateFeatures()
     * }
     */
    public static FunctionDescriptor GetThreadEnabledXStateFeatures$descriptor() {
        return GetThreadEnabledXStateFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD64 GetThreadEnabledXStateFeatures()
     * }
     */
    public static MethodHandle GetThreadEnabledXStateFeatures$handle() {
        return GetThreadEnabledXStateFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD64 GetThreadEnabledXStateFeatures()
     * }
     */
    public static MemorySegment GetThreadEnabledXStateFeatures$address() {
        return GetThreadEnabledXStateFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD64 GetThreadEnabledXStateFeatures()
     * }
     */
    public static long GetThreadEnabledXStateFeatures() {
        var mh$ = GetThreadEnabledXStateFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadEnabledXStateFeatures");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableProcessOptionalXStateFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnableProcessOptionalXStateFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableProcessOptionalXStateFeatures(DWORD64 Features)
     * }
     */
    public static FunctionDescriptor EnableProcessOptionalXStateFeatures$descriptor() {
        return EnableProcessOptionalXStateFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableProcessOptionalXStateFeatures(DWORD64 Features)
     * }
     */
    public static MethodHandle EnableProcessOptionalXStateFeatures$handle() {
        return EnableProcessOptionalXStateFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableProcessOptionalXStateFeatures(DWORD64 Features)
     * }
     */
    public static MemorySegment EnableProcessOptionalXStateFeatures$address() {
        return EnableProcessOptionalXStateFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableProcessOptionalXStateFeatures(DWORD64 Features)
     * }
     */
    public static int EnableProcessOptionalXStateFeatures(long Features) {
        var mh$ = EnableProcessOptionalXStateFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableProcessOptionalXStateFeatures", Features);
            }
            return (int)mh$.invokeExact(Features);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnableThreadProfiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static FunctionDescriptor EnableThreadProfiling$descriptor() {
        return EnableThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static MethodHandle EnableThreadProfiling$handle() {
        return EnableThreadProfiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static MemorySegment EnableThreadProfiling$address() {
        return EnableThreadProfiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static int EnableThreadProfiling(MemorySegment ThreadHandle, int Flags, long HardwareCounters, MemorySegment PerformanceDataHandle) {
        var mh$ = EnableThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableThreadProfiling", ThreadHandle, Flags, HardwareCounters, PerformanceDataHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle, Flags, HardwareCounters, PerformanceDataHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisableThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DisableThreadProfiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static FunctionDescriptor DisableThreadProfiling$descriptor() {
        return DisableThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static MethodHandle DisableThreadProfiling$handle() {
        return DisableThreadProfiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static MemorySegment DisableThreadProfiling$address() {
        return DisableThreadProfiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static int DisableThreadProfiling(MemorySegment PerformanceDataHandle) {
        var mh$ = DisableThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableThreadProfiling", PerformanceDataHandle);
            }
            return (int)mh$.invokeExact(PerformanceDataHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueryThreadProfiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static FunctionDescriptor QueryThreadProfiling$descriptor() {
        return QueryThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static MethodHandle QueryThreadProfiling$handle() {
        return QueryThreadProfiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static MemorySegment QueryThreadProfiling$address() {
        return QueryThreadProfiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static int QueryThreadProfiling(MemorySegment ThreadHandle, MemorySegment Enabled) {
        var mh$ = QueryThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadProfiling", ThreadHandle, Enabled);
            }
            return (int)mh$.invokeExact(ThreadHandle, Enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadThreadProfilingData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadThreadProfilingData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static FunctionDescriptor ReadThreadProfilingData$descriptor() {
        return ReadThreadProfilingData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static MethodHandle ReadThreadProfilingData$handle() {
        return ReadThreadProfilingData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static MemorySegment ReadThreadProfilingData$address() {
        return ReadThreadProfilingData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static int ReadThreadProfilingData(MemorySegment PerformanceDataHandle, int Flags, MemorySegment PerformanceData) {
        var mh$ = ReadThreadProfilingData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadThreadProfilingData", PerformanceDataHandle, Flags, PerformanceData);
            }
            return (int)mh$.invokeExact(PerformanceDataHandle, Flags, PerformanceData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseCustomSystemEventTrigger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RaiseCustomSystemEventTrigger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static FunctionDescriptor RaiseCustomSystemEventTrigger$descriptor() {
        return RaiseCustomSystemEventTrigger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static MethodHandle RaiseCustomSystemEventTrigger$handle() {
        return RaiseCustomSystemEventTrigger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static MemorySegment RaiseCustomSystemEventTrigger$address() {
        return RaiseCustomSystemEventTrigger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static int RaiseCustomSystemEventTrigger(MemorySegment CustomSystemEventTriggerConfig) {
        var mh$ = RaiseCustomSystemEventTrigger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseCustomSystemEventTrigger", CustomSystemEventTriggerConfig);
            }
            return (int)mh$.invokeExact(CustomSystemEventTriggerConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DRAWPATRECT {
     *     POINT ptPosition;
     *     POINT ptSize;
     *     WORD wStyle;
     *     WORD wPattern;
     * } *PDRAWPATRECT
     * }
     */
    public static final AddressLayout PDRAWPATRECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSINJECTDATA {
     *     DWORD DataBytes;
     *     WORD InjectionPoint;
     *     WORD PageNumber;
     * } *PPSINJECTDATA
     * }
     */
    public static final AddressLayout PPSINJECTDATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSFEATURE_OUTPUT {
     *     BOOL bPageIndependent;
     *     BOOL bSetPageDevice;
     * } *PPSFEATURE_OUTPUT
     * }
     */
    public static final AddressLayout PPSFEATURE_OUTPUT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSFEATURE_CUSTPAPER {
     *     LONG lOrientation;
     *     LONG lWidth;
     *     LONG lHeight;
     *     LONG lWidthOffset;
     *     LONG lHeightOffset;
     * } *PPSFEATURE_CUSTPAPER
     * }
     */
    public static final AddressLayout PPSFEATURE_CUSTPAPER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagXFORM {
     *     FLOAT eM11;
     *     FLOAT eM12;
     *     FLOAT eM21;
     *     FLOAT eM22;
     *     FLOAT eDx;
     *     FLOAT eDy;
     * } *PXFORM
     * }
     */
    public static final AddressLayout PXFORM = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagXFORM {
     *     FLOAT eM11;
     *     FLOAT eM12;
     *     FLOAT eM21;
     *     FLOAT eM22;
     *     FLOAT eDx;
     *     FLOAT eDy;
     * } *LPXFORM
     * }
     */
    public static final AddressLayout LPXFORM = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *PBITMAP
     * }
     */
    public static final AddressLayout PBITMAP = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *NPBITMAP
     * }
     */
    public static final AddressLayout NPBITMAP = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *LPBITMAP
     * }
     */
    public static final AddressLayout LPBITMAP = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *PRGBTRIPLE
     * }
     */
    public static final AddressLayout PRGBTRIPLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *NPRGBTRIPLE
     * }
     */
    public static final AddressLayout NPRGBTRIPLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *LPRGBTRIPLE
     * }
     */
    public static final AddressLayout LPRGBTRIPLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RGBQUAD *LPRGBQUAD
     * }
     */
    public static final AddressLayout LPRGBQUAD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LONG LCSCSTYPE
     * }
     */
    public static final OfInt LCSCSTYPE = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG LCSGAMUTMATCH
     * }
     */
    public static final OfInt LCSGAMUTMATCH = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long FXPT16DOT16
     * }
     */
    public static final OfInt FXPT16DOT16 = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long *LPFXPT16DOT16
     * }
     */
    public static final AddressLayout LPFXPT16DOT16 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long FXPT2DOT30
     * }
     */
    public static final OfInt FXPT2DOT30 = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long *LPFXPT2DOT30
     * }
     */
    public static final AddressLayout LPFXPT2DOT30 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CIEXYZ *LPCIEXYZ
     * }
     */
    public static final AddressLayout LPCIEXYZ = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CIEXYZTRIPLE *LPCIEXYZTRIPLE
     * }
     */
    public static final AddressLayout LPCIEXYZTRIPLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGCOLORSPACEA {
     *     DWORD lcsSignature;
     *     DWORD lcsVersion;
     *     DWORD lcsSize;
     *     LCSCSTYPE lcsCSType;
     *     LCSGAMUTMATCH lcsIntent;
     *     CIEXYZTRIPLE lcsEndpoints;
     *     DWORD lcsGammaRed;
     *     DWORD lcsGammaGreen;
     *     DWORD lcsGammaBlue;
     *     CHAR lcsFilename[260];
     * } *LPLOGCOLORSPACEA
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGCOLORSPACEW {
     *     DWORD lcsSignature;
     *     DWORD lcsVersion;
     *     DWORD lcsSize;
     *     LCSCSTYPE lcsCSType;
     *     LCSGAMUTMATCH lcsIntent;
     *     CIEXYZTRIPLE lcsEndpoints;
     *     DWORD lcsGammaRed;
     *     DWORD lcsGammaGreen;
     *     DWORD lcsGammaBlue;
     *     WCHAR lcsFilename[260];
     * } *LPLOGCOLORSPACEW
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREHEADER {
     *     DWORD bcSize;
     *     WORD bcWidth;
     *     WORD bcHeight;
     *     WORD bcPlanes;
     *     WORD bcBitCount;
     * } *LPBITMAPCOREHEADER
     * }
     */
    public static final AddressLayout LPBITMAPCOREHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREHEADER {
     *     DWORD bcSize;
     *     WORD bcWidth;
     *     WORD bcHeight;
     *     WORD bcPlanes;
     *     WORD bcBitCount;
     * } *PBITMAPCOREHEADER
     * }
     */
    public static final AddressLayout PBITMAPCOREHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFOHEADER {
     *     DWORD biSize;
     *     LONG biWidth;
     *     LONG biHeight;
     *     WORD biPlanes;
     *     WORD biBitCount;
     *     DWORD biCompression;
     *     DWORD biSizeImage;
     *     LONG biXPelsPerMeter;
     *     LONG biYPelsPerMeter;
     *     DWORD biClrUsed;
     *     DWORD biClrImportant;
     * } *LPBITMAPINFOHEADER
     * }
     */
    public static final AddressLayout LPBITMAPINFOHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFOHEADER {
     *     DWORD biSize;
     *     LONG biWidth;
     *     LONG biHeight;
     *     WORD biPlanes;
     *     WORD biBitCount;
     *     DWORD biCompression;
     *     DWORD biSizeImage;
     *     LONG biXPelsPerMeter;
     *     LONG biYPelsPerMeter;
     *     DWORD biClrUsed;
     *     DWORD biClrImportant;
     * } *PBITMAPINFOHEADER
     * }
     */
    public static final AddressLayout PBITMAPINFOHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV4Size;
     *     LONG bV4Width;
     *     LONG bV4Height;
     *     WORD bV4Planes;
     *     WORD bV4BitCount;
     *     DWORD bV4V4Compression;
     *     DWORD bV4SizeImage;
     *     LONG bV4XPelsPerMeter;
     *     LONG bV4YPelsPerMeter;
     *     DWORD bV4ClrUsed;
     *     DWORD bV4ClrImportant;
     *     DWORD bV4RedMask;
     *     DWORD bV4GreenMask;
     *     DWORD bV4BlueMask;
     *     DWORD bV4AlphaMask;
     *     DWORD bV4CSType;
     *     CIEXYZTRIPLE bV4Endpoints;
     *     DWORD bV4GammaRed;
     *     DWORD bV4GammaGreen;
     *     DWORD bV4GammaBlue;
     * } *LPBITMAPV4HEADER
     * }
     */
    public static final AddressLayout LPBITMAPV4HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV4Size;
     *     LONG bV4Width;
     *     LONG bV4Height;
     *     WORD bV4Planes;
     *     WORD bV4BitCount;
     *     DWORD bV4V4Compression;
     *     DWORD bV4SizeImage;
     *     LONG bV4XPelsPerMeter;
     *     LONG bV4YPelsPerMeter;
     *     DWORD bV4ClrUsed;
     *     DWORD bV4ClrImportant;
     *     DWORD bV4RedMask;
     *     DWORD bV4GreenMask;
     *     DWORD bV4BlueMask;
     *     DWORD bV4AlphaMask;
     *     DWORD bV4CSType;
     *     CIEXYZTRIPLE bV4Endpoints;
     *     DWORD bV4GammaRed;
     *     DWORD bV4GammaGreen;
     *     DWORD bV4GammaBlue;
     * } *PBITMAPV4HEADER
     * }
     */
    public static final AddressLayout PBITMAPV4HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV5Size;
     *     LONG bV5Width;
     *     LONG bV5Height;
     *     WORD bV5Planes;
     *     WORD bV5BitCount;
     *     DWORD bV5Compression;
     *     DWORD bV5SizeImage;
     *     LONG bV5XPelsPerMeter;
     *     LONG bV5YPelsPerMeter;
     *     DWORD bV5ClrUsed;
     *     DWORD bV5ClrImportant;
     *     DWORD bV5RedMask;
     *     DWORD bV5GreenMask;
     *     DWORD bV5BlueMask;
     *     DWORD bV5AlphaMask;
     *     DWORD bV5CSType;
     *     CIEXYZTRIPLE bV5Endpoints;
     *     DWORD bV5GammaRed;
     *     DWORD bV5GammaGreen;
     *     DWORD bV5GammaBlue;
     *     DWORD bV5Intent;
     *     DWORD bV5ProfileData;
     *     DWORD bV5ProfileSize;
     *     DWORD bV5Reserved;
     * } *LPBITMAPV5HEADER
     * }
     */
    public static final AddressLayout LPBITMAPV5HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV5Size;
     *     LONG bV5Width;
     *     LONG bV5Height;
     *     WORD bV5Planes;
     *     WORD bV5BitCount;
     *     DWORD bV5Compression;
     *     DWORD bV5SizeImage;
     *     LONG bV5XPelsPerMeter;
     *     LONG bV5YPelsPerMeter;
     *     DWORD bV5ClrUsed;
     *     DWORD bV5ClrImportant;
     *     DWORD bV5RedMask;
     *     DWORD bV5GreenMask;
     *     DWORD bV5BlueMask;
     *     DWORD bV5AlphaMask;
     *     DWORD bV5CSType;
     *     CIEXYZTRIPLE bV5Endpoints;
     *     DWORD bV5GammaRed;
     *     DWORD bV5GammaGreen;
     *     DWORD bV5GammaBlue;
     *     DWORD bV5Intent;
     *     DWORD bV5ProfileData;
     *     DWORD bV5ProfileSize;
     *     DWORD bV5Reserved;
     * } *PBITMAPV5HEADER
     * }
     */
    public static final AddressLayout PBITMAPV5HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFO {
     *     BITMAPINFOHEADER bmiHeader;
     *     RGBQUAD bmiColors[1];
     * } *LPBITMAPINFO
     * }
     */
    public static final AddressLayout LPBITMAPINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFO {
     *     BITMAPINFOHEADER bmiHeader;
     *     RGBQUAD bmiColors[1];
     * } *PBITMAPINFO
     * }
     */
    public static final AddressLayout PBITMAPINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREINFO {
     *     BITMAPCOREHEADER bmciHeader;
     *     RGBTRIPLE bmciColors[1];
     * } *LPBITMAPCOREINFO
     * }
     */
    public static final AddressLayout LPBITMAPCOREINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREINFO {
     *     BITMAPCOREHEADER bmciHeader;
     *     RGBTRIPLE bmciColors[1];
     * } *PBITMAPCOREINFO
     * }
     */
    public static final AddressLayout PBITMAPCOREINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPFILEHEADER {
     *     WORD bfType;
     *     DWORD bfSize;
     *     WORD bfReserved1;
     *     WORD bfReserved2;
     *     DWORD bfOffBits;
     * } *LPBITMAPFILEHEADER
     * }
     */
    public static final AddressLayout LPBITMAPFILEHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPFILEHEADER {
     *     WORD bfType;
     *     DWORD bfSize;
     *     WORD bfReserved1;
     *     WORD bfReserved2;
     *     DWORD bfOffBits;
     * } *PBITMAPFILEHEADER
     * }
     */
    public static final AddressLayout PBITMAPFILEHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagFONTSIGNATURE {
     *     DWORD fsUsb[4];
     *     DWORD fsCsb[2];
     * } *PFONTSIGNATURE
     * }
     */
    public static final AddressLayout PFONTSIGNATURE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagFONTSIGNATURE {
     *     DWORD fsUsb[4];
     *     DWORD fsCsb[2];
     * } *LPFONTSIGNATURE
     * }
     */
    public static final AddressLayout LPFONTSIGNATURE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *PCHARSETINFO
     * }
     */
    public static final AddressLayout PCHARSETINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *NPCHARSETINFO
     * }
     */
    public static final AddressLayout NPCHARSETINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *LPCHARSETINFO
     * }
     */
    public static final AddressLayout LPCHARSETINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOCALESIGNATURE {
     *     DWORD lsUsb[4];
     *     DWORD lsCsbDefault[2];
     *     DWORD lsCsbSupported[2];
     * } *PLOCALESIGNATURE
     * }
     */
    public static final AddressLayout PLOCALESIGNATURE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOCALESIGNATURE {
     *     DWORD lsUsb[4];
     *     DWORD lsCsbDefault[2];
     *     DWORD lsCsbSupported[2];
     * } *LPLOCALESIGNATURE
     * }
     */
    public static final AddressLayout LPLOCALESIGNATURE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHANDLETABLE {
     *     HGDIOBJ objectHandle[1];
     * } *PHANDLETABLE
     * }
     */
    public static final AddressLayout PHANDLETABLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHANDLETABLE {
     *     HGDIOBJ objectHandle[1];
     * } *LPHANDLETABLE
     * }
     */
    public static final AddressLayout LPHANDLETABLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETARECORD {
     *     DWORD rdSize;
     *     WORD rdFunction;
     *     WORD rdParm[1];
     * } *PMETARECORD
     * }
     */
    public static final AddressLayout PMETARECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETARECORD {
     *     DWORD rdSize;
     *     WORD rdFunction;
     *     WORD rdParm[1];
     * } *LPMETARECORD
     * }
     */
    public static final AddressLayout LPMETARECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMETAFILEPICT {
     *     LONG mm;
     *     LONG xExt;
     *     LONG yExt;
     *     HMETAFILE hMF;
     * } *LPMETAFILEPICT
     * }
     */
    public static final AddressLayout LPMETAFILEPICT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETAHEADER {
     *     WORD mtType;
     *     WORD mtHeaderSize;
     *     WORD mtVersion;
     *     DWORD mtSize;
     *     WORD mtNoObjects;
     *     DWORD mtMaxRecord;
     *     WORD mtNoParameters;
     * } *PMETAHEADER
     * }
     */
    public static final AddressLayout PMETAHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETAHEADER {
     *     WORD mtType;
     *     WORD mtHeaderSize;
     *     WORD mtVersion;
     *     DWORD mtSize;
     *     WORD mtNoObjects;
     *     DWORD mtMaxRecord;
     *     WORD mtNoParameters;
     * } *LPMETAHEADER
     * }
     */
    public static final AddressLayout LPMETAHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETARECORD {
     *     DWORD iType;
     *     DWORD nSize;
     *     DWORD dParm[1];
     * } *PENHMETARECORD
     * }
     */
    public static final AddressLayout PENHMETARECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETARECORD {
     *     DWORD iType;
     *     DWORD nSize;
     *     DWORD dParm[1];
     * } *LPENHMETARECORD
     * }
     */
    public static final AddressLayout LPENHMETARECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETAHEADER {
     *     DWORD iType;
     *     DWORD nSize;
     *     RECTL rclBounds;
     *     RECTL rclFrame;
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD nBytes;
     *     DWORD nRecords;
     *     WORD nHandles;
     *     WORD sReserved;
     *     DWORD nDescription;
     *     DWORD offDescription;
     *     DWORD nPalEntries;
     *     SIZEL szlDevice;
     *     SIZEL szlMillimeters;
     *     DWORD cbPixelFormat;
     *     DWORD offPixelFormat;
     *     DWORD bOpenGL;
     *     SIZEL szlMicrometers;
     * } *PENHMETAHEADER
     * }
     */
    public static final AddressLayout PENHMETAHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETAHEADER {
     *     DWORD iType;
     *     DWORD nSize;
     *     RECTL rclBounds;
     *     RECTL rclFrame;
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD nBytes;
     *     DWORD nRecords;
     *     WORD nHandles;
     *     WORD sReserved;
     *     DWORD nDescription;
     *     DWORD offDescription;
     *     DWORD nPalEntries;
     *     SIZEL szlDevice;
     *     SIZEL szlMillimeters;
     *     DWORD cbPixelFormat;
     *     DWORD offPixelFormat;
     *     DWORD bOpenGL;
     *     SIZEL szlMicrometers;
     * } *LPENHMETAHEADER
     * }
     */
    public static final AddressLayout LPENHMETAHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BYTE BCHAR
     * }
     */
    public static final OfByte BCHAR = winapi.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *PTEXTMETRICA
     * }
     */
    public static final AddressLayout PTEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *NPTEXTMETRICA
     * }
     */
    public static final AddressLayout NPTEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *LPTEXTMETRICA
     * }
     */
    public static final AddressLayout LPTEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *PTEXTMETRICW
     * }
     */
    public static final AddressLayout PTEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *NPTEXTMETRICW
     * }
     */
    public static final AddressLayout NPTEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *LPTEXTMETRICW
     * }
     */
    public static final AddressLayout LPTEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PTEXTMETRICA PTEXTMETRIC
     * }
     */
    public static final AddressLayout PTEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPTEXTMETRICA NPTEXTMETRIC
     * }
     */
    public static final AddressLayout NPTEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPTEXTMETRICA LPTEXTMETRIC
     * }
     */
    public static final AddressLayout LPTEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *PNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout PNEWTEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *NPNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *LPNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *PNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout PNEWTEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *NPNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *LPNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PNEWTEXTMETRICA PNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout PNEWTEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *PPELARRAY
     * }
     */
    public static final AddressLayout PPELARRAY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *NPPELARRAY
     * }
     */
    public static final AddressLayout NPPELARRAY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *LPPELARRAY
     * }
     */
    public static final AddressLayout LPPELARRAY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *PLOGBRUSH
     * }
     */
    public static final AddressLayout PLOGBRUSH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *NPLOGBRUSH
     * }
     */
    public static final AddressLayout NPLOGBRUSH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *LPLOGBRUSH
     * }
     */
    public static final AddressLayout LPLOGBRUSH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *PLOGBRUSH32
     * }
     */
    public static final AddressLayout PLOGBRUSH32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *NPLOGBRUSH32
     * }
     */
    public static final AddressLayout NPLOGBRUSH32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *LPLOGBRUSH32
     * }
     */
    public static final AddressLayout LPLOGBRUSH32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *PPATTERN
     * }
     */
    public static final AddressLayout PPATTERN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *NPPATTERN
     * }
     */
    public static final AddressLayout NPPATTERN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *LPPATTERN
     * }
     */
    public static final AddressLayout LPPATTERN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *PLOGPEN
     * }
     */
    public static final AddressLayout PLOGPEN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *NPLOGPEN
     * }
     */
    public static final AddressLayout NPLOGPEN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *LPLOGPEN
     * }
     */
    public static final AddressLayout LPLOGPEN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *PEXTLOGPEN
     * }
     */
    public static final AddressLayout PEXTLOGPEN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *NPEXTLOGPEN
     * }
     */
    public static final AddressLayout NPEXTLOGPEN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *LPEXTLOGPEN
     * }
     */
    public static final AddressLayout LPEXTLOGPEN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *PEXTLOGPEN32
     * }
     */
    public static final AddressLayout PEXTLOGPEN32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *NPEXTLOGPEN32
     * }
     */
    public static final AddressLayout NPEXTLOGPEN32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *LPEXTLOGPEN32
     * }
     */
    public static final AddressLayout LPEXTLOGPEN32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPALETTEENTRY {
     *     BYTE peRed;
     *     BYTE peGreen;
     *     BYTE peBlue;
     *     BYTE peFlags;
     * } *PPALETTEENTRY
     * }
     */
    public static final AddressLayout PPALETTEENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPALETTEENTRY {
     *     BYTE peRed;
     *     BYTE peGreen;
     *     BYTE peBlue;
     *     BYTE peFlags;
     * } *LPPALETTEENTRY
     * }
     */
    public static final AddressLayout LPPALETTEENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *PLOGPALETTE
     * }
     */
    public static final AddressLayout PLOGPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *NPLOGPALETTE
     * }
     */
    public static final AddressLayout NPLOGPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *LPLOGPALETTE
     * }
     */
    public static final AddressLayout LPLOGPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *PLOGFONTA
     * }
     */
    public static final AddressLayout PLOGFONTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *NPLOGFONTA
     * }
     */
    public static final AddressLayout NPLOGFONTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *LPLOGFONTA
     * }
     */
    public static final AddressLayout LPLOGFONTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *PLOGFONTW
     * }
     */
    public static final AddressLayout PLOGFONTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *NPLOGFONTW
     * }
     */
    public static final AddressLayout NPLOGFONTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *LPLOGFONTW
     * }
     */
    public static final AddressLayout LPLOGFONTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PLOGFONTA PLOGFONT
     * }
     */
    public static final AddressLayout PLOGFONT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPLOGFONTA NPLOGFONT
     * }
     */
    public static final AddressLayout NPLOGFONT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPLOGFONTA LPLOGFONT
     * }
     */
    public static final AddressLayout LPLOGFONT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     * } *LPENUMLOGFONTA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     * } *LPENUMLOGFONTW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTA LPENUMLOGFONT
     * }
     */
    public static final AddressLayout LPENUMLOGFONT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     BYTE elfScript[32];
     * } *LPENUMLOGFONTEXA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     WCHAR elfScript[32];
     * } *LPENUMLOGFONTEXW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPANOSE {
     *     BYTE bFamilyType;
     *     BYTE bSerifStyle;
     *     BYTE bWeight;
     *     BYTE bProportion;
     *     BYTE bContrast;
     *     BYTE bStrokeVariation;
     *     BYTE bArmStyle;
     *     BYTE bLetterform;
     *     BYTE bMidline;
     *     BYTE bXHeight;
     * } *LPPANOSE
     * }
     */
    public static final AddressLayout LPPANOSE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *PEXTLOGFONTA
     * }
     */
    public static final AddressLayout PEXTLOGFONTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *NPEXTLOGFONTA
     * }
     */
    public static final AddressLayout NPEXTLOGFONTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *LPEXTLOGFONTA
     * }
     */
    public static final AddressLayout LPEXTLOGFONTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *PEXTLOGFONTW
     * }
     */
    public static final AddressLayout PEXTLOGFONTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *NPEXTLOGFONTW
     * }
     */
    public static final AddressLayout NPEXTLOGFONTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *LPEXTLOGFONTW
     * }
     */
    public static final AddressLayout LPEXTLOGFONTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXTLOGFONTA PEXTLOGFONT
     * }
     */
    public static final AddressLayout PEXTLOGFONT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPEXTLOGFONTA NPEXTLOGFONT
     * }
     */
    public static final AddressLayout NPEXTLOGFONT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPEXTLOGFONTA LPEXTLOGFONT
     * }
     */
    public static final AddressLayout LPEXTLOGFONT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *PDEVMODEA
     * }
     */
    public static final AddressLayout PDEVMODEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *NPDEVMODEA
     * }
     */
    public static final AddressLayout NPDEVMODEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *LPDEVMODEA
     * }
     */
    public static final AddressLayout LPDEVMODEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *PDEVMODEW
     * }
     */
    public static final AddressLayout PDEVMODEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *NPDEVMODEW
     * }
     */
    public static final AddressLayout NPDEVMODEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *LPDEVMODEW
     * }
     */
    public static final AddressLayout LPDEVMODEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDEVMODEA PDEVMODE
     * }
     */
    public static final AddressLayout PDEVMODE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPDEVMODEA NPDEVMODE
     * }
     */
    public static final AddressLayout NPDEVMODE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDEVMODEA LPDEVMODE
     * }
     */
    public static final AddressLayout LPDEVMODE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEA {
     *     DWORD cb;
     *     CHAR DeviceName[32];
     *     CHAR DeviceString[128];
     *     DWORD StateFlags;
     *     CHAR DeviceID[128];
     *     CHAR DeviceKey[128];
     * } *PDISPLAY_DEVICEA
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEA {
     *     DWORD cb;
     *     CHAR DeviceName[32];
     *     CHAR DeviceString[128];
     *     DWORD StateFlags;
     *     CHAR DeviceID[128];
     *     CHAR DeviceKey[128];
     * } *LPDISPLAY_DEVICEA
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEW {
     *     DWORD cb;
     *     WCHAR DeviceName[32];
     *     WCHAR DeviceString[128];
     *     DWORD StateFlags;
     *     WCHAR DeviceID[128];
     *     WCHAR DeviceKey[128];
     * } *PDISPLAY_DEVICEW
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEW {
     *     DWORD cb;
     *     WCHAR DeviceName[32];
     *     WCHAR DeviceString[128];
     *     DWORD StateFlags;
     *     WCHAR DeviceID[128];
     *     WCHAR DeviceKey[128];
     * } *LPDISPLAY_DEVICEW
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICE = winapi.C_POINTER;
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = 17
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL = 18
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = -2147483648
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_SCALING_IDENTITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_IDENTITY = 1
     * }
     */
    public static int DISPLAYCONFIG_SCALING_IDENTITY() {
        return DISPLAYCONFIG_SCALING_IDENTITY;
    }
    private static final int DISPLAYCONFIG_SCALING_CENTERED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_CENTERED = 2
     * }
     */
    public static int DISPLAYCONFIG_SCALING_CENTERED() {
        return DISPLAYCONFIG_SCALING_CENTERED;
    }
    private static final int DISPLAYCONFIG_SCALING_STRETCHED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_STRETCHED = 3
     * }
     */
    public static int DISPLAYCONFIG_SCALING_STRETCHED() {
        return DISPLAYCONFIG_SCALING_STRETCHED;
    }
    private static final int DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4
     * }
     */
    public static int DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX() {
        return DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX;
    }
    private static final int DISPLAYCONFIG_SCALING_CUSTOM = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_CUSTOM = 5
     * }
     */
    public static int DISPLAYCONFIG_SCALING_CUSTOM() {
        return DISPLAYCONFIG_SCALING_CUSTOM;
    }
    private static final int DISPLAYCONFIG_SCALING_PREFERRED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_PREFERRED = 128
     * }
     */
    public static int DISPLAYCONFIG_SCALING_PREFERRED() {
        return DISPLAYCONFIG_SCALING_PREFERRED;
    }
    private static final int DISPLAYCONFIG_SCALING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_SCALING_FORCE_UINT32() {
        return DISPLAYCONFIG_SCALING_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_ROTATION_IDENTITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_IDENTITY = 1
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_IDENTITY() {
        return DISPLAYCONFIG_ROTATION_IDENTITY;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE90 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE90 = 2
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE90() {
        return DISPLAYCONFIG_ROTATION_ROTATE90;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE180 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE180 = 3
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE180() {
        return DISPLAYCONFIG_ROTATION_ROTATE180;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE270 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE270 = 4
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE270() {
        return DISPLAYCONFIG_ROTATION_ROTATE270;
    }
    private static final int DISPLAYCONFIG_ROTATION_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_FORCE_UINT32() {
        return DISPLAYCONFIG_ROTATION_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_TARGET() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_TARGET;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_8BPP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_8BPP = 1
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_8BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_8BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_16BPP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_16BPP = 2
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_16BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_16BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_24BPP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_24BPP = 3
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_24BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_24BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_32BPP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_32BPP = 4
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_32BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_32BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_NONGDI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_NONGDI() {
        return DISPLAYCONFIG_PIXELFORMAT_NONGDI;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32() {
        return DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_INTERNAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_INTERNAL = 1
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_INTERNAL() {
        return DISPLAYCONFIG_TOPOLOGY_INTERNAL;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_CLONE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_CLONE = 2
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_CLONE() {
        return DISPLAYCONFIG_TOPOLOGY_CLONE;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_EXTEND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTEND = 4
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_EXTEND() {
        return DISPLAYCONFIG_TOPOLOGY_EXTEND;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_EXTERNAL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 8
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_EXTERNAL() {
        return DISPLAYCONFIG_TOPOLOGY_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32() {
        return DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION = 12
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION = 13
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_RESERVED1 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_RESERVED1 = 14
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_RESERVED1() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_RESERVED1;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO_2 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO_2 = 15
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO_2() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO_2;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_HDR_STATE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_HDR_STATE = 16
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_HDR_STATE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_HDR_STATE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_WCG_STATE = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_WCG_STATE = 17
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_WCG_STATE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_WCG_STATE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32() {
        return DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_RGB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_RGB = 0
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_RGB() {
        return DISPLAYCONFIG_COLOR_ENCODING_RGB;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR444() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR444;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR422() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR422;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR420() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR420;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_INTENSITY() {
        return DISPLAYCONFIG_COLOR_ENCODING_INTENSITY;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32() {
        return DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_ADVANCED_COLOR_MODE_SDR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_ADVANCED_COLOR_MODE.DISPLAYCONFIG_ADVANCED_COLOR_MODE_SDR = 0
     * }
     */
    public static int DISPLAYCONFIG_ADVANCED_COLOR_MODE_SDR() {
        return DISPLAYCONFIG_ADVANCED_COLOR_MODE_SDR;
    }
    private static final int DISPLAYCONFIG_ADVANCED_COLOR_MODE_WCG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_ADVANCED_COLOR_MODE.DISPLAYCONFIG_ADVANCED_COLOR_MODE_WCG = 1
     * }
     */
    public static int DISPLAYCONFIG_ADVANCED_COLOR_MODE_WCG() {
        return DISPLAYCONFIG_ADVANCED_COLOR_MODE_WCG;
    }
    private static final int DISPLAYCONFIG_ADVANCED_COLOR_MODE_HDR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_ADVANCED_COLOR_MODE.DISPLAYCONFIG_ADVANCED_COLOR_MODE_HDR = 2
     * }
     */
    public static int DISPLAYCONFIG_ADVANCED_COLOR_MODE_HDR() {
        return DISPLAYCONFIG_ADVANCED_COLOR_MODE_HDR;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATAHEADER {
     *     DWORD dwSize;
     *     DWORD iType;
     *     DWORD nCount;
     *     DWORD nRgnSize;
     *     RECT rcBound;
     * } *PRGNDATAHEADER
     * }
     */
    public static final AddressLayout PRGNDATAHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *PRGNDATA
     * }
     */
    public static final AddressLayout PRGNDATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *NPRGNDATA
     * }
     */
    public static final AddressLayout NPRGNDATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *LPRGNDATA
     * }
     */
    public static final AddressLayout LPRGNDATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *PABC
     * }
     */
    public static final AddressLayout PABC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *NPABC
     * }
     */
    public static final AddressLayout NPABC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *LPABC
     * }
     */
    public static final AddressLayout LPABC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *PABCFLOAT
     * }
     */
    public static final AddressLayout PABCFLOAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *NPABCFLOAT
     * }
     */
    public static final AddressLayout NPABCFLOAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *LPABCFLOAT
     * }
     */
    public static final AddressLayout LPABCFLOAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *POUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *NPOUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *LPOUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *POUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *NPOUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *LPOUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *PPOLYTEXTA
     * }
     */
    public static final AddressLayout PPOLYTEXTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *NPPOLYTEXTA
     * }
     */
    public static final AddressLayout NPPOLYTEXTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *LPPOLYTEXTA
     * }
     */
    public static final AddressLayout LPPOLYTEXTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *PPOLYTEXTW
     * }
     */
    public static final AddressLayout PPOLYTEXTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *NPPOLYTEXTW
     * }
     */
    public static final AddressLayout NPPOLYTEXTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *LPPOLYTEXTW
     * }
     */
    public static final AddressLayout LPPOLYTEXTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PPOLYTEXTA PPOLYTEXT
     * }
     */
    public static final AddressLayout PPOLYTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPPOLYTEXTA NPPOLYTEXT
     * }
     */
    public static final AddressLayout NPPOLYTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPPOLYTEXTA LPPOLYTEXT
     * }
     */
    public static final AddressLayout LPPOLYTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MAT2 {
     *     FIXED eM11;
     *     FIXED eM12;
     *     FIXED eM21;
     *     FIXED eM22;
     * } *LPMAT2
     * }
     */
    public static final AddressLayout LPMAT2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICS {
     *     UINT gmBlackBoxX;
     *     UINT gmBlackBoxY;
     *     POINT gmptGlyphOrigin;
     *     short gmCellIncX;
     *     short gmCellIncY;
     * } *LPGLYPHMETRICS
     * }
     */
    public static final AddressLayout LPGLYPHMETRICS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTFX {
     *     FIXED x;
     *     FIXED y;
     * } *LPPOINTFX
     * }
     */
    public static final AddressLayout LPPOINTFX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTTPOLYCURVE {
     *     WORD wType;
     *     WORD cpfx;
     *     POINTFX apfx[1];
     * } *LPTTPOLYCURVE
     * }
     */
    public static final AddressLayout LPTTPOLYCURVE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTTPOLYGONHEADER {
     *     DWORD cb;
     *     DWORD dwType;
     *     POINTFX pfxStart;
     * } *LPTTPOLYGONHEADER
     * }
     */
    public static final AddressLayout LPTTPOLYGONHEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGCP_RESULTSA {
     *     DWORD lStructSize;
     *     LPSTR lpOutString;
     *     UINT *lpOrder;
     *     int *lpDx;
     *     int *lpCaretPos;
     *     LPSTR lpClass;
     *     LPWSTR lpGlyphs;
     *     UINT nGlyphs;
     *     int nMaxFit;
     * } *LPGCP_RESULTSA
     * }
     */
    public static final AddressLayout LPGCP_RESULTSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGCP_RESULTSW {
     *     DWORD lStructSize;
     *     LPWSTR lpOutString;
     *     UINT *lpOrder;
     *     int *lpDx;
     *     int *lpCaretPos;
     *     LPSTR lpClass;
     *     LPWSTR lpGlyphs;
     *     UINT nGlyphs;
     *     int nMaxFit;
     * } *LPGCP_RESULTSW
     * }
     */
    public static final AddressLayout LPGCP_RESULTSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPGCP_RESULTSA LPGCP_RESULTS
     * }
     */
    public static final AddressLayout LPGCP_RESULTS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RASTERIZER_STATUS {
     *     short nSize;
     *     short wFlags;
     *     short nLanguageID;
     * } *LPRASTERIZER_STATUS
     * }
     */
    public static final AddressLayout LPRASTERIZER_STATUS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPIXELFORMATDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerType;
     *     BYTE bReserved;
     *     DWORD dwLayerMask;
     *     DWORD dwVisibleMask;
     *     DWORD dwDamageMask;
     * } *PPIXELFORMATDESCRIPTOR
     * }
     */
    public static final AddressLayout PPIXELFORMATDESCRIPTOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPIXELFORMATDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerType;
     *     BYTE bReserved;
     *     DWORD dwLayerMask;
     *     DWORD dwVisibleMask;
     *     DWORD dwDamageMask;
     * } *LPPIXELFORMATDESCRIPTOR
     * }
     */
    public static final AddressLayout LPPIXELFORMATDESCRIPTOR = winapi.C_POINTER;

    private static class AddFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddFontResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static FunctionDescriptor AddFontResourceA$descriptor() {
        return AddFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static MethodHandle AddFontResourceA$handle() {
        return AddFontResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static MemorySegment AddFontResourceA$address() {
        return AddFontResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static int AddFontResourceA(MemorySegment x0) {
        var mh$ = AddFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceA", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddFontResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static FunctionDescriptor AddFontResourceW$descriptor() {
        return AddFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static MethodHandle AddFontResourceW$handle() {
        return AddFontResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static MemorySegment AddFontResourceW$address() {
        return AddFontResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static int AddFontResourceW(MemorySegment x0) {
        var mh$ = AddFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceW", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimatePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AnimatePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static FunctionDescriptor AnimatePalette$descriptor() {
        return AnimatePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static MethodHandle AnimatePalette$handle() {
        return AnimatePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static MemorySegment AnimatePalette$address() {
        return AnimatePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static int AnimatePalette(MemorySegment hPal, int iStartIndex, int cEntries, MemorySegment ppe) {
        var mh$ = AnimatePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimatePalette", hPal, iStartIndex, cEntries, ppe);
            }
            return (int)mh$.invokeExact(hPal, iStartIndex, cEntries, ppe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Arc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Arc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static FunctionDescriptor Arc$descriptor() {
        return Arc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MethodHandle Arc$handle() {
        return Arc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MemorySegment Arc$address() {
        return Arc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static int Arc(MemorySegment hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
        var mh$ = Arc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Arc", hdc, x1, y1, x2, y2, x3, y3, x4, y4);
            }
            return (int)mh$.invokeExact(hdc, x1, y1, x2, y2, x3, y3, x4, y4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BitBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("BitBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static FunctionDescriptor BitBlt$descriptor() {
        return BitBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static MethodHandle BitBlt$handle() {
        return BitBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static MemorySegment BitBlt$address() {
        return BitBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static int BitBlt(MemorySegment hdc, int x, int y, int cx, int cy, MemorySegment hdcSrc, int x1, int y1, int rop) {
        var mh$ = BitBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BitBlt", hdc, x, y, cx, cy, hdcSrc, x1, y1, rop);
            }
            return (int)mh$.invokeExact(hdc, x, y, cx, cy, hdcSrc, x1, y1, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CancelDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor CancelDC$descriptor() {
        return CancelDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static MethodHandle CancelDC$handle() {
        return CancelDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static MemorySegment CancelDC$address() {
        return CancelDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static int CancelDC(MemorySegment hdc) {
        var mh$ = CancelDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Chord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Chord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static FunctionDescriptor Chord$descriptor() {
        return Chord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MethodHandle Chord$handle() {
        return Chord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MemorySegment Chord$address() {
        return Chord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static int Chord(MemorySegment hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
        var mh$ = Chord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Chord", hdc, x1, y1, x2, y2, x3, y3, x4, y4);
            }
            return (int)mh$.invokeExact(hdc, x1, y1, x2, y2, x3, y3, x4, y4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChoosePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ChoosePixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor ChoosePixelFormat$descriptor() {
        return ChoosePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle ChoosePixelFormat$handle() {
        return ChoosePixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MemorySegment ChoosePixelFormat$address() {
        return ChoosePixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int ChoosePixelFormat(MemorySegment hdc, MemorySegment ppfd) {
        var mh$ = ChoosePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChoosePixelFormat", hdc, ppfd);
            }
            return (int)mh$.invokeExact(hdc, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CloseMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseMetaFile$descriptor() {
        return CloseMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MethodHandle CloseMetaFile$handle() {
        return CloseMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseMetaFile$address() {
        return CloseMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseMetaFile(MemorySegment hdc) {
        var mh$ = CloseMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseMetaFile", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CombineRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CombineRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static FunctionDescriptor CombineRgn$descriptor() {
        return CombineRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static MethodHandle CombineRgn$handle() {
        return CombineRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static MemorySegment CombineRgn$address() {
        return CombineRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static int CombineRgn(MemorySegment hrgnDst, MemorySegment hrgnSrc1, MemorySegment hrgnSrc2, int iMode) {
        var mh$ = CombineRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CombineRgn", hrgnDst, hrgnSrc1, hrgnSrc2, iMode);
            }
            return (int)mh$.invokeExact(hrgnDst, hrgnSrc1, hrgnSrc2, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CopyMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static FunctionDescriptor CopyMetaFileA$descriptor() {
        return CopyMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MethodHandle CopyMetaFileA$handle() {
        return CopyMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MemorySegment CopyMetaFileA$address() {
        return CopyMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MemorySegment CopyMetaFileA(MemorySegment x0, MemorySegment x1) {
        var mh$ = CopyMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyMetaFileA", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CopyMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static FunctionDescriptor CopyMetaFileW$descriptor() {
        return CopyMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MethodHandle CopyMetaFileW$handle() {
        return CopyMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MemorySegment CopyMetaFileW$address() {
        return CopyMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MemorySegment CopyMetaFileW(MemorySegment x0, MemorySegment x1) {
        var mh$ = CopyMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyMetaFileW", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static FunctionDescriptor CreateBitmap$descriptor() {
        return CreateBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MethodHandle CreateBitmap$handle() {
        return CreateBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MemorySegment CreateBitmap$address() {
        return CreateBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MemorySegment CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitCount, MemorySegment lpBits) {
        var mh$ = CreateBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBitmap", nWidth, nHeight, nPlanes, nBitCount, lpBits);
            }
            return (MemorySegment)mh$.invokeExact(nWidth, nHeight, nPlanes, nBitCount, lpBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBitmapIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateBitmapIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static FunctionDescriptor CreateBitmapIndirect$descriptor() {
        return CreateBitmapIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MethodHandle CreateBitmapIndirect$handle() {
        return CreateBitmapIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MemorySegment CreateBitmapIndirect$address() {
        return CreateBitmapIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MemorySegment CreateBitmapIndirect(MemorySegment pbm) {
        var mh$ = CreateBitmapIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBitmapIndirect", pbm);
            }
            return (MemorySegment)mh$.invokeExact(pbm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBrushIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateBrushIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static FunctionDescriptor CreateBrushIndirect$descriptor() {
        return CreateBrushIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MethodHandle CreateBrushIndirect$handle() {
        return CreateBrushIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MemorySegment CreateBrushIndirect$address() {
        return CreateBrushIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MemorySegment CreateBrushIndirect(MemorySegment plbrush) {
        var mh$ = CreateBrushIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBrushIndirect", plbrush);
            }
            return (MemorySegment)mh$.invokeExact(plbrush);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCompatibleBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateCompatibleBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static FunctionDescriptor CreateCompatibleBitmap$descriptor() {
        return CreateCompatibleBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MethodHandle CreateCompatibleBitmap$handle() {
        return CreateCompatibleBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateCompatibleBitmap$address() {
        return CreateCompatibleBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateCompatibleBitmap(MemorySegment hdc, int cx, int cy) {
        var mh$ = CreateCompatibleBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCompatibleBitmap", hdc, cx, cy);
            }
            return (MemorySegment)mh$.invokeExact(hdc, cx, cy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDiscardableBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDiscardableBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static FunctionDescriptor CreateDiscardableBitmap$descriptor() {
        return CreateDiscardableBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MethodHandle CreateDiscardableBitmap$handle() {
        return CreateDiscardableBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateDiscardableBitmap$address() {
        return CreateDiscardableBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateDiscardableBitmap(MemorySegment hdc, int cx, int cy) {
        var mh$ = CreateDiscardableBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDiscardableBitmap", hdc, cx, cy);
            }
            return (MemorySegment)mh$.invokeExact(hdc, cx, cy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCompatibleDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateCompatibleDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor CreateCompatibleDC$descriptor() {
        return CreateCompatibleDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MethodHandle CreateCompatibleDC$handle() {
        return CreateCompatibleDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MemorySegment CreateCompatibleDC$address() {
        return CreateCompatibleDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MemorySegment CreateCompatibleDC(MemorySegment hdc) {
        var mh$ = CreateCompatibleDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCompatibleDC", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDCA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDCA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static FunctionDescriptor CreateDCA$descriptor() {
        return CreateDCA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MethodHandle CreateDCA$handle() {
        return CreateDCA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateDCA$address() {
        return CreateDCA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateDCA(MemorySegment pwszDriver, MemorySegment pwszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateDCA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDCA", pwszDriver, pwszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pwszDriver, pwszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDCW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static FunctionDescriptor CreateDCW$descriptor() {
        return CreateDCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MethodHandle CreateDCW$handle() {
        return CreateDCW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateDCW$address() {
        return CreateDCW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateDCW(MemorySegment pwszDriver, MemorySegment pwszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateDCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDCW", pwszDriver, pwszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pwszDriver, pwszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDIBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBitmap$descriptor() {
        return CreateDIBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBitmap$handle() {
        return CreateDIBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBitmap$address() {
        return CreateDIBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBitmap(MemorySegment hdc, MemorySegment pbmih, int flInit, MemorySegment pjBits, MemorySegment pbmi, int iUsage) {
        var mh$ = CreateDIBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBitmap", hdc, pbmih, flInit, pjBits, pbmi, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(hdc, pbmih, flInit, pjBits, pbmi, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBPatternBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDIBPatternBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBPatternBrush$descriptor() {
        return CreateDIBPatternBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBPatternBrush$handle() {
        return CreateDIBPatternBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrush$address() {
        return CreateDIBPatternBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrush(MemorySegment h, int iUsage) {
        var mh$ = CreateDIBPatternBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBPatternBrush", h, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(h, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBPatternBrushPt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDIBPatternBrushPt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBPatternBrushPt$descriptor() {
        return CreateDIBPatternBrushPt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBPatternBrushPt$handle() {
        return CreateDIBPatternBrushPt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrushPt$address() {
        return CreateDIBPatternBrushPt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrushPt(MemorySegment lpPackedDIB, int iUsage) {
        var mh$ = CreateDIBPatternBrushPt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBPatternBrushPt", lpPackedDIB, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(lpPackedDIB, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEllipticRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateEllipticRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static FunctionDescriptor CreateEllipticRgn$descriptor() {
        return CreateEllipticRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MethodHandle CreateEllipticRgn$handle() {
        return CreateEllipticRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateEllipticRgn$address() {
        return CreateEllipticRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateEllipticRgn(int x1, int y1, int x2, int y2) {
        var mh$ = CreateEllipticRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEllipticRgn", x1, y1, x2, y2);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEllipticRgnIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateEllipticRgnIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static FunctionDescriptor CreateEllipticRgnIndirect$descriptor() {
        return CreateEllipticRgnIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MethodHandle CreateEllipticRgnIndirect$handle() {
        return CreateEllipticRgnIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateEllipticRgnIndirect$address() {
        return CreateEllipticRgnIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateEllipticRgnIndirect(MemorySegment lprect) {
        var mh$ = CreateEllipticRgnIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEllipticRgnIndirect", lprect);
            }
            return (MemorySegment)mh$.invokeExact(lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFontIndirectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectA$descriptor() {
        return CreateFontIndirectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MethodHandle CreateFontIndirectA$handle() {
        return CreateFontIndirectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectA$address() {
        return CreateFontIndirectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectA(MemorySegment lplf) {
        var mh$ = CreateFontIndirectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectA", lplf);
            }
            return (MemorySegment)mh$.invokeExact(lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFontIndirectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectW$descriptor() {
        return CreateFontIndirectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MethodHandle CreateFontIndirectW$handle() {
        return CreateFontIndirectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectW$address() {
        return CreateFontIndirectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectW(MemorySegment lplf) {
        var mh$ = CreateFontIndirectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectW", lplf);
            }
            return (MemorySegment)mh$.invokeExact(lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFontA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static FunctionDescriptor CreateFontA$descriptor() {
        return CreateFontA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MethodHandle CreateFontA$handle() {
        return CreateFontA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontA$address() {
        return CreateFontA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, int bItalic, int bUnderline, int bStrikeOut, int iCharSet, int iOutPrecision, int iClipPrecision, int iQuality, int iPitchAndFamily, MemorySegment pszFaceName) {
        var mh$ = CreateFontA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontA", cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
            }
            return (MemorySegment)mh$.invokeExact(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFontW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static FunctionDescriptor CreateFontW$descriptor() {
        return CreateFontW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MethodHandle CreateFontW$handle() {
        return CreateFontW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontW$address() {
        return CreateFontW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, int bItalic, int bUnderline, int bStrikeOut, int iCharSet, int iOutPrecision, int iClipPrecision, int iQuality, int iPitchAndFamily, MemorySegment pszFaceName) {
        var mh$ = CreateFontW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontW", cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
            }
            return (MemorySegment)mh$.invokeExact(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHatchBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateHatchBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static FunctionDescriptor CreateHatchBrush$descriptor() {
        return CreateHatchBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MethodHandle CreateHatchBrush$handle() {
        return CreateHatchBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MemorySegment CreateHatchBrush$address() {
        return CreateHatchBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MemorySegment CreateHatchBrush(int iHatch, int color) {
        var mh$ = CreateHatchBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHatchBrush", iHatch, color);
            }
            return (MemorySegment)mh$.invokeExact(iHatch, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateICA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateICA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static FunctionDescriptor CreateICA$descriptor() {
        return CreateICA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MethodHandle CreateICA$handle() {
        return CreateICA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateICA$address() {
        return CreateICA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateICA(MemorySegment pszDriver, MemorySegment pszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateICA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateICA", pszDriver, pszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pszDriver, pszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateICW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateICW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static FunctionDescriptor CreateICW$descriptor() {
        return CreateICW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MethodHandle CreateICW$handle() {
        return CreateICW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateICW$address() {
        return CreateICW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateICW(MemorySegment pszDriver, MemorySegment pszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateICW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateICW", pszDriver, pszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pszDriver, pszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static FunctionDescriptor CreateMetaFileA$descriptor() {
        return CreateMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MethodHandle CreateMetaFileA$handle() {
        return CreateMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileA$address() {
        return CreateMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileA(MemorySegment pszFile) {
        var mh$ = CreateMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMetaFileA", pszFile);
            }
            return (MemorySegment)mh$.invokeExact(pszFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static FunctionDescriptor CreateMetaFileW$descriptor() {
        return CreateMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MethodHandle CreateMetaFileW$handle() {
        return CreateMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileW$address() {
        return CreateMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileW(MemorySegment pszFile) {
        var mh$ = CreateMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMetaFileW", pszFile);
            }
            return (MemorySegment)mh$.invokeExact(pszFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreatePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static FunctionDescriptor CreatePalette$descriptor() {
        return CreatePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MethodHandle CreatePalette$handle() {
        return CreatePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MemorySegment CreatePalette$address() {
        return CreatePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MemorySegment CreatePalette(MemorySegment plpal) {
        var mh$ = CreatePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePalette", plpal);
            }
            return (MemorySegment)mh$.invokeExact(plpal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreatePen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static FunctionDescriptor CreatePen$descriptor() {
        return CreatePen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MethodHandle CreatePen$handle() {
        return CreatePen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MemorySegment CreatePen$address() {
        return CreatePen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MemorySegment CreatePen(int iStyle, int cWidth, int color) {
        var mh$ = CreatePen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePen", iStyle, cWidth, color);
            }
            return (MemorySegment)mh$.invokeExact(iStyle, cWidth, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePenIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreatePenIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static FunctionDescriptor CreatePenIndirect$descriptor() {
        return CreatePenIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MethodHandle CreatePenIndirect$handle() {
        return CreatePenIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MemorySegment CreatePenIndirect$address() {
        return CreatePenIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MemorySegment CreatePenIndirect(MemorySegment plpen) {
        var mh$ = CreatePenIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePenIndirect", plpen);
            }
            return (MemorySegment)mh$.invokeExact(plpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePolyPolygonRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreatePolyPolygonRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static FunctionDescriptor CreatePolyPolygonRgn$descriptor() {
        return CreatePolyPolygonRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MethodHandle CreatePolyPolygonRgn$handle() {
        return CreatePolyPolygonRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MemorySegment CreatePolyPolygonRgn$address() {
        return CreatePolyPolygonRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MemorySegment CreatePolyPolygonRgn(MemorySegment pptl, MemorySegment pc, int cPoly, int iMode) {
        var mh$ = CreatePolyPolygonRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePolyPolygonRgn", pptl, pc, cPoly, iMode);
            }
            return (MemorySegment)mh$.invokeExact(pptl, pc, cPoly, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePatternBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreatePatternBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static FunctionDescriptor CreatePatternBrush$descriptor() {
        return CreatePatternBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MethodHandle CreatePatternBrush$handle() {
        return CreatePatternBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MemorySegment CreatePatternBrush$address() {
        return CreatePatternBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MemorySegment CreatePatternBrush(MemorySegment hbm) {
        var mh$ = CreatePatternBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePatternBrush", hbm);
            }
            return (MemorySegment)mh$.invokeExact(hbm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateRectRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static FunctionDescriptor CreateRectRgn$descriptor() {
        return CreateRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MethodHandle CreateRectRgn$handle() {
        return CreateRectRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateRectRgn$address() {
        return CreateRectRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateRectRgn(int x1, int y1, int x2, int y2) {
        var mh$ = CreateRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRectRgn", x1, y1, x2, y2);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRectRgnIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateRectRgnIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static FunctionDescriptor CreateRectRgnIndirect$descriptor() {
        return CreateRectRgnIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MethodHandle CreateRectRgnIndirect$handle() {
        return CreateRectRgnIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateRectRgnIndirect$address() {
        return CreateRectRgnIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateRectRgnIndirect(MemorySegment lprect) {
        var mh$ = CreateRectRgnIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRectRgnIndirect", lprect);
            }
            return (MemorySegment)mh$.invokeExact(lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRoundRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateRoundRectRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static FunctionDescriptor CreateRoundRectRgn$descriptor() {
        return CreateRoundRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MethodHandle CreateRoundRectRgn$handle() {
        return CreateRoundRectRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MemorySegment CreateRoundRectRgn$address() {
        return CreateRoundRectRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MemorySegment CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h) {
        var mh$ = CreateRoundRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRoundRectRgn", x1, y1, x2, y2, w, h);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateScalableFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateScalableFontResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static FunctionDescriptor CreateScalableFontResourceA$descriptor() {
        return CreateScalableFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static MethodHandle CreateScalableFontResourceA$handle() {
        return CreateScalableFontResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static MemorySegment CreateScalableFontResourceA$address() {
        return CreateScalableFontResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static int CreateScalableFontResourceA(int fdwHidden, MemorySegment lpszFont, MemorySegment lpszFile, MemorySegment lpszPath) {
        var mh$ = CreateScalableFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateScalableFontResourceA", fdwHidden, lpszFont, lpszFile, lpszPath);
            }
            return (int)mh$.invokeExact(fdwHidden, lpszFont, lpszFile, lpszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateScalableFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateScalableFontResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static FunctionDescriptor CreateScalableFontResourceW$descriptor() {
        return CreateScalableFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static MethodHandle CreateScalableFontResourceW$handle() {
        return CreateScalableFontResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static MemorySegment CreateScalableFontResourceW$address() {
        return CreateScalableFontResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static int CreateScalableFontResourceW(int fdwHidden, MemorySegment lpszFont, MemorySegment lpszFile, MemorySegment lpszPath) {
        var mh$ = CreateScalableFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateScalableFontResourceW", fdwHidden, lpszFont, lpszFile, lpszPath);
            }
            return (int)mh$.invokeExact(fdwHidden, lpszFont, lpszFile, lpszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSolidBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateSolidBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static FunctionDescriptor CreateSolidBrush$descriptor() {
        return CreateSolidBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MethodHandle CreateSolidBrush$handle() {
        return CreateSolidBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MemorySegment CreateSolidBrush$address() {
        return CreateSolidBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MemorySegment CreateSolidBrush(int color) {
        var mh$ = CreateSolidBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSolidBrush", color);
            }
            return (MemorySegment)mh$.invokeExact(color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor DeleteDC$descriptor() {
        return DeleteDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static MethodHandle DeleteDC$handle() {
        return DeleteDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static MemorySegment DeleteDC$address() {
        return DeleteDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static int DeleteDC(MemorySegment hdc) {
        var mh$ = DeleteDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor DeleteMetaFile$descriptor() {
        return DeleteMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static MethodHandle DeleteMetaFile$handle() {
        return DeleteMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static MemorySegment DeleteMetaFile$address() {
        return DeleteMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static int DeleteMetaFile(MemorySegment hmf) {
        var mh$ = DeleteMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteMetaFile", hmf);
            }
            return (int)mh$.invokeExact(hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static FunctionDescriptor DeleteObject$descriptor() {
        return DeleteObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static MethodHandle DeleteObject$handle() {
        return DeleteObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static MemorySegment DeleteObject$address() {
        return DeleteObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static int DeleteObject(MemorySegment ho) {
        var mh$ = DeleteObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteObject", ho);
            }
            return (int)mh$.invokeExact(ho);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DescribePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DescribePixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static FunctionDescriptor DescribePixelFormat$descriptor() {
        return DescribePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static MethodHandle DescribePixelFormat$handle() {
        return DescribePixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static MemorySegment DescribePixelFormat$address() {
        return DescribePixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static int DescribePixelFormat(MemorySegment hdc, int iPixelFormat, int nBytes, MemorySegment ppfd) {
        var mh$ = DescribePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DescribePixelFormat", hdc, iPixelFormat, nBytes, ppfd);
            }
            return (int)mh$.invokeExact(hdc, iPixelFormat, nBytes, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceCapabilitiesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_SHORT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeviceCapabilitiesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static FunctionDescriptor DeviceCapabilitiesA$descriptor() {
        return DeviceCapabilitiesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static MethodHandle DeviceCapabilitiesA$handle() {
        return DeviceCapabilitiesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static MemorySegment DeviceCapabilitiesA$address() {
        return DeviceCapabilitiesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static int DeviceCapabilitiesA(MemorySegment pDevice, MemorySegment pPort, short fwCapability, MemorySegment pOutput, MemorySegment pDevMode) {
        var mh$ = DeviceCapabilitiesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceCapabilitiesA", pDevice, pPort, fwCapability, pOutput, pDevMode);
            }
            return (int)mh$.invokeExact(pDevice, pPort, fwCapability, pOutput, pDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceCapabilitiesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_SHORT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeviceCapabilitiesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static FunctionDescriptor DeviceCapabilitiesW$descriptor() {
        return DeviceCapabilitiesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static MethodHandle DeviceCapabilitiesW$handle() {
        return DeviceCapabilitiesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static MemorySegment DeviceCapabilitiesW$address() {
        return DeviceCapabilitiesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static int DeviceCapabilitiesW(MemorySegment pDevice, MemorySegment pPort, short fwCapability, MemorySegment pOutput, MemorySegment pDevMode) {
        var mh$ = DeviceCapabilitiesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceCapabilitiesW", pDevice, pPort, fwCapability, pOutput, pDevMode);
            }
            return (int)mh$.invokeExact(pDevice, pPort, fwCapability, pOutput, pDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DrawEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static FunctionDescriptor DrawEscape$descriptor() {
        return DrawEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static MethodHandle DrawEscape$handle() {
        return DrawEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static MemorySegment DrawEscape$address() {
        return DrawEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static int DrawEscape(MemorySegment hdc, int iEscape, int cjIn, MemorySegment lpIn) {
        var mh$ = DrawEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEscape", hdc, iEscape, cjIn, lpIn);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjIn, lpIn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ellipse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Ellipse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor Ellipse$descriptor() {
        return Ellipse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle Ellipse$handle() {
        return Ellipse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment Ellipse$address() {
        return Ellipse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int Ellipse(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = Ellipse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ellipse", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumFontFamiliesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesExA$descriptor() {
        return EnumFontFamiliesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumFontFamiliesExA$handle() {
        return EnumFontFamiliesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumFontFamiliesExA$address() {
        return EnumFontFamiliesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static int EnumFontFamiliesExA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam, int dwFlags) {
        var mh$ = EnumFontFamiliesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesExA", hdc, lpLogfont, lpProc, lParam, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumFontFamiliesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesExW$descriptor() {
        return EnumFontFamiliesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumFontFamiliesExW$handle() {
        return EnumFontFamiliesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumFontFamiliesExW$address() {
        return EnumFontFamiliesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static int EnumFontFamiliesExW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam, int dwFlags) {
        var mh$ = EnumFontFamiliesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesExW", hdc, lpLogfont, lpProc, lParam, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumFontFamiliesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesA$descriptor() {
        return EnumFontFamiliesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontFamiliesA$handle() {
        return EnumFontFamiliesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontFamiliesA$address() {
        return EnumFontFamiliesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontFamiliesA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontFamiliesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesA", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumFontFamiliesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesW$descriptor() {
        return EnumFontFamiliesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontFamiliesW$handle() {
        return EnumFontFamiliesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontFamiliesW$address() {
        return EnumFontFamiliesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontFamiliesW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontFamiliesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesW", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumFontsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontsA$descriptor() {
        return EnumFontsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontsA$handle() {
        return EnumFontsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontsA$address() {
        return EnumFontsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontsA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontsA", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumFontsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontsW$descriptor() {
        return EnumFontsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontsW$handle() {
        return EnumFontsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontsW$address() {
        return EnumFontsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontsW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontsW", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumObjects$descriptor() {
        return EnumObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumObjects$handle() {
        return EnumObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumObjects$address() {
        return EnumObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static int EnumObjects(MemorySegment hdc, int nType, MemorySegment lpFunc, long lParam) {
        var mh$ = EnumObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumObjects", hdc, nType, lpFunc, lParam);
            }
            return (int)mh$.invokeExact(hdc, nType, lpFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EqualRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static FunctionDescriptor EqualRgn$descriptor() {
        return EqualRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static MethodHandle EqualRgn$handle() {
        return EqualRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static MemorySegment EqualRgn$address() {
        return EqualRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static int EqualRgn(MemorySegment hrgn1, MemorySegment hrgn2) {
        var mh$ = EqualRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualRgn", hrgn1, hrgn2);
            }
            return (int)mh$.invokeExact(hrgn1, hrgn2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Escape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Escape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static FunctionDescriptor Escape$descriptor() {
        return Escape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static MethodHandle Escape$handle() {
        return Escape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static MemorySegment Escape$address() {
        return Escape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static int Escape(MemorySegment hdc, int iEscape, int cjIn, MemorySegment pvIn, MemorySegment pvOut) {
        var mh$ = Escape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Escape", hdc, iEscape, cjIn, pvIn, pvOut);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjIn, pvIn, pvOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExtEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static FunctionDescriptor ExtEscape$descriptor() {
        return ExtEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static MethodHandle ExtEscape$handle() {
        return ExtEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static MemorySegment ExtEscape$address() {
        return ExtEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static int ExtEscape(MemorySegment hdc, int iEscape, int cjInput, MemorySegment lpInData, int cjOutput, MemorySegment lpOutData) {
        var mh$ = ExtEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtEscape", hdc, iEscape, cjInput, lpInData, cjOutput, lpOutData);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjInput, lpInData, cjOutput, lpOutData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExcludeClipRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExcludeClipRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor ExcludeClipRect$descriptor() {
        return ExcludeClipRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle ExcludeClipRect$handle() {
        return ExcludeClipRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment ExcludeClipRect$address() {
        return ExcludeClipRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int ExcludeClipRect(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = ExcludeClipRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExcludeClipRect", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtCreateRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExtCreateRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static FunctionDescriptor ExtCreateRegion$descriptor() {
        return ExtCreateRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MethodHandle ExtCreateRegion$handle() {
        return ExtCreateRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MemorySegment ExtCreateRegion$address() {
        return ExtCreateRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MemorySegment ExtCreateRegion(MemorySegment lpx, int nCount, MemorySegment lpData) {
        var mh$ = ExtCreateRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtCreateRegion", lpx, nCount, lpData);
            }
            return (MemorySegment)mh$.invokeExact(lpx, nCount, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtFloodFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExtFloodFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static FunctionDescriptor ExtFloodFill$descriptor() {
        return ExtFloodFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static MethodHandle ExtFloodFill$handle() {
        return ExtFloodFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static MemorySegment ExtFloodFill$address() {
        return ExtFloodFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static int ExtFloodFill(MemorySegment hdc, int x, int y, int color, int type) {
        var mh$ = ExtFloodFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtFloodFill", hdc, x, y, color, type);
            }
            return (int)mh$.invokeExact(hdc, x, y, color, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FillRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static FunctionDescriptor FillRgn$descriptor() {
        return FillRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static MethodHandle FillRgn$handle() {
        return FillRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static MemorySegment FillRgn$address() {
        return FillRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static int FillRgn(MemorySegment hdc, MemorySegment hrgn, MemorySegment hbr) {
        var mh$ = FillRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillRgn", hdc, hrgn, hbr);
            }
            return (int)mh$.invokeExact(hdc, hrgn, hbr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FloodFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FloodFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor FloodFill$descriptor() {
        return FloodFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle FloodFill$handle() {
        return FloodFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MemorySegment FloodFill$address() {
        return FloodFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int FloodFill(MemorySegment hdc, int x, int y, int color) {
        var mh$ = FloodFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FloodFill", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FrameRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FrameRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static FunctionDescriptor FrameRgn$descriptor() {
        return FrameRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static MethodHandle FrameRgn$handle() {
        return FrameRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static MemorySegment FrameRgn$address() {
        return FrameRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static int FrameRgn(MemorySegment hdc, MemorySegment hrgn, MemorySegment hbr, int w, int h) {
        var mh$ = FrameRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FrameRgn", hdc, hrgn, hbr, w, h);
            }
            return (int)mh$.invokeExact(hdc, hrgn, hbr, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetROP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetROP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetROP2$descriptor() {
        return GetROP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static MethodHandle GetROP2$handle() {
        return GetROP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static MemorySegment GetROP2$address() {
        return GetROP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static int GetROP2(MemorySegment hdc) {
        var mh$ = GetROP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetROP2", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAspectRatioFilterEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetAspectRatioFilterEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetAspectRatioFilterEx$descriptor() {
        return GetAspectRatioFilterEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetAspectRatioFilterEx$handle() {
        return GetAspectRatioFilterEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetAspectRatioFilterEx$address() {
        return GetAspectRatioFilterEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetAspectRatioFilterEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetAspectRatioFilterEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAspectRatioFilterEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBkColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetBkColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetBkColor$descriptor() {
        return GetBkColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static MethodHandle GetBkColor$handle() {
        return GetBkColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static MemorySegment GetBkColor$address() {
        return GetBkColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static int GetBkColor(MemorySegment hdc) {
        var mh$ = GetBkColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBkColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCBrushColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDCBrushColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetDCBrushColor$descriptor() {
        return GetDCBrushColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static MethodHandle GetDCBrushColor$handle() {
        return GetDCBrushColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static MemorySegment GetDCBrushColor$address() {
        return GetDCBrushColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static int GetDCBrushColor(MemorySegment hdc) {
        var mh$ = GetDCBrushColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCBrushColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCPenColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDCPenColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetDCPenColor$descriptor() {
        return GetDCPenColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static MethodHandle GetDCPenColor$handle() {
        return GetDCPenColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static MemorySegment GetDCPenColor$address() {
        return GetDCPenColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static int GetDCPenColor(MemorySegment hdc) {
        var mh$ = GetDCPenColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCPenColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBkMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetBkMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetBkMode$descriptor() {
        return GetBkMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static MethodHandle GetBkMode$handle() {
        return GetBkMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static MemorySegment GetBkMode$address() {
        return GetBkMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static int GetBkMode(MemorySegment hdc) {
        var mh$ = GetBkMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBkMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBitmapBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetBitmapBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static FunctionDescriptor GetBitmapBits$descriptor() {
        return GetBitmapBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static MethodHandle GetBitmapBits$handle() {
        return GetBitmapBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static MemorySegment GetBitmapBits$address() {
        return GetBitmapBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static int GetBitmapBits(MemorySegment hbit, int cb, MemorySegment lpvBits) {
        var mh$ = GetBitmapBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBitmapBits", hbit, cb, lpvBits);
            }
            return (int)mh$.invokeExact(hbit, cb, lpvBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBitmapDimensionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetBitmapDimensionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetBitmapDimensionEx$descriptor() {
        return GetBitmapDimensionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetBitmapDimensionEx$handle() {
        return GetBitmapDimensionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetBitmapDimensionEx$address() {
        return GetBitmapDimensionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static int GetBitmapDimensionEx(MemorySegment hbit, MemorySegment lpsize) {
        var mh$ = GetBitmapDimensionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBitmapDimensionEx", hbit, lpsize);
            }
            return (int)mh$.invokeExact(hbit, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBoundsRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetBoundsRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor GetBoundsRect$descriptor() {
        return GetBoundsRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static MethodHandle GetBoundsRect$handle() {
        return GetBoundsRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static MemorySegment GetBoundsRect$address() {
        return GetBoundsRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static int GetBoundsRect(MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = GetBoundsRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBoundsRect", hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetBrushOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetBrushOrgEx$descriptor() {
        return GetBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetBrushOrgEx$handle() {
        return GetBrushOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MemorySegment GetBrushOrgEx$address() {
        return GetBrushOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetBrushOrgEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBrushOrgEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharWidthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthA$descriptor() {
        return GetCharWidthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthA$handle() {
        return GetCharWidthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthA$address() {
        return GetCharWidthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidthA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthA", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharWidthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthW$descriptor() {
        return GetCharWidthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthW$handle() {
        return GetCharWidthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthW$address() {
        return GetCharWidthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidthW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthW", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidth32A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharWidth32A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidth32A$descriptor() {
        return GetCharWidth32A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidth32A$handle() {
        return GetCharWidth32A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidth32A$address() {
        return GetCharWidth32A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidth32A(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidth32A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidth32A", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidth32W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharWidth32W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidth32W$descriptor() {
        return GetCharWidth32W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidth32W$handle() {
        return GetCharWidth32W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidth32W$address() {
        return GetCharWidth32W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidth32W(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidth32W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidth32W", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthFloatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharWidthFloatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthFloatA$descriptor() {
        return GetCharWidthFloatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthFloatA$handle() {
        return GetCharWidthFloatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthFloatA$address() {
        return GetCharWidthFloatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static int GetCharWidthFloatA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthFloatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthFloatA", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthFloatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharWidthFloatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthFloatW$descriptor() {
        return GetCharWidthFloatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthFloatW$handle() {
        return GetCharWidthFloatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthFloatW$address() {
        return GetCharWidthFloatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static int GetCharWidthFloatW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthFloatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthFloatW", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharABCWidthsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsA$descriptor() {
        return GetCharABCWidthsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsA$handle() {
        return GetCharABCWidthsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsA$address() {
        return GetCharABCWidthsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static int GetCharABCWidthsA(MemorySegment hdc, int wFirst, int wLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsA", hdc, wFirst, wLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, wFirst, wLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharABCWidthsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsW$descriptor() {
        return GetCharABCWidthsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsW$handle() {
        return GetCharABCWidthsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsW$address() {
        return GetCharABCWidthsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static int GetCharABCWidthsW(MemorySegment hdc, int wFirst, int wLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsW", hdc, wFirst, wLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, wFirst, wLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsFloatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharABCWidthsFloatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsFloatA$descriptor() {
        return GetCharABCWidthsFloatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsFloatA$handle() {
        return GetCharABCWidthsFloatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsFloatA$address() {
        return GetCharABCWidthsFloatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static int GetCharABCWidthsFloatA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsFloatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsFloatA", hdc, iFirst, iLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsFloatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharABCWidthsFloatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsFloatW$descriptor() {
        return GetCharABCWidthsFloatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsFloatW$handle() {
        return GetCharABCWidthsFloatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsFloatW$address() {
        return GetCharABCWidthsFloatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static int GetCharABCWidthsFloatW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsFloatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsFloatW", hdc, iFirst, iLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetClipBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static FunctionDescriptor GetClipBox$descriptor() {
        return GetClipBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static MethodHandle GetClipBox$handle() {
        return GetClipBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static MemorySegment GetClipBox$address() {
        return GetClipBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static int GetClipBox(MemorySegment hdc, MemorySegment lprect) {
        var mh$ = GetClipBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipBox", hdc, lprect);
            }
            return (int)mh$.invokeExact(hdc, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor GetClipRgn$descriptor() {
        return GetClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle GetClipRgn$handle() {
        return GetClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment GetClipRgn$address() {
        return GetClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int GetClipRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = GetClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetMetaRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor GetMetaRgn$descriptor() {
        return GetMetaRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle GetMetaRgn$handle() {
        return GetMetaRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment GetMetaRgn$address() {
        return GetMetaRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int GetMetaRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = GetMetaRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrentObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static FunctionDescriptor GetCurrentObject$descriptor() {
        return GetCurrentObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MethodHandle GetCurrentObject$handle() {
        return GetCurrentObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MemorySegment GetCurrentObject$address() {
        return GetCurrentObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MemorySegment GetCurrentObject(MemorySegment hdc, int type) {
        var mh$ = GetCurrentObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentObject", hdc, type);
            }
            return (MemorySegment)mh$.invokeExact(hdc, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentPositionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrentPositionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetCurrentPositionEx$descriptor() {
        return GetCurrentPositionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetCurrentPositionEx$handle() {
        return GetCurrentPositionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MemorySegment GetCurrentPositionEx$address() {
        return GetCurrentPositionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetCurrentPositionEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetCurrentPositionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentPositionEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDeviceCaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDeviceCaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static FunctionDescriptor GetDeviceCaps$descriptor() {
        return GetDeviceCaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static MethodHandle GetDeviceCaps$handle() {
        return GetDeviceCaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static MemorySegment GetDeviceCaps$address() {
        return GetDeviceCaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static int GetDeviceCaps(MemorySegment hdc, int index) {
        var mh$ = GetDeviceCaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDeviceCaps", hdc, index);
            }
            return (int)mh$.invokeExact(hdc, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDIBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static FunctionDescriptor GetDIBits$descriptor() {
        return GetDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static MethodHandle GetDIBits$handle() {
        return GetDIBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static MemorySegment GetDIBits$address() {
        return GetDIBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static int GetDIBits(MemorySegment hdc, MemorySegment hbm, int start, int cLines, MemorySegment lpvBits, MemorySegment lpbmi, int usage) {
        var mh$ = GetDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDIBits", hdc, hbm, start, cLines, lpvBits, lpbmi, usage);
            }
            return (int)mh$.invokeExact(hdc, hbm, start, cLines, lpvBits, lpbmi, usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFontData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static FunctionDescriptor GetFontData$descriptor() {
        return GetFontData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static MethodHandle GetFontData$handle() {
        return GetFontData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static MemorySegment GetFontData$address() {
        return GetFontData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static int GetFontData(MemorySegment hdc, int dwTable, int dwOffset, MemorySegment pvBuffer, int cjBuffer) {
        var mh$ = GetFontData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontData", hdc, dwTable, dwOffset, pvBuffer, cjBuffer);
            }
            return (int)mh$.invokeExact(hdc, dwTable, dwOffset, pvBuffer, cjBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphOutlineA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetGlyphOutlineA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static FunctionDescriptor GetGlyphOutlineA$descriptor() {
        return GetGlyphOutlineA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MethodHandle GetGlyphOutlineA$handle() {
        return GetGlyphOutlineA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MemorySegment GetGlyphOutlineA$address() {
        return GetGlyphOutlineA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static int GetGlyphOutlineA(MemorySegment hdc, int uChar, int fuFormat, MemorySegment lpgm, int cjBuffer, MemorySegment pvBuffer, MemorySegment lpmat2) {
        var mh$ = GetGlyphOutlineA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphOutlineA", hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
            }
            return (int)mh$.invokeExact(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphOutlineW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetGlyphOutlineW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static FunctionDescriptor GetGlyphOutlineW$descriptor() {
        return GetGlyphOutlineW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MethodHandle GetGlyphOutlineW$handle() {
        return GetGlyphOutlineW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MemorySegment GetGlyphOutlineW$address() {
        return GetGlyphOutlineW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static int GetGlyphOutlineW(MemorySegment hdc, int uChar, int fuFormat, MemorySegment lpgm, int cjBuffer, MemorySegment pvBuffer, MemorySegment lpmat2) {
        var mh$ = GetGlyphOutlineW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphOutlineW", hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
            }
            return (int)mh$.invokeExact(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGraphicsMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetGraphicsMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetGraphicsMode$descriptor() {
        return GetGraphicsMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static MethodHandle GetGraphicsMode$handle() {
        return GetGraphicsMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static MemorySegment GetGraphicsMode$address() {
        return GetGraphicsMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static int GetGraphicsMode(MemorySegment hdc) {
        var mh$ = GetGraphicsMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGraphicsMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMapMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetMapMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetMapMode$descriptor() {
        return GetMapMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static MethodHandle GetMapMode$handle() {
        return GetMapMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static MemorySegment GetMapMode$address() {
        return GetMapMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static int GetMapMode(MemorySegment hdc) {
        var mh$ = GetMapMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMapMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileBitsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetMetaFileBitsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetMetaFileBitsEx$descriptor() {
        return GetMetaFileBitsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static MethodHandle GetMetaFileBitsEx$handle() {
        return GetMetaFileBitsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static MemorySegment GetMetaFileBitsEx$address() {
        return GetMetaFileBitsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static int GetMetaFileBitsEx(MemorySegment hMF, int cbBuffer, MemorySegment lpData) {
        var mh$ = GetMetaFileBitsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileBitsEx", hMF, cbBuffer, lpData);
            }
            return (int)mh$.invokeExact(hMF, cbBuffer, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor GetMetaFileA$descriptor() {
        return GetMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MethodHandle GetMetaFileA$handle() {
        return GetMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileA$address() {
        return GetMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileA(MemorySegment lpName) {
        var mh$ = GetMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileA", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetMetaFileW$descriptor() {
        return GetMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MethodHandle GetMetaFileW$handle() {
        return GetMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileW$address() {
        return GetMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileW(MemorySegment lpName) {
        var mh$ = GetMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileW", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNearestColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNearestColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor GetNearestColor$descriptor() {
        return GetNearestColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle GetNearestColor$handle() {
        return GetNearestColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment GetNearestColor$address() {
        return GetNearestColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static int GetNearestColor(MemorySegment hdc, int color) {
        var mh$ = GetNearestColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNearestColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNearestPaletteIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNearestPaletteIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static FunctionDescriptor GetNearestPaletteIndex$descriptor() {
        return GetNearestPaletteIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static MethodHandle GetNearestPaletteIndex$handle() {
        return GetNearestPaletteIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static MemorySegment GetNearestPaletteIndex$address() {
        return GetNearestPaletteIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static int GetNearestPaletteIndex(MemorySegment h, int color) {
        var mh$ = GetNearestPaletteIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNearestPaletteIndex", h, color);
            }
            return (int)mh$.invokeExact(h, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetObjectType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor GetObjectType$descriptor() {
        return GetObjectType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static MethodHandle GetObjectType$handle() {
        return GetObjectType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static MemorySegment GetObjectType$address() {
        return GetObjectType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static int GetObjectType(MemorySegment h) {
        var mh$ = GetObjectType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectType", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOutlineTextMetricsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetOutlineTextMetricsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static FunctionDescriptor GetOutlineTextMetricsA$descriptor() {
        return GetOutlineTextMetricsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static MethodHandle GetOutlineTextMetricsA$handle() {
        return GetOutlineTextMetricsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static MemorySegment GetOutlineTextMetricsA$address() {
        return GetOutlineTextMetricsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static int GetOutlineTextMetricsA(MemorySegment hdc, int cjCopy, MemorySegment potm) {
        var mh$ = GetOutlineTextMetricsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOutlineTextMetricsA", hdc, cjCopy, potm);
            }
            return (int)mh$.invokeExact(hdc, cjCopy, potm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOutlineTextMetricsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetOutlineTextMetricsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static FunctionDescriptor GetOutlineTextMetricsW$descriptor() {
        return GetOutlineTextMetricsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static MethodHandle GetOutlineTextMetricsW$handle() {
        return GetOutlineTextMetricsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static MemorySegment GetOutlineTextMetricsW$address() {
        return GetOutlineTextMetricsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static int GetOutlineTextMetricsW(MemorySegment hdc, int cjCopy, MemorySegment potm) {
        var mh$ = GetOutlineTextMetricsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOutlineTextMetricsW", hdc, cjCopy, potm);
            }
            return (int)mh$.invokeExact(hdc, cjCopy, potm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static FunctionDescriptor GetPaletteEntries$descriptor() {
        return GetPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MethodHandle GetPaletteEntries$handle() {
        return GetPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MemorySegment GetPaletteEntries$address() {
        return GetPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static int GetPaletteEntries(MemorySegment hpal, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = GetPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPaletteEntries", hpal, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hpal, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor GetPixel$descriptor() {
        return GetPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle GetPixel$handle() {
        return GetPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment GetPixel$address() {
        return GetPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static int GetPixel(MemorySegment hdc, int x, int y) {
        var mh$ = GetPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixel", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetPixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetPixelFormat$descriptor() {
        return GetPixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static MethodHandle GetPixelFormat$handle() {
        return GetPixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static MemorySegment GetPixelFormat$address() {
        return GetPixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static int GetPixelFormat(MemorySegment hdc) {
        var mh$ = GetPixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixelFormat", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPolyFillMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetPolyFillMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetPolyFillMode$descriptor() {
        return GetPolyFillMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static MethodHandle GetPolyFillMode$handle() {
        return GetPolyFillMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static MemorySegment GetPolyFillMode$address() {
        return GetPolyFillMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static int GetPolyFillMode(MemorySegment hdc) {
        var mh$ = GetPolyFillMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPolyFillMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRasterizerCaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetRasterizerCaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static FunctionDescriptor GetRasterizerCaps$descriptor() {
        return GetRasterizerCaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static MethodHandle GetRasterizerCaps$handle() {
        return GetRasterizerCaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static MemorySegment GetRasterizerCaps$address() {
        return GetRasterizerCaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static int GetRasterizerCaps(MemorySegment lpraststat, int cjBytes) {
        var mh$ = GetRasterizerCaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRasterizerCaps", lpraststat, cjBytes);
            }
            return (int)mh$.invokeExact(lpraststat, cjBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRandomRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetRandomRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static FunctionDescriptor GetRandomRgn$descriptor() {
        return GetRandomRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static MethodHandle GetRandomRgn$handle() {
        return GetRandomRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static MemorySegment GetRandomRgn$address() {
        return GetRandomRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static int GetRandomRgn(MemorySegment hdc, MemorySegment hrgn, int i) {
        var mh$ = GetRandomRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRandomRgn", hdc, hrgn, i);
            }
            return (int)mh$.invokeExact(hdc, hrgn, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRegionData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetRegionData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static FunctionDescriptor GetRegionData$descriptor() {
        return GetRegionData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static MethodHandle GetRegionData$handle() {
        return GetRegionData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static MemorySegment GetRegionData$address() {
        return GetRegionData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static int GetRegionData(MemorySegment hrgn, int nCount, MemorySegment lpRgnData) {
        var mh$ = GetRegionData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRegionData", hrgn, nCount, lpRgnData);
            }
            return (int)mh$.invokeExact(hrgn, nCount, lpRgnData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRgnBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetRgnBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static FunctionDescriptor GetRgnBox$descriptor() {
        return GetRgnBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static MethodHandle GetRgnBox$handle() {
        return GetRgnBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static MemorySegment GetRgnBox$address() {
        return GetRgnBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static int GetRgnBox(MemorySegment hrgn, MemorySegment lprc) {
        var mh$ = GetRgnBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRgnBox", hrgn, lprc);
            }
            return (int)mh$.invokeExact(hrgn, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStockObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetStockObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static FunctionDescriptor GetStockObject$descriptor() {
        return GetStockObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MethodHandle GetStockObject$handle() {
        return GetStockObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MemorySegment GetStockObject$address() {
        return GetStockObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MemorySegment GetStockObject(int i) {
        var mh$ = GetStockObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStockObject", i);
            }
            return (MemorySegment)mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStretchBltMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetStretchBltMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetStretchBltMode$descriptor() {
        return GetStretchBltMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static MethodHandle GetStretchBltMode$handle() {
        return GetStretchBltMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static MemorySegment GetStretchBltMode$address() {
        return GetStretchBltMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static int GetStretchBltMode(MemorySegment hdc) {
        var mh$ = GetStretchBltMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStretchBltMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetSystemPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static FunctionDescriptor GetSystemPaletteEntries$descriptor() {
        return GetSystemPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MethodHandle GetSystemPaletteEntries$handle() {
        return GetSystemPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MemorySegment GetSystemPaletteEntries$address() {
        return GetSystemPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static int GetSystemPaletteEntries(MemorySegment hdc, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = GetSystemPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPaletteEntries", hdc, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPaletteUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetSystemPaletteUse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetSystemPaletteUse$descriptor() {
        return GetSystemPaletteUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static MethodHandle GetSystemPaletteUse$handle() {
        return GetSystemPaletteUse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static MemorySegment GetSystemPaletteUse$address() {
        return GetSystemPaletteUse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static int GetSystemPaletteUse(MemorySegment hdc) {
        var mh$ = GetSystemPaletteUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPaletteUse", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharacterExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextCharacterExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextCharacterExtra$descriptor() {
        return GetTextCharacterExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static MethodHandle GetTextCharacterExtra$handle() {
        return GetTextCharacterExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static MemorySegment GetTextCharacterExtra$address() {
        return GetTextCharacterExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static int GetTextCharacterExtra(MemorySegment hdc) {
        var mh$ = GetTextCharacterExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharacterExtra", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextAlign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextAlign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextAlign$descriptor() {
        return GetTextAlign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static MethodHandle GetTextAlign$handle() {
        return GetTextAlign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static MemorySegment GetTextAlign$address() {
        return GetTextAlign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static int GetTextAlign(MemorySegment hdc) {
        var mh$ = GetTextAlign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextAlign", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextColor$descriptor() {
        return GetTextColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static MethodHandle GetTextColor$handle() {
        return GetTextColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static MemorySegment GetTextColor$address() {
        return GetTextColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static int GetTextColor(MemorySegment hdc) {
        var mh$ = GetTextColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextExtentPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointA$descriptor() {
        return GetTextExtentPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MethodHandle GetTextExtentPointA$handle() {
        return GetTextExtentPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MemorySegment GetTextExtentPointA$address() {
        return GetTextExtentPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static int GetTextExtentPointA(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment lpsz) {
        var mh$ = GetTextExtentPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointA", hdc, lpString, c, lpsz);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextExtentPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointW$descriptor() {
        return GetTextExtentPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MethodHandle GetTextExtentPointW$handle() {
        return GetTextExtentPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MemorySegment GetTextExtentPointW$address() {
        return GetTextExtentPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static int GetTextExtentPointW(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment lpsz) {
        var mh$ = GetTextExtentPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointW", hdc, lpString, c, lpsz);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPoint32A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextExtentPoint32A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static FunctionDescriptor GetTextExtentPoint32A$descriptor() {
        return GetTextExtentPoint32A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MethodHandle GetTextExtentPoint32A$handle() {
        return GetTextExtentPoint32A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MemorySegment GetTextExtentPoint32A$address() {
        return GetTextExtentPoint32A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static int GetTextExtentPoint32A(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment psizl) {
        var mh$ = GetTextExtentPoint32A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPoint32A", hdc, lpString, c, psizl);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, psizl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPoint32W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextExtentPoint32W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static FunctionDescriptor GetTextExtentPoint32W$descriptor() {
        return GetTextExtentPoint32W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MethodHandle GetTextExtentPoint32W$handle() {
        return GetTextExtentPoint32W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MemorySegment GetTextExtentPoint32W$address() {
        return GetTextExtentPoint32W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static int GetTextExtentPoint32W(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment psizl) {
        var mh$ = GetTextExtentPoint32W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPoint32W", hdc, lpString, c, psizl);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, psizl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextExtentExPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointA$descriptor() {
        return GetTextExtentExPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointA$handle() {
        return GetTextExtentExPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MemorySegment GetTextExtentExPointA$address() {
        return GetTextExtentExPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointA(MemorySegment hdc, MemorySegment lpszString, int cchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointA", hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextExtentExPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointW$descriptor() {
        return GetTextExtentExPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointW$handle() {
        return GetTextExtentExPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MemorySegment GetTextExtentExPointW$address() {
        return GetTextExtentExPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointW(MemorySegment hdc, MemorySegment lpszString, int cchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointW", hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextCharset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextCharset$descriptor() {
        return GetTextCharset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static MethodHandle GetTextCharset$handle() {
        return GetTextCharset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static MemorySegment GetTextCharset$address() {
        return GetTextCharset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static int GetTextCharset(MemorySegment hdc) {
        var mh$ = GetTextCharset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharset", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharsetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextCharsetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetTextCharsetInfo$descriptor() {
        return GetTextCharsetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetTextCharsetInfo$handle() {
        return GetTextCharsetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetTextCharsetInfo$address() {
        return GetTextCharsetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static int GetTextCharsetInfo(MemorySegment hdc, MemorySegment lpSig, int dwFlags) {
        var mh$ = GetTextCharsetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharsetInfo", hdc, lpSig, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpSig, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateCharsetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TranslateCharsetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor TranslateCharsetInfo$descriptor() {
        return TranslateCharsetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static MethodHandle TranslateCharsetInfo$handle() {
        return TranslateCharsetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static MemorySegment TranslateCharsetInfo$address() {
        return TranslateCharsetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static int TranslateCharsetInfo(MemorySegment lpSrc, MemorySegment lpCs, int dwFlags) {
        var mh$ = TranslateCharsetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateCharsetInfo", lpSrc, lpCs, dwFlags);
            }
            return (int)mh$.invokeExact(lpSrc, lpCs, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontLanguageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFontLanguageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetFontLanguageInfo$descriptor() {
        return GetFontLanguageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static MethodHandle GetFontLanguageInfo$handle() {
        return GetFontLanguageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static MemorySegment GetFontLanguageInfo$address() {
        return GetFontLanguageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static int GetFontLanguageInfo(MemorySegment hdc) {
        var mh$ = GetFontLanguageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontLanguageInfo", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharacterPlacementA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharacterPlacementA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetCharacterPlacementA$descriptor() {
        return GetCharacterPlacementA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetCharacterPlacementA$handle() {
        return GetCharacterPlacementA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetCharacterPlacementA$address() {
        return GetCharacterPlacementA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static int GetCharacterPlacementA(MemorySegment hdc, MemorySegment lpString, int nCount, int nMexExtent, MemorySegment lpResults, int dwFlags) {
        var mh$ = GetCharacterPlacementA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharacterPlacementA", hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharacterPlacementW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharacterPlacementW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetCharacterPlacementW$descriptor() {
        return GetCharacterPlacementW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetCharacterPlacementW$handle() {
        return GetCharacterPlacementW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetCharacterPlacementW$address() {
        return GetCharacterPlacementW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static int GetCharacterPlacementW(MemorySegment hdc, MemorySegment lpString, int nCount, int nMexExtent, MemorySegment lpResults, int dwFlags) {
        var mh$ = GetCharacterPlacementW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharacterPlacementW", hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWCRANGE {
     *     WCHAR wcLow;
     *     USHORT cGlyphs;
     * } *PWCRANGE
     * }
     */
    public static final AddressLayout PWCRANGE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWCRANGE {
     *     WCHAR wcLow;
     *     USHORT cGlyphs;
     * } *LPWCRANGE
     * }
     */
    public static final AddressLayout LPWCRANGE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGLYPHSET {
     *     DWORD cbThis;
     *     DWORD flAccel;
     *     DWORD cGlyphsSupported;
     *     DWORD cRanges;
     *     WCRANGE ranges[1];
     * } *PGLYPHSET
     * }
     */
    public static final AddressLayout PGLYPHSET = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGLYPHSET {
     *     DWORD cbThis;
     *     DWORD flAccel;
     *     DWORD cGlyphsSupported;
     *     DWORD cRanges;
     *     WCRANGE ranges[1];
     * } *LPGLYPHSET
     * }
     */
    public static final AddressLayout LPGLYPHSET = winapi.C_POINTER;

    private static class GetFontUnicodeRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFontUnicodeRanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static FunctionDescriptor GetFontUnicodeRanges$descriptor() {
        return GetFontUnicodeRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static MethodHandle GetFontUnicodeRanges$handle() {
        return GetFontUnicodeRanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static MemorySegment GetFontUnicodeRanges$address() {
        return GetFontUnicodeRanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static int GetFontUnicodeRanges(MemorySegment hdc, MemorySegment lpgs) {
        var mh$ = GetFontUnicodeRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontUnicodeRanges", hdc, lpgs);
            }
            return (int)mh$.invokeExact(hdc, lpgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndicesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetGlyphIndicesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static FunctionDescriptor GetGlyphIndicesA$descriptor() {
        return GetGlyphIndicesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MethodHandle GetGlyphIndicesA$handle() {
        return GetGlyphIndicesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MemorySegment GetGlyphIndicesA$address() {
        return GetGlyphIndicesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static int GetGlyphIndicesA(MemorySegment hdc, MemorySegment lpstr, int c, MemorySegment pgi, int fl) {
        var mh$ = GetGlyphIndicesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndicesA", hdc, lpstr, c, pgi, fl);
            }
            return (int)mh$.invokeExact(hdc, lpstr, c, pgi, fl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndicesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetGlyphIndicesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static FunctionDescriptor GetGlyphIndicesW$descriptor() {
        return GetGlyphIndicesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MethodHandle GetGlyphIndicesW$handle() {
        return GetGlyphIndicesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MemorySegment GetGlyphIndicesW$address() {
        return GetGlyphIndicesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static int GetGlyphIndicesW(MemorySegment hdc, MemorySegment lpstr, int c, MemorySegment pgi, int fl) {
        var mh$ = GetGlyphIndicesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndicesW", hdc, lpstr, c, pgi, fl);
            }
            return (int)mh$.invokeExact(hdc, lpstr, c, pgi, fl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextExtentPointI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointI$descriptor() {
        return GetTextExtentPointI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static MethodHandle GetTextExtentPointI$handle() {
        return GetTextExtentPointI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static MemorySegment GetTextExtentPointI$address() {
        return GetTextExtentPointI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static int GetTextExtentPointI(MemorySegment hdc, MemorySegment pgiIn, int cgi, MemorySegment psize) {
        var mh$ = GetTextExtentPointI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointI", hdc, pgiIn, cgi, psize);
            }
            return (int)mh$.invokeExact(hdc, pgiIn, cgi, psize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextExtentExPointI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointI$descriptor() {
        return GetTextExtentExPointI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointI$handle() {
        return GetTextExtentExPointI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MemorySegment GetTextExtentExPointI$address() {
        return GetTextExtentExPointI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointI(MemorySegment hdc, MemorySegment lpwszString, int cwchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointI", hdc, lpwszString, cwchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpwszString, cwchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharWidthI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static FunctionDescriptor GetCharWidthI$descriptor() {
        return GetCharWidthI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static MethodHandle GetCharWidthI$handle() {
        return GetCharWidthI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static MemorySegment GetCharWidthI$address() {
        return GetCharWidthI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static int GetCharWidthI(MemorySegment hdc, int giFirst, int cgi, MemorySegment pgi, MemorySegment piWidths) {
        var mh$ = GetCharWidthI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthI", hdc, giFirst, cgi, pgi, piWidths);
            }
            return (int)mh$.invokeExact(hdc, giFirst, cgi, pgi, piWidths);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCharABCWidthsI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsI$descriptor() {
        return GetCharABCWidthsI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static MethodHandle GetCharABCWidthsI$handle() {
        return GetCharABCWidthsI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static MemorySegment GetCharABCWidthsI$address() {
        return GetCharABCWidthsI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static int GetCharABCWidthsI(MemorySegment hdc, int giFirst, int cgi, MemorySegment pgi, MemorySegment pabc) {
        var mh$ = GetCharABCWidthsI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsI", hdc, giFirst, cgi, pgi, pabc);
            }
            return (int)mh$.invokeExact(hdc, giFirst, cgi, pgi, pabc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDESIGNVECTOR {
     *     DWORD dvReserved;
     *     DWORD dvNumAxes;
     *     LONG dvValues[16];
     * } *PDESIGNVECTOR
     * }
     */
    public static final AddressLayout PDESIGNVECTOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDESIGNVECTOR {
     *     DWORD dvReserved;
     *     DWORD dvNumAxes;
     *     LONG dvValues[16];
     * } *LPDESIGNVECTOR
     * }
     */
    public static final AddressLayout LPDESIGNVECTOR = winapi.C_POINTER;

    private static class AddFontResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddFontResourceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static FunctionDescriptor AddFontResourceExA$descriptor() {
        return AddFontResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MethodHandle AddFontResourceExA$handle() {
        return AddFontResourceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MemorySegment AddFontResourceExA$address() {
        return AddFontResourceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static int AddFontResourceExA(MemorySegment name, int fl, MemorySegment res) {
        var mh$ = AddFontResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceExA", name, fl, res);
            }
            return (int)mh$.invokeExact(name, fl, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddFontResourceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static FunctionDescriptor AddFontResourceExW$descriptor() {
        return AddFontResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MethodHandle AddFontResourceExW$handle() {
        return AddFontResourceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MemorySegment AddFontResourceExW$address() {
        return AddFontResourceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static int AddFontResourceExW(MemorySegment name, int fl, MemorySegment res) {
        var mh$ = AddFontResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceExW", name, fl, res);
            }
            return (int)mh$.invokeExact(name, fl, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveFontResourceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceExA$descriptor() {
        return RemoveFontResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MethodHandle RemoveFontResourceExA$handle() {
        return RemoveFontResourceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MemorySegment RemoveFontResourceExA$address() {
        return RemoveFontResourceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static int RemoveFontResourceExA(MemorySegment name, int fl, MemorySegment pdv) {
        var mh$ = RemoveFontResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceExA", name, fl, pdv);
            }
            return (int)mh$.invokeExact(name, fl, pdv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveFontResourceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceExW$descriptor() {
        return RemoveFontResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MethodHandle RemoveFontResourceExW$handle() {
        return RemoveFontResourceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MemorySegment RemoveFontResourceExW$address() {
        return RemoveFontResourceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static int RemoveFontResourceExW(MemorySegment name, int fl, MemorySegment pdv) {
        var mh$ = RemoveFontResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceExW", name, fl, pdv);
            }
            return (int)mh$.invokeExact(name, fl, pdv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontMemResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddFontMemResourceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static FunctionDescriptor AddFontMemResourceEx$descriptor() {
        return AddFontMemResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MethodHandle AddFontMemResourceEx$handle() {
        return AddFontMemResourceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MemorySegment AddFontMemResourceEx$address() {
        return AddFontMemResourceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MemorySegment AddFontMemResourceEx(MemorySegment pFileView, int cjSize, MemorySegment pvResrved, MemorySegment pNumFonts) {
        var mh$ = AddFontMemResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontMemResourceEx", pFileView, cjSize, pvResrved, pNumFonts);
            }
            return (MemorySegment)mh$.invokeExact(pFileView, cjSize, pvResrved, pNumFonts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontMemResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveFontMemResourceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static FunctionDescriptor RemoveFontMemResourceEx$descriptor() {
        return RemoveFontMemResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static MethodHandle RemoveFontMemResourceEx$handle() {
        return RemoveFontMemResourceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static MemorySegment RemoveFontMemResourceEx$address() {
        return RemoveFontMemResourceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static int RemoveFontMemResourceEx(MemorySegment h) {
        var mh$ = RemoveFontMemResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontMemResourceEx", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOA {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     BYTE axAxisName[16];
     * } *PAXISINFOA
     * }
     */
    public static final AddressLayout PAXISINFOA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOA {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     BYTE axAxisName[16];
     * } *LPAXISINFOA
     * }
     */
    public static final AddressLayout LPAXISINFOA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOW {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     WCHAR axAxisName[16];
     * } *PAXISINFOW
     * }
     */
    public static final AddressLayout PAXISINFOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOW {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     WCHAR axAxisName[16];
     * } *LPAXISINFOW
     * }
     */
    public static final AddressLayout LPAXISINFOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAXISINFOA PAXISINFO
     * }
     */
    public static final AddressLayout PAXISINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAXISINFOA LPAXISINFO
     * }
     */
    public static final AddressLayout LPAXISINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTA {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOA axlAxisInfo[16];
     * } *PAXESLISTA
     * }
     */
    public static final AddressLayout PAXESLISTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTA {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOA axlAxisInfo[16];
     * } *LPAXESLISTA
     * }
     */
    public static final AddressLayout LPAXESLISTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTW {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOW axlAxisInfo[16];
     * } *PAXESLISTW
     * }
     */
    public static final AddressLayout PAXESLISTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTW {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOW axlAxisInfo[16];
     * } *LPAXESLISTW
     * }
     */
    public static final AddressLayout LPAXESLISTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAXESLISTA PAXESLIST
     * }
     */
    public static final AddressLayout PAXESLIST = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAXESLISTA LPAXESLIST
     * }
     */
    public static final AddressLayout LPAXESLIST = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVA {
     *     ENUMLOGFONTEXA elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *PENUMLOGFONTEXDVA
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDVA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVA {
     *     ENUMLOGFONTEXA elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *LPENUMLOGFONTEXDVA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDVA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVW {
     *     ENUMLOGFONTEXW elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *PENUMLOGFONTEXDVW
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDVW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVW {
     *     ENUMLOGFONTEXW elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *LPENUMLOGFONTEXDVW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDVW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDV = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDV = winapi.C_POINTER;

    private static class CreateFontIndirectExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFontIndirectExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectExA$descriptor() {
        return CreateFontIndirectExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MethodHandle CreateFontIndirectExA$handle() {
        return CreateFontIndirectExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MemorySegment CreateFontIndirectExA$address() {
        return CreateFontIndirectExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MemorySegment CreateFontIndirectExA(MemorySegment x0) {
        var mh$ = CreateFontIndirectExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectExA", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFontIndirectExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectExW$descriptor() {
        return CreateFontIndirectExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MethodHandle CreateFontIndirectExW$handle() {
        return CreateFontIndirectExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MemorySegment CreateFontIndirectExW$address() {
        return CreateFontIndirectExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MemorySegment CreateFontIndirectExW(MemorySegment x0) {
        var mh$ = CreateFontIndirectExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectExW", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICA {
     *     NEWTEXTMETRICEXA etmNewTextMetricEx;
     *     AXESLISTA etmAxesList;
     * } *PENUMTEXTMETRICA
     * }
     */
    public static final AddressLayout PENUMTEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICA {
     *     NEWTEXTMETRICEXA etmNewTextMetricEx;
     *     AXESLISTA etmAxesList;
     * } *LPENUMTEXTMETRICA
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRICA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICW {
     *     NEWTEXTMETRICEXW etmNewTextMetricEx;
     *     AXESLISTW etmAxesList;
     * } *PENUMTEXTMETRICW
     * }
     */
    public static final AddressLayout PENUMTEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICW {
     *     NEWTEXTMETRICEXW etmNewTextMetricEx;
     *     AXESLISTW etmAxesList;
     * } *LPENUMTEXTMETRICW
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRICW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PENUMTEXTMETRICA PENUMTEXTMETRIC
     * }
     */
    public static final AddressLayout PENUMTEXTMETRIC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRIC = winapi.C_POINTER;

    private static class GetViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetViewportExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetViewportExtEx$descriptor() {
        return GetViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetViewportExtEx$handle() {
        return GetViewportExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetViewportExtEx$address() {
        return GetViewportExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetViewportExtEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetViewportExtEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetViewportOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static FunctionDescriptor GetViewportOrgEx$descriptor() {
        return GetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MethodHandle GetViewportOrgEx$handle() {
        return GetViewportOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MemorySegment GetViewportOrgEx$address() {
        return GetViewportOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static int GetViewportOrgEx(MemorySegment hdc, MemorySegment lppoint) {
        var mh$ = GetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetViewportOrgEx", hdc, lppoint);
            }
            return (int)mh$.invokeExact(hdc, lppoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetWindowExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetWindowExtEx$descriptor() {
        return GetWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetWindowExtEx$handle() {
        return GetWindowExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetWindowExtEx$address() {
        return GetWindowExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetWindowExtEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowExtEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetWindowOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static FunctionDescriptor GetWindowOrgEx$descriptor() {
        return GetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MethodHandle GetWindowOrgEx$handle() {
        return GetWindowOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MemorySegment GetWindowOrgEx$address() {
        return GetWindowOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static int GetWindowOrgEx(MemorySegment hdc, MemorySegment lppoint) {
        var mh$ = GetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowOrgEx", hdc, lppoint);
            }
            return (int)mh$.invokeExact(hdc, lppoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectClipRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IntersectClipRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor IntersectClipRect$descriptor() {
        return IntersectClipRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle IntersectClipRect$handle() {
        return IntersectClipRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment IntersectClipRect$address() {
        return IntersectClipRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int IntersectClipRect(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = IntersectClipRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectClipRect", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvertRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InvertRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor InvertRgn$descriptor() {
        return InvertRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle InvertRgn$handle() {
        return InvertRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment InvertRgn$address() {
        return InvertRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int InvertRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = InvertRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvertRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LineDDA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LineDDA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static FunctionDescriptor LineDDA$descriptor() {
        return LineDDA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static MethodHandle LineDDA$handle() {
        return LineDDA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static MemorySegment LineDDA$address() {
        return LineDDA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static int LineDDA(int xStart, int yStart, int xEnd, int yEnd, MemorySegment lpProc, long data) {
        var mh$ = LineDDA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LineDDA", xStart, yStart, xEnd, yEnd, lpProc, data);
            }
            return (int)mh$.invokeExact(xStart, yStart, xEnd, yEnd, lpProc, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LineTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LineTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor LineTo$descriptor() {
        return LineTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle LineTo$handle() {
        return LineTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment LineTo$address() {
        return LineTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static int LineTo(MemorySegment hdc, int x, int y) {
        var mh$ = LineTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LineTo", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MaskBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("MaskBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static FunctionDescriptor MaskBlt$descriptor() {
        return MaskBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static MethodHandle MaskBlt$handle() {
        return MaskBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static MemorySegment MaskBlt$address() {
        return MaskBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static int MaskBlt(MemorySegment hdcDest, int xDest, int yDest, int width, int height, MemorySegment hdcSrc, int xSrc, int ySrc, MemorySegment hbmMask, int xMask, int yMask, int rop) {
        var mh$ = MaskBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MaskBlt", hdcDest, xDest, yDest, width, height, hdcSrc, xSrc, ySrc, hbmMask, xMask, yMask, rop);
            }
            return (int)mh$.invokeExact(hdcDest, xDest, yDest, width, height, hdcSrc, xSrc, ySrc, hbmMask, xMask, yMask, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlgBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PlgBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static FunctionDescriptor PlgBlt$descriptor() {
        return PlgBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static MethodHandle PlgBlt$handle() {
        return PlgBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static MemorySegment PlgBlt$address() {
        return PlgBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static int PlgBlt(MemorySegment hdcDest, MemorySegment lpPoint, MemorySegment hdcSrc, int xSrc, int ySrc, int width, int height, MemorySegment hbmMask, int xMask, int yMask) {
        var mh$ = PlgBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlgBlt", hdcDest, lpPoint, hdcSrc, xSrc, ySrc, width, height, hbmMask, xMask, yMask);
            }
            return (int)mh$.invokeExact(hdcDest, lpPoint, hdcSrc, xSrc, ySrc, width, height, hbmMask, xMask, yMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OffsetClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor OffsetClipRgn$descriptor() {
        return OffsetClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle OffsetClipRgn$handle() {
        return OffsetClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment OffsetClipRgn$address() {
        return OffsetClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static int OffsetClipRgn(MemorySegment hdc, int x, int y) {
        var mh$ = OffsetClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetClipRgn", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OffsetRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static FunctionDescriptor OffsetRgn$descriptor() {
        return OffsetRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static MethodHandle OffsetRgn$handle() {
        return OffsetRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static MemorySegment OffsetRgn$address() {
        return OffsetRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static int OffsetRgn(MemorySegment hrgn, int x, int y) {
        var mh$ = OffsetRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetRgn", hrgn, x, y);
            }
            return (int)mh$.invokeExact(hrgn, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PatBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PatBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static FunctionDescriptor PatBlt$descriptor() {
        return PatBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static MethodHandle PatBlt$handle() {
        return PatBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static MemorySegment PatBlt$address() {
        return PatBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static int PatBlt(MemorySegment hdc, int x, int y, int w, int h, int rop) {
        var mh$ = PatBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PatBlt", hdc, x, y, w, h, rop);
            }
            return (int)mh$.invokeExact(hdc, x, y, w, h, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Pie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Pie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static FunctionDescriptor Pie$descriptor() {
        return Pie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MethodHandle Pie$handle() {
        return Pie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MemorySegment Pie$address() {
        return Pie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static int Pie(MemorySegment hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2) {
        var mh$ = Pie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Pie", hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PlayMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor PlayMetaFile$descriptor() {
        return PlayMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static MethodHandle PlayMetaFile$handle() {
        return PlayMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static MemorySegment PlayMetaFile$address() {
        return PlayMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static int PlayMetaFile(MemorySegment hdc, MemorySegment hmf) {
        var mh$ = PlayMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMetaFile", hdc, hmf);
            }
            return (int)mh$.invokeExact(hdc, hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PaintRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PaintRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor PaintRgn$descriptor() {
        return PaintRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle PaintRgn$handle() {
        return PaintRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment PaintRgn$address() {
        return PaintRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int PaintRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = PaintRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PaintRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PolyPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static FunctionDescriptor PolyPolygon$descriptor() {
        return PolyPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static MethodHandle PolyPolygon$handle() {
        return PolyPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static MemorySegment PolyPolygon$address() {
        return PolyPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static int PolyPolygon(MemorySegment hdc, MemorySegment apt, MemorySegment asz, int csz) {
        var mh$ = PolyPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyPolygon", hdc, apt, asz, csz);
            }
            return (int)mh$.invokeExact(hdc, apt, asz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtInRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PtInRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static FunctionDescriptor PtInRegion$descriptor() {
        return PtInRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static MethodHandle PtInRegion$handle() {
        return PtInRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static MemorySegment PtInRegion$address() {
        return PtInRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static int PtInRegion(MemorySegment hrgn, int x, int y) {
        var mh$ = PtInRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtInRegion", hrgn, x, y);
            }
            return (int)mh$.invokeExact(hrgn, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PtVisible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor PtVisible$descriptor() {
        return PtVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle PtVisible$handle() {
        return PtVisible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment PtVisible$address() {
        return PtVisible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static int PtVisible(MemorySegment hdc, int x, int y) {
        var mh$ = PtVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtVisible", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RectInRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RectInRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor RectInRegion$descriptor() {
        return RectInRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static MethodHandle RectInRegion$handle() {
        return RectInRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static MemorySegment RectInRegion$address() {
        return RectInRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static int RectInRegion(MemorySegment hrgn, MemorySegment lprect) {
        var mh$ = RectInRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RectInRegion", hrgn, lprect);
            }
            return (int)mh$.invokeExact(hrgn, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RectVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RectVisible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor RectVisible$descriptor() {
        return RectVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static MethodHandle RectVisible$handle() {
        return RectVisible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static MemorySegment RectVisible$address() {
        return RectVisible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static int RectVisible(MemorySegment hdc, MemorySegment lprect) {
        var mh$ = RectVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RectVisible", hdc, lprect);
            }
            return (int)mh$.invokeExact(hdc, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Rectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Rectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor Rectangle$descriptor() {
        return Rectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle Rectangle$handle() {
        return Rectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment Rectangle$address() {
        return Rectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int Rectangle(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = Rectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Rectangle", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestoreDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RestoreDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static FunctionDescriptor RestoreDC$descriptor() {
        return RestoreDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static MethodHandle RestoreDC$handle() {
        return RestoreDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static MemorySegment RestoreDC$address() {
        return RestoreDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static int RestoreDC(MemorySegment hdc, int nSavedDC) {
        var mh$ = RestoreDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestoreDC", hdc, nSavedDC);
            }
            return (int)mh$.invokeExact(hdc, nSavedDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetDCA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ResetDCA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static FunctionDescriptor ResetDCA$descriptor() {
        return ResetDCA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MethodHandle ResetDCA$handle() {
        return ResetDCA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MemorySegment ResetDCA$address() {
        return ResetDCA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MemorySegment ResetDCA(MemorySegment hdc, MemorySegment lpdm) {
        var mh$ = ResetDCA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetDCA", hdc, lpdm);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetDCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ResetDCW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static FunctionDescriptor ResetDCW$descriptor() {
        return ResetDCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MethodHandle ResetDCW$handle() {
        return ResetDCW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MemorySegment ResetDCW$address() {
        return ResetDCW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MemorySegment ResetDCW(MemorySegment hdc, MemorySegment lpdm) {
        var mh$ = ResetDCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetDCW", hdc, lpdm);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealizePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RealizePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static FunctionDescriptor RealizePalette$descriptor() {
        return RealizePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static MethodHandle RealizePalette$handle() {
        return RealizePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static MemorySegment RealizePalette$address() {
        return RealizePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static int RealizePalette(MemorySegment hdc) {
        var mh$ = RealizePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealizePalette", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveFontResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceA$descriptor() {
        return RemoveFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle RemoveFontResourceA$handle() {
        return RemoveFontResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment RemoveFontResourceA$address() {
        return RemoveFontResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static int RemoveFontResourceA(MemorySegment lpFileName) {
        var mh$ = RemoveFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveFontResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceW$descriptor() {
        return RemoveFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle RemoveFontResourceW$handle() {
        return RemoveFontResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment RemoveFontResourceW$address() {
        return RemoveFontResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static int RemoveFontResourceW(MemorySegment lpFileName) {
        var mh$ = RemoveFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoundRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RoundRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static FunctionDescriptor RoundRect$descriptor() {
        return RoundRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static MethodHandle RoundRect$handle() {
        return RoundRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static MemorySegment RoundRect$address() {
        return RoundRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static int RoundRect(MemorySegment hdc, int left, int top, int right, int bottom, int width, int height) {
        var mh$ = RoundRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoundRect", hdc, left, top, right, bottom, width, height);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResizePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ResizePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static FunctionDescriptor ResizePalette$descriptor() {
        return ResizePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static MethodHandle ResizePalette$handle() {
        return ResizePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static MemorySegment ResizePalette$address() {
        return ResizePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static int ResizePalette(MemorySegment hpal, int n) {
        var mh$ = ResizePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResizePalette", hpal, n);
            }
            return (int)mh$.invokeExact(hpal, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SaveDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SaveDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor SaveDC$descriptor() {
        return SaveDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static MethodHandle SaveDC$handle() {
        return SaveDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static MemorySegment SaveDC$address() {
        return SaveDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static int SaveDC(MemorySegment hdc) {
        var mh$ = SaveDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SaveDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SelectClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor SelectClipRgn$descriptor() {
        return SelectClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle SelectClipRgn$handle() {
        return SelectClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment SelectClipRgn$address() {
        return SelectClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int SelectClipRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = SelectClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectClipRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtSelectClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExtSelectClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static FunctionDescriptor ExtSelectClipRgn$descriptor() {
        return ExtSelectClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static MethodHandle ExtSelectClipRgn$handle() {
        return ExtSelectClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static MemorySegment ExtSelectClipRgn$address() {
        return ExtSelectClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static int ExtSelectClipRgn(MemorySegment hdc, MemorySegment hrgn, int mode) {
        var mh$ = ExtSelectClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtSelectClipRgn", hdc, hrgn, mode);
            }
            return (int)mh$.invokeExact(hdc, hrgn, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMetaRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetMetaRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static FunctionDescriptor SetMetaRgn$descriptor() {
        return SetMetaRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static MethodHandle SetMetaRgn$handle() {
        return SetMetaRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static MemorySegment SetMetaRgn$address() {
        return SetMetaRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static int SetMetaRgn(MemorySegment hdc) {
        var mh$ = SetMetaRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMetaRgn", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SelectObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor SelectObject$descriptor() {
        return SelectObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MethodHandle SelectObject$handle() {
        return SelectObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MemorySegment SelectObject$address() {
        return SelectObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MemorySegment SelectObject(MemorySegment hdc, MemorySegment h) {
        var mh$ = SelectObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectObject", hdc, h);
            }
            return (MemorySegment)mh$.invokeExact(hdc, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SelectPalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static FunctionDescriptor SelectPalette$descriptor() {
        return SelectPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MethodHandle SelectPalette$handle() {
        return SelectPalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MemorySegment SelectPalette$address() {
        return SelectPalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MemorySegment SelectPalette(MemorySegment hdc, MemorySegment hPal, int bForceBkgd) {
        var mh$ = SelectPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectPalette", hdc, hPal, bForceBkgd);
            }
            return (MemorySegment)mh$.invokeExact(hdc, hPal, bForceBkgd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBkColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetBkColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetBkColor$descriptor() {
        return SetBkColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetBkColor$handle() {
        return SetBkColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetBkColor$address() {
        return SetBkColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetBkColor(MemorySegment hdc, int color) {
        var mh$ = SetBkColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBkColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDCBrushColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetDCBrushColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetDCBrushColor$descriptor() {
        return SetDCBrushColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetDCBrushColor$handle() {
        return SetDCBrushColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetDCBrushColor$address() {
        return SetDCBrushColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetDCBrushColor(MemorySegment hdc, int color) {
        var mh$ = SetDCBrushColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDCBrushColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDCPenColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetDCPenColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetDCPenColor$descriptor() {
        return SetDCPenColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetDCPenColor$handle() {
        return SetDCPenColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetDCPenColor$address() {
        return SetDCPenColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetDCPenColor(MemorySegment hdc, int color) {
        var mh$ = SetDCPenColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDCPenColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBkMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetBkMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetBkMode$descriptor() {
        return SetBkMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetBkMode$handle() {
        return SetBkMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetBkMode$address() {
        return SetBkMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static int SetBkMode(MemorySegment hdc, int mode) {
        var mh$ = SetBkMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBkMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBitmapBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetBitmapBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static FunctionDescriptor SetBitmapBits$descriptor() {
        return SetBitmapBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static MethodHandle SetBitmapBits$handle() {
        return SetBitmapBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static MemorySegment SetBitmapBits$address() {
        return SetBitmapBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static int SetBitmapBits(MemorySegment hbm, int cb, MemorySegment pvBits) {
        var mh$ = SetBitmapBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBitmapBits", hbm, cb, pvBits);
            }
            return (int)mh$.invokeExact(hbm, cb, pvBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBoundsRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetBoundsRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor SetBoundsRect$descriptor() {
        return SetBoundsRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MethodHandle SetBoundsRect$handle() {
        return SetBoundsRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MemorySegment SetBoundsRect$address() {
        return SetBoundsRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static int SetBoundsRect(MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = SetBoundsRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBoundsRect", hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetDIBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static FunctionDescriptor SetDIBits$descriptor() {
        return SetDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MethodHandle SetDIBits$handle() {
        return SetDIBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MemorySegment SetDIBits$address() {
        return SetDIBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static int SetDIBits(MemorySegment hdc, MemorySegment hbm, int start, int cLines, MemorySegment lpBits, MemorySegment lpbmi, int ColorUse) {
        var mh$ = SetDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBits", hdc, hbm, start, cLines, lpBits, lpbmi, ColorUse);
            }
            return (int)mh$.invokeExact(hdc, hbm, start, cLines, lpBits, lpbmi, ColorUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBitsToDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetDIBitsToDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static FunctionDescriptor SetDIBitsToDevice$descriptor() {
        return SetDIBitsToDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MethodHandle SetDIBitsToDevice$handle() {
        return SetDIBitsToDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MemorySegment SetDIBitsToDevice$address() {
        return SetDIBitsToDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static int SetDIBitsToDevice(MemorySegment hdc, int xDest, int yDest, int w, int h, int xSrc, int ySrc, int StartScan, int cLines, MemorySegment lpvBits, MemorySegment lpbmi, int ColorUse) {
        var mh$ = SetDIBitsToDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBitsToDevice", hdc, xDest, yDest, w, h, xSrc, ySrc, StartScan, cLines, lpvBits, lpbmi, ColorUse);
            }
            return (int)mh$.invokeExact(hdc, xDest, yDest, w, h, xSrc, ySrc, StartScan, cLines, lpvBits, lpbmi, ColorUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMapperFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetMapperFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static FunctionDescriptor SetMapperFlags$descriptor() {
        return SetMapperFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static MethodHandle SetMapperFlags$handle() {
        return SetMapperFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static MemorySegment SetMapperFlags$address() {
        return SetMapperFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static int SetMapperFlags(MemorySegment hdc, int flags) {
        var mh$ = SetMapperFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMapperFlags", hdc, flags);
            }
            return (int)mh$.invokeExact(hdc, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetGraphicsMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetGraphicsMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static FunctionDescriptor SetGraphicsMode$descriptor() {
        return SetGraphicsMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static MethodHandle SetGraphicsMode$handle() {
        return SetGraphicsMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static MemorySegment SetGraphicsMode$address() {
        return SetGraphicsMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static int SetGraphicsMode(MemorySegment hdc, int iMode) {
        var mh$ = SetGraphicsMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGraphicsMode", hdc, iMode);
            }
            return (int)mh$.invokeExact(hdc, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMapMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetMapMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static FunctionDescriptor SetMapMode$descriptor() {
        return SetMapMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static MethodHandle SetMapMode$handle() {
        return SetMapMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static MemorySegment SetMapMode$address() {
        return SetMapMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static int SetMapMode(MemorySegment hdc, int iMode) {
        var mh$ = SetMapMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMapMode", hdc, iMode);
            }
            return (int)mh$.invokeExact(hdc, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static FunctionDescriptor SetLayout$descriptor() {
        return SetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static MethodHandle SetLayout$handle() {
        return SetLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static MemorySegment SetLayout$address() {
        return SetLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static int SetLayout(MemorySegment hdc, int l) {
        var mh$ = SetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLayout", hdc, l);
            }
            return (int)mh$.invokeExact(hdc, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetLayout$descriptor() {
        return GetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static MethodHandle GetLayout$handle() {
        return GetLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static MemorySegment GetLayout$address() {
        return GetLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static int GetLayout(MemorySegment hdc) {
        var mh$ = GetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLayout", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMetaFileBitsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetMetaFileBitsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static FunctionDescriptor SetMetaFileBitsEx$descriptor() {
        return SetMetaFileBitsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MethodHandle SetMetaFileBitsEx$handle() {
        return SetMetaFileBitsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MemorySegment SetMetaFileBitsEx$address() {
        return SetMetaFileBitsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MemorySegment SetMetaFileBitsEx(int cbBuffer, MemorySegment lpData) {
        var mh$ = SetMetaFileBitsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMetaFileBitsEx", cbBuffer, lpData);
            }
            return (MemorySegment)mh$.invokeExact(cbBuffer, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static FunctionDescriptor SetPaletteEntries$descriptor() {
        return SetPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static MethodHandle SetPaletteEntries$handle() {
        return SetPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static MemorySegment SetPaletteEntries$address() {
        return SetPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static int SetPaletteEntries(MemorySegment hpal, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = SetPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPaletteEntries", hpal, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hpal, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetPixel$descriptor() {
        return SetPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle SetPixel$handle() {
        return SetPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MemorySegment SetPixel$address() {
        return SetPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int SetPixel(MemorySegment hdc, int x, int y, int color) {
        var mh$ = SetPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixel", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetPixelV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetPixelV$descriptor() {
        return SetPixelV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle SetPixelV$handle() {
        return SetPixelV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MemorySegment SetPixelV$address() {
        return SetPixelV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int SetPixelV(MemorySegment hdc, int x, int y, int color) {
        var mh$ = SetPixelV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelV", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetPixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor SetPixelFormat$descriptor() {
        return SetPixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle SetPixelFormat$handle() {
        return SetPixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MemorySegment SetPixelFormat$address() {
        return SetPixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int SetPixelFormat(MemorySegment hdc, int format, MemorySegment ppfd) {
        var mh$ = SetPixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelFormat", hdc, format, ppfd);
            }
            return (int)mh$.invokeExact(hdc, format, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPolyFillMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetPolyFillMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetPolyFillMode$descriptor() {
        return SetPolyFillMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetPolyFillMode$handle() {
        return SetPolyFillMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetPolyFillMode$address() {
        return SetPolyFillMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static int SetPolyFillMode(MemorySegment hdc, int mode) {
        var mh$ = SetPolyFillMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPolyFillMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StretchBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("StretchBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static FunctionDescriptor StretchBlt$descriptor() {
        return StretchBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static MethodHandle StretchBlt$handle() {
        return StretchBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static MemorySegment StretchBlt$address() {
        return StretchBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static int StretchBlt(MemorySegment hdcDest, int xDest, int yDest, int wDest, int hDest, MemorySegment hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, int rop) {
        var mh$ = StretchBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StretchBlt", hdcDest, xDest, yDest, wDest, hDest, hdcSrc, xSrc, ySrc, wSrc, hSrc, rop);
            }
            return (int)mh$.invokeExact(hdcDest, xDest, yDest, wDest, hDest, hdcSrc, xSrc, ySrc, wSrc, hSrc, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetRectRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor SetRectRgn$descriptor() {
        return SetRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle SetRectRgn$handle() {
        return SetRectRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment SetRectRgn$address() {
        return SetRectRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static int SetRectRgn(MemorySegment hrgn, int left, int top, int right, int bottom) {
        var mh$ = SetRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetRectRgn", hrgn, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hrgn, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StretchDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("StretchDIBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static FunctionDescriptor StretchDIBits$descriptor() {
        return StretchDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static MethodHandle StretchDIBits$handle() {
        return StretchDIBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static MemorySegment StretchDIBits$address() {
        return StretchDIBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static int StretchDIBits(MemorySegment hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, MemorySegment lpBits, MemorySegment lpbmi, int iUsage, int rop) {
        var mh$ = StretchDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StretchDIBits", hdc, xDest, yDest, DestWidth, DestHeight, xSrc, ySrc, SrcWidth, SrcHeight, lpBits, lpbmi, iUsage, rop);
            }
            return (int)mh$.invokeExact(hdc, xDest, yDest, DestWidth, DestHeight, xSrc, ySrc, SrcWidth, SrcHeight, lpBits, lpbmi, iUsage, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetROP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetROP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static FunctionDescriptor SetROP2$descriptor() {
        return SetROP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static MethodHandle SetROP2$handle() {
        return SetROP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static MemorySegment SetROP2$address() {
        return SetROP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static int SetROP2(MemorySegment hdc, int rop2) {
        var mh$ = SetROP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetROP2", hdc, rop2);
            }
            return (int)mh$.invokeExact(hdc, rop2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStretchBltMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetStretchBltMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetStretchBltMode$descriptor() {
        return SetStretchBltMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetStretchBltMode$handle() {
        return SetStretchBltMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetStretchBltMode$address() {
        return SetStretchBltMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static int SetStretchBltMode(MemorySegment hdc, int mode) {
        var mh$ = SetStretchBltMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStretchBltMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemPaletteUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetSystemPaletteUse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static FunctionDescriptor SetSystemPaletteUse$descriptor() {
        return SetSystemPaletteUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static MethodHandle SetSystemPaletteUse$handle() {
        return SetSystemPaletteUse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static MemorySegment SetSystemPaletteUse$address() {
        return SetSystemPaletteUse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static int SetSystemPaletteUse(MemorySegment hdc, int use) {
        var mh$ = SetSystemPaletteUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemPaletteUse", hdc, use);
            }
            return (int)mh$.invokeExact(hdc, use);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextCharacterExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetTextCharacterExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static FunctionDescriptor SetTextCharacterExtra$descriptor() {
        return SetTextCharacterExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static MethodHandle SetTextCharacterExtra$handle() {
        return SetTextCharacterExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static MemorySegment SetTextCharacterExtra$address() {
        return SetTextCharacterExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static int SetTextCharacterExtra(MemorySegment hdc, int extra) {
        var mh$ = SetTextCharacterExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextCharacterExtra", hdc, extra);
            }
            return (int)mh$.invokeExact(hdc, extra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetTextColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetTextColor$descriptor() {
        return SetTextColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetTextColor$handle() {
        return SetTextColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetTextColor$address() {
        return SetTextColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetTextColor(MemorySegment hdc, int color) {
        var mh$ = SetTextColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextAlign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetTextAlign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static FunctionDescriptor SetTextAlign$descriptor() {
        return SetTextAlign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static MethodHandle SetTextAlign$handle() {
        return SetTextAlign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static MemorySegment SetTextAlign$address() {
        return SetTextAlign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static int SetTextAlign(MemorySegment hdc, int align) {
        var mh$ = SetTextAlign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextAlign", hdc, align);
            }
            return (int)mh$.invokeExact(hdc, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextJustification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetTextJustification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static FunctionDescriptor SetTextJustification$descriptor() {
        return SetTextJustification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static MethodHandle SetTextJustification$handle() {
        return SetTextJustification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static MemorySegment SetTextJustification$address() {
        return SetTextJustification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static int SetTextJustification(MemorySegment hdc, int extra, int count) {
        var mh$ = SetTextJustification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextJustification", hdc, extra, count);
            }
            return (int)mh$.invokeExact(hdc, extra, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("UpdateColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static FunctionDescriptor UpdateColors$descriptor() {
        return UpdateColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static MethodHandle UpdateColors$handle() {
        return UpdateColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static MemorySegment UpdateColors$address() {
        return UpdateColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static int UpdateColors(MemorySegment hdc) {
        var mh$ = UpdateColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateColors", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef USHORT COLOR16
     * }
     */
    public static final OfShort COLOR16 = winapi.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct _TRIVERTEX {
     *     LONG x;
     *     LONG y;
     *     COLOR16 Red;
     *     COLOR16 Green;
     *     COLOR16 Blue;
     *     COLOR16 Alpha;
     * } *PTRIVERTEX
     * }
     */
    public static final AddressLayout PTRIVERTEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRIVERTEX {
     *     LONG x;
     *     LONG y;
     *     COLOR16 Red;
     *     COLOR16 Green;
     *     COLOR16 Blue;
     *     COLOR16 Alpha;
     * } *LPTRIVERTEX
     * }
     */
    public static final AddressLayout LPTRIVERTEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_TRIANGLE {
     *     ULONG Vertex1;
     *     ULONG Vertex2;
     *     ULONG Vertex3;
     * } *PGRADIENT_TRIANGLE
     * }
     */
    public static final AddressLayout PGRADIENT_TRIANGLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_TRIANGLE {
     *     ULONG Vertex1;
     *     ULONG Vertex2;
     *     ULONG Vertex3;
     * } *LPGRADIENT_TRIANGLE
     * }
     */
    public static final AddressLayout LPGRADIENT_TRIANGLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_RECT {
     *     ULONG UpperLeft;
     *     ULONG LowerRight;
     * } *PGRADIENT_RECT
     * }
     */
    public static final AddressLayout PGRADIENT_RECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_RECT {
     *     ULONG UpperLeft;
     *     ULONG LowerRight;
     * } *LPGRADIENT_RECT
     * }
     */
    public static final AddressLayout LPGRADIENT_RECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BLENDFUNCTION {
     *     BYTE BlendOp;
     *     BYTE BlendFlags;
     *     BYTE SourceConstantAlpha;
     *     BYTE AlphaFormat;
     * } *PBLENDFUNCTION
     * }
     */
    public static final AddressLayout PBLENDFUNCTION = winapi.C_POINTER;

    private static class AlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            _BLENDFUNCTION.layout()
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AlphaBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static FunctionDescriptor AlphaBlend$descriptor() {
        return AlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MethodHandle AlphaBlend$handle() {
        return AlphaBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MemorySegment AlphaBlend$address() {
        return AlphaBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static int AlphaBlend(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, MemorySegment ftn) {
        var mh$ = AlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AlphaBlend", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransparentBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TransparentBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static FunctionDescriptor TransparentBlt$descriptor() {
        return TransparentBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MethodHandle TransparentBlt$handle() {
        return TransparentBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MemorySegment TransparentBlt$address() {
        return TransparentBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static int TransparentBlt(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, int crTransparent) {
        var mh$ = TransparentBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransparentBlt", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GradientFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GradientFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static FunctionDescriptor GradientFill$descriptor() {
        return GradientFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static MethodHandle GradientFill$handle() {
        return GradientFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static MemorySegment GradientFill$address() {
        return GradientFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static int GradientFill(MemorySegment hdc, MemorySegment pVertex, int nVertex, MemorySegment pMesh, int nMesh, int ulMode) {
        var mh$ = GradientFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GradientFill", hdc, pVertex, nVertex, pMesh, nMesh, ulMode);
            }
            return (int)mh$.invokeExact(hdc, pVertex, nVertex, pMesh, nMesh, ulMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiAlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            _BLENDFUNCTION.layout()
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GdiAlphaBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static FunctionDescriptor GdiAlphaBlend$descriptor() {
        return GdiAlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MethodHandle GdiAlphaBlend$handle() {
        return GdiAlphaBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MemorySegment GdiAlphaBlend$address() {
        return GdiAlphaBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static int GdiAlphaBlend(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, MemorySegment ftn) {
        var mh$ = GdiAlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiAlphaBlend", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiTransparentBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GdiTransparentBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static FunctionDescriptor GdiTransparentBlt$descriptor() {
        return GdiTransparentBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MethodHandle GdiTransparentBlt$handle() {
        return GdiTransparentBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MemorySegment GdiTransparentBlt$address() {
        return GdiTransparentBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static int GdiTransparentBlt(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, int crTransparent) {
        var mh$ = GdiTransparentBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiTransparentBlt", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiGradientFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GdiGradientFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static FunctionDescriptor GdiGradientFill$descriptor() {
        return GdiGradientFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static MethodHandle GdiGradientFill$handle() {
        return GdiGradientFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static MemorySegment GdiGradientFill$address() {
        return GdiGradientFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static int GdiGradientFill(MemorySegment hdc, MemorySegment pVertex, int nVertex, MemorySegment pMesh, int nCount, int ulMode) {
        var mh$ = GdiGradientFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiGradientFill", hdc, pVertex, nVertex, pMesh, nCount, ulMode);
            }
            return (int)mh$.invokeExact(hdc, pVertex, nVertex, pMesh, nCount, ulMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMetaFileRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PlayMetaFileRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static FunctionDescriptor PlayMetaFileRecord$descriptor() {
        return PlayMetaFileRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static MethodHandle PlayMetaFileRecord$handle() {
        return PlayMetaFileRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static MemorySegment PlayMetaFileRecord$address() {
        return PlayMetaFileRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static int PlayMetaFileRecord(MemorySegment hdc, MemorySegment lpHandleTable, MemorySegment lpMR, int noObjs) {
        var mh$ = PlayMetaFileRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMetaFileRecord", hdc, lpHandleTable, lpMR, noObjs);
            }
            return (int)mh$.invokeExact(hdc, lpHandleTable, lpMR, noObjs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumMetaFile$descriptor() {
        return EnumMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumMetaFile$handle() {
        return EnumMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static MemorySegment EnumMetaFile$address() {
        return EnumMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static int EnumMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment proc, long param) {
        var mh$ = EnumMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumMetaFile", hdc, hmf, proc, param);
            }
            return (int)mh$.invokeExact(hdc, hmf, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CloseEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseEnhMetaFile$descriptor() {
        return CloseEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MethodHandle CloseEnhMetaFile$handle() {
        return CloseEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseEnhMetaFile$address() {
        return CloseEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseEnhMetaFile(MemorySegment hdc) {
        var mh$ = CloseEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEnhMetaFile", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CopyEnhMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor CopyEnhMetaFileA$descriptor() {
        return CopyEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle CopyEnhMetaFileA$handle() {
        return CopyEnhMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileA$address() {
        return CopyEnhMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileA(MemorySegment hEnh, MemorySegment lpFileName) {
        var mh$ = CopyEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyEnhMetaFileA", hEnh, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(hEnh, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CopyEnhMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor CopyEnhMetaFileW$descriptor() {
        return CopyEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle CopyEnhMetaFileW$handle() {
        return CopyEnhMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileW$address() {
        return CopyEnhMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileW(MemorySegment hEnh, MemorySegment lpFileName) {
        var mh$ = CopyEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyEnhMetaFileW", hEnh, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(hEnh, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateEnhMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static FunctionDescriptor CreateEnhMetaFileA$descriptor() {
        return CreateEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MethodHandle CreateEnhMetaFileA$handle() {
        return CreateEnhMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileA$address() {
        return CreateEnhMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileA(MemorySegment hdc, MemorySegment lpFilename, MemorySegment lprc, MemorySegment lpDesc) {
        var mh$ = CreateEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnhMetaFileA", hdc, lpFilename, lprc, lpDesc);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpFilename, lprc, lpDesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateEnhMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static FunctionDescriptor CreateEnhMetaFileW$descriptor() {
        return CreateEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MethodHandle CreateEnhMetaFileW$handle() {
        return CreateEnhMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileW$address() {
        return CreateEnhMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileW(MemorySegment hdc, MemorySegment lpFilename, MemorySegment lprc, MemorySegment lpDesc) {
        var mh$ = CreateEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnhMetaFileW", hdc, lpFilename, lprc, lpDesc);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpFilename, lprc, lpDesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor DeleteEnhMetaFile$descriptor() {
        return DeleteEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static MethodHandle DeleteEnhMetaFile$handle() {
        return DeleteEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static MemorySegment DeleteEnhMetaFile$address() {
        return DeleteEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static int DeleteEnhMetaFile(MemorySegment hmf) {
        var mh$ = DeleteEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteEnhMetaFile", hmf);
            }
            return (int)mh$.invokeExact(hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static FunctionDescriptor EnumEnhMetaFile$descriptor() {
        return EnumEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static MethodHandle EnumEnhMetaFile$handle() {
        return EnumEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static MemorySegment EnumEnhMetaFile$address() {
        return EnumEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static int EnumEnhMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment proc, MemorySegment param, MemorySegment lpRect) {
        var mh$ = EnumEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumEnhMetaFile", hdc, hmf, proc, param, lpRect);
            }
            return (int)mh$.invokeExact(hdc, hmf, proc, param, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnhMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileA$descriptor() {
        return GetEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MethodHandle GetEnhMetaFileA$handle() {
        return GetEnhMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileA$address() {
        return GetEnhMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileA(MemorySegment lpName) {
        var mh$ = GetEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileA", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnhMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileW$descriptor() {
        return GetEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MethodHandle GetEnhMetaFileW$handle() {
        return GetEnhMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileW$address() {
        return GetEnhMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileW(MemorySegment lpName) {
        var mh$ = GetEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileW", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnhMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileBits$descriptor() {
        return GetEnhMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static MethodHandle GetEnhMetaFileBits$handle() {
        return GetEnhMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static MemorySegment GetEnhMetaFileBits$address() {
        return GetEnhMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static int GetEnhMetaFileBits(MemorySegment hEMF, int nSize, MemorySegment lpData) {
        var mh$ = GetEnhMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileBits", hEMF, nSize, lpData);
            }
            return (int)mh$.invokeExact(hEMF, nSize, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileDescriptionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnhMetaFileDescriptionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileDescriptionA$descriptor() {
        return GetEnhMetaFileDescriptionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static MethodHandle GetEnhMetaFileDescriptionA$handle() {
        return GetEnhMetaFileDescriptionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static MemorySegment GetEnhMetaFileDescriptionA$address() {
        return GetEnhMetaFileDescriptionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static int GetEnhMetaFileDescriptionA(MemorySegment hemf, int cchBuffer, MemorySegment lpDescription) {
        var mh$ = GetEnhMetaFileDescriptionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileDescriptionA", hemf, cchBuffer, lpDescription);
            }
            return (int)mh$.invokeExact(hemf, cchBuffer, lpDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileDescriptionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnhMetaFileDescriptionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileDescriptionW$descriptor() {
        return GetEnhMetaFileDescriptionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static MethodHandle GetEnhMetaFileDescriptionW$handle() {
        return GetEnhMetaFileDescriptionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static MemorySegment GetEnhMetaFileDescriptionW$address() {
        return GetEnhMetaFileDescriptionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static int GetEnhMetaFileDescriptionW(MemorySegment hemf, int cchBuffer, MemorySegment lpDescription) {
        var mh$ = GetEnhMetaFileDescriptionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileDescriptionW", hemf, cchBuffer, lpDescription);
            }
            return (int)mh$.invokeExact(hemf, cchBuffer, lpDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnhMetaFileHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileHeader$descriptor() {
        return GetEnhMetaFileHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static MethodHandle GetEnhMetaFileHeader$handle() {
        return GetEnhMetaFileHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static MemorySegment GetEnhMetaFileHeader$address() {
        return GetEnhMetaFileHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static int GetEnhMetaFileHeader(MemorySegment hemf, int nSize, MemorySegment lpEnhMetaHeader) {
        var mh$ = GetEnhMetaFileHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileHeader", hemf, nSize, lpEnhMetaHeader);
            }
            return (int)mh$.invokeExact(hemf, nSize, lpEnhMetaHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFilePaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnhMetaFilePaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFilePaletteEntries$descriptor() {
        return GetEnhMetaFilePaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static MethodHandle GetEnhMetaFilePaletteEntries$handle() {
        return GetEnhMetaFilePaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static MemorySegment GetEnhMetaFilePaletteEntries$address() {
        return GetEnhMetaFilePaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static int GetEnhMetaFilePaletteEntries(MemorySegment hemf, int nNumEntries, MemorySegment lpPaletteEntries) {
        var mh$ = GetEnhMetaFilePaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFilePaletteEntries", hemf, nNumEntries, lpPaletteEntries);
            }
            return (int)mh$.invokeExact(hemf, nNumEntries, lpPaletteEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFilePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnhMetaFilePixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFilePixelFormat$descriptor() {
        return GetEnhMetaFilePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle GetEnhMetaFilePixelFormat$handle() {
        return GetEnhMetaFilePixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MemorySegment GetEnhMetaFilePixelFormat$address() {
        return GetEnhMetaFilePixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int GetEnhMetaFilePixelFormat(MemorySegment hemf, int cbBuffer, MemorySegment ppfd) {
        var mh$ = GetEnhMetaFilePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFilePixelFormat", hemf, cbBuffer, ppfd);
            }
            return (int)mh$.invokeExact(hemf, cbBuffer, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWinMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetWinMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static FunctionDescriptor GetWinMetaFileBits$descriptor() {
        return GetWinMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static MethodHandle GetWinMetaFileBits$handle() {
        return GetWinMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static MemorySegment GetWinMetaFileBits$address() {
        return GetWinMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static int GetWinMetaFileBits(MemorySegment hemf, int cbData16, MemorySegment pData16, int iMapMode, MemorySegment hdcRef) {
        var mh$ = GetWinMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWinMetaFileBits", hemf, cbData16, pData16, iMapMode, hdcRef);
            }
            return (int)mh$.invokeExact(hemf, cbData16, pData16, iMapMode, hdcRef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PlayEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor PlayEnhMetaFile$descriptor() {
        return PlayEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static MethodHandle PlayEnhMetaFile$handle() {
        return PlayEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static MemorySegment PlayEnhMetaFile$address() {
        return PlayEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static int PlayEnhMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment lprect) {
        var mh$ = PlayEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayEnhMetaFile", hdc, hmf, lprect);
            }
            return (int)mh$.invokeExact(hdc, hmf, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayEnhMetaFileRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PlayEnhMetaFileRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static FunctionDescriptor PlayEnhMetaFileRecord$descriptor() {
        return PlayEnhMetaFileRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static MethodHandle PlayEnhMetaFileRecord$handle() {
        return PlayEnhMetaFileRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static MemorySegment PlayEnhMetaFileRecord$address() {
        return PlayEnhMetaFileRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static int PlayEnhMetaFileRecord(MemorySegment hdc, MemorySegment pht, MemorySegment pmr, int cht) {
        var mh$ = PlayEnhMetaFileRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayEnhMetaFileRecord", hdc, pht, pmr, cht);
            }
            return (int)mh$.invokeExact(hdc, pht, pmr, cht);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnhMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetEnhMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static FunctionDescriptor SetEnhMetaFileBits$descriptor() {
        return SetEnhMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MethodHandle SetEnhMetaFileBits$handle() {
        return SetEnhMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MemorySegment SetEnhMetaFileBits$address() {
        return SetEnhMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MemorySegment SetEnhMetaFileBits(int nSize, MemorySegment pb) {
        var mh$ = SetEnhMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnhMetaFileBits", nSize, pb);
            }
            return (MemorySegment)mh$.invokeExact(nSize, pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWinMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetWinMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static FunctionDescriptor SetWinMetaFileBits$descriptor() {
        return SetWinMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MethodHandle SetWinMetaFileBits$handle() {
        return SetWinMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MemorySegment SetWinMetaFileBits$address() {
        return SetWinMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MemorySegment SetWinMetaFileBits(int nSize, MemorySegment lpMeta16Data, MemorySegment hdcRef, MemorySegment lpMFP) {
        var mh$ = SetWinMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWinMetaFileBits", nSize, lpMeta16Data, hdcRef, lpMFP);
            }
            return (MemorySegment)mh$.invokeExact(nSize, lpMeta16Data, hdcRef, lpMFP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiComment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GdiComment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static FunctionDescriptor GdiComment$descriptor() {
        return GdiComment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static MethodHandle GdiComment$handle() {
        return GdiComment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static MemorySegment GdiComment$address() {
        return GdiComment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static int GdiComment(MemorySegment hdc, int nSize, MemorySegment lpData) {
        var mh$ = GdiComment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiComment", hdc, nSize, lpData);
            }
            return (int)mh$.invokeExact(hdc, nSize, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextMetricsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextMetricsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static FunctionDescriptor GetTextMetricsA$descriptor() {
        return GetTextMetricsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static MethodHandle GetTextMetricsA$handle() {
        return GetTextMetricsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static MemorySegment GetTextMetricsA$address() {
        return GetTextMetricsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static int GetTextMetricsA(MemorySegment hdc, MemorySegment lptm) {
        var mh$ = GetTextMetricsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextMetricsA", hdc, lptm);
            }
            return (int)mh$.invokeExact(hdc, lptm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextMetricsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextMetricsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static FunctionDescriptor GetTextMetricsW$descriptor() {
        return GetTextMetricsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static MethodHandle GetTextMetricsW$handle() {
        return GetTextMetricsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static MemorySegment GetTextMetricsW$address() {
        return GetTextMetricsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static int GetTextMetricsW(MemorySegment hdc, MemorySegment lptm) {
        var mh$ = GetTextMetricsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextMetricsW", hdc, lptm);
            }
            return (int)mh$.invokeExact(hdc, lptm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDIBSECTION {
     *     BITMAP dsBm;
     *     BITMAPINFOHEADER dsBmih;
     *     DWORD dsBitfields[3];
     *     HANDLE dshSection;
     *     DWORD dsOffset;
     * } *LPDIBSECTION
     * }
     */
    public static final AddressLayout LPDIBSECTION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDIBSECTION {
     *     BITMAP dsBm;
     *     BITMAPINFOHEADER dsBmih;
     *     DWORD dsBitfields[3];
     *     HANDLE dshSection;
     *     DWORD dsOffset;
     * } *PDIBSECTION
     * }
     */
    public static final AddressLayout PDIBSECTION = winapi.C_POINTER;

    private static class AngleArc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_FLOAT,
            winapi.C_FLOAT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AngleArc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static FunctionDescriptor AngleArc$descriptor() {
        return AngleArc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static MethodHandle AngleArc$handle() {
        return AngleArc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static MemorySegment AngleArc$address() {
        return AngleArc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static int AngleArc(MemorySegment hdc, int x, int y, int r, float StartAngle, float SweepAngle) {
        var mh$ = AngleArc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AngleArc", hdc, x, y, r, StartAngle, SweepAngle);
            }
            return (int)mh$.invokeExact(hdc, x, y, r, StartAngle, SweepAngle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyPolyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PolyPolyline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static FunctionDescriptor PolyPolyline$descriptor() {
        return PolyPolyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static MethodHandle PolyPolyline$handle() {
        return PolyPolyline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static MemorySegment PolyPolyline$address() {
        return PolyPolyline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static int PolyPolyline(MemorySegment hdc, MemorySegment apt, MemorySegment asz, int csz) {
        var mh$ = PolyPolyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyPolyline", hdc, apt, asz, csz);
            }
            return (int)mh$.invokeExact(hdc, apt, asz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetWorldTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static FunctionDescriptor GetWorldTransform$descriptor() {
        return GetWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static MethodHandle GetWorldTransform$handle() {
        return GetWorldTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static MemorySegment GetWorldTransform$address() {
        return GetWorldTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static int GetWorldTransform(MemorySegment hdc, MemorySegment lpxf) {
        var mh$ = GetWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWorldTransform", hdc, lpxf);
            }
            return (int)mh$.invokeExact(hdc, lpxf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetWorldTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static FunctionDescriptor SetWorldTransform$descriptor() {
        return SetWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static MethodHandle SetWorldTransform$handle() {
        return SetWorldTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static MemorySegment SetWorldTransform$address() {
        return SetWorldTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static int SetWorldTransform(MemorySegment hdc, MemorySegment lpxf) {
        var mh$ = SetWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWorldTransform", hdc, lpxf);
            }
            return (int)mh$.invokeExact(hdc, lpxf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ModifyWorldTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static FunctionDescriptor ModifyWorldTransform$descriptor() {
        return ModifyWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static MethodHandle ModifyWorldTransform$handle() {
        return ModifyWorldTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static MemorySegment ModifyWorldTransform$address() {
        return ModifyWorldTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static int ModifyWorldTransform(MemorySegment hdc, MemorySegment lpxf, int mode) {
        var mh$ = ModifyWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyWorldTransform", hdc, lpxf, mode);
            }
            return (int)mh$.invokeExact(hdc, lpxf, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CombineTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CombineTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static FunctionDescriptor CombineTransform$descriptor() {
        return CombineTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static MethodHandle CombineTransform$handle() {
        return CombineTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static MemorySegment CombineTransform$address() {
        return CombineTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static int CombineTransform(MemorySegment lpxfOut, MemorySegment lpxf1, MemorySegment lpxf2) {
        var mh$ = CombineTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CombineTransform", lpxfOut, lpxf1, lpxf2);
            }
            return (int)mh$.invokeExact(lpxfOut, lpxf1, lpxf2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDIBSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static FunctionDescriptor CreateDIBSection$descriptor() {
        return CreateDIBSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MethodHandle CreateDIBSection$handle() {
        return CreateDIBSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MemorySegment CreateDIBSection$address() {
        return CreateDIBSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MemorySegment CreateDIBSection(MemorySegment hdc, MemorySegment pbmi, int usage, MemorySegment ppvBits, MemorySegment hSection, int offset) {
        var mh$ = CreateDIBSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBSection", hdc, pbmi, usage, ppvBits, hSection, offset);
            }
            return (MemorySegment)mh$.invokeExact(hdc, pbmi, usage, ppvBits, hSection, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDIBColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDIBColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static FunctionDescriptor GetDIBColorTable$descriptor() {
        return GetDIBColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static MethodHandle GetDIBColorTable$handle() {
        return GetDIBColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static MemorySegment GetDIBColorTable$address() {
        return GetDIBColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static int GetDIBColorTable(MemorySegment hdc, int iStart, int cEntries, MemorySegment prgbq) {
        var mh$ = GetDIBColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDIBColorTable", hdc, iStart, cEntries, prgbq);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, prgbq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetDIBColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static FunctionDescriptor SetDIBColorTable$descriptor() {
        return SetDIBColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static MethodHandle SetDIBColorTable$handle() {
        return SetDIBColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static MemorySegment SetDIBColorTable$address() {
        return SetDIBColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static int SetDIBColorTable(MemorySegment hdc, int iStart, int cEntries, MemorySegment prgbq) {
        var mh$ = SetDIBColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBColorTable", hdc, iStart, cEntries, prgbq);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, prgbq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORADJUSTMENT {
     *     WORD caSize;
     *     WORD caFlags;
     *     WORD caIlluminantIndex;
     *     WORD caRedGamma;
     *     WORD caGreenGamma;
     *     WORD caBlueGamma;
     *     WORD caReferenceBlack;
     *     WORD caReferenceWhite;
     *     SHORT caContrast;
     *     SHORT caBrightness;
     *     SHORT caColorfulness;
     *     SHORT caRedGreenTint;
     * } *PCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout PCOLORADJUSTMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORADJUSTMENT {
     *     WORD caSize;
     *     WORD caFlags;
     *     WORD caIlluminantIndex;
     *     WORD caRedGamma;
     *     WORD caGreenGamma;
     *     WORD caBlueGamma;
     *     WORD caReferenceBlack;
     *     WORD caReferenceWhite;
     *     SHORT caContrast;
     *     SHORT caBrightness;
     *     SHORT caColorfulness;
     *     SHORT caRedGreenTint;
     * } *LPCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout LPCOLORADJUSTMENT = winapi.C_POINTER;

    private static class SetColorAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetColorAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static FunctionDescriptor SetColorAdjustment$descriptor() {
        return SetColorAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static MethodHandle SetColorAdjustment$handle() {
        return SetColorAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static MemorySegment SetColorAdjustment$address() {
        return SetColorAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static int SetColorAdjustment(MemorySegment hdc, MemorySegment lpca) {
        var mh$ = SetColorAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetColorAdjustment", hdc, lpca);
            }
            return (int)mh$.invokeExact(hdc, lpca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetColorAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static FunctionDescriptor GetColorAdjustment$descriptor() {
        return GetColorAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static MethodHandle GetColorAdjustment$handle() {
        return GetColorAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static MemorySegment GetColorAdjustment$address() {
        return GetColorAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static int GetColorAdjustment(MemorySegment hdc, MemorySegment lpca) {
        var mh$ = GetColorAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorAdjustment", hdc, lpca);
            }
            return (int)mh$.invokeExact(hdc, lpca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHalftonePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateHalftonePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static FunctionDescriptor CreateHalftonePalette$descriptor() {
        return CreateHalftonePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MethodHandle CreateHalftonePalette$handle() {
        return CreateHalftonePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MemorySegment CreateHalftonePalette$address() {
        return CreateHalftonePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MemorySegment CreateHalftonePalette(MemorySegment hdc) {
        var mh$ = CreateHalftonePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHalftonePalette", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DOCINFOA {
     *     int cbSize;
     *     LPCSTR lpszDocName;
     *     LPCSTR lpszOutput;
     *     LPCSTR lpszDatatype;
     *     DWORD fwType;
     * } *LPDOCINFOA
     * }
     */
    public static final AddressLayout LPDOCINFOA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DOCINFOW {
     *     int cbSize;
     *     LPCWSTR lpszDocName;
     *     LPCWSTR lpszOutput;
     *     LPCWSTR lpszDatatype;
     *     DWORD fwType;
     * } *LPDOCINFOW
     * }
     */
    public static final AddressLayout LPDOCINFOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDOCINFOA LPDOCINFO
     * }
     */
    public static final AddressLayout LPDOCINFO = winapi.C_POINTER;

    private static class StartDocA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("StartDocA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static FunctionDescriptor StartDocA$descriptor() {
        return StartDocA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static MethodHandle StartDocA$handle() {
        return StartDocA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static MemorySegment StartDocA$address() {
        return StartDocA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static int StartDocA(MemorySegment hdc, MemorySegment lpdi) {
        var mh$ = StartDocA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartDocA", hdc, lpdi);
            }
            return (int)mh$.invokeExact(hdc, lpdi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartDocW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("StartDocW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static FunctionDescriptor StartDocW$descriptor() {
        return StartDocW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static MethodHandle StartDocW$handle() {
        return StartDocW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static MemorySegment StartDocW$address() {
        return StartDocW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static int StartDocW(MemorySegment hdc, MemorySegment lpdi) {
        var mh$ = StartDocW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartDocW", hdc, lpdi);
            }
            return (int)mh$.invokeExact(hdc, lpdi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EndDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndDoc$descriptor() {
        return EndDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static MethodHandle EndDoc$handle() {
        return EndDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static MemorySegment EndDoc$address() {
        return EndDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static int EndDoc(MemorySegment hdc) {
        var mh$ = EndDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDoc", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartPage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("StartPage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static FunctionDescriptor StartPage$descriptor() {
        return StartPage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static MethodHandle StartPage$handle() {
        return StartPage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static MemorySegment StartPage$address() {
        return StartPage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static int StartPage(MemorySegment hdc) {
        var mh$ = StartPage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartPage", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EndPage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndPage$descriptor() {
        return EndPage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static MethodHandle EndPage$handle() {
        return EndPage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static MemorySegment EndPage$address() {
        return EndPage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static int EndPage(MemorySegment hdc) {
        var mh$ = EndPage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPage", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AbortDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static FunctionDescriptor AbortDoc$descriptor() {
        return AbortDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static MethodHandle AbortDoc$handle() {
        return AbortDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static MemorySegment AbortDoc$address() {
        return AbortDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static int AbortDoc(MemorySegment hdc) {
        var mh$ = AbortDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortDoc", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAbortProc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetAbortProc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static FunctionDescriptor SetAbortProc$descriptor() {
        return SetAbortProc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static MethodHandle SetAbortProc$handle() {
        return SetAbortProc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static MemorySegment SetAbortProc$address() {
        return SetAbortProc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static int SetAbortProc(MemorySegment hdc, MemorySegment proc) {
        var mh$ = SetAbortProc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAbortProc", hdc, proc);
            }
            return (int)mh$.invokeExact(hdc, proc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AbortPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor AbortPath$descriptor() {
        return AbortPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static MethodHandle AbortPath$handle() {
        return AbortPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static MemorySegment AbortPath$address() {
        return AbortPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static int AbortPath(MemorySegment hdc) {
        var mh$ = AbortPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ArcTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ArcTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static FunctionDescriptor ArcTo$descriptor() {
        return ArcTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MethodHandle ArcTo$handle() {
        return ArcTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MemorySegment ArcTo$address() {
        return ArcTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static int ArcTo(MemorySegment hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2) {
        var mh$ = ArcTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ArcTo", hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("BeginPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor BeginPath$descriptor() {
        return BeginPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static MethodHandle BeginPath$handle() {
        return BeginPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static MemorySegment BeginPath$address() {
        return BeginPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static int BeginPath(MemorySegment hdc) {
        var mh$ = BeginPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseFigure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CloseFigure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseFigure$descriptor() {
        return CloseFigure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static MethodHandle CloseFigure$handle() {
        return CloseFigure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static MemorySegment CloseFigure$address() {
        return CloseFigure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static int CloseFigure(MemorySegment hdc) {
        var mh$ = CloseFigure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseFigure", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EndPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndPath$descriptor() {
        return EndPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static MethodHandle EndPath$handle() {
        return EndPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static MemorySegment EndPath$address() {
        return EndPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static int EndPath(MemorySegment hdc) {
        var mh$ = EndPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FillPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor FillPath$descriptor() {
        return FillPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static MethodHandle FillPath$handle() {
        return FillPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static MemorySegment FillPath$address() {
        return FillPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static int FillPath(MemorySegment hdc) {
        var mh$ = FillPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlattenPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FlattenPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor FlattenPath$descriptor() {
        return FlattenPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static MethodHandle FlattenPath$handle() {
        return FlattenPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static MemorySegment FlattenPath$address() {
        return FlattenPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static int FlattenPath(MemorySegment hdc) {
        var mh$ = FlattenPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlattenPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static FunctionDescriptor GetPath$descriptor() {
        return GetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static MethodHandle GetPath$handle() {
        return GetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static MemorySegment GetPath$address() {
        return GetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static int GetPath(MemorySegment hdc, MemorySegment apt, MemorySegment aj, int cpt) {
        var mh$ = GetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPath", hdc, apt, aj, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, aj, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PathToRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PathToRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static FunctionDescriptor PathToRegion$descriptor() {
        return PathToRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MethodHandle PathToRegion$handle() {
        return PathToRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MemorySegment PathToRegion$address() {
        return PathToRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MemorySegment PathToRegion(MemorySegment hdc) {
        var mh$ = PathToRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PathToRegion", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyDraw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PolyDraw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static FunctionDescriptor PolyDraw$descriptor() {
        return PolyDraw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static MethodHandle PolyDraw$handle() {
        return PolyDraw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static MemorySegment PolyDraw$address() {
        return PolyDraw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static int PolyDraw(MemorySegment hdc, MemorySegment apt, MemorySegment aj, int cpt) {
        var mh$ = PolyDraw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyDraw", hdc, apt, aj, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, aj, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SelectClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SelectClipPath$descriptor() {
        return SelectClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SelectClipPath$handle() {
        return SelectClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SelectClipPath$address() {
        return SelectClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static int SelectClipPath(MemorySegment hdc, int mode) {
        var mh$ = SelectClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectClipPath", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetArcDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetArcDirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static FunctionDescriptor SetArcDirection$descriptor() {
        return SetArcDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static MethodHandle SetArcDirection$handle() {
        return SetArcDirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static MemorySegment SetArcDirection$address() {
        return SetArcDirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static int SetArcDirection(MemorySegment hdc, int dir) {
        var mh$ = SetArcDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetArcDirection", hdc, dir);
            }
            return (int)mh$.invokeExact(hdc, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_FLOAT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static FunctionDescriptor SetMiterLimit$descriptor() {
        return SetMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static MethodHandle SetMiterLimit$handle() {
        return SetMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static MemorySegment SetMiterLimit$address() {
        return SetMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static int SetMiterLimit(MemorySegment hdc, float limit, MemorySegment old) {
        var mh$ = SetMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMiterLimit", hdc, limit, old);
            }
            return (int)mh$.invokeExact(hdc, limit, old);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StrokeAndFillPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("StrokeAndFillPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor StrokeAndFillPath$descriptor() {
        return StrokeAndFillPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static MethodHandle StrokeAndFillPath$handle() {
        return StrokeAndFillPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static MemorySegment StrokeAndFillPath$address() {
        return StrokeAndFillPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static int StrokeAndFillPath(MemorySegment hdc) {
        var mh$ = StrokeAndFillPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StrokeAndFillPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StrokePath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("StrokePath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static FunctionDescriptor StrokePath$descriptor() {
        return StrokePath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static MethodHandle StrokePath$handle() {
        return StrokePath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static MemorySegment StrokePath$address() {
        return StrokePath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static int StrokePath(MemorySegment hdc) {
        var mh$ = StrokePath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StrokePath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WidenPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WidenPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor WidenPath$descriptor() {
        return WidenPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static MethodHandle WidenPath$handle() {
        return WidenPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static MemorySegment WidenPath$address() {
        return WidenPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static int WidenPath(MemorySegment hdc) {
        var mh$ = WidenPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WidenPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtCreatePen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExtCreatePen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static FunctionDescriptor ExtCreatePen$descriptor() {
        return ExtCreatePen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MethodHandle ExtCreatePen$handle() {
        return ExtCreatePen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MemorySegment ExtCreatePen$address() {
        return ExtCreatePen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MemorySegment ExtCreatePen(int iPenStyle, int cWidth, MemorySegment plbrush, int cStyle, MemorySegment pstyle) {
        var mh$ = ExtCreatePen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtCreatePen", iPenStyle, cWidth, plbrush, cStyle, pstyle);
            }
            return (MemorySegment)mh$.invokeExact(iPenStyle, cWidth, plbrush, cStyle, pstyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static FunctionDescriptor GetMiterLimit$descriptor() {
        return GetMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static MethodHandle GetMiterLimit$handle() {
        return GetMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static MemorySegment GetMiterLimit$address() {
        return GetMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static int GetMiterLimit(MemorySegment hdc, MemorySegment plimit) {
        var mh$ = GetMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMiterLimit", hdc, plimit);
            }
            return (int)mh$.invokeExact(hdc, plimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetArcDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetArcDirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetArcDirection$descriptor() {
        return GetArcDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static MethodHandle GetArcDirection$handle() {
        return GetArcDirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static MemorySegment GetArcDirection$address() {
        return GetArcDirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static int GetArcDirection(MemorySegment hdc) {
        var mh$ = GetArcDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetArcDirection", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetObjectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static FunctionDescriptor GetObjectA$descriptor() {
        return GetObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MethodHandle GetObjectA$handle() {
        return GetObjectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MemorySegment GetObjectA$address() {
        return GetObjectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static int GetObjectA(MemorySegment h, int c, MemorySegment pv) {
        var mh$ = GetObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectA", h, c, pv);
            }
            return (int)mh$.invokeExact(h, c, pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetObjectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static FunctionDescriptor GetObjectW$descriptor() {
        return GetObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MethodHandle GetObjectW$handle() {
        return GetObjectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MemorySegment GetObjectW$address() {
        return GetObjectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static int GetObjectW(MemorySegment h, int c, MemorySegment pv) {
        var mh$ = GetObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectW", h, c, pv);
            }
            return (int)mh$.invokeExact(h, c, pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveToEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("MoveToEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor MoveToEx$descriptor() {
        return MoveToEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle MoveToEx$handle() {
        return MoveToEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment MoveToEx$address() {
        return MoveToEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int MoveToEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = MoveToEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveToEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static FunctionDescriptor TextOutA$descriptor() {
        return TextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static MethodHandle TextOutA$handle() {
        return TextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static MemorySegment TextOutA$address() {
        return TextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static int TextOutA(MemorySegment hdc, int x, int y, MemorySegment lpString, int c) {
        var mh$ = TextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextOutA", hdc, x, y, lpString, c);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static FunctionDescriptor TextOutW$descriptor() {
        return TextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static MethodHandle TextOutW$handle() {
        return TextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static MemorySegment TextOutW$address() {
        return TextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static int TextOutW(MemorySegment hdc, int x, int y, MemorySegment lpString, int c) {
        var mh$ = TextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextOutW", hdc, x, y, lpString, c);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExtTextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static FunctionDescriptor ExtTextOutA$descriptor() {
        return ExtTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MethodHandle ExtTextOutA$handle() {
        return ExtTextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MemorySegment ExtTextOutA$address() {
        return ExtTextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static int ExtTextOutA(MemorySegment hdc, int x, int y, int options, MemorySegment lprect, MemorySegment lpString, int c, MemorySegment lpDx) {
        var mh$ = ExtTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtTextOutA", hdc, x, y, options, lprect, lpString, c, lpDx);
            }
            return (int)mh$.invokeExact(hdc, x, y, options, lprect, lpString, c, lpDx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExtTextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static FunctionDescriptor ExtTextOutW$descriptor() {
        return ExtTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MethodHandle ExtTextOutW$handle() {
        return ExtTextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MemorySegment ExtTextOutW$address() {
        return ExtTextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static int ExtTextOutW(MemorySegment hdc, int x, int y, int options, MemorySegment lprect, MemorySegment lpString, int c, MemorySegment lpDx) {
        var mh$ = ExtTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtTextOutW", hdc, x, y, options, lprect, lpString, c, lpDx);
            }
            return (int)mh$.invokeExact(hdc, x, y, options, lprect, lpString, c, lpDx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PolyTextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static FunctionDescriptor PolyTextOutA$descriptor() {
        return PolyTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static MethodHandle PolyTextOutA$handle() {
        return PolyTextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static MemorySegment PolyTextOutA$address() {
        return PolyTextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static int PolyTextOutA(MemorySegment hdc, MemorySegment ppt, int nstrings) {
        var mh$ = PolyTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyTextOutA", hdc, ppt, nstrings);
            }
            return (int)mh$.invokeExact(hdc, ppt, nstrings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PolyTextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static FunctionDescriptor PolyTextOutW$descriptor() {
        return PolyTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static MethodHandle PolyTextOutW$handle() {
        return PolyTextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static MemorySegment PolyTextOutW$address() {
        return PolyTextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static int PolyTextOutW(MemorySegment hdc, MemorySegment ppt, int nstrings) {
        var mh$ = PolyTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyTextOutW", hdc, ppt, nstrings);
            }
            return (int)mh$.invokeExact(hdc, ppt, nstrings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePolygonRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreatePolygonRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static FunctionDescriptor CreatePolygonRgn$descriptor() {
        return CreatePolygonRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MethodHandle CreatePolygonRgn$handle() {
        return CreatePolygonRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MemorySegment CreatePolygonRgn$address() {
        return CreatePolygonRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MemorySegment CreatePolygonRgn(MemorySegment pptl, int cPoint, int iMode) {
        var mh$ = CreatePolygonRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePolygonRgn", pptl, cPoint, iMode);
            }
            return (MemorySegment)mh$.invokeExact(pptl, cPoint, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DPtoLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DPtoLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static FunctionDescriptor DPtoLP$descriptor() {
        return DPtoLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MethodHandle DPtoLP$handle() {
        return DPtoLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MemorySegment DPtoLP$address() {
        return DPtoLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static int DPtoLP(MemorySegment hdc, MemorySegment lppt, int c) {
        var mh$ = DPtoLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DPtoLP", hdc, lppt, c);
            }
            return (int)mh$.invokeExact(hdc, lppt, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LPtoDP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LPtoDP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static FunctionDescriptor LPtoDP$descriptor() {
        return LPtoDP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MethodHandle LPtoDP$handle() {
        return LPtoDP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MemorySegment LPtoDP$address() {
        return LPtoDP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static int LPtoDP(MemorySegment hdc, MemorySegment lppt, int c) {
        var mh$ = LPtoDP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LPtoDP", hdc, lppt, c);
            }
            return (int)mh$.invokeExact(hdc, lppt, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Polygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Polygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static FunctionDescriptor Polygon$descriptor() {
        return Polygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MethodHandle Polygon$handle() {
        return Polygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MemorySegment Polygon$address() {
        return Polygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static int Polygon(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = Polygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Polygon", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Polyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Polyline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static FunctionDescriptor Polyline$descriptor() {
        return Polyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MethodHandle Polyline$handle() {
        return Polyline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MemorySegment Polyline$address() {
        return Polyline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static int Polyline(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = Polyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Polyline", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyBezier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PolyBezier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolyBezier$descriptor() {
        return PolyBezier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolyBezier$handle() {
        return PolyBezier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MemorySegment PolyBezier$address() {
        return PolyBezier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolyBezier(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolyBezier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyBezier", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyBezierTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PolyBezierTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolyBezierTo$descriptor() {
        return PolyBezierTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolyBezierTo$handle() {
        return PolyBezierTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MemorySegment PolyBezierTo$address() {
        return PolyBezierTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolyBezierTo(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolyBezierTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyBezierTo", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolylineTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PolylineTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolylineTo$descriptor() {
        return PolylineTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolylineTo$handle() {
        return PolylineTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MemorySegment PolylineTo$address() {
        return PolylineTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolylineTo(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolylineTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolylineTo", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetViewportExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetViewportExtEx$descriptor() {
        return SetViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetViewportExtEx$handle() {
        return SetViewportExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MemorySegment SetViewportExtEx$address() {
        return SetViewportExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static int SetViewportExtEx(MemorySegment hdc, int x, int y, MemorySegment lpsz) {
        var mh$ = SetViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetViewportExtEx", hdc, x, y, lpsz);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetViewportOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetViewportOrgEx$descriptor() {
        return SetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetViewportOrgEx$handle() {
        return SetViewportOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment SetViewportOrgEx$address() {
        return SetViewportOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetViewportOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetViewportOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetWindowExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetWindowExtEx$descriptor() {
        return SetWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetWindowExtEx$handle() {
        return SetWindowExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MemorySegment SetWindowExtEx$address() {
        return SetWindowExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static int SetWindowExtEx(MemorySegment hdc, int x, int y, MemorySegment lpsz) {
        var mh$ = SetWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowExtEx", hdc, x, y, lpsz);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetWindowOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetWindowOrgEx$descriptor() {
        return SetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetWindowOrgEx$handle() {
        return SetWindowOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment SetWindowOrgEx$address() {
        return SetWindowOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetWindowOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OffsetViewportOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor OffsetViewportOrgEx$descriptor() {
        return OffsetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle OffsetViewportOrgEx$handle() {
        return OffsetViewportOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment OffsetViewportOrgEx$address() {
        return OffsetViewportOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int OffsetViewportOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = OffsetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetViewportOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OffsetWindowOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor OffsetWindowOrgEx$descriptor() {
        return OffsetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle OffsetWindowOrgEx$handle() {
        return OffsetWindowOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment OffsetWindowOrgEx$address() {
        return OffsetWindowOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int OffsetWindowOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = OffsetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetWindowOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScaleViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ScaleViewportExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor ScaleViewportExtEx$descriptor() {
        return ScaleViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MethodHandle ScaleViewportExtEx$handle() {
        return ScaleViewportExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MemorySegment ScaleViewportExtEx$address() {
        return ScaleViewportExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static int ScaleViewportExtEx(MemorySegment hdc, int xn, int dx, int yn, int yd, MemorySegment lpsz) {
        var mh$ = ScaleViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScaleViewportExtEx", hdc, xn, dx, yn, yd, lpsz);
            }
            return (int)mh$.invokeExact(hdc, xn, dx, yn, yd, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScaleWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ScaleWindowExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor ScaleWindowExtEx$descriptor() {
        return ScaleWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MethodHandle ScaleWindowExtEx$handle() {
        return ScaleWindowExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MemorySegment ScaleWindowExtEx$address() {
        return ScaleWindowExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static int ScaleWindowExtEx(MemorySegment hdc, int xn, int xd, int yn, int yd, MemorySegment lpsz) {
        var mh$ = ScaleWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScaleWindowExtEx", hdc, xn, xd, yn, yd, lpsz);
            }
            return (int)mh$.invokeExact(hdc, xn, xd, yn, yd, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBitmapDimensionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetBitmapDimensionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetBitmapDimensionEx$descriptor() {
        return SetBitmapDimensionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetBitmapDimensionEx$handle() {
        return SetBitmapDimensionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static MemorySegment SetBitmapDimensionEx$address() {
        return SetBitmapDimensionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static int SetBitmapDimensionEx(MemorySegment hbm, int w, int h, MemorySegment lpsz) {
        var mh$ = SetBitmapDimensionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBitmapDimensionEx", hbm, w, h, lpsz);
            }
            return (int)mh$.invokeExact(hbm, w, h, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetBrushOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetBrushOrgEx$descriptor() {
        return SetBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetBrushOrgEx$handle() {
        return SetBrushOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment SetBrushOrgEx$address() {
        return SetBrushOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetBrushOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBrushOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextFaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextFaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static FunctionDescriptor GetTextFaceA$descriptor() {
        return GetTextFaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static MethodHandle GetTextFaceA$handle() {
        return GetTextFaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static MemorySegment GetTextFaceA$address() {
        return GetTextFaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static int GetTextFaceA(MemorySegment hdc, int c, MemorySegment lpName) {
        var mh$ = GetTextFaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextFaceA", hdc, c, lpName);
            }
            return (int)mh$.invokeExact(hdc, c, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextFaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTextFaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetTextFaceW$descriptor() {
        return GetTextFaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static MethodHandle GetTextFaceW$handle() {
        return GetTextFaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static MemorySegment GetTextFaceW$address() {
        return GetTextFaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static int GetTextFaceW(MemorySegment hdc, int c, MemorySegment lpName) {
        var mh$ = GetTextFaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextFaceW", hdc, c, lpName);
            }
            return (int)mh$.invokeExact(hdc, c, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagKERNINGPAIR {
     *     WORD wFirst;
     *     WORD wSecond;
     *     int iKernAmount;
     * } *LPKERNINGPAIR
     * }
     */
    public static final AddressLayout LPKERNINGPAIR = winapi.C_POINTER;

    private static class GetKerningPairsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetKerningPairsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static FunctionDescriptor GetKerningPairsA$descriptor() {
        return GetKerningPairsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MethodHandle GetKerningPairsA$handle() {
        return GetKerningPairsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MemorySegment GetKerningPairsA$address() {
        return GetKerningPairsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static int GetKerningPairsA(MemorySegment hdc, int nPairs, MemorySegment lpKernPair) {
        var mh$ = GetKerningPairsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKerningPairsA", hdc, nPairs, lpKernPair);
            }
            return (int)mh$.invokeExact(hdc, nPairs, lpKernPair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKerningPairsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetKerningPairsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static FunctionDescriptor GetKerningPairsW$descriptor() {
        return GetKerningPairsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MethodHandle GetKerningPairsW$handle() {
        return GetKerningPairsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MemorySegment GetKerningPairsW$address() {
        return GetKerningPairsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static int GetKerningPairsW(MemorySegment hdc, int nPairs, MemorySegment lpKernPair) {
        var mh$ = GetKerningPairsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKerningPairsW", hdc, nPairs, lpKernPair);
            }
            return (int)mh$.invokeExact(hdc, nPairs, lpKernPair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDCOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetDCOrgEx$descriptor() {
        return GetDCOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetDCOrgEx$handle() {
        return GetDCOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MemorySegment GetDCOrgEx$address() {
        return GetDCOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetDCOrgEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetDCOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCOrgEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FixBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FixBrushOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static FunctionDescriptor FixBrushOrgEx$descriptor() {
        return FixBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static MethodHandle FixBrushOrgEx$handle() {
        return FixBrushOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static MemorySegment FixBrushOrgEx$address() {
        return FixBrushOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static int FixBrushOrgEx(MemorySegment hdc, int x, int y, MemorySegment ptl) {
        var mh$ = FixBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FixBrushOrgEx", hdc, x, y, ptl);
            }
            return (int)mh$.invokeExact(hdc, x, y, ptl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnrealizeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("UnrealizeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor UnrealizeObject$descriptor() {
        return UnrealizeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static MethodHandle UnrealizeObject$handle() {
        return UnrealizeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static MemorySegment UnrealizeObject$address() {
        return UnrealizeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static int UnrealizeObject(MemorySegment h) {
        var mh$ = UnrealizeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnrealizeObject", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GdiFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static FunctionDescriptor GdiFlush$descriptor() {
        return GdiFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static MethodHandle GdiFlush$handle() {
        return GdiFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static MemorySegment GdiFlush$address() {
        return GdiFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static int GdiFlush() {
        var mh$ = GdiFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiFlush");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiSetBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GdiSetBatchLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static FunctionDescriptor GdiSetBatchLimit$descriptor() {
        return GdiSetBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static MethodHandle GdiSetBatchLimit$handle() {
        return GdiSetBatchLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static MemorySegment GdiSetBatchLimit$address() {
        return GdiSetBatchLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static int GdiSetBatchLimit(int dw) {
        var mh$ = GdiSetBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiSetBatchLimit", dw);
            }
            return (int)mh$.invokeExact(dw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiGetBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GdiGetBatchLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static FunctionDescriptor GdiGetBatchLimit$descriptor() {
        return GdiGetBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static MethodHandle GdiGetBatchLimit$handle() {
        return GdiGetBatchLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static MemorySegment GdiGetBatchLimit$address() {
        return GdiGetBatchLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static int GdiGetBatchLimit() {
        var mh$ = GdiGetBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiGetBatchLimit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetICMMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetICMMode$descriptor() {
        return SetICMMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetICMMode$handle() {
        return SetICMMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetICMMode$address() {
        return SetICMMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static int SetICMMode(MemorySegment hdc, int mode) {
        var mh$ = SetICMMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckColorsInGamut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CheckColorsInGamut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static FunctionDescriptor CheckColorsInGamut$descriptor() {
        return CheckColorsInGamut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static MethodHandle CheckColorsInGamut$handle() {
        return CheckColorsInGamut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static MemorySegment CheckColorsInGamut$address() {
        return CheckColorsInGamut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static int CheckColorsInGamut(MemorySegment hdc, MemorySegment lpRGBTriple, MemorySegment dlpBuffer, int nCount) {
        var mh$ = CheckColorsInGamut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckColorsInGamut", hdc, lpRGBTriple, dlpBuffer, nCount);
            }
            return (int)mh$.invokeExact(hdc, lpRGBTriple, dlpBuffer, nCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetColorSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetColorSpace$descriptor() {
        return GetColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MethodHandle GetColorSpace$handle() {
        return GetColorSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MemorySegment GetColorSpace$address() {
        return GetColorSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MemorySegment GetColorSpace(MemorySegment hdc) {
        var mh$ = GetColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorSpace", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogColorSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLogColorSpaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetLogColorSpaceA$descriptor() {
        return GetLogColorSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetLogColorSpaceA$handle() {
        return GetLogColorSpaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetLogColorSpaceA$address() {
        return GetLogColorSpaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static int GetLogColorSpaceA(MemorySegment hColorSpace, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetLogColorSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogColorSpaceA", hColorSpace, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(hColorSpace, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogColorSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLogColorSpaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetLogColorSpaceW$descriptor() {
        return GetLogColorSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetLogColorSpaceW$handle() {
        return GetLogColorSpaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetLogColorSpaceW$address() {
        return GetLogColorSpaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static int GetLogColorSpaceW(MemorySegment hColorSpace, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetLogColorSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogColorSpaceW", hColorSpace, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(hColorSpace, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateColorSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateColorSpaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static FunctionDescriptor CreateColorSpaceA$descriptor() {
        return CreateColorSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MethodHandle CreateColorSpaceA$handle() {
        return CreateColorSpaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceA$address() {
        return CreateColorSpaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceA(MemorySegment lplcs) {
        var mh$ = CreateColorSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateColorSpaceA", lplcs);
            }
            return (MemorySegment)mh$.invokeExact(lplcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateColorSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateColorSpaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static FunctionDescriptor CreateColorSpaceW$descriptor() {
        return CreateColorSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MethodHandle CreateColorSpaceW$handle() {
        return CreateColorSpaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceW$address() {
        return CreateColorSpaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceW(MemorySegment lplcs) {
        var mh$ = CreateColorSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateColorSpaceW", lplcs);
            }
            return (MemorySegment)mh$.invokeExact(lplcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetColorSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static FunctionDescriptor SetColorSpace$descriptor() {
        return SetColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MethodHandle SetColorSpace$handle() {
        return SetColorSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment SetColorSpace$address() {
        return SetColorSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment SetColorSpace(MemorySegment hdc, MemorySegment hcs) {
        var mh$ = SetColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetColorSpace", hdc, hcs);
            }
            return (MemorySegment)mh$.invokeExact(hdc, hcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteColorSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static FunctionDescriptor DeleteColorSpace$descriptor() {
        return DeleteColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static MethodHandle DeleteColorSpace$handle() {
        return DeleteColorSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment DeleteColorSpace$address() {
        return DeleteColorSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static int DeleteColorSpace(MemorySegment hcs) {
        var mh$ = DeleteColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteColorSpace", hcs);
            }
            return (int)mh$.invokeExact(hcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetICMProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetICMProfileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static FunctionDescriptor GetICMProfileA$descriptor() {
        return GetICMProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static MethodHandle GetICMProfileA$handle() {
        return GetICMProfileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static MemorySegment GetICMProfileA$address() {
        return GetICMProfileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static int GetICMProfileA(MemorySegment hdc, MemorySegment pBufSize, MemorySegment pszFilename) {
        var mh$ = GetICMProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetICMProfileA", hdc, pBufSize, pszFilename);
            }
            return (int)mh$.invokeExact(hdc, pBufSize, pszFilename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetICMProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetICMProfileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static FunctionDescriptor GetICMProfileW$descriptor() {
        return GetICMProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static MethodHandle GetICMProfileW$handle() {
        return GetICMProfileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static MemorySegment GetICMProfileW$address() {
        return GetICMProfileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static int GetICMProfileW(MemorySegment hdc, MemorySegment pBufSize, MemorySegment pszFilename) {
        var mh$ = GetICMProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetICMProfileW", hdc, pBufSize, pszFilename);
            }
            return (int)mh$.invokeExact(hdc, pBufSize, pszFilename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetICMProfileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static FunctionDescriptor SetICMProfileA$descriptor() {
        return SetICMProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static MethodHandle SetICMProfileA$handle() {
        return SetICMProfileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static MemorySegment SetICMProfileA$address() {
        return SetICMProfileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static int SetICMProfileA(MemorySegment hdc, MemorySegment lpFileName) {
        var mh$ = SetICMProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMProfileA", hdc, lpFileName);
            }
            return (int)mh$.invokeExact(hdc, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetICMProfileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor SetICMProfileW$descriptor() {
        return SetICMProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static MethodHandle SetICMProfileW$handle() {
        return SetICMProfileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static MemorySegment SetICMProfileW$address() {
        return SetICMProfileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static int SetICMProfileW(MemorySegment hdc, MemorySegment lpFileName) {
        var mh$ = SetICMProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMProfileW", hdc, lpFileName);
            }
            return (int)mh$.invokeExact(hdc, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDeviceGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDeviceGammaRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static FunctionDescriptor GetDeviceGammaRamp$descriptor() {
        return GetDeviceGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MethodHandle GetDeviceGammaRamp$handle() {
        return GetDeviceGammaRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MemorySegment GetDeviceGammaRamp$address() {
        return GetDeviceGammaRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static int GetDeviceGammaRamp(MemorySegment hdc, MemorySegment lpRamp) {
        var mh$ = GetDeviceGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDeviceGammaRamp", hdc, lpRamp);
            }
            return (int)mh$.invokeExact(hdc, lpRamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDeviceGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetDeviceGammaRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static FunctionDescriptor SetDeviceGammaRamp$descriptor() {
        return SetDeviceGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MethodHandle SetDeviceGammaRamp$handle() {
        return SetDeviceGammaRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MemorySegment SetDeviceGammaRamp$address() {
        return SetDeviceGammaRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static int SetDeviceGammaRamp(MemorySegment hdc, MemorySegment lpRamp) {
        var mh$ = SetDeviceGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDeviceGammaRamp", hdc, lpRamp);
            }
            return (int)mh$.invokeExact(hdc, lpRamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorMatchToTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ColorMatchToTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static FunctionDescriptor ColorMatchToTarget$descriptor() {
        return ColorMatchToTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static MethodHandle ColorMatchToTarget$handle() {
        return ColorMatchToTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static MemorySegment ColorMatchToTarget$address() {
        return ColorMatchToTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static int ColorMatchToTarget(MemorySegment hdc, MemorySegment hdcTarget, int action) {
        var mh$ = ColorMatchToTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorMatchToTarget", hdc, hdcTarget, action);
            }
            return (int)mh$.invokeExact(hdc, hdcTarget, action);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumICMProfilesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumICMProfilesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumICMProfilesA$descriptor() {
        return EnumICMProfilesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumICMProfilesA$handle() {
        return EnumICMProfilesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static MemorySegment EnumICMProfilesA$address() {
        return EnumICMProfilesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static int EnumICMProfilesA(MemorySegment hdc, MemorySegment proc, long param) {
        var mh$ = EnumICMProfilesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumICMProfilesA", hdc, proc, param);
            }
            return (int)mh$.invokeExact(hdc, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumICMProfilesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumICMProfilesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumICMProfilesW$descriptor() {
        return EnumICMProfilesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumICMProfilesW$handle() {
        return EnumICMProfilesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static MemorySegment EnumICMProfilesW$address() {
        return EnumICMProfilesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static int EnumICMProfilesW(MemorySegment hdc, MemorySegment proc, long param) {
        var mh$ = EnumICMProfilesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumICMProfilesW", hdc, proc, param);
            }
            return (int)mh$.invokeExact(hdc, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateICMRegKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("UpdateICMRegKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static FunctionDescriptor UpdateICMRegKeyA$descriptor() {
        return UpdateICMRegKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static MethodHandle UpdateICMRegKeyA$handle() {
        return UpdateICMRegKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static MemorySegment UpdateICMRegKeyA$address() {
        return UpdateICMRegKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static int UpdateICMRegKeyA(int reserved, MemorySegment lpszCMID, MemorySegment lpszFileName, int command) {
        var mh$ = UpdateICMRegKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateICMRegKeyA", reserved, lpszCMID, lpszFileName, command);
            }
            return (int)mh$.invokeExact(reserved, lpszCMID, lpszFileName, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateICMRegKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("UpdateICMRegKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static FunctionDescriptor UpdateICMRegKeyW$descriptor() {
        return UpdateICMRegKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static MethodHandle UpdateICMRegKeyW$handle() {
        return UpdateICMRegKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static MemorySegment UpdateICMRegKeyW$address() {
        return UpdateICMRegKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static int UpdateICMRegKeyW(int reserved, MemorySegment lpszCMID, MemorySegment lpszFileName, int command) {
        var mh$ = UpdateICMRegKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateICMRegKeyW", reserved, lpszCMID, lpszFileName, command);
            }
            return (int)mh$.invokeExact(reserved, lpszCMID, lpszFileName, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorCorrectPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ColorCorrectPalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static FunctionDescriptor ColorCorrectPalette$descriptor() {
        return ColorCorrectPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static MethodHandle ColorCorrectPalette$handle() {
        return ColorCorrectPalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static MemorySegment ColorCorrectPalette$address() {
        return ColorCorrectPalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static int ColorCorrectPalette(MemorySegment hdc, MemorySegment hPal, int deFirst, int num) {
        var mh$ = ColorCorrectPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorCorrectPalette", hdc, hPal, deFirst, num);
            }
            return (int)mh$.invokeExact(hdc, hPal, deFirst, num);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagEMR {
     *     DWORD iType;
     *     DWORD nSize;
     * } *PEMR
     * }
     */
    public static final AddressLayout PEMR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRTEXT {
     *     POINTL ptlReference;
     *     DWORD nChars;
     *     DWORD offString;
     *     DWORD fOptions;
     *     RECTL rcl;
     *     DWORD offDx;
     * } *PEMRTEXT
     * }
     */
    public static final AddressLayout PEMRTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRABORTPATH
     * }
     */
    public static final AddressLayout PEMRABORTPATH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRBEGINPATH
     * }
     */
    public static final AddressLayout PEMRBEGINPATH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRENDPATH
     * }
     */
    public static final AddressLayout PEMRENDPATH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRCLOSEFIGURE
     * }
     */
    public static final AddressLayout PEMRCLOSEFIGURE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRFLATTENPATH
     * }
     */
    public static final AddressLayout PEMRFLATTENPATH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRWIDENPATH
     * }
     */
    public static final AddressLayout PEMRWIDENPATH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRSETMETARGN
     * }
     */
    public static final AddressLayout PEMRSETMETARGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRSAVEDC
     * }
     */
    public static final AddressLayout PEMRSAVEDC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRREALIZEPALETTE
     * }
     */
    public static final AddressLayout PEMRREALIZEPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSELECTCLIPPATH
     * }
     */
    public static final AddressLayout PEMRSELECTCLIPPATH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETBKMODE
     * }
     */
    public static final AddressLayout PEMRSETBKMODE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETMAPMODE
     * }
     */
    public static final AddressLayout PEMRSETMAPMODE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETLAYOUT
     * }
     */
    public static final AddressLayout PEMRSETLAYOUT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETPOLYFILLMODE
     * }
     */
    public static final AddressLayout PEMRSETPOLYFILLMODE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETROP2
     * }
     */
    public static final AddressLayout PEMRSETROP2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETSTRETCHBLTMODE
     * }
     */
    public static final AddressLayout PEMRSETSTRETCHBLTMODE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETICMMODE
     * }
     */
    public static final AddressLayout PEMRSETICMMODE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETTEXTALIGN
     * }
     */
    public static final AddressLayout PEMRSETTEXTALIGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETMITERLIMIT {
     *     EMR emr;
     *     FLOAT eMiterLimit;
     * } *PEMRSETMITERLIMIT
     * }
     */
    public static final AddressLayout PEMRSETMITERLIMIT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRRESTOREDC {
     *     EMR emr;
     *     LONG iRelative;
     * } *PEMRRESTOREDC
     * }
     */
    public static final AddressLayout PEMRRESTOREDC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETARCDIRECTION {
     *     EMR emr;
     *     DWORD iArcDirection;
     * } *PEMRSETARCDIRECTION
     * }
     */
    public static final AddressLayout PEMRSETARCDIRECTION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETMAPPERFLAGS {
     *     EMR emr;
     *     DWORD dwFlags;
     * } *PEMRSETMAPPERFLAGS
     * }
     */
    public static final AddressLayout PEMRSETMAPPERFLAGS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETTEXTCOLOR {
     *     EMR emr;
     *     COLORREF crColor;
     * } *PEMRSETBKCOLOR
     * }
     */
    public static final AddressLayout PEMRSETBKCOLOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETTEXTCOLOR {
     *     EMR emr;
     *     COLORREF crColor;
     * } *PEMRSETTEXTCOLOR
     * }
     */
    public static final AddressLayout PEMRSETTEXTCOLOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTOBJECT {
     *     EMR emr;
     *     DWORD ihObject;
     * } *PEMRSELECTOBJECT
     * }
     */
    public static final AddressLayout PEMRSELECTOBJECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTOBJECT {
     *     EMR emr;
     *     DWORD ihObject;
     * } *PEMRDELETEOBJECT
     * }
     */
    public static final AddressLayout PEMRDELETEOBJECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     * } *PEMRSELECTPALETTE
     * }
     */
    public static final AddressLayout PEMRSELECTPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRRESIZEPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     *     DWORD cEntries;
     * } *PEMRRESIZEPALETTE
     * }
     */
    public static final AddressLayout PEMRRESIZEPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETPALETTEENTRIES {
     *     EMR emr;
     *     DWORD ihPal;
     *     DWORD iStart;
     *     DWORD cEntries;
     *     PALETTEENTRY aPalEntries[1];
     * } *PEMRSETPALETTEENTRIES
     * }
     */
    public static final AddressLayout PEMRSETPALETTEENTRIES = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORADJUSTMENT {
     *     EMR emr;
     *     COLORADJUSTMENT ColorAdjustment;
     * } *PEMRSETCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout PEMRSETCOLORADJUSTMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGDICOMMENT {
     *     EMR emr;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGDICOMMENT
     * }
     */
    public static final AddressLayout PEMRGDICOMMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREOF {
     *     EMR emr;
     *     DWORD nPalEntries;
     *     DWORD offPalEntries;
     *     DWORD nSizeLast;
     * } *PEMREOF
     * }
     */
    public static final AddressLayout PEMREOF = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRLINETO {
     *     EMR emr;
     *     POINTL ptl;
     * } *PEMRLINETO
     * }
     */
    public static final AddressLayout PEMRLINETO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRLINETO {
     *     EMR emr;
     *     POINTL ptl;
     * } *PEMRMOVETOEX
     * }
     */
    public static final AddressLayout PEMRMOVETOEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMROFFSETCLIPRGN {
     *     EMR emr;
     *     POINTL ptlOffset;
     * } *PEMROFFSETCLIPRGN
     * }
     */
    public static final AddressLayout PEMROFFSETCLIPRGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRFILLPATH
     * }
     */
    public static final AddressLayout PEMRFILLPATH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRSTROKEANDFILLPATH
     * }
     */
    public static final AddressLayout PEMRSTROKEANDFILLPATH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRSTROKEPATH
     * }
     */
    public static final AddressLayout PEMRSTROKEPATH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXCLUDECLIPRECT {
     *     EMR emr;
     *     RECTL rclClip;
     * } *PEMREXCLUDECLIPRECT
     * }
     */
    public static final AddressLayout PEMREXCLUDECLIPRECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXCLUDECLIPRECT {
     *     EMR emr;
     *     RECTL rclClip;
     * } *PEMRINTERSECTCLIPRECT
     * }
     */
    public static final AddressLayout PEMRINTERSECTCLIPRECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETVIEWPORTORGEX
     * }
     */
    public static final AddressLayout PEMRSETVIEWPORTORGEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETWINDOWORGEX
     * }
     */
    public static final AddressLayout PEMRSETWINDOWORGEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETBRUSHORGEX
     * }
     */
    public static final AddressLayout PEMRSETBRUSHORGEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTEXTEX {
     *     EMR emr;
     *     SIZEL szlExtent;
     * } *PEMRSETVIEWPORTEXTEX
     * }
     */
    public static final AddressLayout PEMRSETVIEWPORTEXTEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTEXTEX {
     *     EMR emr;
     *     SIZEL szlExtent;
     * } *PEMRSETWINDOWEXTEX
     * }
     */
    public static final AddressLayout PEMRSETWINDOWEXTEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSCALEVIEWPORTEXTEX {
     *     EMR emr;
     *     LONG xNum;
     *     LONG xDenom;
     *     LONG yNum;
     *     LONG yDenom;
     * } *PEMRSCALEVIEWPORTEXTEX
     * }
     */
    public static final AddressLayout PEMRSCALEVIEWPORTEXTEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSCALEVIEWPORTEXTEX {
     *     EMR emr;
     *     LONG xNum;
     *     LONG xDenom;
     *     LONG yNum;
     *     LONG yDenom;
     * } *PEMRSCALEWINDOWEXTEX
     * }
     */
    public static final AddressLayout PEMRSCALEWINDOWEXTEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETWORLDTRANSFORM {
     *     EMR emr;
     *     XFORM xform;
     * } *PEMRSETWORLDTRANSFORM
     * }
     */
    public static final AddressLayout PEMRSETWORLDTRANSFORM = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRMODIFYWORLDTRANSFORM {
     *     EMR emr;
     *     XFORM xform;
     *     DWORD iMode;
     * } *PEMRMODIFYWORLDTRANSFORM
     * }
     */
    public static final AddressLayout PEMRMODIFYWORLDTRANSFORM = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETPIXELV {
     *     EMR emr;
     *     POINTL ptlPixel;
     *     COLORREF crColor;
     * } *PEMRSETPIXELV
     * }
     */
    public static final AddressLayout PEMRSETPIXELV = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTFLOODFILL {
     *     EMR emr;
     *     POINTL ptlStart;
     *     COLORREF crColor;
     *     DWORD iMode;
     * } *PEMREXTFLOODFILL
     * }
     */
    public static final AddressLayout PEMREXTFLOODFILL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRELLIPSE {
     *     EMR emr;
     *     RECTL rclBox;
     * } *PEMRELLIPSE
     * }
     */
    public static final AddressLayout PEMRELLIPSE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRELLIPSE {
     *     EMR emr;
     *     RECTL rclBox;
     * } *PEMRRECTANGLE
     * }
     */
    public static final AddressLayout PEMRRECTANGLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRROUNDRECT {
     *     EMR emr;
     *     RECTL rclBox;
     *     SIZEL szlCorner;
     * } *PEMRROUNDRECT
     * }
     */
    public static final AddressLayout PEMRROUNDRECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRARC
     * }
     */
    public static final AddressLayout PEMRARC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRARCTO
     * }
     */
    public static final AddressLayout PEMRARCTO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRCHORD
     * }
     */
    public static final AddressLayout PEMRCHORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRPIE
     * }
     */
    public static final AddressLayout PEMRPIE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRANGLEARC {
     *     EMR emr;
     *     POINTL ptlCenter;
     *     DWORD nRadius;
     *     FLOAT eStartAngle;
     *     FLOAT eSweepAngle;
     * } *PEMRANGLEARC
     * }
     */
    public static final AddressLayout PEMRANGLEARC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYLINE
     * }
     */
    public static final AddressLayout PEMRPOLYLINE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYBEZIER
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYGON
     * }
     */
    public static final AddressLayout PEMRPOLYGON = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYBEZIERTO
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIERTO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYLINETO
     * }
     */
    public static final AddressLayout PEMRPOLYLINETO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYLINE16
     * }
     */
    public static final AddressLayout PEMRPOLYLINE16 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYBEZIER16
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIER16 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYGON16
     * }
     */
    public static final AddressLayout PEMRPOLYGON16 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYBEZIERTO16
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIERTO16 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYLINETO16
     * }
     */
    public static final AddressLayout PEMRPOLYLINETO16 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYDRAW {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     *     BYTE abTypes[1];
     * } *PEMRPOLYDRAW
     * }
     */
    public static final AddressLayout PEMRPOLYDRAW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYDRAW16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     *     BYTE abTypes[1];
     * } *PEMRPOLYDRAW16
     * }
     */
    public static final AddressLayout PEMRPOLYDRAW16 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cptl;
     *     DWORD aPolyCounts[1];
     *     POINTL aptl[1];
     * } *PEMRPOLYPOLYLINE
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYLINE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cptl;
     *     DWORD aPolyCounts[1];
     *     POINTL aptl[1];
     * } *PEMRPOLYPOLYGON
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYGON = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cpts;
     *     DWORD aPolyCounts[1];
     *     POINTS apts[1];
     * } *PEMRPOLYPOLYLINE16
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYLINE16 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cpts;
     *     DWORD aPolyCounts[1];
     *     POINTS apts[1];
     * } *PEMRPOLYPOLYGON16
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYGON16 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRINVERTRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     BYTE RgnData[1];
     * } *PEMRINVERTRGN
     * }
     */
    public static final AddressLayout PEMRINVERTRGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRINVERTRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     BYTE RgnData[1];
     * } *PEMRPAINTRGN
     * }
     */
    public static final AddressLayout PEMRPAINTRGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     DWORD ihBrush;
     *     BYTE RgnData[1];
     * } *PEMRFILLRGN
     * }
     */
    public static final AddressLayout PEMRFILLRGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFRAMERGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     DWORD ihBrush;
     *     SIZEL szlStroke;
     *     BYTE RgnData[1];
     * } *PEMRFRAMERGN
     * }
     */
    public static final AddressLayout PEMRFRAMERGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTSELECTCLIPRGN {
     *     EMR emr;
     *     DWORD cbRgnData;
     *     DWORD iMode;
     *     BYTE RgnData[1];
     * } *PEMREXTSELECTCLIPRGN
     * }
     */
    public static final AddressLayout PEMREXTSELECTCLIPRGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     EMRTEXT emrtext;
     * } *PEMREXTTEXTOUTA
     * }
     */
    public static final AddressLayout PEMREXTTEXTOUTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     EMRTEXT emrtext;
     * } *PEMREXTTEXTOUTW
     * }
     */
    public static final AddressLayout PEMREXTTEXTOUTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     LONG cStrings;
     *     EMRTEXT aemrtext[1];
     * } *PEMRPOLYTEXTOUTA
     * }
     */
    public static final AddressLayout PEMRPOLYTEXTOUTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     LONG cStrings;
     *     EMRTEXT aemrtext[1];
     * } *PEMRPOLYTEXTOUTW
     * }
     */
    public static final AddressLayout PEMRPOLYTEXTOUTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRBITBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     * } *PEMRBITBLT
     * }
     */
    public static final AddressLayout PEMRBITBLT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSTRETCHBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRSTRETCHBLT
     * }
     */
    public static final AddressLayout PEMRSTRETCHBLT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRMASKBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG xMask;
     *     LONG yMask;
     *     DWORD iUsageMask;
     *     DWORD offBmiMask;
     *     DWORD cbBmiMask;
     *     DWORD offBitsMask;
     *     DWORD cbBitsMask;
     * } *PEMRMASKBLT
     * }
     */
    public static final AddressLayout PEMRMASKBLT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPLGBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     POINTL aptlDest[3];
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG xMask;
     *     LONG yMask;
     *     DWORD iUsageMask;
     *     DWORD offBmiMask;
     *     DWORD cbBmiMask;
     *     DWORD offBitsMask;
     *     DWORD cbBitsMask;
     * } *PEMRPLGBLT
     * }
     */
    public static final AddressLayout PEMRPLGBLT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETDIBITSTODEVICE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     DWORD iUsageSrc;
     *     DWORD iStartScan;
     *     DWORD cScans;
     * } *PEMRSETDIBITSTODEVICE
     * }
     */
    public static final AddressLayout PEMRSETDIBITSTODEVICE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSTRETCHDIBITS {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     DWORD iUsageSrc;
     *     DWORD dwRop;
     *     LONG cxDest;
     *     LONG cyDest;
     * } *PEMRSTRETCHDIBITS
     * }
     */
    public static final AddressLayout PEMRSTRETCHDIBITS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTCREATEFONTINDIRECTW {
     *     EMR emr;
     *     DWORD ihFont;
     *     EXTLOGFONTW elfw;
     * } *PEMREXTCREATEFONTINDIRECTW
     * }
     */
    public static final AddressLayout PEMREXTCREATEFONTINDIRECTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     *     LOGPALETTE lgpl;
     * } *PEMRCREATEPALETTE
     * }
     */
    public static final AddressLayout PEMRCREATEPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEPEN {
     *     EMR emr;
     *     DWORD ihPen;
     *     LOGPEN lopn;
     * } *PEMRCREATEPEN
     * }
     */
    public static final AddressLayout PEMRCREATEPEN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTCREATEPEN {
     *     EMR emr;
     *     DWORD ihPen;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     *     EXTLOGPEN32 elp;
     * } *PEMREXTCREATEPEN
     * }
     */
    public static final AddressLayout PEMREXTCREATEPEN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEBRUSHINDIRECT {
     *     EMR emr;
     *     DWORD ihBrush;
     *     LOGBRUSH32 lb;
     * } *PEMRCREATEBRUSHINDIRECT
     * }
     */
    public static final AddressLayout PEMRCREATEBRUSHINDIRECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEMONOBRUSH {
     *     EMR emr;
     *     DWORD ihBrush;
     *     DWORD iUsage;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     * } *PEMRCREATEMONOBRUSH
     * }
     */
    public static final AddressLayout PEMRCREATEMONOBRUSH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEDIBPATTERNBRUSHPT {
     *     EMR emr;
     *     DWORD ihBrush;
     *     DWORD iUsage;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     * } *PEMRCREATEDIBPATTERNBRUSHPT
     * }
     */
    public static final AddressLayout PEMRCREATEDIBPATTERNBRUSHPT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFORMAT {
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD cbData;
     *     DWORD offData;
     * } *PEMRFORMAT
     * }
     */
    public static final AddressLayout PEMRFORMAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGLSRECORD {
     *     EMR emr;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGLSRECORD
     * }
     */
    public static final AddressLayout PEMRGLSRECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGLSBOUNDEDRECORD {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGLSBOUNDEDRECORD
     * }
     */
    public static final AddressLayout PEMRGLSBOUNDEDRECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPIXELFORMAT {
     *     EMR emr;
     *     PIXELFORMATDESCRIPTOR pfd;
     * } *PEMRPIXELFORMAT
     * }
     */
    public static final AddressLayout PEMRPIXELFORMAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATECOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     *     LOGCOLORSPACEA lcs;
     * } *PEMRCREATECOLORSPACE
     * }
     */
    public static final AddressLayout PEMRCREATECOLORSPACE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRSETCOLORSPACE
     * }
     */
    public static final AddressLayout PEMRSETCOLORSPACE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRSELECTCOLORSPACE
     * }
     */
    public static final AddressLayout PEMRSELECTCOLORSPACE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRDELETECOLORSPACE
     * }
     */
    public static final AddressLayout PEMRDELETECOLORSPACE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMREXTESCAPE
     * }
     */
    public static final AddressLayout PEMREXTESCAPE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMRDRAWESCAPE
     * }
     */
    public static final AddressLayout PEMRDRAWESCAPE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRNAMEDESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbDriver;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMRNAMEDESCAPE
     * }
     */
    public static final AddressLayout PEMRNAMEDESCAPE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILE
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILEA
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILEW
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATECOLORSPACEW {
     *     EMR emr;
     *     DWORD ihCS;
     *     LOGCOLORSPACEW lcs;
     *     DWORD dwFlags;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRCREATECOLORSPACEW
     * }
     */
    public static final AddressLayout PEMRCREATECOLORSPACEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORMATCHTOTARGET {
     *     EMR emr;
     *     DWORD dwAction;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRCOLORMATCHTOTARGET
     * }
     */
    public static final AddressLayout PEMRCOLORMATCHTOTARGET = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORCORRECTPALETTE {
     *     EMR emr;
     *     DWORD ihPalette;
     *     DWORD nFirstEntry;
     *     DWORD nPalEntries;
     *     DWORD nReserved;
     * } *PEMRCOLORCORRECTPALETTE
     * }
     */
    public static final AddressLayout PEMRCOLORCORRECTPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRALPHABLEND {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRALPHABLEND
     * }
     */
    public static final AddressLayout PEMRALPHABLEND = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGRADIENTFILL {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nVer;
     *     DWORD nTri;
     *     ULONG ulMode;
     *     TRIVERTEX Ver[1];
     * } *PEMRGRADIENTFILL
     * }
     */
    public static final AddressLayout PEMRGRADIENTFILL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRTRANSPARENTBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRTRANSPARENTBLT
     * }
     */
    public static final AddressLayout PEMRTRANSPARENTBLT = winapi.C_POINTER;

    private static class wglCopyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglCopyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static FunctionDescriptor wglCopyContext$descriptor() {
        return wglCopyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static MethodHandle wglCopyContext$handle() {
        return wglCopyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static MemorySegment wglCopyContext$address() {
        return wglCopyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static int wglCopyContext(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wglCopyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCopyContext", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static FunctionDescriptor wglCreateContext$descriptor() {
        return wglCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MethodHandle wglCreateContext$handle() {
        return wglCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MemorySegment wglCreateContext$address() {
        return wglCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MemorySegment wglCreateContext(MemorySegment x0) {
        var mh$ = wglCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCreateContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglCreateLayerContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglCreateLayerContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static FunctionDescriptor wglCreateLayerContext$descriptor() {
        return wglCreateLayerContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MethodHandle wglCreateLayerContext$handle() {
        return wglCreateLayerContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MemorySegment wglCreateLayerContext$address() {
        return wglCreateLayerContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MemorySegment wglCreateLayerContext(MemorySegment x0, int x1) {
        var mh$ = wglCreateLayerContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCreateLayerContext", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglDeleteContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglDeleteContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static FunctionDescriptor wglDeleteContext$descriptor() {
        return wglDeleteContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static MethodHandle wglDeleteContext$handle() {
        return wglDeleteContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static MemorySegment wglDeleteContext$address() {
        return wglDeleteContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static int wglDeleteContext(MemorySegment x0) {
        var mh$ = wglDeleteContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglDeleteContext", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetCurrentContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglGetCurrentContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static FunctionDescriptor wglGetCurrentContext$descriptor() {
        return wglGetCurrentContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MethodHandle wglGetCurrentContext$handle() {
        return wglGetCurrentContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MemorySegment wglGetCurrentContext$address() {
        return wglGetCurrentContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MemorySegment wglGetCurrentContext() {
        var mh$ = wglGetCurrentContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetCurrentContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetCurrentDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglGetCurrentDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static FunctionDescriptor wglGetCurrentDC$descriptor() {
        return wglGetCurrentDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MethodHandle wglGetCurrentDC$handle() {
        return wglGetCurrentDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MemorySegment wglGetCurrentDC$address() {
        return wglGetCurrentDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MemorySegment wglGetCurrentDC() {
        var mh$ = wglGetCurrentDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetCurrentDC");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglGetProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static FunctionDescriptor wglGetProcAddress$descriptor() {
        return wglGetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MethodHandle wglGetProcAddress$handle() {
        return wglGetProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MemorySegment wglGetProcAddress$address() {
        return wglGetProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MemorySegment wglGetProcAddress(MemorySegment x0) {
        var mh$ = wglGetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetProcAddress", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglMakeCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglMakeCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static FunctionDescriptor wglMakeCurrent$descriptor() {
        return wglMakeCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static MethodHandle wglMakeCurrent$handle() {
        return wglMakeCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static MemorySegment wglMakeCurrent$address() {
        return wglMakeCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static int wglMakeCurrent(MemorySegment x0, MemorySegment x1) {
        var mh$ = wglMakeCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglMakeCurrent", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglShareLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglShareLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static FunctionDescriptor wglShareLists$descriptor() {
        return wglShareLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static MethodHandle wglShareLists$handle() {
        return wglShareLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static MemorySegment wglShareLists$address() {
        return wglShareLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static int wglShareLists(MemorySegment x0, MemorySegment x1) {
        var mh$ = wglShareLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglShareLists", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontBitmapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglUseFontBitmapsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor wglUseFontBitmapsA$descriptor() {
        return wglUseFontBitmapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MethodHandle wglUseFontBitmapsA$handle() {
        return wglUseFontBitmapsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MemorySegment wglUseFontBitmapsA$address() {
        return wglUseFontBitmapsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static int wglUseFontBitmapsA(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = wglUseFontBitmapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontBitmapsA", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontBitmapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglUseFontBitmapsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor wglUseFontBitmapsW$descriptor() {
        return wglUseFontBitmapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MethodHandle wglUseFontBitmapsW$handle() {
        return wglUseFontBitmapsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MemorySegment wglUseFontBitmapsW$address() {
        return wglUseFontBitmapsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static int wglUseFontBitmapsW(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = wglUseFontBitmapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontBitmapsW", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwapBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SwapBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static FunctionDescriptor SwapBuffers$descriptor() {
        return SwapBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static MethodHandle SwapBuffers$handle() {
        return SwapBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static MemorySegment SwapBuffers$address() {
        return SwapBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static int SwapBuffers(MemorySegment x0) {
        var mh$ = SwapBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwapBuffers", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _POINTFLOAT {
     *     FLOAT x;
     *     FLOAT y;
     * } *PPOINTFLOAT
     * }
     */
    public static final AddressLayout PPOINTFLOAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICSFLOAT {
     *     FLOAT gmfBlackBoxX;
     *     FLOAT gmfBlackBoxY;
     *     POINTFLOAT gmfptGlyphOrigin;
     *     FLOAT gmfCellIncX;
     *     FLOAT gmfCellIncY;
     * } *PGLYPHMETRICSFLOAT
     * }
     */
    public static final AddressLayout PGLYPHMETRICSFLOAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICSFLOAT {
     *     FLOAT gmfBlackBoxX;
     *     FLOAT gmfBlackBoxY;
     *     POINTFLOAT gmfptGlyphOrigin;
     *     FLOAT gmfCellIncX;
     *     FLOAT gmfCellIncY;
     * } *LPGLYPHMETRICSFLOAT
     * }
     */
    public static final AddressLayout LPGLYPHMETRICSFLOAT = winapi.C_POINTER;

    private static class wglUseFontOutlinesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_FLOAT,
            winapi.C_FLOAT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglUseFontOutlinesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static FunctionDescriptor wglUseFontOutlinesA$descriptor() {
        return wglUseFontOutlinesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MethodHandle wglUseFontOutlinesA$handle() {
        return wglUseFontOutlinesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MemorySegment wglUseFontOutlinesA$address() {
        return wglUseFontOutlinesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static int wglUseFontOutlinesA(MemorySegment x0, int x1, int x2, int x3, float x4, float x5, int x6, MemorySegment x7) {
        var mh$ = wglUseFontOutlinesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontOutlinesA", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontOutlinesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_FLOAT,
            winapi.C_FLOAT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglUseFontOutlinesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static FunctionDescriptor wglUseFontOutlinesW$descriptor() {
        return wglUseFontOutlinesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MethodHandle wglUseFontOutlinesW$handle() {
        return wglUseFontOutlinesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MemorySegment wglUseFontOutlinesW$address() {
        return wglUseFontOutlinesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static int wglUseFontOutlinesW(MemorySegment x0, int x1, int x2, int x3, float x4, float x5, int x6, MemorySegment x7) {
        var mh$ = wglUseFontOutlinesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontOutlinesW", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagLAYERPLANEDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerPlane;
     *     BYTE bReserved;
     *     COLORREF crTransparent;
     * } *PLAYERPLANEDESCRIPTOR
     * }
     */
    public static final AddressLayout PLAYERPLANEDESCRIPTOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLAYERPLANEDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerPlane;
     *     BYTE bReserved;
     *     COLORREF crTransparent;
     * } *LPLAYERPLANEDESCRIPTOR
     * }
     */
    public static final AddressLayout LPLAYERPLANEDESCRIPTOR = winapi.C_POINTER;

    private static class wglDescribeLayerPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglDescribeLayerPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static FunctionDescriptor wglDescribeLayerPlane$descriptor() {
        return wglDescribeLayerPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static MethodHandle wglDescribeLayerPlane$handle() {
        return wglDescribeLayerPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static MemorySegment wglDescribeLayerPlane$address() {
        return wglDescribeLayerPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static int wglDescribeLayerPlane(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglDescribeLayerPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglDescribeLayerPlane", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglSetLayerPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglSetLayerPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static FunctionDescriptor wglSetLayerPaletteEntries$descriptor() {
        return wglSetLayerPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static MethodHandle wglSetLayerPaletteEntries$handle() {
        return wglSetLayerPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static MemorySegment wglSetLayerPaletteEntries$address() {
        return wglSetLayerPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static int wglSetLayerPaletteEntries(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglSetLayerPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSetLayerPaletteEntries", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetLayerPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglGetLayerPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static FunctionDescriptor wglGetLayerPaletteEntries$descriptor() {
        return wglGetLayerPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static MethodHandle wglGetLayerPaletteEntries$handle() {
        return wglGetLayerPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static MemorySegment wglGetLayerPaletteEntries$address() {
        return wglGetLayerPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static int wglGetLayerPaletteEntries(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglGetLayerPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetLayerPaletteEntries", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglRealizeLayerPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglRealizeLayerPalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static FunctionDescriptor wglRealizeLayerPalette$descriptor() {
        return wglRealizeLayerPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static MethodHandle wglRealizeLayerPalette$handle() {
        return wglRealizeLayerPalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static MemorySegment wglRealizeLayerPalette$address() {
        return wglRealizeLayerPalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static int wglRealizeLayerPalette(MemorySegment x0, int x1, int x2) {
        var mh$ = wglRealizeLayerPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglRealizeLayerPalette", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglSwapLayerBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglSwapLayerBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static FunctionDescriptor wglSwapLayerBuffers$descriptor() {
        return wglSwapLayerBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static MethodHandle wglSwapLayerBuffers$handle() {
        return wglSwapLayerBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static MemorySegment wglSwapLayerBuffers$address() {
        return wglSwapLayerBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static int wglSwapLayerBuffers(MemorySegment x0, int x1) {
        var mh$ = wglSwapLayerBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSwapLayerBuffers", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WGLSWAP {
     *     HDC hdc;
     *     UINT uiFlags;
     * } *PWGLSWAP
     * }
     */
    public static final AddressLayout PWGLSWAP = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WGLSWAP {
     *     HDC hdc;
     *     UINT uiFlags;
     * } *LPWGLSWAP
     * }
     */
    public static final AddressLayout LPWGLSWAP = winapi.C_POINTER;

    private static class wglSwapMultipleBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wglSwapMultipleBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static FunctionDescriptor wglSwapMultipleBuffers$descriptor() {
        return wglSwapMultipleBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static MethodHandle wglSwapMultipleBuffers$handle() {
        return wglSwapMultipleBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static MemorySegment wglSwapMultipleBuffers$address() {
        return wglSwapMultipleBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static int wglSwapMultipleBuffers(int x0, MemorySegment x1) {
        var mh$ = wglSwapMultipleBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSwapMultipleBuffers", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef HANDLE HDWP
     * }
     */
    public static final AddressLayout HDWP = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID LPMENUTEMPLATEA
     * }
     */
    public static final AddressLayout LPMENUTEMPLATEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID LPMENUTEMPLATEW
     * }
     */
    public static final AddressLayout LPMENUTEMPLATEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMENUTEMPLATEA LPMENUTEMPLATE
     * }
     */
    public static final AddressLayout LPMENUTEMPLATE = winapi.C_POINTER;

    private static class wvsprintfA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wvsprintfA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static FunctionDescriptor wvsprintfA$descriptor() {
        return wvsprintfA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static MethodHandle wvsprintfA$handle() {
        return wvsprintfA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static MemorySegment wvsprintfA$address() {
        return wvsprintfA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static int wvsprintfA(MemorySegment x0, MemorySegment x1, MemorySegment arglist) {
        var mh$ = wvsprintfA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wvsprintfA", x0, x1, arglist);
            }
            return (int)mh$.invokeExact(x0, x1, arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wvsprintfW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("wvsprintfW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static FunctionDescriptor wvsprintfW$descriptor() {
        return wvsprintfW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static MethodHandle wvsprintfW$handle() {
        return wvsprintfW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static MemorySegment wvsprintfW$address() {
        return wvsprintfW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static int wvsprintfW(MemorySegment x0, MemorySegment x1, MemorySegment arglist) {
        var mh$ = wvsprintfW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wvsprintfW", x0, x1, arglist);
            }
            return (int)mh$.invokeExact(x0, x1, arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wsprintfA(LPSTR, LPCSTR, ...)
     * }
     */
    public static class wsprintfA {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                winapi.C_INT,
                winapi.C_POINTER,
                winapi.C_POINTER
            );
        private static final MemorySegment ADDR = winapi.findOrThrow("wsprintfA");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wsprintfA(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wsprintfA(LPSTR, LPCSTR, ...)
         * }
         */
        public static wsprintfA makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wsprintfA(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wsprintfA", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wsprintfW(LPWSTR, LPCWSTR, ...)
     * }
     */
    public static class wsprintfW {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                winapi.C_INT,
                winapi.C_POINTER,
                winapi.C_POINTER
            );
        private static final MemorySegment ADDR = winapi.findOrThrow("wsprintfW");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wsprintfW(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wsprintfW(LPWSTR, LPCWSTR, ...)
         * }
         */
        public static wsprintfW makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wsprintfW(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wsprintfW", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCBT_CREATEWNDA {
     *     struct tagCREATESTRUCTA *lpcs;
     *     HWND hwndInsertAfter;
     * } *LPCBT_CREATEWNDA
     * }
     */
    public static final AddressLayout LPCBT_CREATEWNDA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCBT_CREATEWNDW {
     *     struct tagCREATESTRUCTW *lpcs;
     *     HWND hwndInsertAfter;
     * } *LPCBT_CREATEWNDW
     * }
     */
    public static final AddressLayout LPCBT_CREATEWNDW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCBT_CREATEWNDA LPCBT_CREATEWND
     * }
     */
    public static final AddressLayout LPCBT_CREATEWND = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCBTACTIVATESTRUCT {
     *     BOOL fMouse;
     *     HWND hWndActive;
     * } *LPCBTACTIVATESTRUCT
     * }
     */
    public static final AddressLayout LPCBTACTIVATESTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWTSSESSION_NOTIFICATION {
     *     DWORD cbSize;
     *     DWORD dwSessionId;
     * } *PWTSSESSION_NOTIFICATION
     * }
     */
    public static final AddressLayout PWTSSESSION_NOTIFICATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     HWND hwnd;
     *     RECT rc;
     * } *LPSHELLHOOKINFO
     * }
     */
    public static final AddressLayout LPSHELLHOOKINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *PEVENTMSGMSG
     * }
     */
    public static final AddressLayout PEVENTMSGMSG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *NPEVENTMSGMSG
     * }
     */
    public static final AddressLayout NPEVENTMSGMSG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *LPEVENTMSGMSG
     * }
     */
    public static final AddressLayout LPEVENTMSGMSG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *PEVENTMSG
     * }
     */
    public static final AddressLayout PEVENTMSG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *NPEVENTMSG
     * }
     */
    public static final AddressLayout NPEVENTMSG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *LPEVENTMSG
     * }
     */
    public static final AddressLayout LPEVENTMSG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *PCWPSTRUCT
     * }
     */
    public static final AddressLayout PCWPSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *NPCWPSTRUCT
     * }
     */
    public static final AddressLayout NPCWPSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *LPCWPSTRUCT
     * }
     */
    public static final AddressLayout LPCWPSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *PCWPRETSTRUCT
     * }
     */
    public static final AddressLayout PCWPRETSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *NPCWPRETSTRUCT
     * }
     */
    public static final AddressLayout NPCWPRETSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *LPCWPRETSTRUCT
     * }
     */
    public static final AddressLayout LPCWPRETSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKBDLLHOOKSTRUCT {
     *     DWORD vkCode;
     *     DWORD scanCode;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPKBDLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPKBDLLHOOKSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKBDLLHOOKSTRUCT {
     *     DWORD vkCode;
     *     DWORD scanCode;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PKBDLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout PKBDLLHOOKSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSLLHOOKSTRUCT {
     *     POINT pt;
     *     DWORD mouseData;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMSLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPMSLLHOOKSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSLLHOOKSTRUCT {
     *     POINT pt;
     *     DWORD mouseData;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMSLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout PMSLLHOOKSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *PDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout PDEBUGHOOKINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *NPDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout NPDEBUGHOOKINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *LPDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout LPDEBUGHOOKINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCT {
     *     POINT pt;
     *     HWND hwnd;
     *     UINT wHitTestCode;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPMOUSEHOOKSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCT {
     *     POINT pt;
     *     HWND hwnd;
     *     UINT wHitTestCode;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEHOOKSTRUCT
     * }
     */
    public static final AddressLayout PMOUSEHOOKSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCTEX {
     *     DWORD mouseData;
     * } *LPMOUSEHOOKSTRUCTEX
     * }
     */
    public static final AddressLayout LPMOUSEHOOKSTRUCTEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCTEX {
     *     DWORD mouseData;
     * } *PMOUSEHOOKSTRUCTEX
     * }
     */
    public static final AddressLayout PMOUSEHOOKSTRUCTEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREHOOKSTRUCT {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     * } *LPHARDWAREHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPHARDWAREHOOKSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREHOOKSTRUCT {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     * } *PHARDWAREHOOKSTRUCT
     * }
     */
    public static final AddressLayout PHARDWAREHOOKSTRUCT = winapi.C_POINTER;

    private static class LoadKeyboardLayoutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LoadKeyboardLayoutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static FunctionDescriptor LoadKeyboardLayoutA$descriptor() {
        return LoadKeyboardLayoutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MethodHandle LoadKeyboardLayoutA$handle() {
        return LoadKeyboardLayoutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutA$address() {
        return LoadKeyboardLayoutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutA(MemorySegment pwszKLID, int Flags) {
        var mh$ = LoadKeyboardLayoutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadKeyboardLayoutA", pwszKLID, Flags);
            }
            return (MemorySegment)mh$.invokeExact(pwszKLID, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadKeyboardLayoutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LoadKeyboardLayoutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static FunctionDescriptor LoadKeyboardLayoutW$descriptor() {
        return LoadKeyboardLayoutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MethodHandle LoadKeyboardLayoutW$handle() {
        return LoadKeyboardLayoutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutW$address() {
        return LoadKeyboardLayoutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutW(MemorySegment pwszKLID, int Flags) {
        var mh$ = LoadKeyboardLayoutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadKeyboardLayoutW", pwszKLID, Flags);
            }
            return (MemorySegment)mh$.invokeExact(pwszKLID, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ActivateKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ActivateKeyboardLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static FunctionDescriptor ActivateKeyboardLayout$descriptor() {
        return ActivateKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MethodHandle ActivateKeyboardLayout$handle() {
        return ActivateKeyboardLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MemorySegment ActivateKeyboardLayout$address() {
        return ActivateKeyboardLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MemorySegment ActivateKeyboardLayout(MemorySegment hkl, int Flags) {
        var mh$ = ActivateKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ActivateKeyboardLayout", hkl, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hkl, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToUnicodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ToUnicodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor ToUnicodeEx$descriptor() {
        return ToUnicodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static MethodHandle ToUnicodeEx$handle() {
        return ToUnicodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static MemorySegment ToUnicodeEx$address() {
        return ToUnicodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static int ToUnicodeEx(int wVirtKey, int wScanCode, MemorySegment lpKeyState, MemorySegment pwszBuff, int cchBuff, int wFlags, MemorySegment dwhkl) {
        var mh$ = ToUnicodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToUnicodeEx", wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags, dwhkl);
            }
            return (int)mh$.invokeExact(wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("UnloadKeyboardLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static FunctionDescriptor UnloadKeyboardLayout$descriptor() {
        return UnloadKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static MethodHandle UnloadKeyboardLayout$handle() {
        return UnloadKeyboardLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static MemorySegment UnloadKeyboardLayout$address() {
        return UnloadKeyboardLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static int UnloadKeyboardLayout(MemorySegment hkl) {
        var mh$ = UnloadKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadKeyboardLayout", hkl);
            }
            return (int)mh$.invokeExact(hkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetKeyboardLayoutNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutNameA$descriptor() {
        return GetKeyboardLayoutNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static MethodHandle GetKeyboardLayoutNameA$handle() {
        return GetKeyboardLayoutNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static MemorySegment GetKeyboardLayoutNameA$address() {
        return GetKeyboardLayoutNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static int GetKeyboardLayoutNameA(MemorySegment pwszKLID) {
        var mh$ = GetKeyboardLayoutNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutNameA", pwszKLID);
            }
            return (int)mh$.invokeExact(pwszKLID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetKeyboardLayoutNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutNameW$descriptor() {
        return GetKeyboardLayoutNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static MethodHandle GetKeyboardLayoutNameW$handle() {
        return GetKeyboardLayoutNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static MemorySegment GetKeyboardLayoutNameW$address() {
        return GetKeyboardLayoutNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static int GetKeyboardLayoutNameW(MemorySegment pwszKLID) {
        var mh$ = GetKeyboardLayoutNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutNameW", pwszKLID);
            }
            return (int)mh$.invokeExact(pwszKLID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetKeyboardLayoutList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutList$descriptor() {
        return GetKeyboardLayoutList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static MethodHandle GetKeyboardLayoutList$handle() {
        return GetKeyboardLayoutList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static MemorySegment GetKeyboardLayoutList$address() {
        return GetKeyboardLayoutList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static int GetKeyboardLayoutList(int nBuff, MemorySegment lpList) {
        var mh$ = GetKeyboardLayoutList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutList", nBuff, lpList);
            }
            return (int)mh$.invokeExact(nBuff, lpList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetKeyboardLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayout$descriptor() {
        return GetKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MethodHandle GetKeyboardLayout$handle() {
        return GetKeyboardLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MemorySegment GetKeyboardLayout$address() {
        return GetKeyboardLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MemorySegment GetKeyboardLayout(int idThread) {
        var mh$ = GetKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayout", idThread);
            }
            return (MemorySegment)mh$.invokeExact(idThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEMOVEPOINT {
     *     int x;
     *     int y;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEMOVEPOINT
     * }
     */
    public static final AddressLayout PMOUSEMOVEPOINT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEMOVEPOINT {
     *     int x;
     *     int y;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEMOVEPOINT
     * }
     */
    public static final AddressLayout LPMOUSEMOVEPOINT = winapi.C_POINTER;

    private static class GetMouseMovePointsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetMouseMovePointsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static FunctionDescriptor GetMouseMovePointsEx$descriptor() {
        return GetMouseMovePointsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static MethodHandle GetMouseMovePointsEx$handle() {
        return GetMouseMovePointsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static MemorySegment GetMouseMovePointsEx$address() {
        return GetMouseMovePointsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static int GetMouseMovePointsEx(int cbSize, MemorySegment lppt, MemorySegment lpptBuf, int nBufPoints, int resolution) {
        var mh$ = GetMouseMovePointsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseMovePointsEx", cbSize, lppt, lpptBuf, nBufPoints, resolution);
            }
            return (int)mh$.invokeExact(cbSize, lppt, lpptBuf, nBufPoints, resolution);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDesktopA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateDesktopA$descriptor() {
        return CreateDesktopA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateDesktopA$handle() {
        return CreateDesktopA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopA$address() {
        return CreateDesktopA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopA(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateDesktopA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopA", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDesktopW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateDesktopW$descriptor() {
        return CreateDesktopW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateDesktopW$handle() {
        return CreateDesktopW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopW$address() {
        return CreateDesktopW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopW(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateDesktopW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopW", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDesktopExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static FunctionDescriptor CreateDesktopExA$descriptor() {
        return CreateDesktopExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MethodHandle CreateDesktopExA$handle() {
        return CreateDesktopExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExA$address() {
        return CreateDesktopExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExA(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa, int ulHeapSize, MemorySegment pvoid) {
        var mh$ = CreateDesktopExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopExA", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDesktopExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static FunctionDescriptor CreateDesktopExW$descriptor() {
        return CreateDesktopExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MethodHandle CreateDesktopExW$handle() {
        return CreateDesktopExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExW$address() {
        return CreateDesktopExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExW(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa, int ulHeapSize, MemorySegment pvoid) {
        var mh$ = CreateDesktopExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopExW", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenDesktopA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenDesktopA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenDesktopA$descriptor() {
        return OpenDesktopA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenDesktopA$handle() {
        return OpenDesktopA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopA$address() {
        return OpenDesktopA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopA(MemorySegment lpszDesktop, int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenDesktopA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDesktopA", lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenDesktopW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenDesktopW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenDesktopW$descriptor() {
        return OpenDesktopW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenDesktopW$handle() {
        return OpenDesktopW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopW$address() {
        return OpenDesktopW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopW(MemorySegment lpszDesktop, int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenDesktopW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDesktopW", lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenInputDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenInputDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenInputDesktop$descriptor() {
        return OpenInputDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenInputDesktop$handle() {
        return OpenInputDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenInputDesktop$address() {
        return OpenInputDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenInputDesktop(int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenInputDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenInputDesktop", dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumDesktopsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopsA$descriptor() {
        return EnumDesktopsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopsA$handle() {
        return EnumDesktopsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDesktopsA$address() {
        return EnumDesktopsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumDesktopsA(MemorySegment hwinsta, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumDesktopsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopsA", hwinsta, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hwinsta, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumDesktopsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopsW$descriptor() {
        return EnumDesktopsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopsW$handle() {
        return EnumDesktopsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDesktopsW$address() {
        return EnumDesktopsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumDesktopsW(MemorySegment hwinsta, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumDesktopsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopsW", hwinsta, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hwinsta, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumDesktopWindows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopWindows$descriptor() {
        return EnumDesktopWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopWindows$handle() {
        return EnumDesktopWindows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDesktopWindows$address() {
        return EnumDesktopWindows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static int EnumDesktopWindows(MemorySegment hDesktop, MemorySegment lpfn, long lParam) {
        var mh$ = EnumDesktopWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopWindows", hDesktop, lpfn, lParam);
            }
            return (int)mh$.invokeExact(hDesktop, lpfn, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SwitchDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor SwitchDesktop$descriptor() {
        return SwitchDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle SwitchDesktop$handle() {
        return SwitchDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static MemorySegment SwitchDesktop$address() {
        return SwitchDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static int SwitchDesktop(MemorySegment hDesktop) {
        var mh$ = SwitchDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetThreadDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor SetThreadDesktop$descriptor() {
        return SetThreadDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle SetThreadDesktop$handle() {
        return SetThreadDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static MemorySegment SetThreadDesktop$address() {
        return SetThreadDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static int SetThreadDesktop(MemorySegment hDesktop) {
        var mh$ = SetThreadDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CloseDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor CloseDesktop$descriptor() {
        return CloseDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle CloseDesktop$handle() {
        return CloseDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static MemorySegment CloseDesktop$address() {
        return CloseDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static int CloseDesktop(MemorySegment hDesktop) {
        var mh$ = CloseDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetThreadDesktop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor GetThreadDesktop$descriptor() {
        return GetThreadDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MethodHandle GetThreadDesktop$handle() {
        return GetThreadDesktop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MemorySegment GetThreadDesktop$address() {
        return GetThreadDesktop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MemorySegment GetThreadDesktop(int dwThreadId) {
        var mh$ = GetThreadDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDesktop", dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowStationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateWindowStationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateWindowStationA$descriptor() {
        return CreateWindowStationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateWindowStationA$handle() {
        return CreateWindowStationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationA$address() {
        return CreateWindowStationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationA(MemorySegment lpwinsta, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateWindowStationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowStationA", lpwinsta, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpwinsta, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowStationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateWindowStationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateWindowStationW$descriptor() {
        return CreateWindowStationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateWindowStationW$handle() {
        return CreateWindowStationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationW$address() {
        return CreateWindowStationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationW(MemorySegment lpwinsta, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateWindowStationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowStationW", lpwinsta, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpwinsta, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWindowStationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenWindowStationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenWindowStationA$descriptor() {
        return OpenWindowStationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenWindowStationA$handle() {
        return OpenWindowStationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationA$address() {
        return OpenWindowStationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationA(MemorySegment lpszWinSta, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenWindowStationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWindowStationA", lpszWinSta, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszWinSta, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWindowStationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenWindowStationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenWindowStationW$descriptor() {
        return OpenWindowStationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenWindowStationW$handle() {
        return OpenWindowStationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationW$address() {
        return OpenWindowStationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationW(MemorySegment lpszWinSta, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenWindowStationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWindowStationW", lpszWinSta, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszWinSta, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindowStationsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumWindowStationsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindowStationsA$descriptor() {
        return EnumWindowStationsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindowStationsA$handle() {
        return EnumWindowStationsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumWindowStationsA$address() {
        return EnumWindowStationsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindowStationsA(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindowStationsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindowStationsA", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindowStationsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumWindowStationsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindowStationsW$descriptor() {
        return EnumWindowStationsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindowStationsW$handle() {
        return EnumWindowStationsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumWindowStationsW$address() {
        return EnumWindowStationsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindowStationsW(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindowStationsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindowStationsW", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CloseWindowStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static FunctionDescriptor CloseWindowStation$descriptor() {
        return CloseWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MethodHandle CloseWindowStation$handle() {
        return CloseWindowStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MemorySegment CloseWindowStation$address() {
        return CloseWindowStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static int CloseWindowStation(MemorySegment hWinSta) {
        var mh$ = CloseWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseWindowStation", hWinSta);
            }
            return (int)mh$.invokeExact(hWinSta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetProcessWindowStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static FunctionDescriptor SetProcessWindowStation$descriptor() {
        return SetProcessWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MethodHandle SetProcessWindowStation$handle() {
        return SetProcessWindowStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MemorySegment SetProcessWindowStation$address() {
        return SetProcessWindowStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static int SetProcessWindowStation(MemorySegment hWinSta) {
        var mh$ = SetProcessWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWindowStation", hWinSta);
            }
            return (int)mh$.invokeExact(hWinSta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetProcessWindowStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static FunctionDescriptor GetProcessWindowStation$descriptor() {
        return GetProcessWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MethodHandle GetProcessWindowStation$handle() {
        return GetProcessWindowStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MemorySegment GetProcessWindowStation$address() {
        return GetProcessWindowStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MemorySegment GetProcessWindowStation() {
        var mh$ = GetProcessWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWindowStation");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetUserObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static FunctionDescriptor SetUserObjectSecurity$descriptor() {
        return SetUserObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static MethodHandle SetUserObjectSecurity$handle() {
        return SetUserObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static MemorySegment SetUserObjectSecurity$address() {
        return SetUserObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static int SetUserObjectSecurity(MemorySegment hObj, MemorySegment pSIRequested, MemorySegment pSID) {
        var mh$ = SetUserObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectSecurity", hObj, pSIRequested, pSID);
            }
            return (int)mh$.invokeExact(hObj, pSIRequested, pSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectSecurity$descriptor() {
        return GetUserObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectSecurity$handle() {
        return GetUserObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetUserObjectSecurity$address() {
        return GetUserObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectSecurity(MemorySegment hObj, MemorySegment pSIRequested, MemorySegment pSID, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectSecurity", hObj, pSIRequested, pSID, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, pSIRequested, pSID, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUSEROBJECTFLAGS {
     *     BOOL fInherit;
     *     BOOL fReserved;
     *     DWORD dwFlags;
     * } *PUSEROBJECTFLAGS
     * }
     */
    public static final AddressLayout PUSEROBJECTFLAGS = winapi.C_POINTER;

    private static class GetUserObjectInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserObjectInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectInformationA$descriptor() {
        return GetUserObjectInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectInformationA$handle() {
        return GetUserObjectInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetUserObjectInformationA$address() {
        return GetUserObjectInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectInformationA(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectInformationA", hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserObjectInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserObjectInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectInformationW$descriptor() {
        return GetUserObjectInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectInformationW$handle() {
        return GetUserObjectInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetUserObjectInformationW$address() {
        return GetUserObjectInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectInformationW(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectInformationW", hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetUserObjectInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static FunctionDescriptor SetUserObjectInformationA$descriptor() {
        return SetUserObjectInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MethodHandle SetUserObjectInformationA$handle() {
        return SetUserObjectInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MemorySegment SetUserObjectInformationA$address() {
        return SetUserObjectInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static int SetUserObjectInformationA(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength) {
        var mh$ = SetUserObjectInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectInformationA", hObj, nIndex, pvInfo, nLength);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

