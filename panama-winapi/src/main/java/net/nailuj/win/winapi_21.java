// Generated by jextract

package net.nailuj.win;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class winapi_21 extends winapi_22 {

    winapi_21() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef LPCPINFOEXA LPCPINFOEX
     * }
     */
    public static final AddressLayout LPCPINFOEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _numberfmtA {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPSTR lpDecimalSep;
     *     LPSTR lpThousandSep;
     *     UINT NegativeOrder;
     * } *LPNUMBERFMTA
     * }
     */
    public static final AddressLayout LPNUMBERFMTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _numberfmtW {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPWSTR lpDecimalSep;
     *     LPWSTR lpThousandSep;
     *     UINT NegativeOrder;
     * } *LPNUMBERFMTW
     * }
     */
    public static final AddressLayout LPNUMBERFMTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNUMBERFMTA LPNUMBERFMT
     * }
     */
    public static final AddressLayout LPNUMBERFMT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _currencyfmtA {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPSTR lpDecimalSep;
     *     LPSTR lpThousandSep;
     *     UINT NegativeOrder;
     *     UINT PositiveOrder;
     *     LPSTR lpCurrencySymbol;
     * } *LPCURRENCYFMTA
     * }
     */
    public static final AddressLayout LPCURRENCYFMTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _currencyfmtW {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPWSTR lpDecimalSep;
     *     LPWSTR lpThousandSep;
     *     UINT NegativeOrder;
     *     UINT PositiveOrder;
     *     LPWSTR lpCurrencySymbol;
     * } *LPCURRENCYFMTW
     * }
     */
    public static final AddressLayout LPCURRENCYFMTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCURRENCYFMTA LPCURRENCYFMT
     * }
     */
    public static final AddressLayout LPCURRENCYFMT = winapi.C_POINTER;
    private static final int COMPARE_STRING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SYSNLS_FUNCTION.COMPARE_STRING = 1
     * }
     */
    public static int COMPARE_STRING() {
        return COMPARE_STRING;
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD NLS_FUNCTION
     * }
     */
    public static final OfInt NLS_FUNCTION = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _nlsversioninfo {
     *     DWORD dwNLSVersionInfoSize;
     *     DWORD dwNLSVersion;
     *     DWORD dwDefinedVersion;
     *     DWORD dwEffectiveId;
     *     GUID guidCustomVersion;
     * } *LPNLSVERSIONINFO
     * }
     */
    public static final AddressLayout LPNLSVERSIONINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _nlsversioninfoex {
     *     DWORD dwNLSVersionInfoSize;
     *     DWORD dwNLSVersion;
     *     DWORD dwDefinedVersion;
     *     DWORD dwEffectiveId;
     *     GUID guidCustomVersion;
     * } *LPNLSVERSIONINFOEX
     * }
     */
    public static final AddressLayout LPNLSVERSIONINFOEX = winapi.C_POINTER;
    private static final int GEO_NATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_NATION = 1
     * }
     */
    public static int GEO_NATION() {
        return GEO_NATION;
    }
    private static final int GEO_LATITUDE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_LATITUDE = 2
     * }
     */
    public static int GEO_LATITUDE() {
        return GEO_LATITUDE;
    }
    private static final int GEO_LONGITUDE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_LONGITUDE = 3
     * }
     */
    public static int GEO_LONGITUDE() {
        return GEO_LONGITUDE;
    }
    private static final int GEO_ISO2 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ISO2 = 4
     * }
     */
    public static int GEO_ISO2() {
        return GEO_ISO2;
    }
    private static final int GEO_ISO3 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ISO3 = 5
     * }
     */
    public static int GEO_ISO3() {
        return GEO_ISO3;
    }
    private static final int GEO_RFC1766 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_RFC1766 = 6
     * }
     */
    public static int GEO_RFC1766() {
        return GEO_RFC1766;
    }
    private static final int GEO_LCID = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_LCID = 7
     * }
     */
    public static int GEO_LCID() {
        return GEO_LCID;
    }
    private static final int GEO_FRIENDLYNAME = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_FRIENDLYNAME = 8
     * }
     */
    public static int GEO_FRIENDLYNAME() {
        return GEO_FRIENDLYNAME;
    }
    private static final int GEO_OFFICIALNAME = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_OFFICIALNAME = 9
     * }
     */
    public static int GEO_OFFICIALNAME() {
        return GEO_OFFICIALNAME;
    }
    private static final int GEO_TIMEZONES = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_TIMEZONES = 10
     * }
     */
    public static int GEO_TIMEZONES() {
        return GEO_TIMEZONES;
    }
    private static final int GEO_OFFICIALLANGUAGES = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_OFFICIALLANGUAGES = 11
     * }
     */
    public static int GEO_OFFICIALLANGUAGES() {
        return GEO_OFFICIALLANGUAGES;
    }
    private static final int GEO_ISO_UN_NUMBER = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ISO_UN_NUMBER = 12
     * }
     */
    public static int GEO_ISO_UN_NUMBER() {
        return GEO_ISO_UN_NUMBER;
    }
    private static final int GEO_PARENT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_PARENT = 13
     * }
     */
    public static int GEO_PARENT() {
        return GEO_PARENT;
    }
    private static final int GEO_DIALINGCODE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_DIALINGCODE = 14
     * }
     */
    public static int GEO_DIALINGCODE() {
        return GEO_DIALINGCODE;
    }
    private static final int GEO_CURRENCYCODE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_CURRENCYCODE = 15
     * }
     */
    public static int GEO_CURRENCYCODE() {
        return GEO_CURRENCYCODE;
    }
    private static final int GEO_CURRENCYSYMBOL = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_CURRENCYSYMBOL = 16
     * }
     */
    public static int GEO_CURRENCYSYMBOL() {
        return GEO_CURRENCYSYMBOL;
    }
    private static final int GEO_NAME = (int)17L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_NAME = 17
     * }
     */
    public static int GEO_NAME() {
        return GEO_NAME;
    }
    private static final int GEO_ID = (int)18L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ID = 18
     * }
     */
    public static int GEO_ID() {
        return GEO_ID;
    }
    private static final int GEOCLASS_NATION = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOCLASS.GEOCLASS_NATION = 16
     * }
     */
    public static int GEOCLASS_NATION() {
        return GEOCLASS_NATION;
    }
    private static final int GEOCLASS_REGION = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOCLASS.GEOCLASS_REGION = 14
     * }
     */
    public static int GEOCLASS_REGION() {
        return GEOCLASS_REGION;
    }
    private static final int GEOCLASS_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOCLASS.GEOCLASS_ALL = 0
     * }
     */
    public static int GEOCLASS_ALL() {
        return GEOCLASS_ALL;
    }
    private static final int NormalizationOther = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationOther = 0
     * }
     */
    public static int NormalizationOther() {
        return NormalizationOther;
    }
    private static final int NormalizationC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationC = 1
     * }
     */
    public static int NormalizationC() {
        return NormalizationC;
    }
    private static final int NormalizationD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationD = 2
     * }
     */
    public static int NormalizationD() {
        return NormalizationD;
    }
    private static final int NormalizationKC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationKC = 5
     * }
     */
    public static int NormalizationKC() {
        return NormalizationKC;
    }
    private static final int NormalizationKD = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationKD = 6
     * }
     */
    public static int NormalizationKD() {
        return NormalizationKD;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILEMUIINFO {
     *     DWORD dwSize;
     *     DWORD dwVersion;
     *     DWORD dwFileType;
     *     BYTE pChecksum[16];
     *     BYTE pServiceChecksum[16];
     *     DWORD dwLanguageNameOffset;
     *     DWORD dwTypeIDMainSize;
     *     DWORD dwTypeIDMainOffset;
     *     DWORD dwTypeNameMainOffset;
     *     DWORD dwTypeIDMUISize;
     *     DWORD dwTypeIDMUIOffset;
     *     DWORD dwTypeNameMUIOffset;
     *     BYTE abBuffer[8];
     * } *PFILEMUIINFO
     * }
     */
    public static final AddressLayout PFILEMUIINFO = winapi.C_POINTER;

    private static class CompareStringEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CompareStringEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CompareStringEx$descriptor() {
        return CompareStringEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static MethodHandle CompareStringEx$handle() {
        return CompareStringEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static MemorySegment CompareStringEx$address() {
        return CompareStringEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static int CompareStringEx(MemorySegment lpLocaleName, int dwCmpFlags, MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2, MemorySegment lpVersionInformation, MemorySegment lpReserved, long lParam) {
        var mh$ = CompareStringEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringEx", lpLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2, lpVersionInformation, lpReserved, lParam);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2, lpVersionInformation, lpReserved, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareStringOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CompareStringOrdinal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static FunctionDescriptor CompareStringOrdinal$descriptor() {
        return CompareStringOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static MethodHandle CompareStringOrdinal$handle() {
        return CompareStringOrdinal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static MemorySegment CompareStringOrdinal$address() {
        return CompareStringOrdinal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static int CompareStringOrdinal(MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2, int bIgnoreCase) {
        var mh$ = CompareStringOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringOrdinal", lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase);
            }
            return (int)mh$.invokeExact(lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CompareStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static FunctionDescriptor CompareStringW$descriptor() {
        return CompareStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static MethodHandle CompareStringW$handle() {
        return CompareStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static MemorySegment CompareStringW$address() {
        return CompareStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static int CompareStringW(int Locale, int dwCmpFlags, MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2) {
        var mh$ = CompareStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringW", Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
            }
            return (int)mh$.invokeExact(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FoldStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FoldStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor FoldStringW$descriptor() {
        return FoldStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle FoldStringW$handle() {
        return FoldStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MemorySegment FoldStringW$address() {
        return FoldStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static int FoldStringW(int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = FoldStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FoldStringW", dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetStringTypeExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeExW$descriptor() {
        return GetStringTypeExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeExW$handle() {
        return GetStringTypeExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MemorySegment GetStringTypeExW$address() {
        return GetStringTypeExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeExW(int Locale, int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeExW", Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetStringTypeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeW$descriptor() {
        return GetStringTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeW$handle() {
        return GetStringTypeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MemorySegment GetStringTypeW$address() {
        return GetStringTypeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeW(int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeW", dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MultiByteToWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("MultiByteToWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static FunctionDescriptor MultiByteToWideChar$descriptor() {
        return MultiByteToWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static MethodHandle MultiByteToWideChar$handle() {
        return MultiByteToWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static MemorySegment MultiByteToWideChar$address() {
        return MultiByteToWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static int MultiByteToWideChar(int CodePage, int dwFlags, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpWideCharStr, int cchWideChar) {
        var mh$ = MultiByteToWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MultiByteToWideChar", CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WideCharToMultiByte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WideCharToMultiByte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static FunctionDescriptor WideCharToMultiByte$descriptor() {
        return WideCharToMultiByte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static MethodHandle WideCharToMultiByte$handle() {
        return WideCharToMultiByte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static MemorySegment WideCharToMultiByte$address() {
        return WideCharToMultiByte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static int WideCharToMultiByte(int CodePage, int dwFlags, MemorySegment lpWideCharStr, int cchWideChar, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpDefaultChar, MemorySegment lpUsedDefaultChar) {
        var mh$ = WideCharToMultiByte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WideCharToMultiByte", CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidCodePage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsValidCodePage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static FunctionDescriptor IsValidCodePage$descriptor() {
        return IsValidCodePage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static MethodHandle IsValidCodePage$handle() {
        return IsValidCodePage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static MemorySegment IsValidCodePage$address() {
        return IsValidCodePage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static int IsValidCodePage(int CodePage) {
        var mh$ = IsValidCodePage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidCodePage", CodePage);
            }
            return (int)mh$.invokeExact(CodePage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetACP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetACP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static FunctionDescriptor GetACP$descriptor() {
        return GetACP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static MethodHandle GetACP$handle() {
        return GetACP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static MemorySegment GetACP$address() {
        return GetACP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static int GetACP() {
        var mh$ = GetACP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetACP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOEMCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetOEMCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static FunctionDescriptor GetOEMCP$descriptor() {
        return GetOEMCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static MethodHandle GetOEMCP$handle() {
        return GetOEMCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static MemorySegment GetOEMCP$address() {
        return GetOEMCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static int GetOEMCP() {
        var mh$ = GetOEMCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOEMCP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCPInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCPInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static FunctionDescriptor GetCPInfo$descriptor() {
        return GetCPInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static MethodHandle GetCPInfo$handle() {
        return GetCPInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static MemorySegment GetCPInfo$address() {
        return GetCPInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static int GetCPInfo(int CodePage, MemorySegment lpCPInfo) {
        var mh$ = GetCPInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCPInfo", CodePage, lpCPInfo);
            }
            return (int)mh$.invokeExact(CodePage, lpCPInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCPInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCPInfoExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static FunctionDescriptor GetCPInfoExA$descriptor() {
        return GetCPInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static MethodHandle GetCPInfoExA$handle() {
        return GetCPInfoExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static MemorySegment GetCPInfoExA$address() {
        return GetCPInfoExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static int GetCPInfoExA(int CodePage, int dwFlags, MemorySegment lpCPInfoEx) {
        var mh$ = GetCPInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCPInfoExA", CodePage, dwFlags, lpCPInfoEx);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpCPInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCPInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCPInfoExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static FunctionDescriptor GetCPInfoExW$descriptor() {
        return GetCPInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static MethodHandle GetCPInfoExW$handle() {
        return GetCPInfoExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static MemorySegment GetCPInfoExW$address() {
        return GetCPInfoExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static int GetCPInfoExW(int CodePage, int dwFlags, MemorySegment lpCPInfoEx) {
        var mh$ = GetCPInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCPInfoExW", CodePage, dwFlags, lpCPInfoEx);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpCPInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CompareStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static FunctionDescriptor CompareStringA$descriptor() {
        return CompareStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static MethodHandle CompareStringA$handle() {
        return CompareStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static MemorySegment CompareStringA$address() {
        return CompareStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static int CompareStringA(int Locale, int dwCmpFlags, MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2) {
        var mh$ = CompareStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringA", Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
            }
            return (int)mh$.invokeExact(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNLSString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNLSString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static FunctionDescriptor FindNLSString$descriptor() {
        return FindNLSString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static MethodHandle FindNLSString$handle() {
        return FindNLSString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static MemorySegment FindNLSString$address() {
        return FindNLSString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static int FindNLSString(int Locale, int dwFindNLSStringFlags, MemorySegment lpStringSource, int cchSource, MemorySegment lpStringValue, int cchValue, MemorySegment pcchFound) {
        var mh$ = FindNLSString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNLSString", Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound);
            }
            return (int)mh$.invokeExact(Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCMapStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LCMapStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor LCMapStringW$descriptor() {
        return LCMapStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle LCMapStringW$handle() {
        return LCMapStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MemorySegment LCMapStringW$address() {
        return LCMapStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static int LCMapStringW(int Locale, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = LCMapStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCMapStringW", Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCMapStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LCMapStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor LCMapStringA$descriptor() {
        return LCMapStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle LCMapStringA$handle() {
        return LCMapStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MemorySegment LCMapStringA$address() {
        return LCMapStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static int LCMapStringA(int Locale, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = LCMapStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCMapStringA", Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLocaleInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static FunctionDescriptor GetLocaleInfoW$descriptor() {
        return GetLocaleInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MethodHandle GetLocaleInfoW$handle() {
        return GetLocaleInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MemorySegment GetLocaleInfoW$address() {
        return GetLocaleInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static int GetLocaleInfoW(int Locale, int LCType, MemorySegment lpLCData, int cchData) {
        var mh$ = GetLocaleInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleInfoW", Locale, LCType, lpLCData, cchData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData, cchData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLocaleInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static FunctionDescriptor GetLocaleInfoA$descriptor() {
        return GetLocaleInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static MethodHandle GetLocaleInfoA$handle() {
        return GetLocaleInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static MemorySegment GetLocaleInfoA$address() {
        return GetLocaleInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static int GetLocaleInfoA(int Locale, int LCType, MemorySegment lpLCData, int cchData) {
        var mh$ = GetLocaleInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleInfoA", Locale, LCType, lpLCData, cchData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData, cchData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLocaleInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetLocaleInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static FunctionDescriptor SetLocaleInfoA$descriptor() {
        return SetLocaleInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static MethodHandle SetLocaleInfoA$handle() {
        return SetLocaleInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static MemorySegment SetLocaleInfoA$address() {
        return SetLocaleInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static int SetLocaleInfoA(int Locale, int LCType, MemorySegment lpLCData) {
        var mh$ = SetLocaleInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLocaleInfoA", Locale, LCType, lpLCData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLocaleInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetLocaleInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static FunctionDescriptor SetLocaleInfoW$descriptor() {
        return SetLocaleInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static MethodHandle SetLocaleInfoW$handle() {
        return SetLocaleInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static MemorySegment SetLocaleInfoW$address() {
        return SetLocaleInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static int SetLocaleInfoW(int Locale, int LCType, MemorySegment lpLCData) {
        var mh$ = SetLocaleInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLocaleInfoW", Locale, LCType, lpLCData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCalendarInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCalendarInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static FunctionDescriptor GetCalendarInfoA$descriptor() {
        return GetCalendarInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MethodHandle GetCalendarInfoA$handle() {
        return GetCalendarInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MemorySegment GetCalendarInfoA$address() {
        return GetCalendarInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static int GetCalendarInfoA(int Locale, int Calendar, int CalType, MemorySegment lpCalData, int cchData, MemorySegment lpValue) {
        var mh$ = GetCalendarInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCalendarInfoA", Locale, Calendar, CalType, lpCalData, cchData, lpValue);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData, cchData, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCalendarInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCalendarInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static FunctionDescriptor GetCalendarInfoW$descriptor() {
        return GetCalendarInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MethodHandle GetCalendarInfoW$handle() {
        return GetCalendarInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MemorySegment GetCalendarInfoW$address() {
        return GetCalendarInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static int GetCalendarInfoW(int Locale, int Calendar, int CalType, MemorySegment lpCalData, int cchData, MemorySegment lpValue) {
        var mh$ = GetCalendarInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCalendarInfoW", Locale, Calendar, CalType, lpCalData, cchData, lpValue);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData, cchData, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCalendarInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetCalendarInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static FunctionDescriptor SetCalendarInfoA$descriptor() {
        return SetCalendarInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static MethodHandle SetCalendarInfoA$handle() {
        return SetCalendarInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static MemorySegment SetCalendarInfoA$address() {
        return SetCalendarInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static int SetCalendarInfoA(int Locale, int Calendar, int CalType, MemorySegment lpCalData) {
        var mh$ = SetCalendarInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCalendarInfoA", Locale, Calendar, CalType, lpCalData);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCalendarInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetCalendarInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static FunctionDescriptor SetCalendarInfoW$descriptor() {
        return SetCalendarInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static MethodHandle SetCalendarInfoW$handle() {
        return SetCalendarInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static MemorySegment SetCalendarInfoW$address() {
        return SetCalendarInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static int SetCalendarInfoW(int Locale, int Calendar, int CalType, MemorySegment lpCalData) {
        var mh$ = SetCalendarInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCalendarInfoW", Locale, Calendar, CalType, lpCalData);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadStringByReference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LoadStringByReference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static FunctionDescriptor LoadStringByReference$descriptor() {
        return LoadStringByReference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static MethodHandle LoadStringByReference$handle() {
        return LoadStringByReference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static MemorySegment LoadStringByReference$address() {
        return LoadStringByReference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static int LoadStringByReference(int Flags, MemorySegment Language, MemorySegment SourceString, MemorySegment Buffer, int cchBuffer, MemorySegment Directory, MemorySegment pcchBufferOut) {
        var mh$ = LoadStringByReference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadStringByReference", Flags, Language, SourceString, Buffer, cchBuffer, Directory, pcchBufferOut);
            }
            return (int)mh$.invokeExact(Flags, Language, SourceString, Buffer, cchBuffer, Directory, pcchBufferOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDBCSLeadByte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsDBCSLeadByte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static FunctionDescriptor IsDBCSLeadByte$descriptor() {
        return IsDBCSLeadByte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static MethodHandle IsDBCSLeadByte$handle() {
        return IsDBCSLeadByte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static MemorySegment IsDBCSLeadByte$address() {
        return IsDBCSLeadByte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static int IsDBCSLeadByte(byte TestChar) {
        var mh$ = IsDBCSLeadByte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDBCSLeadByte", TestChar);
            }
            return (int)mh$.invokeExact(TestChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDBCSLeadByteEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsDBCSLeadByteEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static FunctionDescriptor IsDBCSLeadByteEx$descriptor() {
        return IsDBCSLeadByteEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static MethodHandle IsDBCSLeadByteEx$handle() {
        return IsDBCSLeadByteEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static MemorySegment IsDBCSLeadByteEx$address() {
        return IsDBCSLeadByteEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static int IsDBCSLeadByteEx(int CodePage, byte TestChar) {
        var mh$ = IsDBCSLeadByteEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDBCSLeadByteEx", CodePage, TestChar);
            }
            return (int)mh$.invokeExact(CodePage, TestChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocaleNameToLCID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LocaleNameToLCID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LocaleNameToLCID$descriptor() {
        return LocaleNameToLCID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static MethodHandle LocaleNameToLCID$handle() {
        return LocaleNameToLCID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static MemorySegment LocaleNameToLCID$address() {
        return LocaleNameToLCID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static int LocaleNameToLCID(MemorySegment lpName, int dwFlags) {
        var mh$ = LocaleNameToLCID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocaleNameToLCID", lpName, dwFlags);
            }
            return (int)mh$.invokeExact(lpName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCIDToLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LCIDToLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LCIDToLocaleName$descriptor() {
        return LCIDToLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static MethodHandle LCIDToLocaleName$handle() {
        return LCIDToLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static MemorySegment LCIDToLocaleName$address() {
        return LCIDToLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static int LCIDToLocaleName(int Locale, MemorySegment lpName, int cchName, int dwFlags) {
        var mh$ = LCIDToLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCIDToLocaleName", Locale, lpName, cchName, dwFlags);
            }
            return (int)mh$.invokeExact(Locale, lpName, cchName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDurationFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDurationFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static FunctionDescriptor GetDurationFormat$descriptor() {
        return GetDurationFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static MethodHandle GetDurationFormat$handle() {
        return GetDurationFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static MemorySegment GetDurationFormat$address() {
        return GetDurationFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static int GetDurationFormat(int Locale, int dwFlags, MemorySegment lpDuration, long ullDuration, MemorySegment lpFormat, MemorySegment lpDurationStr, int cchDuration) {
        var mh$ = GetDurationFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDurationFormat", Locale, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumberFormatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static FunctionDescriptor GetNumberFormatA$descriptor() {
        return GetNumberFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MethodHandle GetNumberFormatA$handle() {
        return GetNumberFormatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MemorySegment GetNumberFormatA$address() {
        return GetNumberFormatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static int GetNumberFormatA(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpNumberStr, int cchNumber) {
        var mh$ = GetNumberFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberFormatA", Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumberFormatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static FunctionDescriptor GetNumberFormatW$descriptor() {
        return GetNumberFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MethodHandle GetNumberFormatW$handle() {
        return GetNumberFormatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MemorySegment GetNumberFormatW$address() {
        return GetNumberFormatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static int GetNumberFormatW(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpNumberStr, int cchNumber) {
        var mh$ = GetNumberFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberFormatW", Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrencyFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrencyFormatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static FunctionDescriptor GetCurrencyFormatA$descriptor() {
        return GetCurrencyFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MethodHandle GetCurrencyFormatA$handle() {
        return GetCurrencyFormatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MemorySegment GetCurrencyFormatA$address() {
        return GetCurrencyFormatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static int GetCurrencyFormatA(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpCurrencyStr, int cchCurrency) {
        var mh$ = GetCurrencyFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrencyFormatA", Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrencyFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrencyFormatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static FunctionDescriptor GetCurrencyFormatW$descriptor() {
        return GetCurrencyFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MethodHandle GetCurrencyFormatW$handle() {
        return GetCurrencyFormatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MemorySegment GetCurrencyFormatW$address() {
        return GetCurrencyFormatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static int GetCurrencyFormatW(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpCurrencyStr, int cchCurrency) {
        var mh$ = GetCurrencyFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrencyFormatW", Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumCalendarInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoA$descriptor() {
        return EnumCalendarInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoA$handle() {
        return EnumCalendarInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MemorySegment EnumCalendarInfoA$address() {
        return EnumCalendarInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoA(MemorySegment lpCalInfoEnumProc, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoA", lpCalInfoEnumProc, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProc, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumCalendarInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoW$descriptor() {
        return EnumCalendarInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoW$handle() {
        return EnumCalendarInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MemorySegment EnumCalendarInfoW$address() {
        return EnumCalendarInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoW(MemorySegment lpCalInfoEnumProc, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoW", lpCalInfoEnumProc, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProc, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumCalendarInfoExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoExA$descriptor() {
        return EnumCalendarInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoExA$handle() {
        return EnumCalendarInfoExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MemorySegment EnumCalendarInfoExA$address() {
        return EnumCalendarInfoExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoExA(MemorySegment lpCalInfoEnumProcEx, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoExA", lpCalInfoEnumProcEx, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProcEx, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumCalendarInfoExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoExW$descriptor() {
        return EnumCalendarInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoExW$handle() {
        return EnumCalendarInfoExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MemorySegment EnumCalendarInfoExW$address() {
        return EnumCalendarInfoExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoExW(MemorySegment lpCalInfoEnumProcEx, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoExW", lpCalInfoEnumProcEx, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProcEx, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumTimeFormatsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumTimeFormatsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumTimeFormatsA$descriptor() {
        return EnumTimeFormatsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumTimeFormatsA$handle() {
        return EnumTimeFormatsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumTimeFormatsA$address() {
        return EnumTimeFormatsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumTimeFormatsA(MemorySegment lpTimeFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumTimeFormatsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumTimeFormatsA", lpTimeFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpTimeFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumTimeFormatsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumTimeFormatsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumTimeFormatsW$descriptor() {
        return EnumTimeFormatsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumTimeFormatsW$handle() {
        return EnumTimeFormatsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumTimeFormatsW$address() {
        return EnumTimeFormatsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumTimeFormatsW(MemorySegment lpTimeFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumTimeFormatsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumTimeFormatsW", lpTimeFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpTimeFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumDateFormatsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsA$descriptor() {
        return EnumDateFormatsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsA$handle() {
        return EnumDateFormatsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDateFormatsA$address() {
        return EnumDateFormatsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsA(MemorySegment lpDateFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsA", lpDateFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumDateFormatsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsW$descriptor() {
        return EnumDateFormatsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsW$handle() {
        return EnumDateFormatsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDateFormatsW$address() {
        return EnumDateFormatsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsW(MemorySegment lpDateFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsW", lpDateFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumDateFormatsExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsExA$descriptor() {
        return EnumDateFormatsExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsExA$handle() {
        return EnumDateFormatsExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDateFormatsExA$address() {
        return EnumDateFormatsExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsExA(MemorySegment lpDateFmtEnumProcEx, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsExA", lpDateFmtEnumProcEx, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProcEx, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumDateFormatsExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsExW$descriptor() {
        return EnumDateFormatsExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsExW$handle() {
        return EnumDateFormatsExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDateFormatsExW$address() {
        return EnumDateFormatsExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsExW(MemorySegment lpDateFmtEnumProcEx, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsExW", lpDateFmtEnumProcEx, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProcEx, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidLanguageGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsValidLanguageGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor IsValidLanguageGroup$descriptor() {
        return IsValidLanguageGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static MethodHandle IsValidLanguageGroup$handle() {
        return IsValidLanguageGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static MemorySegment IsValidLanguageGroup$address() {
        return IsValidLanguageGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static int IsValidLanguageGroup(int LanguageGroup, int dwFlags) {
        var mh$ = IsValidLanguageGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidLanguageGroup", LanguageGroup, dwFlags);
            }
            return (int)mh$.invokeExact(LanguageGroup, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNLSVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNLSVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetNLSVersion$descriptor() {
        return GetNLSVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static MethodHandle GetNLSVersion$handle() {
        return GetNLSVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static MemorySegment GetNLSVersion$address() {
        return GetNLSVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static int GetNLSVersion(int Function, int Locale, MemorySegment lpVersionInformation) {
        var mh$ = GetNLSVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNLSVersion", Function, Locale, lpVersionInformation);
            }
            return (int)mh$.invokeExact(Function, Locale, lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsValidLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor IsValidLocale$descriptor() {
        return IsValidLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle IsValidLocale$handle() {
        return IsValidLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment IsValidLocale$address() {
        return IsValidLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static int IsValidLocale(int Locale, int dwFlags) {
        var mh$ = IsValidLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidLocale", Locale, dwFlags);
            }
            return (int)mh$.invokeExact(Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeoInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_SHORT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetGeoInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static FunctionDescriptor GetGeoInfoA$descriptor() {
        return GetGeoInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MethodHandle GetGeoInfoA$handle() {
        return GetGeoInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MemorySegment GetGeoInfoA$address() {
        return GetGeoInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static int GetGeoInfoA(int Location, int GeoType, MemorySegment lpGeoData, int cchData, short LangId) {
        var mh$ = GetGeoInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeoInfoA", Location, GeoType, lpGeoData, cchData, LangId);
            }
            return (int)mh$.invokeExact(Location, GeoType, lpGeoData, cchData, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeoInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_SHORT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetGeoInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static FunctionDescriptor GetGeoInfoW$descriptor() {
        return GetGeoInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MethodHandle GetGeoInfoW$handle() {
        return GetGeoInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MemorySegment GetGeoInfoW$address() {
        return GetGeoInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static int GetGeoInfoW(int Location, int GeoType, MemorySegment lpGeoData, int cchData, short LangId) {
        var mh$ = GetGeoInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeoInfoW", Location, GeoType, lpGeoData, cchData, LangId);
            }
            return (int)mh$.invokeExact(Location, GeoType, lpGeoData, cchData, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeoInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetGeoInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static FunctionDescriptor GetGeoInfoEx$descriptor() {
        return GetGeoInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static MethodHandle GetGeoInfoEx$handle() {
        return GetGeoInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static MemorySegment GetGeoInfoEx$address() {
        return GetGeoInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static int GetGeoInfoEx(MemorySegment location, int geoType, MemorySegment geoData, int geoDataCount) {
        var mh$ = GetGeoInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeoInfoEx", location, geoType, geoData, geoDataCount);
            }
            return (int)mh$.invokeExact(location, geoType, geoData, geoDataCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemGeoID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumSystemGeoID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static FunctionDescriptor EnumSystemGeoID$descriptor() {
        return EnumSystemGeoID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static MethodHandle EnumSystemGeoID$handle() {
        return EnumSystemGeoID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static MemorySegment EnumSystemGeoID$address() {
        return EnumSystemGeoID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static int EnumSystemGeoID(int GeoClass, int ParentGeoId, MemorySegment lpGeoEnumProc) {
        var mh$ = EnumSystemGeoID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemGeoID", GeoClass, ParentGeoId, lpGeoEnumProc);
            }
            return (int)mh$.invokeExact(GeoClass, ParentGeoId, lpGeoEnumProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemGeoNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumSystemGeoNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static FunctionDescriptor EnumSystemGeoNames$descriptor() {
        return EnumSystemGeoNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static MethodHandle EnumSystemGeoNames$handle() {
        return EnumSystemGeoNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static MemorySegment EnumSystemGeoNames$address() {
        return EnumSystemGeoNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static int EnumSystemGeoNames(int geoClass, MemorySegment geoEnumProc, long data) {
        var mh$ = EnumSystemGeoNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemGeoNames", geoClass, geoEnumProc, data);
            }
            return (int)mh$.invokeExact(geoClass, geoEnumProc, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserGeoID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserGeoID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static FunctionDescriptor GetUserGeoID$descriptor() {
        return GetUserGeoID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static MethodHandle GetUserGeoID$handle() {
        return GetUserGeoID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static MemorySegment GetUserGeoID$address() {
        return GetUserGeoID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static int GetUserGeoID(int GeoClass) {
        var mh$ = GetUserGeoID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserGeoID", GeoClass);
            }
            return (int)mh$.invokeExact(GeoClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultGeoName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserDefaultGeoName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static FunctionDescriptor GetUserDefaultGeoName$descriptor() {
        return GetUserDefaultGeoName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static MethodHandle GetUserDefaultGeoName$handle() {
        return GetUserDefaultGeoName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static MemorySegment GetUserDefaultGeoName$address() {
        return GetUserDefaultGeoName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static int GetUserDefaultGeoName(MemorySegment geoName, int geoNameCount) {
        var mh$ = GetUserDefaultGeoName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultGeoName", geoName, geoNameCount);
            }
            return (int)mh$.invokeExact(geoName, geoNameCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserGeoID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetUserGeoID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static FunctionDescriptor SetUserGeoID$descriptor() {
        return SetUserGeoID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static MethodHandle SetUserGeoID$handle() {
        return SetUserGeoID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static MemorySegment SetUserGeoID$address() {
        return SetUserGeoID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static int SetUserGeoID(int GeoId) {
        var mh$ = SetUserGeoID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserGeoID", GeoId);
            }
            return (int)mh$.invokeExact(GeoId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserGeoName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetUserGeoName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static FunctionDescriptor SetUserGeoName$descriptor() {
        return SetUserGeoName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static MethodHandle SetUserGeoName$handle() {
        return SetUserGeoName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static MemorySegment SetUserGeoName$address() {
        return SetUserGeoName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static int SetUserGeoName(MemorySegment geoName) {
        var mh$ = SetUserGeoName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserGeoName", geoName);
            }
            return (int)mh$.invokeExact(geoName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertDefaultLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ConvertDefaultLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static FunctionDescriptor ConvertDefaultLocale$descriptor() {
        return ConvertDefaultLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static MethodHandle ConvertDefaultLocale$handle() {
        return ConvertDefaultLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static MemorySegment ConvertDefaultLocale$address() {
        return ConvertDefaultLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static int ConvertDefaultLocale(int Locale) {
        var mh$ = ConvertDefaultLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertDefaultLocale", Locale);
            }
            return (int)mh$.invokeExact(Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetSystemDefaultUILanguage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static FunctionDescriptor GetSystemDefaultUILanguage$descriptor() {
        return GetSystemDefaultUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static MethodHandle GetSystemDefaultUILanguage$handle() {
        return GetSystemDefaultUILanguage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static MemorySegment GetSystemDefaultUILanguage$address() {
        return GetSystemDefaultUILanguage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static short GetSystemDefaultUILanguage() {
        var mh$ = GetSystemDefaultUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultUILanguage");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetThreadLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static FunctionDescriptor GetThreadLocale$descriptor() {
        return GetThreadLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static MethodHandle GetThreadLocale$handle() {
        return GetThreadLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static MemorySegment GetThreadLocale$address() {
        return GetThreadLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static int GetThreadLocale() {
        var mh$ = GetThreadLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadLocale");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetThreadLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static FunctionDescriptor SetThreadLocale$descriptor() {
        return SetThreadLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static MethodHandle SetThreadLocale$handle() {
        return SetThreadLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static MemorySegment SetThreadLocale$address() {
        return SetThreadLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static int SetThreadLocale(int Locale) {
        var mh$ = SetThreadLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadLocale", Locale);
            }
            return (int)mh$.invokeExact(Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserDefaultUILanguage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static FunctionDescriptor GetUserDefaultUILanguage$descriptor() {
        return GetUserDefaultUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static MethodHandle GetUserDefaultUILanguage$handle() {
        return GetUserDefaultUILanguage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static MemorySegment GetUserDefaultUILanguage$address() {
        return GetUserDefaultUILanguage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static short GetUserDefaultUILanguage() {
        var mh$ = GetUserDefaultUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultUILanguage");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultLangID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserDefaultLangID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static FunctionDescriptor GetUserDefaultLangID$descriptor() {
        return GetUserDefaultLangID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static MethodHandle GetUserDefaultLangID$handle() {
        return GetUserDefaultLangID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static MemorySegment GetUserDefaultLangID$address() {
        return GetUserDefaultLangID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static short GetUserDefaultLangID() {
        var mh$ = GetUserDefaultLangID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultLangID");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultLangID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetSystemDefaultLangID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static FunctionDescriptor GetSystemDefaultLangID$descriptor() {
        return GetSystemDefaultLangID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static MethodHandle GetSystemDefaultLangID$handle() {
        return GetSystemDefaultLangID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static MemorySegment GetSystemDefaultLangID$address() {
        return GetSystemDefaultLangID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static short GetSystemDefaultLangID() {
        var mh$ = GetSystemDefaultLangID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultLangID");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultLCID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetSystemDefaultLCID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static FunctionDescriptor GetSystemDefaultLCID$descriptor() {
        return GetSystemDefaultLCID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static MethodHandle GetSystemDefaultLCID$handle() {
        return GetSystemDefaultLCID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static MemorySegment GetSystemDefaultLCID$address() {
        return GetSystemDefaultLCID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static int GetSystemDefaultLCID() {
        var mh$ = GetSystemDefaultLCID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultLCID");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultLCID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserDefaultLCID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static FunctionDescriptor GetUserDefaultLCID$descriptor() {
        return GetUserDefaultLCID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static MethodHandle GetUserDefaultLCID$handle() {
        return GetUserDefaultLCID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static MemorySegment GetUserDefaultLCID$address() {
        return GetUserDefaultLCID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static int GetUserDefaultLCID() {
        var mh$ = GetUserDefaultLCID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultLCID");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT,
            winapi.C_SHORT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetThreadUILanguage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static FunctionDescriptor SetThreadUILanguage$descriptor() {
        return SetThreadUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static MethodHandle SetThreadUILanguage$handle() {
        return SetThreadUILanguage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static MemorySegment SetThreadUILanguage$address() {
        return SetThreadUILanguage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static short SetThreadUILanguage(short LangId) {
        var mh$ = SetThreadUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadUILanguage", LangId);
            }
            return (short)mh$.invokeExact(LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetThreadUILanguage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static FunctionDescriptor GetThreadUILanguage$descriptor() {
        return GetThreadUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static MethodHandle GetThreadUILanguage$handle() {
        return GetThreadUILanguage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static MemorySegment GetThreadUILanguage$address() {
        return GetThreadUILanguage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static short GetThreadUILanguage() {
        var mh$ = GetThreadUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadUILanguage");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetProcessPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetProcessPreferredUILanguages$descriptor() {
        return GetProcessPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetProcessPreferredUILanguages$handle() {
        return GetProcessPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MemorySegment GetProcessPreferredUILanguages$address() {
        return GetProcessPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetProcessPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetProcessPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetProcessPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static FunctionDescriptor SetProcessPreferredUILanguages$descriptor() {
        return SetProcessPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MethodHandle SetProcessPreferredUILanguages$handle() {
        return SetProcessPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MemorySegment SetProcessPreferredUILanguages$address() {
        return SetProcessPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static int SetProcessPreferredUILanguages(int dwFlags, MemorySegment pwszLanguagesBuffer, MemorySegment pulNumLanguages) {
        var mh$ = SetProcessPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessPreferredUILanguages", dwFlags, pwszLanguagesBuffer, pulNumLanguages);
            }
            return (int)mh$.invokeExact(dwFlags, pwszLanguagesBuffer, pulNumLanguages);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetUserPreferredUILanguages$descriptor() {
        return GetUserPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetUserPreferredUILanguages$handle() {
        return GetUserPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MemorySegment GetUserPreferredUILanguages$address() {
        return GetUserPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetUserPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetUserPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetSystemPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetSystemPreferredUILanguages$descriptor() {
        return GetSystemPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetSystemPreferredUILanguages$handle() {
        return GetSystemPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MemorySegment GetSystemPreferredUILanguages$address() {
        return GetSystemPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetSystemPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetSystemPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetThreadPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetThreadPreferredUILanguages$descriptor() {
        return GetThreadPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetThreadPreferredUILanguages$handle() {
        return GetThreadPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MemorySegment GetThreadPreferredUILanguages$address() {
        return GetThreadPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetThreadPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetThreadPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetThreadPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static FunctionDescriptor SetThreadPreferredUILanguages$descriptor() {
        return SetThreadPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MethodHandle SetThreadPreferredUILanguages$handle() {
        return SetThreadPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MemorySegment SetThreadPreferredUILanguages$address() {
        return SetThreadPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static int SetThreadPreferredUILanguages(int dwFlags, MemorySegment pwszLanguagesBuffer, MemorySegment pulNumLanguages) {
        var mh$ = SetThreadPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPreferredUILanguages", dwFlags, pwszLanguagesBuffer, pulNumLanguages);
            }
            return (int)mh$.invokeExact(dwFlags, pwszLanguagesBuffer, pulNumLanguages);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileMUIInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileMUIInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static FunctionDescriptor GetFileMUIInfo$descriptor() {
        return GetFileMUIInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static MethodHandle GetFileMUIInfo$handle() {
        return GetFileMUIInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static MemorySegment GetFileMUIInfo$address() {
        return GetFileMUIInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static int GetFileMUIInfo(int dwFlags, MemorySegment pcwszFilePath, MemorySegment pFileMUIInfo, MemorySegment pcbFileMUIInfo) {
        var mh$ = GetFileMUIInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileMUIInfo", dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo);
            }
            return (int)mh$.invokeExact(dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileMUIPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileMUIPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static FunctionDescriptor GetFileMUIPath$descriptor() {
        return GetFileMUIPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static MethodHandle GetFileMUIPath$handle() {
        return GetFileMUIPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static MemorySegment GetFileMUIPath$address() {
        return GetFileMUIPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static int GetFileMUIPath(int dwFlags, MemorySegment pcwszFilePath, MemorySegment pwszLanguage, MemorySegment pcchLanguage, MemorySegment pwszFileMUIPath, MemorySegment pcchFileMUIPath, MemorySegment pululEnumerator) {
        var mh$ = GetFileMUIPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileMUIPath", dwFlags, pcwszFilePath, pwszLanguage, pcchLanguage, pwszFileMUIPath, pcchFileMUIPath, pululEnumerator);
            }
            return (int)mh$.invokeExact(dwFlags, pcwszFilePath, pwszLanguage, pcchLanguage, pwszFileMUIPath, pcchFileMUIPath, pululEnumerator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUILanguageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUILanguageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static FunctionDescriptor GetUILanguageInfo$descriptor() {
        return GetUILanguageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static MethodHandle GetUILanguageInfo$handle() {
        return GetUILanguageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static MemorySegment GetUILanguageInfo$address() {
        return GetUILanguageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static int GetUILanguageInfo(int dwFlags, MemorySegment pwmszLanguage, MemorySegment pwszFallbackLanguages, MemorySegment pcchFallbackLanguages, MemorySegment pAttributes) {
        var mh$ = GetUILanguageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUILanguageInfo", dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes);
            }
            return (int)mh$.invokeExact(dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HSAVEDUILANGUAGES__ {
     *     int unused;
     * } *HSAVEDUILANGUAGES
     * }
     */
    public static final AddressLayout HSAVEDUILANGUAGES = winapi.C_POINTER;

    private static class SetThreadPreferredUILanguages2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetThreadPreferredUILanguages2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static FunctionDescriptor SetThreadPreferredUILanguages2$descriptor() {
        return SetThreadPreferredUILanguages2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static MethodHandle SetThreadPreferredUILanguages2$handle() {
        return SetThreadPreferredUILanguages2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static MemorySegment SetThreadPreferredUILanguages2$address() {
        return SetThreadPreferredUILanguages2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static int SetThreadPreferredUILanguages2(int flags, MemorySegment languages, MemorySegment numLanguagesSet, MemorySegment snapshot) {
        var mh$ = SetThreadPreferredUILanguages2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPreferredUILanguages2", flags, languages, numLanguagesSet, snapshot);
            }
            return (int)mh$.invokeExact(flags, languages, numLanguagesSet, snapshot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestoreThreadPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RestoreThreadPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static FunctionDescriptor RestoreThreadPreferredUILanguages$descriptor() {
        return RestoreThreadPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static MethodHandle RestoreThreadPreferredUILanguages$handle() {
        return RestoreThreadPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static MemorySegment RestoreThreadPreferredUILanguages$address() {
        return RestoreThreadPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static void RestoreThreadPreferredUILanguages(MemorySegment snapshot) {
        var mh$ = RestoreThreadPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestoreThreadPreferredUILanguages", snapshot);
            }
            mh$.invokeExact(snapshot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyUILanguageChange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NotifyUILanguageChange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static FunctionDescriptor NotifyUILanguageChange$descriptor() {
        return NotifyUILanguageChange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static MethodHandle NotifyUILanguageChange$handle() {
        return NotifyUILanguageChange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static MemorySegment NotifyUILanguageChange$address() {
        return NotifyUILanguageChange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static int NotifyUILanguageChange(int dwFlags, MemorySegment pcwstrNewLanguage, MemorySegment pcwstrPreviousLanguage, int dwReserved, MemorySegment pdwStatusRtrn) {
        var mh$ = NotifyUILanguageChange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyUILanguageChange", dwFlags, pcwstrNewLanguage, pcwstrPreviousLanguage, dwReserved, pdwStatusRtrn);
            }
            return (int)mh$.invokeExact(dwFlags, pcwstrNewLanguage, pcwstrPreviousLanguage, dwReserved, pdwStatusRtrn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetStringTypeExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeExA$descriptor() {
        return GetStringTypeExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeExA$handle() {
        return GetStringTypeExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MemorySegment GetStringTypeExA$address() {
        return GetStringTypeExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeExA(int Locale, int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeExA", Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetStringTypeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeA$descriptor() {
        return GetStringTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeA$handle() {
        return GetStringTypeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MemorySegment GetStringTypeA$address() {
        return GetStringTypeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeA(int Locale, int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeA", Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FoldStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FoldStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor FoldStringA$descriptor() {
        return FoldStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle FoldStringA$handle() {
        return FoldStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MemorySegment FoldStringA$address() {
        return FoldStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static int FoldStringA(int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = FoldStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FoldStringA", dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLocalesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumSystemLocalesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemLocalesA$descriptor() {
        return EnumSystemLocalesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemLocalesA$handle() {
        return EnumSystemLocalesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumSystemLocalesA$address() {
        return EnumSystemLocalesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemLocalesA(MemorySegment lpLocaleEnumProc, int dwFlags) {
        var mh$ = EnumSystemLocalesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLocalesA", lpLocaleEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpLocaleEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLocalesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumSystemLocalesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemLocalesW$descriptor() {
        return EnumSystemLocalesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemLocalesW$handle() {
        return EnumSystemLocalesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumSystemLocalesW$address() {
        return EnumSystemLocalesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemLocalesW(MemorySegment lpLocaleEnumProc, int dwFlags) {
        var mh$ = EnumSystemLocalesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLocalesW", lpLocaleEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpLocaleEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLanguageGroupsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumSystemLanguageGroupsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumSystemLanguageGroupsA$descriptor() {
        return EnumSystemLanguageGroupsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumSystemLanguageGroupsA$handle() {
        return EnumSystemLanguageGroupsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumSystemLanguageGroupsA$address() {
        return EnumSystemLanguageGroupsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumSystemLanguageGroupsA(MemorySegment lpLanguageGroupEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumSystemLanguageGroupsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLanguageGroupsA", lpLanguageGroupEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLanguageGroupEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLanguageGroupsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumSystemLanguageGroupsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumSystemLanguageGroupsW$descriptor() {
        return EnumSystemLanguageGroupsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumSystemLanguageGroupsW$handle() {
        return EnumSystemLanguageGroupsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumSystemLanguageGroupsW$address() {
        return EnumSystemLanguageGroupsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumSystemLanguageGroupsW(MemorySegment lpLanguageGroupEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumSystemLanguageGroupsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLanguageGroupsW", lpLanguageGroupEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLanguageGroupEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumLanguageGroupLocalesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumLanguageGroupLocalesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumLanguageGroupLocalesA$descriptor() {
        return EnumLanguageGroupLocalesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumLanguageGroupLocalesA$handle() {
        return EnumLanguageGroupLocalesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumLanguageGroupLocalesA$address() {
        return EnumLanguageGroupLocalesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumLanguageGroupLocalesA(MemorySegment lpLangGroupLocaleEnumProc, int LanguageGroup, int dwFlags, long lParam) {
        var mh$ = EnumLanguageGroupLocalesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumLanguageGroupLocalesA", lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumLanguageGroupLocalesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumLanguageGroupLocalesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumLanguageGroupLocalesW$descriptor() {
        return EnumLanguageGroupLocalesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumLanguageGroupLocalesW$handle() {
        return EnumLanguageGroupLocalesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumLanguageGroupLocalesW$address() {
        return EnumLanguageGroupLocalesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumLanguageGroupLocalesW(MemorySegment lpLangGroupLocaleEnumProc, int LanguageGroup, int dwFlags, long lParam) {
        var mh$ = EnumLanguageGroupLocalesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumLanguageGroupLocalesW", lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumUILanguagesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumUILanguagesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumUILanguagesA$descriptor() {
        return EnumUILanguagesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumUILanguagesA$handle() {
        return EnumUILanguagesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumUILanguagesA$address() {
        return EnumUILanguagesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumUILanguagesA(MemorySegment lpUILanguageEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumUILanguagesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumUILanguagesA", lpUILanguageEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpUILanguageEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumUILanguagesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumUILanguagesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumUILanguagesW$descriptor() {
        return EnumUILanguagesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumUILanguagesW$handle() {
        return EnumUILanguagesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumUILanguagesW$address() {
        return EnumUILanguagesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumUILanguagesW(MemorySegment lpUILanguageEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumUILanguagesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumUILanguagesW", lpUILanguageEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpUILanguageEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemCodePagesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumSystemCodePagesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemCodePagesA$descriptor() {
        return EnumSystemCodePagesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemCodePagesA$handle() {
        return EnumSystemCodePagesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumSystemCodePagesA$address() {
        return EnumSystemCodePagesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemCodePagesA(MemorySegment lpCodePageEnumProc, int dwFlags) {
        var mh$ = EnumSystemCodePagesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemCodePagesA", lpCodePageEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpCodePageEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemCodePagesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumSystemCodePagesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemCodePagesW$descriptor() {
        return EnumSystemCodePagesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemCodePagesW$handle() {
        return EnumSystemCodePagesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumSystemCodePagesW$address() {
        return EnumSystemCodePagesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemCodePagesW(MemorySegment lpCodePageEnumProc, int dwFlags) {
        var mh$ = EnumSystemCodePagesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemCodePagesW", lpCodePageEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpCodePageEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdnToAscii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IdnToAscii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static FunctionDescriptor IdnToAscii$descriptor() {
        return IdnToAscii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static MethodHandle IdnToAscii$handle() {
        return IdnToAscii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static MemorySegment IdnToAscii$address() {
        return IdnToAscii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static int IdnToAscii(int dwFlags, MemorySegment lpUnicodeCharStr, int cchUnicodeChar, MemorySegment lpASCIICharStr, int cchASCIIChar) {
        var mh$ = IdnToAscii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdnToAscii", dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, cchASCIIChar);
            }
            return (int)mh$.invokeExact(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, cchASCIIChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdnToUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IdnToUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static FunctionDescriptor IdnToUnicode$descriptor() {
        return IdnToUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static MethodHandle IdnToUnicode$handle() {
        return IdnToUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static MemorySegment IdnToUnicode$address() {
        return IdnToUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static int IdnToUnicode(int dwFlags, MemorySegment lpASCIICharStr, int cchASCIIChar, MemorySegment lpUnicodeCharStr, int cchUnicodeChar) {
        var mh$ = IdnToUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdnToUnicode", dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, cchUnicodeChar);
            }
            return (int)mh$.invokeExact(dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, cchUnicodeChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdnToNameprepUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IdnToNameprepUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static FunctionDescriptor IdnToNameprepUnicode$descriptor() {
        return IdnToNameprepUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static MethodHandle IdnToNameprepUnicode$handle() {
        return IdnToNameprepUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static MemorySegment IdnToNameprepUnicode$address() {
        return IdnToNameprepUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static int IdnToNameprepUnicode(int dwFlags, MemorySegment lpUnicodeCharStr, int cchUnicodeChar, MemorySegment lpNameprepCharStr, int cchNameprepChar) {
        var mh$ = IdnToNameprepUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdnToNameprepUnicode", dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar);
            }
            return (int)mh$.invokeExact(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NormalizeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NormalizeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static FunctionDescriptor NormalizeString$descriptor() {
        return NormalizeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static MethodHandle NormalizeString$handle() {
        return NormalizeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static MemorySegment NormalizeString$address() {
        return NormalizeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static int NormalizeString(int NormForm, MemorySegment lpSrcString, int cwSrcLength, MemorySegment lpDstString, int cwDstLength) {
        var mh$ = NormalizeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NormalizeString", NormForm, lpSrcString, cwSrcLength, lpDstString, cwDstLength);
            }
            return (int)mh$.invokeExact(NormForm, lpSrcString, cwSrcLength, lpDstString, cwDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsNormalizedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsNormalizedString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static FunctionDescriptor IsNormalizedString$descriptor() {
        return IsNormalizedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static MethodHandle IsNormalizedString$handle() {
        return IsNormalizedString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static MemorySegment IsNormalizedString$address() {
        return IsNormalizedString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static int IsNormalizedString(int NormForm, MemorySegment lpString, int cwLength) {
        var mh$ = IsNormalizedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsNormalizedString", NormForm, lpString, cwLength);
            }
            return (int)mh$.invokeExact(NormForm, lpString, cwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerifyScripts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerifyScripts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static FunctionDescriptor VerifyScripts$descriptor() {
        return VerifyScripts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static MethodHandle VerifyScripts$handle() {
        return VerifyScripts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static MemorySegment VerifyScripts$address() {
        return VerifyScripts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static int VerifyScripts(int dwFlags, MemorySegment lpLocaleScripts, int cchLocaleScripts, MemorySegment lpTestScripts, int cchTestScripts) {
        var mh$ = VerifyScripts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerifyScripts", dwFlags, lpLocaleScripts, cchLocaleScripts, lpTestScripts, cchTestScripts);
            }
            return (int)mh$.invokeExact(dwFlags, lpLocaleScripts, cchLocaleScripts, lpTestScripts, cchTestScripts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringScripts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetStringScripts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static FunctionDescriptor GetStringScripts$descriptor() {
        return GetStringScripts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static MethodHandle GetStringScripts$handle() {
        return GetStringScripts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static MemorySegment GetStringScripts$address() {
        return GetStringScripts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static int GetStringScripts(int dwFlags, MemorySegment lpString, int cchString, MemorySegment lpScripts, int cchScripts) {
        var mh$ = GetStringScripts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringScripts", dwFlags, lpString, cchString, lpScripts, cchScripts);
            }
            return (int)mh$.invokeExact(dwFlags, lpString, cchString, lpScripts, cchScripts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLocaleInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static FunctionDescriptor GetLocaleInfoEx$descriptor() {
        return GetLocaleInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MethodHandle GetLocaleInfoEx$handle() {
        return GetLocaleInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MemorySegment GetLocaleInfoEx$address() {
        return GetLocaleInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static int GetLocaleInfoEx(MemorySegment lpLocaleName, int LCType, MemorySegment lpLCData, int cchData) {
        var mh$ = GetLocaleInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleInfoEx", lpLocaleName, LCType, lpLCData, cchData);
            }
            return (int)mh$.invokeExact(lpLocaleName, LCType, lpLCData, cchData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCalendarInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCalendarInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static FunctionDescriptor GetCalendarInfoEx$descriptor() {
        return GetCalendarInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MethodHandle GetCalendarInfoEx$handle() {
        return GetCalendarInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MemorySegment GetCalendarInfoEx$address() {
        return GetCalendarInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static int GetCalendarInfoEx(MemorySegment lpLocaleName, int Calendar, MemorySegment lpReserved, int CalType, MemorySegment lpCalData, int cchData, MemorySegment lpValue) {
        var mh$ = GetCalendarInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCalendarInfoEx", lpLocaleName, Calendar, lpReserved, CalType, lpCalData, cchData, lpValue);
            }
            return (int)mh$.invokeExact(lpLocaleName, Calendar, lpReserved, CalType, lpCalData, cchData, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumberFormatEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static FunctionDescriptor GetNumberFormatEx$descriptor() {
        return GetNumberFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MethodHandle GetNumberFormatEx$handle() {
        return GetNumberFormatEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MemorySegment GetNumberFormatEx$address() {
        return GetNumberFormatEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static int GetNumberFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpNumberStr, int cchNumber) {
        var mh$ = GetNumberFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberFormatEx", lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrencyFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrencyFormatEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static FunctionDescriptor GetCurrencyFormatEx$descriptor() {
        return GetCurrencyFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MethodHandle GetCurrencyFormatEx$handle() {
        return GetCurrencyFormatEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MemorySegment GetCurrencyFormatEx$address() {
        return GetCurrencyFormatEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static int GetCurrencyFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpCurrencyStr, int cchCurrency) {
        var mh$ = GetCurrencyFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrencyFormatEx", lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetUserDefaultLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static FunctionDescriptor GetUserDefaultLocaleName$descriptor() {
        return GetUserDefaultLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MethodHandle GetUserDefaultLocaleName$handle() {
        return GetUserDefaultLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MemorySegment GetUserDefaultLocaleName$address() {
        return GetUserDefaultLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static int GetUserDefaultLocaleName(MemorySegment lpLocaleName, int cchLocaleName) {
        var mh$ = GetUserDefaultLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultLocaleName", lpLocaleName, cchLocaleName);
            }
            return (int)mh$.invokeExact(lpLocaleName, cchLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetSystemDefaultLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static FunctionDescriptor GetSystemDefaultLocaleName$descriptor() {
        return GetSystemDefaultLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MethodHandle GetSystemDefaultLocaleName$handle() {
        return GetSystemDefaultLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MemorySegment GetSystemDefaultLocaleName$address() {
        return GetSystemDefaultLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static int GetSystemDefaultLocaleName(MemorySegment lpLocaleName, int cchLocaleName) {
        var mh$ = GetSystemDefaultLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultLocaleName", lpLocaleName, cchLocaleName);
            }
            return (int)mh$.invokeExact(lpLocaleName, cchLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsNLSDefinedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsNLSDefinedString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static FunctionDescriptor IsNLSDefinedString$descriptor() {
        return IsNLSDefinedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static MethodHandle IsNLSDefinedString$handle() {
        return IsNLSDefinedString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static MemorySegment IsNLSDefinedString$address() {
        return IsNLSDefinedString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static int IsNLSDefinedString(int Function, int dwFlags, MemorySegment lpVersionInformation, MemorySegment lpString, int cchStr) {
        var mh$ = IsNLSDefinedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsNLSDefinedString", Function, dwFlags, lpVersionInformation, lpString, cchStr);
            }
            return (int)mh$.invokeExact(Function, dwFlags, lpVersionInformation, lpString, cchStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNLSVersionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNLSVersionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetNLSVersionEx$descriptor() {
        return GetNLSVersionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MethodHandle GetNLSVersionEx$handle() {
        return GetNLSVersionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MemorySegment GetNLSVersionEx$address() {
        return GetNLSVersionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static int GetNLSVersionEx(int function, MemorySegment lpLocaleName, MemorySegment lpVersionInformation) {
        var mh$ = GetNLSVersionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNLSVersionEx", function, lpLocaleName, lpVersionInformation);
            }
            return (int)mh$.invokeExact(function, lpLocaleName, lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidNLSVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsValidNLSVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static FunctionDescriptor IsValidNLSVersion$descriptor() {
        return IsValidNLSVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MethodHandle IsValidNLSVersion$handle() {
        return IsValidNLSVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MemorySegment IsValidNLSVersion$address() {
        return IsValidNLSVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static int IsValidNLSVersion(int function, MemorySegment lpLocaleName, MemorySegment lpVersionInformation) {
        var mh$ = IsValidNLSVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidNLSVersion", function, lpLocaleName, lpVersionInformation);
            }
            return (int)mh$.invokeExact(function, lpLocaleName, lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNLSStringEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNLSStringEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static FunctionDescriptor FindNLSStringEx$descriptor() {
        return FindNLSStringEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MethodHandle FindNLSStringEx$handle() {
        return FindNLSStringEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MemorySegment FindNLSStringEx$address() {
        return FindNLSStringEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static int FindNLSStringEx(MemorySegment lpLocaleName, int dwFindNLSStringFlags, MemorySegment lpStringSource, int cchSource, MemorySegment lpStringValue, int cchValue, MemorySegment pcchFound, MemorySegment lpVersionInformation, MemorySegment lpReserved, long sortHandle) {
        var mh$ = FindNLSStringEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNLSStringEx", lpLocaleName, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound, lpVersionInformation, lpReserved, sortHandle);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound, lpVersionInformation, lpReserved, sortHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCMapStringEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LCMapStringEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static FunctionDescriptor LCMapStringEx$descriptor() {
        return LCMapStringEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MethodHandle LCMapStringEx$handle() {
        return LCMapStringEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MemorySegment LCMapStringEx$address() {
        return LCMapStringEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static int LCMapStringEx(MemorySegment lpLocaleName, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest, MemorySegment lpVersionInformation, MemorySegment lpReserved, long sortHandle) {
        var mh$ = LCMapStringEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCMapStringEx", lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, lpVersionInformation, lpReserved, sortHandle);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, lpVersionInformation, lpReserved, sortHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsValidLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static FunctionDescriptor IsValidLocaleName$descriptor() {
        return IsValidLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static MethodHandle IsValidLocaleName$handle() {
        return IsValidLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static MemorySegment IsValidLocaleName$address() {
        return IsValidLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static int IsValidLocaleName(MemorySegment lpLocaleName) {
        var mh$ = IsValidLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidLocaleName", lpLocaleName);
            }
            return (int)mh$.invokeExact(lpLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoExEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumCalendarInfoExEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoExEx$descriptor() {
        return EnumCalendarInfoExEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumCalendarInfoExEx$handle() {
        return EnumCalendarInfoExEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumCalendarInfoExEx$address() {
        return EnumCalendarInfoExEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static int EnumCalendarInfoExEx(MemorySegment pCalInfoEnumProcExEx, MemorySegment lpLocaleName, int Calendar, MemorySegment lpReserved, int CalType, long lParam) {
        var mh$ = EnumCalendarInfoExEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoExEx", pCalInfoEnumProcExEx, lpLocaleName, Calendar, lpReserved, CalType, lParam);
            }
            return (int)mh$.invokeExact(pCalInfoEnumProcExEx, lpLocaleName, Calendar, lpReserved, CalType, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsExEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumDateFormatsExEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsExEx$descriptor() {
        return EnumDateFormatsExEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDateFormatsExEx$handle() {
        return EnumDateFormatsExEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDateFormatsExEx$address() {
        return EnumDateFormatsExEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static int EnumDateFormatsExEx(MemorySegment lpDateFmtEnumProcExEx, MemorySegment lpLocaleName, int dwFlags, long lParam) {
        var mh$ = EnumDateFormatsExEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsExEx", lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumTimeFormatsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumTimeFormatsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumTimeFormatsEx$descriptor() {
        return EnumTimeFormatsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumTimeFormatsEx$handle() {
        return EnumTimeFormatsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumTimeFormatsEx$address() {
        return EnumTimeFormatsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static int EnumTimeFormatsEx(MemorySegment lpTimeFmtEnumProcEx, MemorySegment lpLocaleName, int dwFlags, long lParam) {
        var mh$ = EnumTimeFormatsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumTimeFormatsEx", lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLocalesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnumSystemLocalesEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor EnumSystemLocalesEx$descriptor() {
        return EnumSystemLocalesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static MethodHandle EnumSystemLocalesEx$handle() {
        return EnumSystemLocalesEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static MemorySegment EnumSystemLocalesEx$address() {
        return EnumSystemLocalesEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static int EnumSystemLocalesEx(MemorySegment lpLocaleEnumProcEx, int dwFlags, long lParam, MemorySegment lpReserved) {
        var mh$ = EnumSystemLocalesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLocalesEx", lpLocaleEnumProcEx, dwFlags, lParam, lpReserved);
            }
            return (int)mh$.invokeExact(lpLocaleEnumProcEx, dwFlags, lParam, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResolveLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ResolveLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static FunctionDescriptor ResolveLocaleName$descriptor() {
        return ResolveLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MethodHandle ResolveLocaleName$handle() {
        return ResolveLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MemorySegment ResolveLocaleName$address() {
        return ResolveLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static int ResolveLocaleName(MemorySegment lpNameToResolve, MemorySegment lpLocaleName, int cchLocaleName) {
        var mh$ = ResolveLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResolveLocaleName", lpNameToResolve, lpLocaleName, cchLocaleName);
            }
            return (int)mh$.invokeExact(lpNameToResolve, lpLocaleName, cchLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _COORD {
     *     SHORT X;
     *     SHORT Y;
     * } *PCOORD
     * }
     */
    public static final AddressLayout PCOORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SMALL_RECT {
     *     SHORT Left;
     *     SHORT Top;
     *     SHORT Right;
     *     SHORT Bottom;
     * } *PSMALL_RECT
     * }
     */
    public static final AddressLayout PSMALL_RECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KEY_EVENT_RECORD {
     *     BOOL bKeyDown;
     *     WORD wRepeatCount;
     *     WORD wVirtualKeyCode;
     *     WORD wVirtualScanCode;
     *     union {
     *         WCHAR UnicodeChar;
     *         CHAR AsciiChar;
     *     } uChar;
     *     DWORD dwControlKeyState;
     * } *PKEY_EVENT_RECORD
     * }
     */
    public static final AddressLayout PKEY_EVENT_RECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MOUSE_EVENT_RECORD {
     *     COORD dwMousePosition;
     *     DWORD dwButtonState;
     *     DWORD dwControlKeyState;
     *     DWORD dwEventFlags;
     * } *PMOUSE_EVENT_RECORD
     * }
     */
    public static final AddressLayout PMOUSE_EVENT_RECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WINDOW_BUFFER_SIZE_RECORD {
     *     COORD dwSize;
     * } *PWINDOW_BUFFER_SIZE_RECORD
     * }
     */
    public static final AddressLayout PWINDOW_BUFFER_SIZE_RECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MENU_EVENT_RECORD {
     *     UINT dwCommandId;
     * } *PMENU_EVENT_RECORD
     * }
     */
    public static final AddressLayout PMENU_EVENT_RECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FOCUS_EVENT_RECORD {
     *     BOOL bSetFocus;
     * } *PFOCUS_EVENT_RECORD
     * }
     */
    public static final AddressLayout PFOCUS_EVENT_RECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _INPUT_RECORD {
     *     WORD EventType;
     *     union {
     *         KEY_EVENT_RECORD KeyEvent;
     *         MOUSE_EVENT_RECORD MouseEvent;
     *         WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
     *         MENU_EVENT_RECORD MenuEvent;
     *         FOCUS_EVENT_RECORD FocusEvent;
     *     } Event;
     * } *PINPUT_RECORD
     * }
     */
    public static final AddressLayout PINPUT_RECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CHAR_INFO {
     *     union {
     *         WCHAR UnicodeChar;
     *         CHAR AsciiChar;
     *     } Char;
     *     WORD Attributes;
     * } *PCHAR_INFO
     * }
     */
    public static final AddressLayout PCHAR_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_FONT_INFO {
     *     DWORD nFont;
     *     COORD dwFontSize;
     * } *PCONSOLE_FONT_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_FONT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HPCON
     * }
     */
    public static final AddressLayout HPCON = winapi.C_POINTER;

    private static class AllocConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("AllocConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static FunctionDescriptor AllocConsole$descriptor() {
        return AllocConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static MethodHandle AllocConsole$handle() {
        return AllocConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static MemorySegment AllocConsole$address() {
        return AllocConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static int AllocConsole() {
        var mh$ = AllocConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocConsole");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ALLOC_CONSOLE_MODE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ALLOC_CONSOLE_MODE.ALLOC_CONSOLE_MODE_DEFAULT = 0
     * }
     */
    public static int ALLOC_CONSOLE_MODE_DEFAULT() {
        return ALLOC_CONSOLE_MODE_DEFAULT;
    }
    private static final int ALLOC_CONSOLE_MODE_NEW_WINDOW = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ALLOC_CONSOLE_MODE.ALLOC_CONSOLE_MODE_NEW_WINDOW = 1
     * }
     */
    public static int ALLOC_CONSOLE_MODE_NEW_WINDOW() {
        return ALLOC_CONSOLE_MODE_NEW_WINDOW;
    }
    private static final int ALLOC_CONSOLE_MODE_NO_WINDOW = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ALLOC_CONSOLE_MODE.ALLOC_CONSOLE_MODE_NO_WINDOW = 2
     * }
     */
    public static int ALLOC_CONSOLE_MODE_NO_WINDOW() {
        return ALLOC_CONSOLE_MODE_NO_WINDOW;
    }
    /**
     * {@snippet lang=c :
     * typedef struct ALLOC_CONSOLE_OPTIONS {
     *     ALLOC_CONSOLE_MODE mode;
     *     BOOL useShowWindow;
     *     WORD showWindow;
     * } *PALLOC_CONSOLE_OPTIONS
     * }
     */
    public static final AddressLayout PALLOC_CONSOLE_OPTIONS = winapi.C_POINTER;
    private static final int ALLOC_CONSOLE_RESULT_NO_CONSOLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ALLOC_CONSOLE_RESULT.ALLOC_CONSOLE_RESULT_NO_CONSOLE = 0
     * }
     */
    public static int ALLOC_CONSOLE_RESULT_NO_CONSOLE() {
        return ALLOC_CONSOLE_RESULT_NO_CONSOLE;
    }
    private static final int ALLOC_CONSOLE_RESULT_NEW_CONSOLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ALLOC_CONSOLE_RESULT.ALLOC_CONSOLE_RESULT_NEW_CONSOLE = 1
     * }
     */
    public static int ALLOC_CONSOLE_RESULT_NEW_CONSOLE() {
        return ALLOC_CONSOLE_RESULT_NEW_CONSOLE;
    }
    private static final int ALLOC_CONSOLE_RESULT_EXISTING_CONSOLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ALLOC_CONSOLE_RESULT.ALLOC_CONSOLE_RESULT_EXISTING_CONSOLE = 2
     * }
     */
    public static int ALLOC_CONSOLE_RESULT_EXISTING_CONSOLE() {
        return ALLOC_CONSOLE_RESULT_EXISTING_CONSOLE;
    }
    /**
     * {@snippet lang=c :
     * typedef enum ALLOC_CONSOLE_RESULT {
     *     ALLOC_CONSOLE_RESULT_NO_CONSOLE = 0,
     *     ALLOC_CONSOLE_RESULT_NEW_CONSOLE = 1,
     *     ALLOC_CONSOLE_RESULT_EXISTING_CONSOLE = 2
     * } *PALLOC_CONSOLE_RESULT
     * }
     */
    public static final AddressLayout PALLOC_CONSOLE_RESULT = winapi.C_POINTER;

    private static class AllocConsoleWithOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AllocConsoleWithOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT AllocConsoleWithOptions(PALLOC_CONSOLE_OPTIONS options, PALLOC_CONSOLE_RESULT result)
     * }
     */
    public static FunctionDescriptor AllocConsoleWithOptions$descriptor() {
        return AllocConsoleWithOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT AllocConsoleWithOptions(PALLOC_CONSOLE_OPTIONS options, PALLOC_CONSOLE_RESULT result)
     * }
     */
    public static MethodHandle AllocConsoleWithOptions$handle() {
        return AllocConsoleWithOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT AllocConsoleWithOptions(PALLOC_CONSOLE_OPTIONS options, PALLOC_CONSOLE_RESULT result)
     * }
     */
    public static MemorySegment AllocConsoleWithOptions$address() {
        return AllocConsoleWithOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT AllocConsoleWithOptions(PALLOC_CONSOLE_OPTIONS options, PALLOC_CONSOLE_RESULT result)
     * }
     */
    public static int AllocConsoleWithOptions(MemorySegment options, MemorySegment result) {
        var mh$ = AllocConsoleWithOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocConsoleWithOptions", options, result);
            }
            return (int)mh$.invokeExact(options, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("FreeConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static FunctionDescriptor FreeConsole$descriptor() {
        return FreeConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static MethodHandle FreeConsole$handle() {
        return FreeConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static MemorySegment FreeConsole$address() {
        return FreeConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static int FreeConsole() {
        var mh$ = FreeConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeConsole");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AttachConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor AttachConsole$descriptor() {
        return AttachConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static MethodHandle AttachConsole$handle() {
        return AttachConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static MemorySegment AttachConsole$address() {
        return AttachConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static int AttachConsole(int dwProcessId) {
        var mh$ = AttachConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachConsole", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static FunctionDescriptor GetConsoleCP$descriptor() {
        return GetConsoleCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static MethodHandle GetConsoleCP$handle() {
        return GetConsoleCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static MemorySegment GetConsoleCP$address() {
        return GetConsoleCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static int GetConsoleCP() {
        var mh$ = GetConsoleCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleOutputCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleOutputCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static FunctionDescriptor GetConsoleOutputCP$descriptor() {
        return GetConsoleOutputCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static MethodHandle GetConsoleOutputCP$handle() {
        return GetConsoleOutputCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static MemorySegment GetConsoleOutputCP$address() {
        return GetConsoleOutputCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static int GetConsoleOutputCP() {
        var mh$ = GetConsoleOutputCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleOutputCP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static FunctionDescriptor GetConsoleMode$descriptor() {
        return GetConsoleMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static MethodHandle GetConsoleMode$handle() {
        return GetConsoleMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static MemorySegment GetConsoleMode$address() {
        return GetConsoleMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static int GetConsoleMode(MemorySegment hConsoleHandle, MemorySegment lpMode) {
        var mh$ = GetConsoleMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleMode", hConsoleHandle, lpMode);
            }
            return (int)mh$.invokeExact(hConsoleHandle, lpMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static FunctionDescriptor SetConsoleMode$descriptor() {
        return SetConsoleMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static MethodHandle SetConsoleMode$handle() {
        return SetConsoleMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static MemorySegment SetConsoleMode$address() {
        return SetConsoleMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static int SetConsoleMode(MemorySegment hConsoleHandle, int dwMode) {
        var mh$ = SetConsoleMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleMode", hConsoleHandle, dwMode);
            }
            return (int)mh$.invokeExact(hConsoleHandle, dwMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberOfConsoleInputEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumberOfConsoleInputEvents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static FunctionDescriptor GetNumberOfConsoleInputEvents$descriptor() {
        return GetNumberOfConsoleInputEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static MethodHandle GetNumberOfConsoleInputEvents$handle() {
        return GetNumberOfConsoleInputEvents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static MemorySegment GetNumberOfConsoleInputEvents$address() {
        return GetNumberOfConsoleInputEvents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static int GetNumberOfConsoleInputEvents(MemorySegment hConsoleInput, MemorySegment lpNumberOfEvents) {
        var mh$ = GetNumberOfConsoleInputEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberOfConsoleInputEvents", hConsoleInput, lpNumberOfEvents);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpNumberOfEvents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleInputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadConsoleInputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleInputA$descriptor() {
        return ReadConsoleInputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle ReadConsoleInputA$handle() {
        return ReadConsoleInputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MemorySegment ReadConsoleInputA$address() {
        return ReadConsoleInputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int ReadConsoleInputA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = ReadConsoleInputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleInputA", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleInputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadConsoleInputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleInputW$descriptor() {
        return ReadConsoleInputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle ReadConsoleInputW$handle() {
        return ReadConsoleInputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MemorySegment ReadConsoleInputW$address() {
        return ReadConsoleInputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int ReadConsoleInputW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = ReadConsoleInputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleInputW", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekConsoleInputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PeekConsoleInputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor PeekConsoleInputA$descriptor() {
        return PeekConsoleInputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle PeekConsoleInputA$handle() {
        return PeekConsoleInputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MemorySegment PeekConsoleInputA$address() {
        return PeekConsoleInputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int PeekConsoleInputA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = PeekConsoleInputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekConsoleInputA", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekConsoleInputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PeekConsoleInputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor PeekConsoleInputW$descriptor() {
        return PeekConsoleInputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle PeekConsoleInputW$handle() {
        return PeekConsoleInputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MemorySegment PeekConsoleInputW$address() {
        return PeekConsoleInputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int PeekConsoleInputW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = PeekConsoleInputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekConsoleInputW", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_READCONSOLE_CONTROL {
     *     ULONG nLength;
     *     ULONG nInitialChars;
     *     ULONG dwCtrlWakeupMask;
     *     ULONG dwControlKeyState;
     * } *PCONSOLE_READCONSOLE_CONTROL
     * }
     */
    public static final AddressLayout PCONSOLE_READCONSOLE_CONTROL = winapi.C_POINTER;

    private static class ReadConsoleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadConsoleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static FunctionDescriptor ReadConsoleA$descriptor() {
        return ReadConsoleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MethodHandle ReadConsoleA$handle() {
        return ReadConsoleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MemorySegment ReadConsoleA$address() {
        return ReadConsoleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static int ReadConsoleA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nNumberOfCharsToRead, MemorySegment lpNumberOfCharsRead, MemorySegment pInputControl) {
        var mh$ = ReadConsoleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleA", hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadConsoleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static FunctionDescriptor ReadConsoleW$descriptor() {
        return ReadConsoleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MethodHandle ReadConsoleW$handle() {
        return ReadConsoleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MemorySegment ReadConsoleW$address() {
        return ReadConsoleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static int ReadConsoleW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nNumberOfCharsToRead, MemorySegment lpNumberOfCharsRead, MemorySegment pInputControl) {
        var mh$ = ReadConsoleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleW", hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteConsoleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor WriteConsoleA$descriptor() {
        return WriteConsoleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MethodHandle WriteConsoleA$handle() {
        return WriteConsoleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MemorySegment WriteConsoleA$address() {
        return WriteConsoleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static int WriteConsoleA(MemorySegment hConsoleOutput, MemorySegment lpBuffer, int nNumberOfCharsToWrite, MemorySegment lpNumberOfCharsWritten, MemorySegment lpReserved) {
        var mh$ = WriteConsoleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleA", hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteConsoleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor WriteConsoleW$descriptor() {
        return WriteConsoleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MethodHandle WriteConsoleW$handle() {
        return WriteConsoleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MemorySegment WriteConsoleW$address() {
        return WriteConsoleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static int WriteConsoleW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, int nNumberOfCharsToWrite, MemorySegment lpNumberOfCharsWritten, MemorySegment lpReserved) {
        var mh$ = WriteConsoleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleW", hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCtrlHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleCtrlHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static FunctionDescriptor SetConsoleCtrlHandler$descriptor() {
        return SetConsoleCtrlHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static MethodHandle SetConsoleCtrlHandler$handle() {
        return SetConsoleCtrlHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static MemorySegment SetConsoleCtrlHandler$address() {
        return SetConsoleCtrlHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static int SetConsoleCtrlHandler(MemorySegment HandlerRoutine, int Add) {
        var mh$ = SetConsoleCtrlHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCtrlHandler", HandlerRoutine, Add);
            }
            return (int)mh$.invokeExact(HandlerRoutine, Add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreatePseudoConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static FunctionDescriptor CreatePseudoConsole$descriptor() {
        return CreatePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static MethodHandle CreatePseudoConsole$handle() {
        return CreatePseudoConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static MemorySegment CreatePseudoConsole$address() {
        return CreatePseudoConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static int CreatePseudoConsole(MemorySegment size, MemorySegment hInput, MemorySegment hOutput, int dwFlags, MemorySegment phPC) {
        var mh$ = CreatePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePseudoConsole", size, hInput, hOutput, dwFlags, phPC);
            }
            return (int)mh$.invokeExact(size, hInput, hOutput, dwFlags, phPC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResizePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            _COORD.layout()
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ResizePseudoConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static FunctionDescriptor ResizePseudoConsole$descriptor() {
        return ResizePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static MethodHandle ResizePseudoConsole$handle() {
        return ResizePseudoConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static MemorySegment ResizePseudoConsole$address() {
        return ResizePseudoConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static int ResizePseudoConsole(MemorySegment hPC, MemorySegment size) {
        var mh$ = ResizePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResizePseudoConsole", hPC, size);
            }
            return (int)mh$.invokeExact(hPC, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClosePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ClosePseudoConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static FunctionDescriptor ClosePseudoConsole$descriptor() {
        return ClosePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static MethodHandle ClosePseudoConsole$handle() {
        return ClosePseudoConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static MemorySegment ClosePseudoConsole$address() {
        return ClosePseudoConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static void ClosePseudoConsole(MemorySegment hPC) {
        var mh$ = ClosePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClosePseudoConsole", hPC);
            }
            mh$.invokeExact(hPC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleasePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReleasePseudoConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ReleasePseudoConsole(HPCON hPC)
     * }
     */
    public static FunctionDescriptor ReleasePseudoConsole$descriptor() {
        return ReleasePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ReleasePseudoConsole(HPCON hPC)
     * }
     */
    public static MethodHandle ReleasePseudoConsole$handle() {
        return ReleasePseudoConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ReleasePseudoConsole(HPCON hPC)
     * }
     */
    public static MemorySegment ReleasePseudoConsole$address() {
        return ReleasePseudoConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ReleasePseudoConsole(HPCON hPC)
     * }
     */
    public static int ReleasePseudoConsole(MemorySegment hPC) {
        var mh$ = ReleasePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleasePseudoConsole", hPC);
            }
            return (int)mh$.invokeExact(hPC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillConsoleOutputCharacterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_CHAR,
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FillConsoleOutputCharacterA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor FillConsoleOutputCharacterA$descriptor() {
        return FillConsoleOutputCharacterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle FillConsoleOutputCharacterA$handle() {
        return FillConsoleOutputCharacterA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MemorySegment FillConsoleOutputCharacterA$address() {
        return FillConsoleOutputCharacterA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int FillConsoleOutputCharacterA(MemorySegment hConsoleOutput, byte cCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = FillConsoleOutputCharacterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillConsoleOutputCharacterA", hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillConsoleOutputCharacterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_SHORT,
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FillConsoleOutputCharacterW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor FillConsoleOutputCharacterW$descriptor() {
        return FillConsoleOutputCharacterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle FillConsoleOutputCharacterW$handle() {
        return FillConsoleOutputCharacterW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MemorySegment FillConsoleOutputCharacterW$address() {
        return FillConsoleOutputCharacterW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int FillConsoleOutputCharacterW(MemorySegment hConsoleOutput, short cCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = FillConsoleOutputCharacterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillConsoleOutputCharacterW", hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillConsoleOutputAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_SHORT,
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FillConsoleOutputAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static FunctionDescriptor FillConsoleOutputAttribute$descriptor() {
        return FillConsoleOutputAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MethodHandle FillConsoleOutputAttribute$handle() {
        return FillConsoleOutputAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MemorySegment FillConsoleOutputAttribute$address() {
        return FillConsoleOutputAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static int FillConsoleOutputAttribute(MemorySegment hConsoleOutput, short wAttribute, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfAttrsWritten) {
        var mh$ = FillConsoleOutputAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillConsoleOutputAttribute", hConsoleOutput, wAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, wAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenerateConsoleCtrlEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GenerateConsoleCtrlEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static FunctionDescriptor GenerateConsoleCtrlEvent$descriptor() {
        return GenerateConsoleCtrlEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static MethodHandle GenerateConsoleCtrlEvent$handle() {
        return GenerateConsoleCtrlEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static MemorySegment GenerateConsoleCtrlEvent$address() {
        return GenerateConsoleCtrlEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static int GenerateConsoleCtrlEvent(int dwCtrlEvent, int dwProcessGroupId) {
        var mh$ = GenerateConsoleCtrlEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenerateConsoleCtrlEvent", dwCtrlEvent, dwProcessGroupId);
            }
            return (int)mh$.invokeExact(dwCtrlEvent, dwProcessGroupId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateConsoleScreenBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateConsoleScreenBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static FunctionDescriptor CreateConsoleScreenBuffer$descriptor() {
        return CreateConsoleScreenBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static MethodHandle CreateConsoleScreenBuffer$handle() {
        return CreateConsoleScreenBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static MemorySegment CreateConsoleScreenBuffer$address() {
        return CreateConsoleScreenBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static MemorySegment CreateConsoleScreenBuffer(int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwFlags, MemorySegment lpScreenBufferData) {
        var mh$ = CreateConsoleScreenBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateConsoleScreenBuffer", dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlags, lpScreenBufferData);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlags, lpScreenBufferData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleActiveScreenBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleActiveScreenBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static FunctionDescriptor SetConsoleActiveScreenBuffer$descriptor() {
        return SetConsoleActiveScreenBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static MethodHandle SetConsoleActiveScreenBuffer$handle() {
        return SetConsoleActiveScreenBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static MemorySegment SetConsoleActiveScreenBuffer$address() {
        return SetConsoleActiveScreenBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static int SetConsoleActiveScreenBuffer(MemorySegment hConsoleOutput) {
        var mh$ = SetConsoleActiveScreenBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleActiveScreenBuffer", hConsoleOutput);
            }
            return (int)mh$.invokeExact(hConsoleOutput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushConsoleInputBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FlushConsoleInputBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static FunctionDescriptor FlushConsoleInputBuffer$descriptor() {
        return FlushConsoleInputBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static MethodHandle FlushConsoleInputBuffer$handle() {
        return FlushConsoleInputBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static MemorySegment FlushConsoleInputBuffer$address() {
        return FlushConsoleInputBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static int FlushConsoleInputBuffer(MemorySegment hConsoleInput) {
        var mh$ = FlushConsoleInputBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushConsoleInputBuffer", hConsoleInput);
            }
            return (int)mh$.invokeExact(hConsoleInput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static FunctionDescriptor SetConsoleCP$descriptor() {
        return SetConsoleCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static MethodHandle SetConsoleCP$handle() {
        return SetConsoleCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static MemorySegment SetConsoleCP$address() {
        return SetConsoleCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static int SetConsoleCP(int wCodePageID) {
        var mh$ = SetConsoleCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCP", wCodePageID);
            }
            return (int)mh$.invokeExact(wCodePageID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleOutputCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleOutputCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static FunctionDescriptor SetConsoleOutputCP$descriptor() {
        return SetConsoleOutputCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static MethodHandle SetConsoleOutputCP$handle() {
        return SetConsoleOutputCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static MemorySegment SetConsoleOutputCP$address() {
        return SetConsoleOutputCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static int SetConsoleOutputCP(int wCodePageID) {
        var mh$ = SetConsoleOutputCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleOutputCP", wCodePageID);
            }
            return (int)mh$.invokeExact(wCodePageID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_CURSOR_INFO {
     *     DWORD dwSize;
     *     BOOL bVisible;
     * } *PCONSOLE_CURSOR_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_CURSOR_INFO = winapi.C_POINTER;

    private static class GetConsoleCursorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleCursorInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleCursorInfo$descriptor() {
        return GetConsoleCursorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static MethodHandle GetConsoleCursorInfo$handle() {
        return GetConsoleCursorInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static MemorySegment GetConsoleCursorInfo$address() {
        return GetConsoleCursorInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static int GetConsoleCursorInfo(MemorySegment hConsoleOutput, MemorySegment lpConsoleCursorInfo) {
        var mh$ = GetConsoleCursorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCursorInfo", hConsoleOutput, lpConsoleCursorInfo);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleCursorInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCursorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleCursorInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static FunctionDescriptor SetConsoleCursorInfo$descriptor() {
        return SetConsoleCursorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static MethodHandle SetConsoleCursorInfo$handle() {
        return SetConsoleCursorInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static MemorySegment SetConsoleCursorInfo$address() {
        return SetConsoleCursorInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static int SetConsoleCursorInfo(MemorySegment hConsoleOutput, MemorySegment lpConsoleCursorInfo) {
        var mh$ = SetConsoleCursorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCursorInfo", hConsoleOutput, lpConsoleCursorInfo);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleCursorInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
     *     COORD dwSize;
     *     COORD dwCursorPosition;
     *     WORD wAttributes;
     *     SMALL_RECT srWindow;
     *     COORD dwMaximumWindowSize;
     * } *PCONSOLE_SCREEN_BUFFER_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_SCREEN_BUFFER_INFO = winapi.C_POINTER;

    private static class GetConsoleScreenBufferInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleScreenBufferInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleScreenBufferInfo$descriptor() {
        return GetConsoleScreenBufferInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static MethodHandle GetConsoleScreenBufferInfo$handle() {
        return GetConsoleScreenBufferInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static MemorySegment GetConsoleScreenBufferInfo$address() {
        return GetConsoleScreenBufferInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static int GetConsoleScreenBufferInfo(MemorySegment hConsoleOutput, MemorySegment lpConsoleScreenBufferInfo) {
        var mh$ = GetConsoleScreenBufferInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleScreenBufferInfo", hConsoleOutput, lpConsoleScreenBufferInfo);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
     *     ULONG cbSize;
     *     COORD dwSize;
     *     COORD dwCursorPosition;
     *     WORD wAttributes;
     *     SMALL_RECT srWindow;
     *     COORD dwMaximumWindowSize;
     *     WORD wPopupAttributes;
     *     BOOL bFullscreenSupported;
     *     COLORREF ColorTable[16];
     * } *PCONSOLE_SCREEN_BUFFER_INFOEX
     * }
     */
    public static final AddressLayout PCONSOLE_SCREEN_BUFFER_INFOEX = winapi.C_POINTER;

    private static class GetConsoleScreenBufferInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleScreenBufferInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static FunctionDescriptor GetConsoleScreenBufferInfoEx$descriptor() {
        return GetConsoleScreenBufferInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MethodHandle GetConsoleScreenBufferInfoEx$handle() {
        return GetConsoleScreenBufferInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MemorySegment GetConsoleScreenBufferInfoEx$address() {
        return GetConsoleScreenBufferInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static int GetConsoleScreenBufferInfoEx(MemorySegment hConsoleOutput, MemorySegment lpConsoleScreenBufferInfoEx) {
        var mh$ = GetConsoleScreenBufferInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleScreenBufferInfoEx", hConsoleOutput, lpConsoleScreenBufferInfoEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleScreenBufferInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleScreenBufferInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static FunctionDescriptor SetConsoleScreenBufferInfoEx$descriptor() {
        return SetConsoleScreenBufferInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MethodHandle SetConsoleScreenBufferInfoEx$handle() {
        return SetConsoleScreenBufferInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MemorySegment SetConsoleScreenBufferInfoEx$address() {
        return SetConsoleScreenBufferInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static int SetConsoleScreenBufferInfoEx(MemorySegment hConsoleOutput, MemorySegment lpConsoleScreenBufferInfoEx) {
        var mh$ = SetConsoleScreenBufferInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleScreenBufferInfoEx", hConsoleOutput, lpConsoleScreenBufferInfoEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleScreenBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            _COORD.layout()
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleScreenBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static FunctionDescriptor SetConsoleScreenBufferSize$descriptor() {
        return SetConsoleScreenBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static MethodHandle SetConsoleScreenBufferSize$handle() {
        return SetConsoleScreenBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static MemorySegment SetConsoleScreenBufferSize$address() {
        return SetConsoleScreenBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static int SetConsoleScreenBufferSize(MemorySegment hConsoleOutput, MemorySegment dwSize) {
        var mh$ = SetConsoleScreenBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleScreenBufferSize", hConsoleOutput, dwSize);
            }
            return (int)mh$.invokeExact(hConsoleOutput, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCursorPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            _COORD.layout()
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleCursorPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static FunctionDescriptor SetConsoleCursorPosition$descriptor() {
        return SetConsoleCursorPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static MethodHandle SetConsoleCursorPosition$handle() {
        return SetConsoleCursorPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static MemorySegment SetConsoleCursorPosition$address() {
        return SetConsoleCursorPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static int SetConsoleCursorPosition(MemorySegment hConsoleOutput, MemorySegment dwCursorPosition) {
        var mh$ = SetConsoleCursorPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCursorPosition", hConsoleOutput, dwCursorPosition);
            }
            return (int)mh$.invokeExact(hConsoleOutput, dwCursorPosition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLargestConsoleWindowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLargestConsoleWindowSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static FunctionDescriptor GetLargestConsoleWindowSize$descriptor() {
        return GetLargestConsoleWindowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static MethodHandle GetLargestConsoleWindowSize$handle() {
        return GetLargestConsoleWindowSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static MemorySegment GetLargestConsoleWindowSize$address() {
        return GetLargestConsoleWindowSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static MemorySegment GetLargestConsoleWindowSize(SegmentAllocator allocator, MemorySegment hConsoleOutput) {
        var mh$ = GetLargestConsoleWindowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLargestConsoleWindowSize", allocator, hConsoleOutput);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hConsoleOutput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleTextAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_SHORT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleTextAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static FunctionDescriptor SetConsoleTextAttribute$descriptor() {
        return SetConsoleTextAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static MethodHandle SetConsoleTextAttribute$handle() {
        return SetConsoleTextAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static MemorySegment SetConsoleTextAttribute$address() {
        return SetConsoleTextAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static int SetConsoleTextAttribute(MemorySegment hConsoleOutput, short wAttributes) {
        var mh$ = SetConsoleTextAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleTextAttribute", hConsoleOutput, wAttributes);
            }
            return (int)mh$.invokeExact(hConsoleOutput, wAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleWindowInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleWindowInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static FunctionDescriptor SetConsoleWindowInfo$descriptor() {
        return SetConsoleWindowInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static MethodHandle SetConsoleWindowInfo$handle() {
        return SetConsoleWindowInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static MemorySegment SetConsoleWindowInfo$address() {
        return SetConsoleWindowInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static int SetConsoleWindowInfo(MemorySegment hConsoleOutput, int bAbsolute, MemorySegment lpConsoleWindow) {
        var mh$ = SetConsoleWindowInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleWindowInfo", hConsoleOutput, bAbsolute, lpConsoleWindow);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bAbsolute, lpConsoleWindow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputCharacterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteConsoleOutputCharacterA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputCharacterA$descriptor() {
        return WriteConsoleOutputCharacterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle WriteConsoleOutputCharacterA$handle() {
        return WriteConsoleOutputCharacterA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MemorySegment WriteConsoleOutputCharacterA$address() {
        return WriteConsoleOutputCharacterA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int WriteConsoleOutputCharacterA(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = WriteConsoleOutputCharacterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputCharacterA", hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputCharacterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteConsoleOutputCharacterW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputCharacterW$descriptor() {
        return WriteConsoleOutputCharacterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle WriteConsoleOutputCharacterW$handle() {
        return WriteConsoleOutputCharacterW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MemorySegment WriteConsoleOutputCharacterW$address() {
        return WriteConsoleOutputCharacterW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int WriteConsoleOutputCharacterW(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = WriteConsoleOutputCharacterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputCharacterW", hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteConsoleOutputAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputAttribute$descriptor() {
        return WriteConsoleOutputAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MethodHandle WriteConsoleOutputAttribute$handle() {
        return WriteConsoleOutputAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MemorySegment WriteConsoleOutputAttribute$address() {
        return WriteConsoleOutputAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static int WriteConsoleOutputAttribute(MemorySegment hConsoleOutput, MemorySegment lpAttribute, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfAttrsWritten) {
        var mh$ = WriteConsoleOutputAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputAttribute", hConsoleOutput, lpAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputCharacterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadConsoleOutputCharacterA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputCharacterA$descriptor() {
        return ReadConsoleOutputCharacterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MethodHandle ReadConsoleOutputCharacterA$handle() {
        return ReadConsoleOutputCharacterA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MemorySegment ReadConsoleOutputCharacterA$address() {
        return ReadConsoleOutputCharacterA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static int ReadConsoleOutputCharacterA(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwReadCoord, MemorySegment lpNumberOfCharsRead) {
        var mh$ = ReadConsoleOutputCharacterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputCharacterA", hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputCharacterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadConsoleOutputCharacterW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputCharacterW$descriptor() {
        return ReadConsoleOutputCharacterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MethodHandle ReadConsoleOutputCharacterW$handle() {
        return ReadConsoleOutputCharacterW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MemorySegment ReadConsoleOutputCharacterW$address() {
        return ReadConsoleOutputCharacterW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static int ReadConsoleOutputCharacterW(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwReadCoord, MemorySegment lpNumberOfCharsRead) {
        var mh$ = ReadConsoleOutputCharacterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputCharacterW", hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadConsoleOutputAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputAttribute$descriptor() {
        return ReadConsoleOutputAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static MethodHandle ReadConsoleOutputAttribute$handle() {
        return ReadConsoleOutputAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static MemorySegment ReadConsoleOutputAttribute$address() {
        return ReadConsoleOutputAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static int ReadConsoleOutputAttribute(MemorySegment hConsoleOutput, MemorySegment lpAttribute, int nLength, MemorySegment dwReadCoord, MemorySegment lpNumberOfAttrsRead) {
        var mh$ = ReadConsoleOutputAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputAttribute", hConsoleOutput, lpAttribute, nLength, dwReadCoord, lpNumberOfAttrsRead);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpAttribute, nLength, dwReadCoord, lpNumberOfAttrsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleInputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteConsoleInputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleInputA$descriptor() {
        return WriteConsoleInputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MethodHandle WriteConsoleInputA$handle() {
        return WriteConsoleInputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MemorySegment WriteConsoleInputA$address() {
        return WriteConsoleInputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static int WriteConsoleInputA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsWritten) {
        var mh$ = WriteConsoleInputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleInputA", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleInputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteConsoleInputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleInputW$descriptor() {
        return WriteConsoleInputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MethodHandle WriteConsoleInputW$handle() {
        return WriteConsoleInputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MemorySegment WriteConsoleInputW$address() {
        return WriteConsoleInputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static int WriteConsoleInputW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsWritten) {
        var mh$ = WriteConsoleInputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleInputW", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollConsoleScreenBufferA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ScrollConsoleScreenBufferA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static FunctionDescriptor ScrollConsoleScreenBufferA$descriptor() {
        return ScrollConsoleScreenBufferA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MethodHandle ScrollConsoleScreenBufferA$handle() {
        return ScrollConsoleScreenBufferA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MemorySegment ScrollConsoleScreenBufferA$address() {
        return ScrollConsoleScreenBufferA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static int ScrollConsoleScreenBufferA(MemorySegment hConsoleOutput, MemorySegment lpScrollRectangle, MemorySegment lpClipRectangle, MemorySegment dwDestinationOrigin, MemorySegment lpFill) {
        var mh$ = ScrollConsoleScreenBufferA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollConsoleScreenBufferA", hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollConsoleScreenBufferW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ScrollConsoleScreenBufferW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static FunctionDescriptor ScrollConsoleScreenBufferW$descriptor() {
        return ScrollConsoleScreenBufferW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MethodHandle ScrollConsoleScreenBufferW$handle() {
        return ScrollConsoleScreenBufferW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MemorySegment ScrollConsoleScreenBufferW$address() {
        return ScrollConsoleScreenBufferW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static int ScrollConsoleScreenBufferW(MemorySegment hConsoleOutput, MemorySegment lpScrollRectangle, MemorySegment lpClipRectangle, MemorySegment dwDestinationOrigin, MemorySegment lpFill) {
        var mh$ = ScrollConsoleScreenBufferW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollConsoleScreenBufferW", hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteConsoleOutputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputA$descriptor() {
        return WriteConsoleOutputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MethodHandle WriteConsoleOutputA$handle() {
        return WriteConsoleOutputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MemorySegment WriteConsoleOutputA$address() {
        return WriteConsoleOutputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static int WriteConsoleOutputA(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpWriteRegion) {
        var mh$ = WriteConsoleOutputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputA", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteConsoleOutputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputW$descriptor() {
        return WriteConsoleOutputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MethodHandle WriteConsoleOutputW$handle() {
        return WriteConsoleOutputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MemorySegment WriteConsoleOutputW$address() {
        return WriteConsoleOutputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static int WriteConsoleOutputW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpWriteRegion) {
        var mh$ = WriteConsoleOutputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputW", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadConsoleOutputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputA$descriptor() {
        return ReadConsoleOutputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MethodHandle ReadConsoleOutputA$handle() {
        return ReadConsoleOutputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MemorySegment ReadConsoleOutputA$address() {
        return ReadConsoleOutputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static int ReadConsoleOutputA(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpReadRegion) {
        var mh$ = ReadConsoleOutputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputA", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadConsoleOutputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputW$descriptor() {
        return ReadConsoleOutputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MethodHandle ReadConsoleOutputW$handle() {
        return ReadConsoleOutputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MemorySegment ReadConsoleOutputW$address() {
        return ReadConsoleOutputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static int ReadConsoleOutputW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpReadRegion) {
        var mh$ = ReadConsoleOutputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputW", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleTitleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleTitleA$descriptor() {
        return GetConsoleTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleTitleA$handle() {
        return GetConsoleTitleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MemorySegment GetConsoleTitleA$address() {
        return GetConsoleTitleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleTitleA(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleTitleA", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleTitleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleTitleW$descriptor() {
        return GetConsoleTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleTitleW$handle() {
        return GetConsoleTitleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MemorySegment GetConsoleTitleW$address() {
        return GetConsoleTitleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleTitleW(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleTitleW", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleOriginalTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleOriginalTitleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleOriginalTitleA$descriptor() {
        return GetConsoleOriginalTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleOriginalTitleA$handle() {
        return GetConsoleOriginalTitleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MemorySegment GetConsoleOriginalTitleA$address() {
        return GetConsoleOriginalTitleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleOriginalTitleA(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleOriginalTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleOriginalTitleA", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleOriginalTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleOriginalTitleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleOriginalTitleW$descriptor() {
        return GetConsoleOriginalTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleOriginalTitleW$handle() {
        return GetConsoleOriginalTitleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MemorySegment GetConsoleOriginalTitleW$address() {
        return GetConsoleOriginalTitleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleOriginalTitleW(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleOriginalTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleOriginalTitleW", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleTitleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static FunctionDescriptor SetConsoleTitleA$descriptor() {
        return SetConsoleTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static MethodHandle SetConsoleTitleA$handle() {
        return SetConsoleTitleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static MemorySegment SetConsoleTitleA$address() {
        return SetConsoleTitleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static int SetConsoleTitleA(MemorySegment lpConsoleTitle) {
        var mh$ = SetConsoleTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleTitleA", lpConsoleTitle);
            }
            return (int)mh$.invokeExact(lpConsoleTitle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleTitleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static FunctionDescriptor SetConsoleTitleW$descriptor() {
        return SetConsoleTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static MethodHandle SetConsoleTitleW$handle() {
        return SetConsoleTitleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static MemorySegment SetConsoleTitleW$address() {
        return SetConsoleTitleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static int SetConsoleTitleW(MemorySegment lpConsoleTitle) {
        var mh$ = SetConsoleTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleTitleW", lpConsoleTitle);
            }
            return (int)mh$.invokeExact(lpConsoleTitle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberOfConsoleMouseButtons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNumberOfConsoleMouseButtons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static FunctionDescriptor GetNumberOfConsoleMouseButtons$descriptor() {
        return GetNumberOfConsoleMouseButtons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static MethodHandle GetNumberOfConsoleMouseButtons$handle() {
        return GetNumberOfConsoleMouseButtons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static MemorySegment GetNumberOfConsoleMouseButtons$address() {
        return GetNumberOfConsoleMouseButtons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static int GetNumberOfConsoleMouseButtons(MemorySegment lpNumberOfMouseButtons) {
        var mh$ = GetNumberOfConsoleMouseButtons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberOfConsoleMouseButtons", lpNumberOfMouseButtons);
            }
            return (int)mh$.invokeExact(lpNumberOfMouseButtons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleFontSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _COORD.layout(),
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleFontSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static FunctionDescriptor GetConsoleFontSize$descriptor() {
        return GetConsoleFontSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static MethodHandle GetConsoleFontSize$handle() {
        return GetConsoleFontSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static MemorySegment GetConsoleFontSize$address() {
        return GetConsoleFontSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static MemorySegment GetConsoleFontSize(SegmentAllocator allocator, MemorySegment hConsoleOutput, int nFont) {
        var mh$ = GetConsoleFontSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleFontSize", allocator, hConsoleOutput, nFont);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hConsoleOutput, nFont);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentConsoleFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrentConsoleFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static FunctionDescriptor GetCurrentConsoleFont$descriptor() {
        return GetCurrentConsoleFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static MethodHandle GetCurrentConsoleFont$handle() {
        return GetCurrentConsoleFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static MemorySegment GetCurrentConsoleFont$address() {
        return GetCurrentConsoleFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static int GetCurrentConsoleFont(MemorySegment hConsoleOutput, int bMaximumWindow, MemorySegment lpConsoleCurrentFont) {
        var mh$ = GetCurrentConsoleFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentConsoleFont", hConsoleOutput, bMaximumWindow, lpConsoleCurrentFont);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFont);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_FONT_INFOEX {
     *     ULONG cbSize;
     *     DWORD nFont;
     *     COORD dwFontSize;
     *     UINT FontFamily;
     *     UINT FontWeight;
     *     WCHAR FaceName[32];
     * } *PCONSOLE_FONT_INFOEX
     * }
     */
    public static final AddressLayout PCONSOLE_FONT_INFOEX = winapi.C_POINTER;

    private static class GetCurrentConsoleFontEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrentConsoleFontEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static FunctionDescriptor GetCurrentConsoleFontEx$descriptor() {
        return GetCurrentConsoleFontEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MethodHandle GetCurrentConsoleFontEx$handle() {
        return GetCurrentConsoleFontEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MemorySegment GetCurrentConsoleFontEx$address() {
        return GetCurrentConsoleFontEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static int GetCurrentConsoleFontEx(MemorySegment hConsoleOutput, int bMaximumWindow, MemorySegment lpConsoleCurrentFontEx) {
        var mh$ = GetCurrentConsoleFontEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentConsoleFontEx", hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCurrentConsoleFontEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetCurrentConsoleFontEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static FunctionDescriptor SetCurrentConsoleFontEx$descriptor() {
        return SetCurrentConsoleFontEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MethodHandle SetCurrentConsoleFontEx$handle() {
        return SetCurrentConsoleFontEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MemorySegment SetCurrentConsoleFontEx$address() {
        return SetCurrentConsoleFontEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static int SetCurrentConsoleFontEx(MemorySegment hConsoleOutput, int bMaximumWindow, MemorySegment lpConsoleCurrentFontEx) {
        var mh$ = SetCurrentConsoleFontEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCurrentConsoleFontEx", hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_SELECTION_INFO {
     *     DWORD dwFlags;
     *     COORD dwSelectionAnchor;
     *     SMALL_RECT srSelection;
     * } *PCONSOLE_SELECTION_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_SELECTION_INFO = winapi.C_POINTER;

    private static class GetConsoleSelectionInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleSelectionInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleSelectionInfo$descriptor() {
        return GetConsoleSelectionInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static MethodHandle GetConsoleSelectionInfo$handle() {
        return GetConsoleSelectionInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static MemorySegment GetConsoleSelectionInfo$address() {
        return GetConsoleSelectionInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static int GetConsoleSelectionInfo(MemorySegment lpConsoleSelectionInfo) {
        var mh$ = GetConsoleSelectionInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleSelectionInfo", lpConsoleSelectionInfo);
            }
            return (int)mh$.invokeExact(lpConsoleSelectionInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_HISTORY_INFO {
     *     UINT cbSize;
     *     UINT HistoryBufferSize;
     *     UINT NumberOfHistoryBuffers;
     *     DWORD dwFlags;
     * } *PCONSOLE_HISTORY_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_HISTORY_INFO = winapi.C_POINTER;

    private static class GetConsoleHistoryInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleHistoryInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleHistoryInfo$descriptor() {
        return GetConsoleHistoryInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MethodHandle GetConsoleHistoryInfo$handle() {
        return GetConsoleHistoryInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MemorySegment GetConsoleHistoryInfo$address() {
        return GetConsoleHistoryInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static int GetConsoleHistoryInfo(MemorySegment lpConsoleHistoryInfo) {
        var mh$ = GetConsoleHistoryInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleHistoryInfo", lpConsoleHistoryInfo);
            }
            return (int)mh$.invokeExact(lpConsoleHistoryInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleHistoryInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleHistoryInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static FunctionDescriptor SetConsoleHistoryInfo$descriptor() {
        return SetConsoleHistoryInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MethodHandle SetConsoleHistoryInfo$handle() {
        return SetConsoleHistoryInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MemorySegment SetConsoleHistoryInfo$address() {
        return SetConsoleHistoryInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static int SetConsoleHistoryInfo(MemorySegment lpConsoleHistoryInfo) {
        var mh$ = SetConsoleHistoryInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleHistoryInfo", lpConsoleHistoryInfo);
            }
            return (int)mh$.invokeExact(lpConsoleHistoryInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleDisplayMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleDisplayMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static FunctionDescriptor GetConsoleDisplayMode$descriptor() {
        return GetConsoleDisplayMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static MethodHandle GetConsoleDisplayMode$handle() {
        return GetConsoleDisplayMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static MemorySegment GetConsoleDisplayMode$address() {
        return GetConsoleDisplayMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static int GetConsoleDisplayMode(MemorySegment lpModeFlags) {
        var mh$ = GetConsoleDisplayMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleDisplayMode", lpModeFlags);
            }
            return (int)mh$.invokeExact(lpModeFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleDisplayMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleDisplayMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static FunctionDescriptor SetConsoleDisplayMode$descriptor() {
        return SetConsoleDisplayMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static MethodHandle SetConsoleDisplayMode$handle() {
        return SetConsoleDisplayMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static MemorySegment SetConsoleDisplayMode$address() {
        return SetConsoleDisplayMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static int SetConsoleDisplayMode(MemorySegment hConsoleOutput, int dwFlags, MemorySegment lpNewScreenBufferDimensions) {
        var mh$ = SetConsoleDisplayMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleDisplayMode", hConsoleOutput, dwFlags, lpNewScreenBufferDimensions);
            }
            return (int)mh$.invokeExact(hConsoleOutput, dwFlags, lpNewScreenBufferDimensions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static FunctionDescriptor GetConsoleWindow$descriptor() {
        return GetConsoleWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static MethodHandle GetConsoleWindow$handle() {
        return GetConsoleWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static MemorySegment GetConsoleWindow$address() {
        return GetConsoleWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static MemorySegment GetConsoleWindow() {
        var mh$ = GetConsoleWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddConsoleAliasA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddConsoleAliasA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor AddConsoleAliasA$descriptor() {
        return AddConsoleAliasA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static MethodHandle AddConsoleAliasA$handle() {
        return AddConsoleAliasA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static MemorySegment AddConsoleAliasA$address() {
        return AddConsoleAliasA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static int AddConsoleAliasA(MemorySegment Source, MemorySegment Target, MemorySegment ExeName) {
        var mh$ = AddConsoleAliasA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddConsoleAliasA", Source, Target, ExeName);
            }
            return (int)mh$.invokeExact(Source, Target, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddConsoleAliasW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddConsoleAliasW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor AddConsoleAliasW$descriptor() {
        return AddConsoleAliasW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static MethodHandle AddConsoleAliasW$handle() {
        return AddConsoleAliasW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static MemorySegment AddConsoleAliasW$address() {
        return AddConsoleAliasW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static int AddConsoleAliasW(MemorySegment Source, MemorySegment Target, MemorySegment ExeName) {
        var mh$ = AddConsoleAliasW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddConsoleAliasW", Source, Target, ExeName);
            }
            return (int)mh$.invokeExact(Source, Target, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasA$descriptor() {
        return GetConsoleAliasA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasA$handle() {
        return GetConsoleAliasA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasA$address() {
        return GetConsoleAliasA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static int GetConsoleAliasA(MemorySegment Source, MemorySegment TargetBuffer, int TargetBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasA", Source, TargetBuffer, TargetBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Source, TargetBuffer, TargetBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasW$descriptor() {
        return GetConsoleAliasW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasW$handle() {
        return GetConsoleAliasW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasW$address() {
        return GetConsoleAliasW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static int GetConsoleAliasW(MemorySegment Source, MemorySegment TargetBuffer, int TargetBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasW", Source, TargetBuffer, TargetBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Source, TargetBuffer, TargetBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasesLengthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesLengthA$descriptor() {
        return GetConsoleAliasesLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesLengthA$handle() {
        return GetConsoleAliasesLengthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasesLengthA$address() {
        return GetConsoleAliasesLengthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesLengthA(MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesLengthA", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasesLengthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesLengthW$descriptor() {
        return GetConsoleAliasesLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesLengthW$handle() {
        return GetConsoleAliasesLengthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasesLengthW$address() {
        return GetConsoleAliasesLengthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesLengthW(MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesLengthW", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasExesLengthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesLengthA$descriptor() {
        return GetConsoleAliasExesLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static MethodHandle GetConsoleAliasExesLengthA$handle() {
        return GetConsoleAliasExesLengthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static MemorySegment GetConsoleAliasExesLengthA$address() {
        return GetConsoleAliasExesLengthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static int GetConsoleAliasExesLengthA() {
        var mh$ = GetConsoleAliasExesLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesLengthA");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasExesLengthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesLengthW$descriptor() {
        return GetConsoleAliasExesLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static MethodHandle GetConsoleAliasExesLengthW$handle() {
        return GetConsoleAliasExesLengthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static MemorySegment GetConsoleAliasExesLengthW$address() {
        return GetConsoleAliasExesLengthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static int GetConsoleAliasExesLengthW() {
        var mh$ = GetConsoleAliasExesLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesLengthW");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesA$descriptor() {
        return GetConsoleAliasesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesA$handle() {
        return GetConsoleAliasesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasesA$address() {
        return GetConsoleAliasesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesA(MemorySegment AliasBuffer, int AliasBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesA", AliasBuffer, AliasBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(AliasBuffer, AliasBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesW$descriptor() {
        return GetConsoleAliasesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesW$handle() {
        return GetConsoleAliasesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasesW$address() {
        return GetConsoleAliasesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesW(MemorySegment AliasBuffer, int AliasBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesW", AliasBuffer, AliasBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(AliasBuffer, AliasBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasExesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesA$descriptor() {
        return GetConsoleAliasExesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MethodHandle GetConsoleAliasExesA$handle() {
        return GetConsoleAliasExesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MemorySegment GetConsoleAliasExesA$address() {
        return GetConsoleAliasExesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static int GetConsoleAliasExesA(MemorySegment ExeNameBuffer, int ExeNameBufferLength) {
        var mh$ = GetConsoleAliasExesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesA", ExeNameBuffer, ExeNameBufferLength);
            }
            return (int)mh$.invokeExact(ExeNameBuffer, ExeNameBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleAliasExesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesW$descriptor() {
        return GetConsoleAliasExesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MethodHandle GetConsoleAliasExesW$handle() {
        return GetConsoleAliasExesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MemorySegment GetConsoleAliasExesW$address() {
        return GetConsoleAliasExesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static int GetConsoleAliasExesW(MemorySegment ExeNameBuffer, int ExeNameBufferLength) {
        var mh$ = GetConsoleAliasExesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesW", ExeNameBuffer, ExeNameBufferLength);
            }
            return (int)mh$.invokeExact(ExeNameBuffer, ExeNameBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpungeConsoleCommandHistoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExpungeConsoleCommandHistoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor ExpungeConsoleCommandHistoryA$descriptor() {
        return ExpungeConsoleCommandHistoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static MethodHandle ExpungeConsoleCommandHistoryA$handle() {
        return ExpungeConsoleCommandHistoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static MemorySegment ExpungeConsoleCommandHistoryA$address() {
        return ExpungeConsoleCommandHistoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static void ExpungeConsoleCommandHistoryA(MemorySegment ExeName) {
        var mh$ = ExpungeConsoleCommandHistoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpungeConsoleCommandHistoryA", ExeName);
            }
            mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpungeConsoleCommandHistoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExpungeConsoleCommandHistoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor ExpungeConsoleCommandHistoryW$descriptor() {
        return ExpungeConsoleCommandHistoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static MethodHandle ExpungeConsoleCommandHistoryW$handle() {
        return ExpungeConsoleCommandHistoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static MemorySegment ExpungeConsoleCommandHistoryW$address() {
        return ExpungeConsoleCommandHistoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static void ExpungeConsoleCommandHistoryW(MemorySegment ExeName) {
        var mh$ = ExpungeConsoleCommandHistoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpungeConsoleCommandHistoryW", ExeName);
            }
            mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleNumberOfCommandsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleNumberOfCommandsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor SetConsoleNumberOfCommandsA$descriptor() {
        return SetConsoleNumberOfCommandsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static MethodHandle SetConsoleNumberOfCommandsA$handle() {
        return SetConsoleNumberOfCommandsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static MemorySegment SetConsoleNumberOfCommandsA$address() {
        return SetConsoleNumberOfCommandsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static int SetConsoleNumberOfCommandsA(int Number_, MemorySegment ExeName) {
        var mh$ = SetConsoleNumberOfCommandsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleNumberOfCommandsA", Number_, ExeName);
            }
            return (int)mh$.invokeExact(Number_, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleNumberOfCommandsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetConsoleNumberOfCommandsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor SetConsoleNumberOfCommandsW$descriptor() {
        return SetConsoleNumberOfCommandsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static MethodHandle SetConsoleNumberOfCommandsW$handle() {
        return SetConsoleNumberOfCommandsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static MemorySegment SetConsoleNumberOfCommandsW$address() {
        return SetConsoleNumberOfCommandsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static int SetConsoleNumberOfCommandsW(int Number_, MemorySegment ExeName) {
        var mh$ = SetConsoleNumberOfCommandsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleNumberOfCommandsW", Number_, ExeName);
            }
            return (int)mh$.invokeExact(Number_, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleCommandHistoryLengthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryLengthA$descriptor() {
        return GetConsoleCommandHistoryLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryLengthA$handle() {
        return GetConsoleCommandHistoryLengthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleCommandHistoryLengthA$address() {
        return GetConsoleCommandHistoryLengthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryLengthA(MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryLengthA", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleCommandHistoryLengthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryLengthW$descriptor() {
        return GetConsoleCommandHistoryLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryLengthW$handle() {
        return GetConsoleCommandHistoryLengthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleCommandHistoryLengthW$address() {
        return GetConsoleCommandHistoryLengthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryLengthW(MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryLengthW", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleCommandHistoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryA$descriptor() {
        return GetConsoleCommandHistoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryA$handle() {
        return GetConsoleCommandHistoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleCommandHistoryA$address() {
        return GetConsoleCommandHistoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryA(MemorySegment Commands, int CommandBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryA", Commands, CommandBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Commands, CommandBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleCommandHistoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryW$descriptor() {
        return GetConsoleCommandHistoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryW$handle() {
        return GetConsoleCommandHistoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleCommandHistoryW$address() {
        return GetConsoleCommandHistoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryW(MemorySegment Commands, int CommandBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryW", Commands, CommandBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Commands, CommandBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleProcessList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetConsoleProcessList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static FunctionDescriptor GetConsoleProcessList$descriptor() {
        return GetConsoleProcessList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static MethodHandle GetConsoleProcessList$handle() {
        return GetConsoleProcessList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static MemorySegment GetConsoleProcessList$address() {
        return GetConsoleProcessList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static int GetConsoleProcessList(MemorySegment lpdwProcessList, int dwProcessCount) {
        var mh$ = GetConsoleProcessList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleProcessList", lpdwProcessList, dwProcessCount);
            }
            return (int)mh$.invokeExact(lpdwProcessList, dwProcessCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerFindFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerFindFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static FunctionDescriptor VerFindFileA$descriptor() {
        return VerFindFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MethodHandle VerFindFileA$handle() {
        return VerFindFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MemorySegment VerFindFileA$address() {
        return VerFindFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static int VerFindFileA(int uFlags, MemorySegment szFileName, MemorySegment szWinDir, MemorySegment szAppDir, MemorySegment szCurDir, MemorySegment puCurDirLen, MemorySegment szDestDir, MemorySegment puDestDirLen) {
        var mh$ = VerFindFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerFindFileA", uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
            }
            return (int)mh$.invokeExact(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerFindFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerFindFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static FunctionDescriptor VerFindFileW$descriptor() {
        return VerFindFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MethodHandle VerFindFileW$handle() {
        return VerFindFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MemorySegment VerFindFileW$address() {
        return VerFindFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static int VerFindFileW(int uFlags, MemorySegment szFileName, MemorySegment szWinDir, MemorySegment szAppDir, MemorySegment szCurDir, MemorySegment puCurDirLen, MemorySegment szDestDir, MemorySegment puDestDirLen) {
        var mh$ = VerFindFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerFindFileW", uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
            }
            return (int)mh$.invokeExact(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerInstallFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerInstallFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static FunctionDescriptor VerInstallFileA$descriptor() {
        return VerInstallFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MethodHandle VerInstallFileA$handle() {
        return VerInstallFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MemorySegment VerInstallFileA$address() {
        return VerInstallFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static int VerInstallFileA(int uFlags, MemorySegment szSrcFileName, MemorySegment szDestFileName, MemorySegment szSrcDir, MemorySegment szDestDir, MemorySegment szCurDir, MemorySegment szTmpFile, MemorySegment puTmpFileLen) {
        var mh$ = VerInstallFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerInstallFileA", uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
            }
            return (int)mh$.invokeExact(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerInstallFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerInstallFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static FunctionDescriptor VerInstallFileW$descriptor() {
        return VerInstallFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MethodHandle VerInstallFileW$handle() {
        return VerInstallFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MemorySegment VerInstallFileW$address() {
        return VerInstallFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static int VerInstallFileW(int uFlags, MemorySegment szSrcFileName, MemorySegment szDestFileName, MemorySegment szSrcDir, MemorySegment szDestDir, MemorySegment szCurDir, MemorySegment szTmpFile, MemorySegment puTmpFileLen) {
        var mh$ = VerInstallFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerInstallFileW", uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
            }
            return (int)mh$.invokeExact(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileVersionInfoSizeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeA$descriptor() {
        return GetFileVersionInfoSizeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeA$handle() {
        return GetFileVersionInfoSizeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MemorySegment GetFileVersionInfoSizeA$address() {
        return GetFileVersionInfoSizeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeA(MemorySegment lptstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeA", lptstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(lptstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileVersionInfoSizeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeW$descriptor() {
        return GetFileVersionInfoSizeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeW$handle() {
        return GetFileVersionInfoSizeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MemorySegment GetFileVersionInfoSizeW$address() {
        return GetFileVersionInfoSizeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeW(MemorySegment lptstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeW", lptstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(lptstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileVersionInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoA$descriptor() {
        return GetFileVersionInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoA$handle() {
        return GetFileVersionInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MemorySegment GetFileVersionInfoA$address() {
        return GetFileVersionInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoA(MemorySegment lptstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoA", lptstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(lptstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileVersionInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoW$descriptor() {
        return GetFileVersionInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoW$handle() {
        return GetFileVersionInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MemorySegment GetFileVersionInfoW$address() {
        return GetFileVersionInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoW(MemorySegment lptstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoW", lptstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(lptstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileVersionInfoSizeExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeExA$descriptor() {
        return GetFileVersionInfoSizeExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeExA$handle() {
        return GetFileVersionInfoSizeExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MemorySegment GetFileVersionInfoSizeExA$address() {
        return GetFileVersionInfoSizeExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeExA(int dwFlags, MemorySegment lpwstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeExA", dwFlags, lpwstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileVersionInfoSizeExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeExW$descriptor() {
        return GetFileVersionInfoSizeExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeExW$handle() {
        return GetFileVersionInfoSizeExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MemorySegment GetFileVersionInfoSizeExW$address() {
        return GetFileVersionInfoSizeExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeExW(int dwFlags, MemorySegment lpwstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeExW", dwFlags, lpwstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileVersionInfoExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoExA$descriptor() {
        return GetFileVersionInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoExA$handle() {
        return GetFileVersionInfoExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MemorySegment GetFileVersionInfoExA$address() {
        return GetFileVersionInfoExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoExA(int dwFlags, MemorySegment lpwstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoExA", dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileVersionInfoExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoExW$descriptor() {
        return GetFileVersionInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoExW$handle() {
        return GetFileVersionInfoExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MemorySegment GetFileVersionInfoExW$address() {
        return GetFileVersionInfoExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoExW(int dwFlags, MemorySegment lpwstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoExW", dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerLanguageNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerLanguageNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static FunctionDescriptor VerLanguageNameA$descriptor() {
        return VerLanguageNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static MethodHandle VerLanguageNameA$handle() {
        return VerLanguageNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static MemorySegment VerLanguageNameA$address() {
        return VerLanguageNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static int VerLanguageNameA(int wLang, MemorySegment szLang, int cchLang) {
        var mh$ = VerLanguageNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerLanguageNameA", wLang, szLang, cchLang);
            }
            return (int)mh$.invokeExact(wLang, szLang, cchLang);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerLanguageNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerLanguageNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static FunctionDescriptor VerLanguageNameW$descriptor() {
        return VerLanguageNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static MethodHandle VerLanguageNameW$handle() {
        return VerLanguageNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static MemorySegment VerLanguageNameW$address() {
        return VerLanguageNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static int VerLanguageNameW(int wLang, MemorySegment szLang, int cchLang) {
        var mh$ = VerLanguageNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerLanguageNameW", wLang, szLang, cchLang);
            }
            return (int)mh$.invokeExact(wLang, szLang, cchLang);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerQueryValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerQueryValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static FunctionDescriptor VerQueryValueA$descriptor() {
        return VerQueryValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MethodHandle VerQueryValueA$handle() {
        return VerQueryValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MemorySegment VerQueryValueA$address() {
        return VerQueryValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static int VerQueryValueA(MemorySegment pBlock, MemorySegment lpSubBlock, MemorySegment lplpBuffer, MemorySegment puLen) {
        var mh$ = VerQueryValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerQueryValueA", pBlock, lpSubBlock, lplpBuffer, puLen);
            }
            return (int)mh$.invokeExact(pBlock, lpSubBlock, lplpBuffer, puLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerQueryValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerQueryValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static FunctionDescriptor VerQueryValueW$descriptor() {
        return VerQueryValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MethodHandle VerQueryValueW$handle() {
        return VerQueryValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MemorySegment VerQueryValueW$address() {
        return VerQueryValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static int VerQueryValueW(MemorySegment pBlock, MemorySegment lpSubBlock, MemorySegment lplpBuffer, MemorySegment puLen) {
        var mh$ = VerQueryValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerQueryValueW", pBlock, lpSubBlock, lplpBuffer, puLen);
            }
            return (int)mh$.invokeExact(pBlock, lpSubBlock, lplpBuffer, puLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LONG LSTATUS
     * }
     */
    public static final OfInt LSTATUS = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ACCESS_MASK REGSAM
     * }
     */
    public static final OfInt REGSAM = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct val_context {
     *     int valuelen;
     *     LPVOID value_context;
     *     LPVOID val_buff_ptr;
     * } *PVALCONTEXT
     * }
     */
    public static final AddressLayout PVALCONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct pvalueA {
     *     LPSTR pv_valuename;
     *     int pv_valuelen;
     *     LPVOID pv_value_context;
     *     DWORD pv_type;
     * } *PPVALUEA
     * }
     */
    public static final AddressLayout PPVALUEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct pvalueW {
     *     LPWSTR pv_valuename;
     *     int pv_valuelen;
     *     LPVOID pv_value_context;
     *     DWORD pv_type;
     * } *PPVALUEW
     * }
     */
    public static final AddressLayout PPVALUEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PPVALUEA PPVALUE
     * }
     */
    public static final AddressLayout PPVALUE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct provider_info {
     *     PQUERYHANDLER pi_R0_1val;
     *     PQUERYHANDLER pi_R0_allvals;
     *     PQUERYHANDLER pi_R3_1val;
     *     PQUERYHANDLER pi_R3_allvals;
     *     DWORD pi_flags;
     *     LPVOID pi_key_context;
     * } *PPROVIDER
     * }
     */
    public static final AddressLayout PPROVIDER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct value_entA {
     *     LPSTR ve_valuename;
     *     DWORD ve_valuelen;
     *     DWORD_PTR ve_valueptr;
     *     DWORD ve_type;
     * } *PVALENTA
     * }
     */
    public static final AddressLayout PVALENTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct value_entW {
     *     LPWSTR ve_valuename;
     *     DWORD ve_valuelen;
     *     DWORD_PTR ve_valueptr;
     *     DWORD ve_type;
     * } *PVALENTW
     * }
     */
    public static final AddressLayout PVALENTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVALENTA PVALENT
     * }
     */
    public static final AddressLayout PVALENT = winapi.C_POINTER;

    private static class RegCloseKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegCloseKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static FunctionDescriptor RegCloseKey$descriptor() {
        return RegCloseKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static MethodHandle RegCloseKey$handle() {
        return RegCloseKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static MemorySegment RegCloseKey$address() {
        return RegCloseKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static int RegCloseKey(MemorySegment hKey) {
        var mh$ = RegCloseKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCloseKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOverridePredefKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegOverridePredefKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static FunctionDescriptor RegOverridePredefKey$descriptor() {
        return RegOverridePredefKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static MethodHandle RegOverridePredefKey$handle() {
        return RegOverridePredefKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static MemorySegment RegOverridePredefKey$address() {
        return RegOverridePredefKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static int RegOverridePredefKey(MemorySegment hKey, MemorySegment hNewHKey) {
        var mh$ = RegOverridePredefKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOverridePredefKey", hKey, hNewHKey);
            }
            return (int)mh$.invokeExact(hKey, hNewHKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenUserClassesRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegOpenUserClassesRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenUserClassesRoot$descriptor() {
        return RegOpenUserClassesRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenUserClassesRoot$handle() {
        return RegOpenUserClassesRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenUserClassesRoot$address() {
        return RegOpenUserClassesRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenUserClassesRoot(MemorySegment hToken, int dwOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenUserClassesRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenUserClassesRoot", hToken, dwOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hToken, dwOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenCurrentUser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegOpenCurrentUser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenCurrentUser$descriptor() {
        return RegOpenCurrentUser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenCurrentUser$handle() {
        return RegOpenCurrentUser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenCurrentUser$address() {
        return RegOpenCurrentUser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenCurrentUser(int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenCurrentUser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenCurrentUser", samDesired, phkResult);
            }
            return (int)mh$.invokeExact(samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDisablePredefinedCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDisablePredefinedCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static FunctionDescriptor RegDisablePredefinedCache$descriptor() {
        return RegDisablePredefinedCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static MethodHandle RegDisablePredefinedCache$handle() {
        return RegDisablePredefinedCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static MemorySegment RegDisablePredefinedCache$address() {
        return RegDisablePredefinedCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static int RegDisablePredefinedCache() {
        var mh$ = RegDisablePredefinedCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDisablePredefinedCache");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDisablePredefinedCacheEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDisablePredefinedCacheEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static FunctionDescriptor RegDisablePredefinedCacheEx$descriptor() {
        return RegDisablePredefinedCacheEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static MethodHandle RegDisablePredefinedCacheEx$handle() {
        return RegDisablePredefinedCacheEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static MemorySegment RegDisablePredefinedCacheEx$address() {
        return RegDisablePredefinedCacheEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static int RegDisablePredefinedCacheEx() {
        var mh$ = RegDisablePredefinedCacheEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDisablePredefinedCacheEx");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegConnectRegistryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryA$descriptor() {
        return RegConnectRegistryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryA$handle() {
        return RegConnectRegistryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegConnectRegistryA$address() {
        return RegConnectRegistryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryA(MemorySegment lpMachineName, MemorySegment hKey, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryA", lpMachineName, hKey, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegConnectRegistryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryW$descriptor() {
        return RegConnectRegistryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryW$handle() {
        return RegConnectRegistryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegConnectRegistryW$address() {
        return RegConnectRegistryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryW(MemorySegment lpMachineName, MemorySegment hKey, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryW", lpMachineName, hKey, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegConnectRegistryExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryExA$descriptor() {
        return RegConnectRegistryExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryExA$handle() {
        return RegConnectRegistryExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegConnectRegistryExA$address() {
        return RegConnectRegistryExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryExA(MemorySegment lpMachineName, MemorySegment hKey, int Flags, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryExA", lpMachineName, hKey, Flags, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, Flags, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegConnectRegistryExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryExW$descriptor() {
        return RegConnectRegistryExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryExW$handle() {
        return RegConnectRegistryExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegConnectRegistryExW$address() {
        return RegConnectRegistryExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryExW(MemorySegment lpMachineName, MemorySegment hKey, int Flags, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryExW", lpMachineName, hKey, Flags, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, Flags, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegCreateKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegCreateKeyA$descriptor() {
        return RegCreateKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegCreateKeyA$handle() {
        return RegCreateKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegCreateKeyA$address() {
        return RegCreateKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegCreateKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegCreateKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyA", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegCreateKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegCreateKeyW$descriptor() {
        return RegCreateKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegCreateKeyW$handle() {
        return RegCreateKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegCreateKeyW$address() {
        return RegCreateKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegCreateKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegCreateKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyW", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegCreateKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static FunctionDescriptor RegCreateKeyExA$descriptor() {
        return RegCreateKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MethodHandle RegCreateKeyExA$handle() {
        return RegCreateKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MemorySegment RegCreateKeyExA$address() {
        return RegCreateKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static int RegCreateKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition) {
        var mh$ = RegCreateKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyExA", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegCreateKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static FunctionDescriptor RegCreateKeyExW$descriptor() {
        return RegCreateKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MethodHandle RegCreateKeyExW$handle() {
        return RegCreateKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MemorySegment RegCreateKeyExW$address() {
        return RegCreateKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static int RegCreateKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition) {
        var mh$ = RegCreateKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyExW", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegCreateKeyTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegCreateKeyTransactedA$descriptor() {
        return RegCreateKeyTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegCreateKeyTransactedA$handle() {
        return RegCreateKeyTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegCreateKeyTransactedA$address() {
        return RegCreateKeyTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegCreateKeyTransactedA(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegCreateKeyTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyTransactedA", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegCreateKeyTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegCreateKeyTransactedW$descriptor() {
        return RegCreateKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegCreateKeyTransactedW$handle() {
        return RegCreateKeyTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegCreateKeyTransactedW$address() {
        return RegCreateKeyTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegCreateKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegCreateKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyTransactedW", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyA$descriptor() {
        return RegDeleteKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteKeyA$handle() {
        return RegDeleteKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MemorySegment RegDeleteKeyA$address() {
        return RegDeleteKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static int RegDeleteKeyA(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyA", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyW$descriptor() {
        return RegDeleteKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteKeyW$handle() {
        return RegDeleteKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MemorySegment RegDeleteKeyW$address() {
        return RegDeleteKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static int RegDeleteKeyW(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyW", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyExA$descriptor() {
        return RegDeleteKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MethodHandle RegDeleteKeyExA$handle() {
        return RegDeleteKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MemorySegment RegDeleteKeyExA$address() {
        return RegDeleteKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static int RegDeleteKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved) {
        var mh$ = RegDeleteKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyExA", hKey, lpSubKey, samDesired, Reserved);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyExW$descriptor() {
        return RegDeleteKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MethodHandle RegDeleteKeyExW$handle() {
        return RegDeleteKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MemorySegment RegDeleteKeyExW$address() {
        return RegDeleteKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static int RegDeleteKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved) {
        var mh$ = RegDeleteKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyExW", hKey, lpSubKey, samDesired, Reserved);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteKeyTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyTransactedA$descriptor() {
        return RegDeleteKeyTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MethodHandle RegDeleteKeyTransactedA$handle() {
        return RegDeleteKeyTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MemorySegment RegDeleteKeyTransactedA$address() {
        return RegDeleteKeyTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static int RegDeleteKeyTransactedA(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved, MemorySegment hTransaction, MemorySegment pExtendedParameter) {
        var mh$ = RegDeleteKeyTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyTransactedA", hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteKeyTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyTransactedW$descriptor() {
        return RegDeleteKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MethodHandle RegDeleteKeyTransactedW$handle() {
        return RegDeleteKeyTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MemorySegment RegDeleteKeyTransactedW$address() {
        return RegDeleteKeyTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static int RegDeleteKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved, MemorySegment hTransaction, MemorySegment pExtendedParameter) {
        var mh$ = RegDeleteKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyTransactedW", hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDisableReflectionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDisableReflectionKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static FunctionDescriptor RegDisableReflectionKey$descriptor() {
        return RegDisableReflectionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static MethodHandle RegDisableReflectionKey$handle() {
        return RegDisableReflectionKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static MemorySegment RegDisableReflectionKey$address() {
        return RegDisableReflectionKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static int RegDisableReflectionKey(MemorySegment hBase) {
        var mh$ = RegDisableReflectionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDisableReflectionKey", hBase);
            }
            return (int)mh$.invokeExact(hBase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnableReflectionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegEnableReflectionKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static FunctionDescriptor RegEnableReflectionKey$descriptor() {
        return RegEnableReflectionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static MethodHandle RegEnableReflectionKey$handle() {
        return RegEnableReflectionKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static MemorySegment RegEnableReflectionKey$address() {
        return RegEnableReflectionKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static int RegEnableReflectionKey(MemorySegment hBase) {
        var mh$ = RegEnableReflectionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnableReflectionKey", hBase);
            }
            return (int)mh$.invokeExact(hBase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryReflectionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegQueryReflectionKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static FunctionDescriptor RegQueryReflectionKey$descriptor() {
        return RegQueryReflectionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static MethodHandle RegQueryReflectionKey$handle() {
        return RegQueryReflectionKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static MemorySegment RegQueryReflectionKey$address() {
        return RegQueryReflectionKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static int RegQueryReflectionKey(MemorySegment hBase, MemorySegment bIsReflectionDisabled) {
        var mh$ = RegQueryReflectionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryReflectionKey", hBase, bIsReflectionDisabled);
            }
            return (int)mh$.invokeExact(hBase, bIsReflectionDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteValueA$descriptor() {
        return RegDeleteValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteValueA$handle() {
        return RegDeleteValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static MemorySegment RegDeleteValueA$address() {
        return RegDeleteValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static int RegDeleteValueA(MemorySegment hKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteValueA", hKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteValueW$descriptor() {
        return RegDeleteValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteValueW$handle() {
        return RegDeleteValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static MemorySegment RegDeleteValueW$address() {
        return RegDeleteValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static int RegDeleteValueW(MemorySegment hKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteValueW", hKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegEnumKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static FunctionDescriptor RegEnumKeyA$descriptor() {
        return RegEnumKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static MethodHandle RegEnumKeyA$handle() {
        return RegEnumKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static MemorySegment RegEnumKeyA$address() {
        return RegEnumKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static int RegEnumKeyA(MemorySegment hKey, int dwIndex, MemorySegment lpName, int cchName) {
        var mh$ = RegEnumKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyA", hKey, dwIndex, lpName, cchName);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegEnumKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static FunctionDescriptor RegEnumKeyW$descriptor() {
        return RegEnumKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static MethodHandle RegEnumKeyW$handle() {
        return RegEnumKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static MemorySegment RegEnumKeyW$address() {
        return RegEnumKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static int RegEnumKeyW(MemorySegment hKey, int dwIndex, MemorySegment lpName, int cchName) {
        var mh$ = RegEnumKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyW", hKey, dwIndex, lpName, cchName);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegEnumKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegEnumKeyExA$descriptor() {
        return RegEnumKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegEnumKeyExA$handle() {
        return RegEnumKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MemorySegment RegEnumKeyExA$address() {
        return RegEnumKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegEnumKeyExA(MemorySegment hKey, int dwIndex, MemorySegment lpName, MemorySegment lpcchName, MemorySegment lpReserved, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpftLastWriteTime) {
        var mh$ = RegEnumKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyExA", hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegEnumKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegEnumKeyExW$descriptor() {
        return RegEnumKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegEnumKeyExW$handle() {
        return RegEnumKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MemorySegment RegEnumKeyExW$address() {
        return RegEnumKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegEnumKeyExW(MemorySegment hKey, int dwIndex, MemorySegment lpName, MemorySegment lpcchName, MemorySegment lpReserved, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpftLastWriteTime) {
        var mh$ = RegEnumKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyExW", hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegEnumValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegEnumValueA$descriptor() {
        return RegEnumValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegEnumValueA$handle() {
        return RegEnumValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MemorySegment RegEnumValueA$address() {
        return RegEnumValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegEnumValueA(MemorySegment hKey, int dwIndex, MemorySegment lpValueName, MemorySegment lpcchValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegEnumValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumValueA", hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegEnumValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegEnumValueW$descriptor() {
        return RegEnumValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegEnumValueW$handle() {
        return RegEnumValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MemorySegment RegEnumValueW$address() {
        return RegEnumValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegEnumValueW(MemorySegment hKey, int dwIndex, MemorySegment lpValueName, MemorySegment lpcchValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegEnumValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumValueW", hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegFlushKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegFlushKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static FunctionDescriptor RegFlushKey$descriptor() {
        return RegFlushKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static MethodHandle RegFlushKey$handle() {
        return RegFlushKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static MemorySegment RegFlushKey$address() {
        return RegFlushKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static int RegFlushKey(MemorySegment hKey) {
        var mh$ = RegFlushKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegFlushKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegGetKeySecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegGetKeySecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor RegGetKeySecurity$descriptor() {
        return RegGetKeySecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static MethodHandle RegGetKeySecurity$handle() {
        return RegGetKeySecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static MemorySegment RegGetKeySecurity$address() {
        return RegGetKeySecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static int RegGetKeySecurity(MemorySegment hKey, int SecurityInformation, MemorySegment pSecurityDescriptor, MemorySegment lpcbSecurityDescriptor) {
        var mh$ = RegGetKeySecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegGetKeySecurity", hKey, SecurityInformation, pSecurityDescriptor, lpcbSecurityDescriptor);
            }
            return (int)mh$.invokeExact(hKey, SecurityInformation, pSecurityDescriptor, lpcbSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegLoadKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static FunctionDescriptor RegLoadKeyA$descriptor() {
        return RegLoadKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static MethodHandle RegLoadKeyA$handle() {
        return RegLoadKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static MemorySegment RegLoadKeyA$address() {
        return RegLoadKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static int RegLoadKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpFile) {
        var mh$ = RegLoadKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadKeyA", hKey, lpSubKey, lpFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegLoadKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static FunctionDescriptor RegLoadKeyW$descriptor() {
        return RegLoadKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static MethodHandle RegLoadKeyW$handle() {
        return RegLoadKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static MemorySegment RegLoadKeyW$address() {
        return RegLoadKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static int RegLoadKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpFile) {
        var mh$ = RegLoadKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadKeyW", hKey, lpSubKey, lpFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegNotifyChangeKeyValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegNotifyChangeKeyValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static FunctionDescriptor RegNotifyChangeKeyValue$descriptor() {
        return RegNotifyChangeKeyValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static MethodHandle RegNotifyChangeKeyValue$handle() {
        return RegNotifyChangeKeyValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static MemorySegment RegNotifyChangeKeyValue$address() {
        return RegNotifyChangeKeyValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static int RegNotifyChangeKeyValue(MemorySegment hKey, int bWatchSubtree, int dwNotifyFilter, MemorySegment hEvent, int fAsynchronous) {
        var mh$ = RegNotifyChangeKeyValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegNotifyChangeKeyValue", hKey, bWatchSubtree, dwNotifyFilter, hEvent, fAsynchronous);
            }
            return (int)mh$.invokeExact(hKey, bWatchSubtree, dwNotifyFilter, hEvent, fAsynchronous);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegOpenKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyA$descriptor() {
        return RegOpenKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyA$handle() {
        return RegOpenKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenKeyA$address() {
        return RegOpenKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegOpenKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyA", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegOpenKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyW$descriptor() {
        return RegOpenKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyW$handle() {
        return RegOpenKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenKeyW$address() {
        return RegOpenKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegOpenKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyW", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegOpenKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyExA$descriptor() {
        return RegOpenKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyExA$handle() {
        return RegOpenKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenKeyExA$address() {
        return RegOpenKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyExA", hKey, lpSubKey, ulOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegOpenKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyExW$descriptor() {
        return RegOpenKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyExW$handle() {
        return RegOpenKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenKeyExW$address() {
        return RegOpenKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyExW", hKey, lpSubKey, ulOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegOpenKeyTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegOpenKeyTransactedA$descriptor() {
        return RegOpenKeyTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegOpenKeyTransactedA$handle() {
        return RegOpenKeyTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegOpenKeyTransactedA$address() {
        return RegOpenKeyTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegOpenKeyTransactedA(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegOpenKeyTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyTransactedA", hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegOpenKeyTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegOpenKeyTransactedW$descriptor() {
        return RegOpenKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegOpenKeyTransactedW$handle() {
        return RegOpenKeyTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegOpenKeyTransactedW$address() {
        return RegOpenKeyTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegOpenKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegOpenKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyTransactedW", hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryInfoKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegQueryInfoKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegQueryInfoKeyA$descriptor() {
        return RegQueryInfoKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegQueryInfoKeyA$handle() {
        return RegQueryInfoKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MemorySegment RegQueryInfoKeyA$address() {
        return RegQueryInfoKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegQueryInfoKeyA(MemorySegment hKey, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpReserved, MemorySegment lpcSubKeys, MemorySegment lpcbMaxSubKeyLen, MemorySegment lpcbMaxClassLen, MemorySegment lpcValues, MemorySegment lpcbMaxValueNameLen, MemorySegment lpcbMaxValueLen, MemorySegment lpcbSecurityDescriptor, MemorySegment lpftLastWriteTime) {
        var mh$ = RegQueryInfoKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryInfoKeyA", hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryInfoKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegQueryInfoKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegQueryInfoKeyW$descriptor() {
        return RegQueryInfoKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegQueryInfoKeyW$handle() {
        return RegQueryInfoKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MemorySegment RegQueryInfoKeyW$address() {
        return RegQueryInfoKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegQueryInfoKeyW(MemorySegment hKey, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpReserved, MemorySegment lpcSubKeys, MemorySegment lpcbMaxSubKeyLen, MemorySegment lpcbMaxClassLen, MemorySegment lpcValues, MemorySegment lpcbMaxValueNameLen, MemorySegment lpcbMaxValueLen, MemorySegment lpcbSecurityDescriptor, MemorySegment lpftLastWriteTime) {
        var mh$ = RegQueryInfoKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryInfoKeyW", hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegQueryValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueA$descriptor() {
        return RegQueryValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueA$handle() {
        return RegQueryValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static MemorySegment RegQueryValueA$address() {
        return RegQueryValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static int RegQueryValueA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueA", hKey, lpSubKey, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegQueryValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueW$descriptor() {
        return RegQueryValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueW$handle() {
        return RegQueryValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static MemorySegment RegQueryValueW$address() {
        return RegQueryValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static int RegQueryValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueW", hKey, lpSubKey, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryMultipleValuesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegQueryMultipleValuesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static FunctionDescriptor RegQueryMultipleValuesA$descriptor() {
        return RegQueryMultipleValuesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MethodHandle RegQueryMultipleValuesA$handle() {
        return RegQueryMultipleValuesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MemorySegment RegQueryMultipleValuesA$address() {
        return RegQueryMultipleValuesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static int RegQueryMultipleValuesA(MemorySegment hKey, MemorySegment val_list, int num_vals, MemorySegment lpValueBuf, MemorySegment ldwTotsize) {
        var mh$ = RegQueryMultipleValuesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryMultipleValuesA", hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
            }
            return (int)mh$.invokeExact(hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryMultipleValuesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegQueryMultipleValuesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static FunctionDescriptor RegQueryMultipleValuesW$descriptor() {
        return RegQueryMultipleValuesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MethodHandle RegQueryMultipleValuesW$handle() {
        return RegQueryMultipleValuesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MemorySegment RegQueryMultipleValuesW$address() {
        return RegQueryMultipleValuesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static int RegQueryMultipleValuesW(MemorySegment hKey, MemorySegment val_list, int num_vals, MemorySegment lpValueBuf, MemorySegment ldwTotsize) {
        var mh$ = RegQueryMultipleValuesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryMultipleValuesW", hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
            }
            return (int)mh$.invokeExact(hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegQueryValueExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueExA$descriptor() {
        return RegQueryValueExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueExA$handle() {
        return RegQueryValueExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MemorySegment RegQueryValueExA$address() {
        return RegQueryValueExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegQueryValueExA(MemorySegment hKey, MemorySegment lpValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueExA", hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegQueryValueExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueExW$descriptor() {
        return RegQueryValueExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueExW$handle() {
        return RegQueryValueExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MemorySegment RegQueryValueExW$address() {
        return RegQueryValueExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegQueryValueExW(MemorySegment hKey, MemorySegment lpValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueExW", hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegReplaceKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegReplaceKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static FunctionDescriptor RegReplaceKeyA$descriptor() {
        return RegReplaceKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static MethodHandle RegReplaceKeyA$handle() {
        return RegReplaceKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static MemorySegment RegReplaceKeyA$address() {
        return RegReplaceKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static int RegReplaceKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpNewFile, MemorySegment lpOldFile) {
        var mh$ = RegReplaceKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegReplaceKeyA", hKey, lpSubKey, lpNewFile, lpOldFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpNewFile, lpOldFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegReplaceKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegReplaceKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static FunctionDescriptor RegReplaceKeyW$descriptor() {
        return RegReplaceKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static MethodHandle RegReplaceKeyW$handle() {
        return RegReplaceKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static MemorySegment RegReplaceKeyW$address() {
        return RegReplaceKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static int RegReplaceKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpNewFile, MemorySegment lpOldFile) {
        var mh$ = RegReplaceKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegReplaceKeyW", hKey, lpSubKey, lpNewFile, lpOldFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpNewFile, lpOldFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegRestoreKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegRestoreKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegRestoreKeyA$descriptor() {
        return RegRestoreKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegRestoreKeyA$handle() {
        return RegRestoreKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegRestoreKeyA$address() {
        return RegRestoreKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static int RegRestoreKeyA(MemorySegment hKey, MemorySegment lpFile, int dwFlags) {
        var mh$ = RegRestoreKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegRestoreKeyA", hKey, lpFile, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegRestoreKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegRestoreKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegRestoreKeyW$descriptor() {
        return RegRestoreKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegRestoreKeyW$handle() {
        return RegRestoreKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegRestoreKeyW$address() {
        return RegRestoreKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static int RegRestoreKeyW(MemorySegment hKey, MemorySegment lpFile, int dwFlags) {
        var mh$ = RegRestoreKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegRestoreKeyW", hKey, lpFile, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegRenameKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegRenameKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static FunctionDescriptor RegRenameKey$descriptor() {
        return RegRenameKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static MethodHandle RegRenameKey$handle() {
        return RegRenameKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static MemorySegment RegRenameKey$address() {
        return RegRenameKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static int RegRenameKey(MemorySegment hKey, MemorySegment lpSubKeyName, MemorySegment lpNewKeyName) {
        var mh$ = RegRenameKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegRenameKey", hKey, lpSubKeyName, lpNewKeyName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKeyName, lpNewKeyName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSaveKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor RegSaveKeyA$descriptor() {
        return RegSaveKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle RegSaveKeyA$handle() {
        return RegSaveKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment RegSaveKeyA$address() {
        return RegSaveKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int RegSaveKeyA(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes) {
        var mh$ = RegSaveKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyA", hKey, lpFile, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSaveKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor RegSaveKeyW$descriptor() {
        return RegSaveKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle RegSaveKeyW$handle() {
        return RegSaveKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment RegSaveKeyW$address() {
        return RegSaveKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int RegSaveKeyW(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes) {
        var mh$ = RegSaveKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyW", hKey, lpFile, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetKeySecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSetKeySecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor RegSetKeySecurity$descriptor() {
        return RegSetKeySecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle RegSetKeySecurity$handle() {
        return RegSetKeySecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment RegSetKeySecurity$address() {
        return RegSetKeySecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int RegSetKeySecurity(MemorySegment hKey, int SecurityInformation, MemorySegment pSecurityDescriptor) {
        var mh$ = RegSetKeySecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetKeySecurity", hKey, SecurityInformation, pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(hKey, SecurityInformation, pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSetValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueA$descriptor() {
        return RegSetValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueA$handle() {
        return RegSetValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetValueA$address() {
        return RegSetValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueA(MemorySegment hKey, MemorySegment lpSubKey, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueA", hKey, lpSubKey, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSetValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueW$descriptor() {
        return RegSetValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueW$handle() {
        return RegSetValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetValueW$address() {
        return RegSetValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueW(MemorySegment hKey, MemorySegment lpSubKey, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueW", hKey, lpSubKey, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSetValueExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueExA$descriptor() {
        return RegSetValueExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueExA$handle() {
        return RegSetValueExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetValueExA$address() {
        return RegSetValueExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueExA(MemorySegment hKey, MemorySegment lpValueName, int Reserved, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueExA", hKey, lpValueName, Reserved, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSetValueExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueExW$descriptor() {
        return RegSetValueExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueExW$handle() {
        return RegSetValueExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetValueExW$address() {
        return RegSetValueExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueExW(MemorySegment hKey, MemorySegment lpValueName, int Reserved, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueExW", hKey, lpValueName, Reserved, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegUnLoadKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegUnLoadKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegUnLoadKeyA$descriptor() {
        return RegUnLoadKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MethodHandle RegUnLoadKeyA$handle() {
        return RegUnLoadKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MemorySegment RegUnLoadKeyA$address() {
        return RegUnLoadKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static int RegUnLoadKeyA(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegUnLoadKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegUnLoadKeyA", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegUnLoadKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegUnLoadKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegUnLoadKeyW$descriptor() {
        return RegUnLoadKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MethodHandle RegUnLoadKeyW$handle() {
        return RegUnLoadKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MemorySegment RegUnLoadKeyW$address() {
        return RegUnLoadKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static int RegUnLoadKeyW(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegUnLoadKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegUnLoadKeyW", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteKeyValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyValueA$descriptor() {
        return RegDeleteKeyValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteKeyValueA$handle() {
        return RegDeleteKeyValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static MemorySegment RegDeleteKeyValueA$address() {
        return RegDeleteKeyValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static int RegDeleteKeyValueA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteKeyValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyValueA", hKey, lpSubKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteKeyValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyValueW$descriptor() {
        return RegDeleteKeyValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteKeyValueW$handle() {
        return RegDeleteKeyValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static MemorySegment RegDeleteKeyValueW$address() {
        return RegDeleteKeyValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static int RegDeleteKeyValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteKeyValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyValueW", hKey, lpSubKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetKeyValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSetKeyValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetKeyValueA$descriptor() {
        return RegSetKeyValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetKeyValueA$handle() {
        return RegSetKeyValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetKeyValueA$address() {
        return RegSetKeyValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static int RegSetKeyValueA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetKeyValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetKeyValueA", hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetKeyValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSetKeyValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetKeyValueW$descriptor() {
        return RegSetKeyValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetKeyValueW$handle() {
        return RegSetKeyValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetKeyValueW$address() {
        return RegSetKeyValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static int RegSetKeyValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetKeyValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetKeyValueW", hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteTreeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteTreeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteTreeA$descriptor() {
        return RegDeleteTreeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteTreeA$handle() {
        return RegDeleteTreeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MemorySegment RegDeleteTreeA$address() {
        return RegDeleteTreeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static int RegDeleteTreeA(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteTreeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteTreeA", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteTreeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegDeleteTreeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteTreeW$descriptor() {
        return RegDeleteTreeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteTreeW$handle() {
        return RegDeleteTreeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MemorySegment RegDeleteTreeW$address() {
        return RegDeleteTreeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static int RegDeleteTreeW(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteTreeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteTreeW", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCopyTreeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegCopyTreeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static FunctionDescriptor RegCopyTreeA$descriptor() {
        return RegCopyTreeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static MethodHandle RegCopyTreeA$handle() {
        return RegCopyTreeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static MemorySegment RegCopyTreeA$address() {
        return RegCopyTreeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static int RegCopyTreeA(MemorySegment hKeySrc, MemorySegment lpSubKey, MemorySegment hKeyDest) {
        var mh$ = RegCopyTreeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCopyTreeA", hKeySrc, lpSubKey, hKeyDest);
            }
            return (int)mh$.invokeExact(hKeySrc, lpSubKey, hKeyDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegGetValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegGetValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueA(HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static FunctionDescriptor RegGetValueA$descriptor() {
        return RegGetValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueA(HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MethodHandle RegGetValueA$handle() {
        return RegGetValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueA(HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MemorySegment RegGetValueA$address() {
        return RegGetValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegGetValueA(HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static int RegGetValueA(MemorySegment hkey, MemorySegment lpSubKey, MemorySegment lpValue, int dwFlags, MemorySegment pdwType, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = RegGetValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegGetValueA", hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegGetValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegGetValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static FunctionDescriptor RegGetValueW$descriptor() {
        return RegGetValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MethodHandle RegGetValueW$handle() {
        return RegGetValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MemorySegment RegGetValueW$address() {
        return RegGetValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static int RegGetValueW(MemorySegment hkey, MemorySegment lpSubKey, MemorySegment lpValue, int dwFlags, MemorySegment pdwType, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = RegGetValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegGetValueW", hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCopyTreeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegCopyTreeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static FunctionDescriptor RegCopyTreeW$descriptor() {
        return RegCopyTreeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static MethodHandle RegCopyTreeW$handle() {
        return RegCopyTreeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static MemorySegment RegCopyTreeW$address() {
        return RegCopyTreeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static int RegCopyTreeW(MemorySegment hKeySrc, MemorySegment lpSubKey, MemorySegment hKeyDest) {
        var mh$ = RegCopyTreeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCopyTreeW", hKeySrc, lpSubKey, hKeyDest);
            }
            return (int)mh$.invokeExact(hKeySrc, lpSubKey, hKeyDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadMUIStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegLoadMUIStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory)
     * }
     */
    public static FunctionDescriptor RegLoadMUIStringA$descriptor() {
        return RegLoadMUIStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory)
     * }
     */
    public static MethodHandle RegLoadMUIStringA$handle() {
        return RegLoadMUIStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory)
     * }
     */
    public static MemorySegment RegLoadMUIStringA$address() {
        return RegLoadMUIStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory)
     * }
     */
    public static int RegLoadMUIStringA(MemorySegment hKey, MemorySegment pszValue, MemorySegment pszOutBuf, int cbOutBuf, MemorySegment pcbData, int Flags, MemorySegment pszDirectory) {
        var mh$ = RegLoadMUIStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadMUIStringA", hKey, pszValue, pszOutBuf, cbOutBuf, pcbData, Flags, pszDirectory);
            }
            return (int)mh$.invokeExact(hKey, pszValue, pszOutBuf, cbOutBuf, pcbData, Flags, pszDirectory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadMUIStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegLoadMUIStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory)
     * }
     */
    public static FunctionDescriptor RegLoadMUIStringW$descriptor() {
        return RegLoadMUIStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory)
     * }
     */
    public static MethodHandle RegLoadMUIStringW$handle() {
        return RegLoadMUIStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory)
     * }
     */
    public static MemorySegment RegLoadMUIStringW$address() {
        return RegLoadMUIStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory)
     * }
     */
    public static int RegLoadMUIStringW(MemorySegment hKey, MemorySegment pszValue, MemorySegment pszOutBuf, int cbOutBuf, MemorySegment pcbData, int Flags, MemorySegment pszDirectory) {
        var mh$ = RegLoadMUIStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadMUIStringW", hKey, pszValue, pszOutBuf, cbOutBuf, pcbData, Flags, pszDirectory);
            }
            return (int)mh$.invokeExact(hKey, pszValue, pszOutBuf, cbOutBuf, pcbData, Flags, pszDirectory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadAppKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegLoadAppKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegLoadAppKeyA$descriptor() {
        return RegLoadAppKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static MethodHandle RegLoadAppKeyA$handle() {
        return RegLoadAppKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static MemorySegment RegLoadAppKeyA$address() {
        return RegLoadAppKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static int RegLoadAppKeyA(MemorySegment lpFile, MemorySegment phkResult, int samDesired, int dwOptions, int Reserved) {
        var mh$ = RegLoadAppKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadAppKeyA", lpFile, phkResult, samDesired, dwOptions, Reserved);
            }
            return (int)mh$.invokeExact(lpFile, phkResult, samDesired, dwOptions, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadAppKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegLoadAppKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegLoadAppKeyW$descriptor() {
        return RegLoadAppKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static MethodHandle RegLoadAppKeyW$handle() {
        return RegLoadAppKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static MemorySegment RegLoadAppKeyW$address() {
        return RegLoadAppKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static int RegLoadAppKeyW(MemorySegment lpFile, MemorySegment phkResult, int samDesired, int dwOptions, int Reserved) {
        var mh$ = RegLoadAppKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadAppKeyW", lpFile, phkResult, samDesired, dwOptions, Reserved);
            }
            return (int)mh$.invokeExact(lpFile, phkResult, samDesired, dwOptions, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateSystemShutdownA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitiateSystemShutdownA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static FunctionDescriptor InitiateSystemShutdownA$descriptor() {
        return InitiateSystemShutdownA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static MethodHandle InitiateSystemShutdownA$handle() {
        return InitiateSystemShutdownA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static MemorySegment InitiateSystemShutdownA$address() {
        return InitiateSystemShutdownA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static int InitiateSystemShutdownA(MemorySegment lpMachineName, MemorySegment lpMessage, int dwTimeout, int bForceAppsClosed, int bRebootAfterShutdown) {
        var mh$ = InitiateSystemShutdownA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateSystemShutdownA", lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateSystemShutdownW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitiateSystemShutdownW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static FunctionDescriptor InitiateSystemShutdownW$descriptor() {
        return InitiateSystemShutdownW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static MethodHandle InitiateSystemShutdownW$handle() {
        return InitiateSystemShutdownW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static MemorySegment InitiateSystemShutdownW$address() {
        return InitiateSystemShutdownW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static int InitiateSystemShutdownW(MemorySegment lpMachineName, MemorySegment lpMessage, int dwTimeout, int bForceAppsClosed, int bRebootAfterShutdown) {
        var mh$ = InitiateSystemShutdownW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateSystemShutdownW", lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortSystemShutdownA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AbortSystemShutdownA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownA(LPSTR lpMachineName)
     * }
     */
    public static FunctionDescriptor AbortSystemShutdownA$descriptor() {
        return AbortSystemShutdownA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownA(LPSTR lpMachineName)
     * }
     */
    public static MethodHandle AbortSystemShutdownA$handle() {
        return AbortSystemShutdownA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownA(LPSTR lpMachineName)
     * }
     */
    public static MemorySegment AbortSystemShutdownA$address() {
        return AbortSystemShutdownA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownA(LPSTR lpMachineName)
     * }
     */
    public static int AbortSystemShutdownA(MemorySegment lpMachineName) {
        var mh$ = AbortSystemShutdownA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortSystemShutdownA", lpMachineName);
            }
            return (int)mh$.invokeExact(lpMachineName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortSystemShutdownW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AbortSystemShutdownW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownW(LPWSTR lpMachineName)
     * }
     */
    public static FunctionDescriptor AbortSystemShutdownW$descriptor() {
        return AbortSystemShutdownW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownW(LPWSTR lpMachineName)
     * }
     */
    public static MethodHandle AbortSystemShutdownW$handle() {
        return AbortSystemShutdownW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownW(LPWSTR lpMachineName)
     * }
     */
    public static MemorySegment AbortSystemShutdownW$address() {
        return AbortSystemShutdownW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownW(LPWSTR lpMachineName)
     * }
     */
    public static int AbortSystemShutdownW(MemorySegment lpMachineName) {
        var mh$ = AbortSystemShutdownW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortSystemShutdownW", lpMachineName);
            }
            return (int)mh$.invokeExact(lpMachineName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateSystemShutdownExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitiateSystemShutdownExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor InitiateSystemShutdownExA$descriptor() {
        return InitiateSystemShutdownExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static MethodHandle InitiateSystemShutdownExA$handle() {
        return InitiateSystemShutdownExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static MemorySegment InitiateSystemShutdownExA$address() {
        return InitiateSystemShutdownExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static int InitiateSystemShutdownExA(MemorySegment lpMachineName, MemorySegment lpMessage, int dwTimeout, int bForceAppsClosed, int bRebootAfterShutdown, int dwReason) {
        var mh$ = InitiateSystemShutdownExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateSystemShutdownExA", lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown, dwReason);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateSystemShutdownExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitiateSystemShutdownExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor InitiateSystemShutdownExW$descriptor() {
        return InitiateSystemShutdownExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static MethodHandle InitiateSystemShutdownExW$handle() {
        return InitiateSystemShutdownExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static MemorySegment InitiateSystemShutdownExW$address() {
        return InitiateSystemShutdownExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static int InitiateSystemShutdownExW(MemorySegment lpMachineName, MemorySegment lpMessage, int dwTimeout, int bForceAppsClosed, int bRebootAfterShutdown, int dwReason) {
        var mh$ = InitiateSystemShutdownExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateSystemShutdownExW", lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown, dwReason);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateShutdownA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitiateShutdownA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor InitiateShutdownA$descriptor() {
        return InitiateShutdownA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static MethodHandle InitiateShutdownA$handle() {
        return InitiateShutdownA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static MemorySegment InitiateShutdownA$address() {
        return InitiateShutdownA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static int InitiateShutdownA(MemorySegment lpMachineName, MemorySegment lpMessage, int dwGracePeriod, int dwShutdownFlags, int dwReason) {
        var mh$ = InitiateShutdownA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateShutdownA", lpMachineName, lpMessage, dwGracePeriod, dwShutdownFlags, dwReason);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwGracePeriod, dwShutdownFlags, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateShutdownW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitiateShutdownW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor InitiateShutdownW$descriptor() {
        return InitiateShutdownW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static MethodHandle InitiateShutdownW$handle() {
        return InitiateShutdownW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static MemorySegment InitiateShutdownW$address() {
        return InitiateShutdownW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static int InitiateShutdownW(MemorySegment lpMachineName, MemorySegment lpMessage, int dwGracePeriod, int dwShutdownFlags, int dwReason) {
        var mh$ = InitiateShutdownW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateShutdownW", lpMachineName, lpMessage, dwGracePeriod, dwShutdownFlags, dwReason);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwGracePeriod, dwShutdownFlags, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckForHiberboot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CheckForHiberboot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag)
     * }
     */
    public static FunctionDescriptor CheckForHiberboot$descriptor() {
        return CheckForHiberboot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag)
     * }
     */
    public static MethodHandle CheckForHiberboot$handle() {
        return CheckForHiberboot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag)
     * }
     */
    public static MemorySegment CheckForHiberboot$address() {
        return CheckForHiberboot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag)
     * }
     */
    public static int CheckForHiberboot(MemorySegment pHiberboot, byte bClearFlag) {
        var mh$ = CheckForHiberboot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckForHiberboot", pHiberboot, bClearFlag);
            }
            return (int)mh$.invokeExact(pHiberboot, bClearFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSaveKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegSaveKeyExA$descriptor() {
        return RegSaveKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static MethodHandle RegSaveKeyExA$handle() {
        return RegSaveKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static MemorySegment RegSaveKeyExA$address() {
        return RegSaveKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static int RegSaveKeyExA(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes, int Flags) {
        var mh$ = RegSaveKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyExA", hKey, lpFile, lpSecurityAttributes, Flags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RegSaveKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegSaveKeyExW$descriptor() {
        return RegSaveKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static MethodHandle RegSaveKeyExW$handle() {
        return RegSaveKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static MemorySegment RegSaveKeyExW$address() {
        return RegSaveKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static int RegSaveKeyExW(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes, int Flags) {
        var mh$ = RegSaveKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyExW", hKey, lpFile, lpSecurityAttributes, Flags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NETRESOURCEA {
     *     DWORD dwScope;
     *     DWORD dwType;
     *     DWORD dwDisplayType;
     *     DWORD dwUsage;
     *     LPSTR lpLocalName;
     *     LPSTR lpRemoteName;
     *     LPSTR lpComment;
     *     LPSTR lpProvider;
     * } *LPNETRESOURCEA
     * }
     */
    public static final AddressLayout LPNETRESOURCEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NETRESOURCEW {
     *     DWORD dwScope;
     *     DWORD dwType;
     *     DWORD dwDisplayType;
     *     DWORD dwUsage;
     *     LPWSTR lpLocalName;
     *     LPWSTR lpRemoteName;
     *     LPWSTR lpComment;
     *     LPWSTR lpProvider;
     * } *LPNETRESOURCEW
     * }
     */
    public static final AddressLayout LPNETRESOURCEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNETRESOURCEA LPNETRESOURCE
     * }
     */
    public static final AddressLayout LPNETRESOURCE = winapi.C_POINTER;

    private static class WNetAddConnectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetAddConnectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionA(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName)
     * }
     */
    public static FunctionDescriptor WNetAddConnectionA$descriptor() {
        return WNetAddConnectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionA(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName)
     * }
     */
    public static MethodHandle WNetAddConnectionA$handle() {
        return WNetAddConnectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionA(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName)
     * }
     */
    public static MemorySegment WNetAddConnectionA$address() {
        return WNetAddConnectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnectionA(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName)
     * }
     */
    public static int WNetAddConnectionA(MemorySegment lpRemoteName, MemorySegment lpPassword, MemorySegment lpLocalName) {
        var mh$ = WNetAddConnectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnectionA", lpRemoteName, lpPassword, lpLocalName);
            }
            return (int)mh$.invokeExact(lpRemoteName, lpPassword, lpLocalName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetAddConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionW(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName)
     * }
     */
    public static FunctionDescriptor WNetAddConnectionW$descriptor() {
        return WNetAddConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionW(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName)
     * }
     */
    public static MethodHandle WNetAddConnectionW$handle() {
        return WNetAddConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionW(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName)
     * }
     */
    public static MemorySegment WNetAddConnectionW$address() {
        return WNetAddConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnectionW(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName)
     * }
     */
    public static int WNetAddConnectionW(MemorySegment lpRemoteName, MemorySegment lpPassword, MemorySegment lpLocalName) {
        var mh$ = WNetAddConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnectionW", lpRemoteName, lpPassword, lpLocalName);
            }
            return (int)mh$.invokeExact(lpRemoteName, lpPassword, lpLocalName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetAddConnection2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor WNetAddConnection2A$descriptor() {
        return WNetAddConnection2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MethodHandle WNetAddConnection2A$handle() {
        return WNetAddConnection2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MemorySegment WNetAddConnection2A$address() {
        return WNetAddConnection2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static int WNetAddConnection2A(MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserName, int dwFlags) {
        var mh$ = WNetAddConnection2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection2A", lpNetResource, lpPassword, lpUserName, dwFlags);
            }
            return (int)mh$.invokeExact(lpNetResource, lpPassword, lpUserName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetAddConnection2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor WNetAddConnection2W$descriptor() {
        return WNetAddConnection2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MethodHandle WNetAddConnection2W$handle() {
        return WNetAddConnection2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MemorySegment WNetAddConnection2W$address() {
        return WNetAddConnection2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static int WNetAddConnection2W(MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserName, int dwFlags) {
        var mh$ = WNetAddConnection2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection2W", lpNetResource, lpPassword, lpUserName, dwFlags);
            }
            return (int)mh$.invokeExact(lpNetResource, lpPassword, lpUserName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection3A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetAddConnection3A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor WNetAddConnection3A$descriptor() {
        return WNetAddConnection3A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MethodHandle WNetAddConnection3A$handle() {
        return WNetAddConnection3A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MemorySegment WNetAddConnection3A$address() {
        return WNetAddConnection3A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection3A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static int WNetAddConnection3A(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserName, int dwFlags) {
        var mh$ = WNetAddConnection3A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection3A", hwndOwner, lpNetResource, lpPassword, lpUserName, dwFlags);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, lpPassword, lpUserName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection3W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetAddConnection3W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor WNetAddConnection3W$descriptor() {
        return WNetAddConnection3W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MethodHandle WNetAddConnection3W$handle() {
        return WNetAddConnection3W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MemorySegment WNetAddConnection3W$address() {
        return WNetAddConnection3W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection3W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static int WNetAddConnection3W(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserName, int dwFlags) {
        var mh$ = WNetAddConnection3W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection3W", hwndOwner, lpNetResource, lpPassword, lpUserName, dwFlags);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, lpPassword, lpUserName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection4A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetAddConnection4A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static FunctionDescriptor WNetAddConnection4A$descriptor() {
        return WNetAddConnection4A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static MethodHandle WNetAddConnection4A$handle() {
        return WNetAddConnection4A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static MemorySegment WNetAddConnection4A$address() {
        return WNetAddConnection4A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static int WNetAddConnection4A(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment pAuthBuffer, int cbAuthBuffer, int dwFlags, MemorySegment lpUseOptions, int cbUseOptions) {
        var mh$ = WNetAddConnection4A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection4A", hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection4W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetAddConnection4W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static FunctionDescriptor WNetAddConnection4W$descriptor() {
        return WNetAddConnection4W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static MethodHandle WNetAddConnection4W$handle() {
        return WNetAddConnection4W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static MemorySegment WNetAddConnection4W$address() {
        return WNetAddConnection4W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static int WNetAddConnection4W(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment pAuthBuffer, int cbAuthBuffer, int dwFlags, MemorySegment lpUseOptions, int cbUseOptions) {
        var mh$ = WNetAddConnection4W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection4W", hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCancelConnectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetCancelConnectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionA(LPCSTR lpName, BOOL fForce)
     * }
     */
    public static FunctionDescriptor WNetCancelConnectionA$descriptor() {
        return WNetCancelConnectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionA(LPCSTR lpName, BOOL fForce)
     * }
     */
    public static MethodHandle WNetCancelConnectionA$handle() {
        return WNetCancelConnectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionA(LPCSTR lpName, BOOL fForce)
     * }
     */
    public static MemorySegment WNetCancelConnectionA$address() {
        return WNetCancelConnectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionA(LPCSTR lpName, BOOL fForce)
     * }
     */
    public static int WNetCancelConnectionA(MemorySegment lpName, int fForce) {
        var mh$ = WNetCancelConnectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCancelConnectionA", lpName, fForce);
            }
            return (int)mh$.invokeExact(lpName, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCancelConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetCancelConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionW(LPCWSTR lpName, BOOL fForce)
     * }
     */
    public static FunctionDescriptor WNetCancelConnectionW$descriptor() {
        return WNetCancelConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionW(LPCWSTR lpName, BOOL fForce)
     * }
     */
    public static MethodHandle WNetCancelConnectionW$handle() {
        return WNetCancelConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionW(LPCWSTR lpName, BOOL fForce)
     * }
     */
    public static MemorySegment WNetCancelConnectionW$address() {
        return WNetCancelConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionW(LPCWSTR lpName, BOOL fForce)
     * }
     */
    public static int WNetCancelConnectionW(MemorySegment lpName, int fForce) {
        var mh$ = WNetCancelConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCancelConnectionW", lpName, fForce);
            }
            return (int)mh$.invokeExact(lpName, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCancelConnection2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetCancelConnection2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static FunctionDescriptor WNetCancelConnection2A$descriptor() {
        return WNetCancelConnection2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static MethodHandle WNetCancelConnection2A$handle() {
        return WNetCancelConnection2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static MemorySegment WNetCancelConnection2A$address() {
        return WNetCancelConnection2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static int WNetCancelConnection2A(MemorySegment lpName, int dwFlags, int fForce) {
        var mh$ = WNetCancelConnection2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCancelConnection2A", lpName, dwFlags, fForce);
            }
            return (int)mh$.invokeExact(lpName, dwFlags, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCancelConnection2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetCancelConnection2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static FunctionDescriptor WNetCancelConnection2W$descriptor() {
        return WNetCancelConnection2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static MethodHandle WNetCancelConnection2W$handle() {
        return WNetCancelConnection2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static MemorySegment WNetCancelConnection2W$address() {
        return WNetCancelConnection2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static int WNetCancelConnection2W(MemorySegment lpName, int dwFlags, int fForce) {
        var mh$ = WNetCancelConnection2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCancelConnection2W", lpName, dwFlags, fForce);
            }
            return (int)mh$.invokeExact(lpName, dwFlags, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetConnectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetConnectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static FunctionDescriptor WNetGetConnectionA$descriptor() {
        return WNetGetConnectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static MethodHandle WNetGetConnectionA$handle() {
        return WNetGetConnectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static MemorySegment WNetGetConnectionA$address() {
        return WNetGetConnectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static int WNetGetConnectionA(MemorySegment lpLocalName, MemorySegment lpRemoteName, MemorySegment lpnLength) {
        var mh$ = WNetGetConnectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetConnectionA", lpLocalName, lpRemoteName, lpnLength);
            }
            return (int)mh$.invokeExact(lpLocalName, lpRemoteName, lpnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static FunctionDescriptor WNetGetConnectionW$descriptor() {
        return WNetGetConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static MethodHandle WNetGetConnectionW$handle() {
        return WNetGetConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static MemorySegment WNetGetConnectionW$address() {
        return WNetGetConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static int WNetGetConnectionW(MemorySegment lpLocalName, MemorySegment lpRemoteName, MemorySegment lpnLength) {
        var mh$ = WNetGetConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetConnectionW", lpLocalName, lpRemoteName, lpnLength);
            }
            return (int)mh$.invokeExact(lpLocalName, lpRemoteName, lpnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetRestoreSingleConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetRestoreSingleConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetRestoreSingleConnectionW(HWND hwndParent, LPCWSTR lpDevice, BOOL fUseUI)
     * }
     */
    public static FunctionDescriptor WNetRestoreSingleConnectionW$descriptor() {
        return WNetRestoreSingleConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetRestoreSingleConnectionW(HWND hwndParent, LPCWSTR lpDevice, BOOL fUseUI)
     * }
     */
    public static MethodHandle WNetRestoreSingleConnectionW$handle() {
        return WNetRestoreSingleConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetRestoreSingleConnectionW(HWND hwndParent, LPCWSTR lpDevice, BOOL fUseUI)
     * }
     */
    public static MemorySegment WNetRestoreSingleConnectionW$address() {
        return WNetRestoreSingleConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetRestoreSingleConnectionW(HWND hwndParent, LPCWSTR lpDevice, BOOL fUseUI)
     * }
     */
    public static int WNetRestoreSingleConnectionW(MemorySegment hwndParent, MemorySegment lpDevice, int fUseUI) {
        var mh$ = WNetRestoreSingleConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetRestoreSingleConnectionW", hwndParent, lpDevice, fUseUI);
            }
            return (int)mh$.invokeExact(hwndParent, lpDevice, fUseUI);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetUseConnectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetUseConnectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionA(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserId, DWORD dwFlags, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static FunctionDescriptor WNetUseConnectionA$descriptor() {
        return WNetUseConnectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionA(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserId, DWORD dwFlags, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MethodHandle WNetUseConnectionA$handle() {
        return WNetUseConnectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionA(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserId, DWORD dwFlags, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MemorySegment WNetUseConnectionA$address() {
        return WNetUseConnectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetUseConnectionA(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserId, DWORD dwFlags, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static int WNetUseConnectionA(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserId, int dwFlags, MemorySegment lpAccessName, MemorySegment lpBufferSize, MemorySegment lpResult) {
        var mh$ = WNetUseConnectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetUseConnectionA", hwndOwner, lpNetResource, lpPassword, lpUserId, dwFlags, lpAccessName, lpBufferSize, lpResult);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, lpPassword, lpUserId, dwFlags, lpAccessName, lpBufferSize, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetUseConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetUseConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionW(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserId, DWORD dwFlags, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static FunctionDescriptor WNetUseConnectionW$descriptor() {
        return WNetUseConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionW(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserId, DWORD dwFlags, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MethodHandle WNetUseConnectionW$handle() {
        return WNetUseConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionW(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserId, DWORD dwFlags, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MemorySegment WNetUseConnectionW$address() {
        return WNetUseConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetUseConnectionW(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserId, DWORD dwFlags, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static int WNetUseConnectionW(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserId, int dwFlags, MemorySegment lpAccessName, MemorySegment lpBufferSize, MemorySegment lpResult) {
        var mh$ = WNetUseConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetUseConnectionW", hwndOwner, lpNetResource, lpPassword, lpUserId, dwFlags, lpAccessName, lpBufferSize, lpResult);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, lpPassword, lpUserId, dwFlags, lpAccessName, lpBufferSize, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetUseConnection4A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetUseConnection4A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static FunctionDescriptor WNetUseConnection4A$descriptor() {
        return WNetUseConnection4A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MethodHandle WNetUseConnection4A$handle() {
        return WNetUseConnection4A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MemorySegment WNetUseConnection4A$address() {
        return WNetUseConnection4A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetUseConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static int WNetUseConnection4A(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment pAuthBuffer, int cbAuthBuffer, int dwFlags, MemorySegment lpUseOptions, int cbUseOptions, MemorySegment lpAccessName, MemorySegment lpBufferSize, MemorySegment lpResult) {
        var mh$ = WNetUseConnection4A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetUseConnection4A", hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions, lpAccessName, lpBufferSize, lpResult);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions, lpAccessName, lpBufferSize, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetUseConnection4W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetUseConnection4W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static FunctionDescriptor WNetUseConnection4W$descriptor() {
        return WNetUseConnection4W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MethodHandle WNetUseConnection4W$handle() {
        return WNetUseConnection4W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MemorySegment WNetUseConnection4W$address() {
        return WNetUseConnection4W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetUseConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static int WNetUseConnection4W(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment pAuthBuffer, int cbAuthBuffer, int dwFlags, MemorySegment lpUseOptions, int cbUseOptions, MemorySegment lpAccessName, MemorySegment lpBufferSize, MemorySegment lpResult) {
        var mh$ = WNetUseConnection4W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetUseConnection4W", hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions, lpAccessName, lpBufferSize, lpResult);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions, lpAccessName, lpBufferSize, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetConnectionDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetConnectionDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static FunctionDescriptor WNetConnectionDialog$descriptor() {
        return WNetConnectionDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static MethodHandle WNetConnectionDialog$handle() {
        return WNetConnectionDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static MemorySegment WNetConnectionDialog$address() {
        return WNetConnectionDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static int WNetConnectionDialog(MemorySegment hwnd, int dwType) {
        var mh$ = WNetConnectionDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetConnectionDialog", hwnd, dwType);
            }
            return (int)mh$.invokeExact(hwnd, dwType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetDisconnectDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetDisconnectDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static FunctionDescriptor WNetDisconnectDialog$descriptor() {
        return WNetDisconnectDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static MethodHandle WNetDisconnectDialog$handle() {
        return WNetDisconnectDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static MemorySegment WNetDisconnectDialog$address() {
        return WNetDisconnectDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static int WNetDisconnectDialog(MemorySegment hwnd, int dwType) {
        var mh$ = WNetDisconnectDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetDisconnectDialog", hwnd, dwType);
            }
            return (int)mh$.invokeExact(hwnd, dwType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONNECTDLGSTRUCTA {
     *     DWORD cbStructure;
     *     HWND hwndOwner;
     *     LPNETRESOURCEA lpConnRes;
     *     DWORD dwFlags;
     *     DWORD dwDevNum;
     * } *LPCONNECTDLGSTRUCTA
     * }
     */
    public static final AddressLayout LPCONNECTDLGSTRUCTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CONNECTDLGSTRUCTW {
     *     DWORD cbStructure;
     *     HWND hwndOwner;
     *     LPNETRESOURCEW lpConnRes;
     *     DWORD dwFlags;
     *     DWORD dwDevNum;
     * } *LPCONNECTDLGSTRUCTW
     * }
     */
    public static final AddressLayout LPCONNECTDLGSTRUCTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT
     * }
     */
    public static final AddressLayout LPCONNECTDLGSTRUCT = winapi.C_POINTER;

    private static class WNetConnectionDialog1A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetConnectionDialog1A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static FunctionDescriptor WNetConnectionDialog1A$descriptor() {
        return WNetConnectionDialog1A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static MethodHandle WNetConnectionDialog1A$handle() {
        return WNetConnectionDialog1A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static MemorySegment WNetConnectionDialog1A$address() {
        return WNetConnectionDialog1A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static int WNetConnectionDialog1A(MemorySegment lpConnDlgStruct) {
        var mh$ = WNetConnectionDialog1A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetConnectionDialog1A", lpConnDlgStruct);
            }
            return (int)mh$.invokeExact(lpConnDlgStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetConnectionDialog1W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetConnectionDialog1W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static FunctionDescriptor WNetConnectionDialog1W$descriptor() {
        return WNetConnectionDialog1W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static MethodHandle WNetConnectionDialog1W$handle() {
        return WNetConnectionDialog1W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static MemorySegment WNetConnectionDialog1W$address() {
        return WNetConnectionDialog1W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static int WNetConnectionDialog1W(MemorySegment lpConnDlgStruct) {
        var mh$ = WNetConnectionDialog1W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetConnectionDialog1W", lpConnDlgStruct);
            }
            return (int)mh$.invokeExact(lpConnDlgStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DISCDLGSTRUCTA {
     *     DWORD cbStructure;
     *     HWND hwndOwner;
     *     LPSTR lpLocalName;
     *     LPSTR lpRemoteName;
     *     DWORD dwFlags;
     * } *LPDISCDLGSTRUCTA
     * }
     */
    public static final AddressLayout LPDISCDLGSTRUCTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISCDLGSTRUCTW {
     *     DWORD cbStructure;
     *     HWND hwndOwner;
     *     LPWSTR lpLocalName;
     *     LPWSTR lpRemoteName;
     *     DWORD dwFlags;
     * } *LPDISCDLGSTRUCTW
     * }
     */
    public static final AddressLayout LPDISCDLGSTRUCTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT
     * }
     */
    public static final AddressLayout LPDISCDLGSTRUCT = winapi.C_POINTER;

    private static class WNetDisconnectDialog1A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetDisconnectDialog1A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static FunctionDescriptor WNetDisconnectDialog1A$descriptor() {
        return WNetDisconnectDialog1A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static MethodHandle WNetDisconnectDialog1A$handle() {
        return WNetDisconnectDialog1A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static MemorySegment WNetDisconnectDialog1A$address() {
        return WNetDisconnectDialog1A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static int WNetDisconnectDialog1A(MemorySegment lpConnDlgStruct) {
        var mh$ = WNetDisconnectDialog1A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetDisconnectDialog1A", lpConnDlgStruct);
            }
            return (int)mh$.invokeExact(lpConnDlgStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetDisconnectDialog1W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetDisconnectDialog1W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static FunctionDescriptor WNetDisconnectDialog1W$descriptor() {
        return WNetDisconnectDialog1W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static MethodHandle WNetDisconnectDialog1W$handle() {
        return WNetDisconnectDialog1W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static MemorySegment WNetDisconnectDialog1W$address() {
        return WNetDisconnectDialog1W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static int WNetDisconnectDialog1W(MemorySegment lpConnDlgStruct) {
        var mh$ = WNetDisconnectDialog1W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetDisconnectDialog1W", lpConnDlgStruct);
            }
            return (int)mh$.invokeExact(lpConnDlgStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetOpenEnumA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetOpenEnumA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static FunctionDescriptor WNetOpenEnumA$descriptor() {
        return WNetOpenEnumA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static MethodHandle WNetOpenEnumA$handle() {
        return WNetOpenEnumA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static MemorySegment WNetOpenEnumA$address() {
        return WNetOpenEnumA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static int WNetOpenEnumA(int dwScope, int dwType, int dwUsage, MemorySegment lpNetResource, MemorySegment lphEnum) {
        var mh$ = WNetOpenEnumA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetOpenEnumA", dwScope, dwType, dwUsage, lpNetResource, lphEnum);
            }
            return (int)mh$.invokeExact(dwScope, dwType, dwUsage, lpNetResource, lphEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetOpenEnumW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetOpenEnumW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static FunctionDescriptor WNetOpenEnumW$descriptor() {
        return WNetOpenEnumW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static MethodHandle WNetOpenEnumW$handle() {
        return WNetOpenEnumW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static MemorySegment WNetOpenEnumW$address() {
        return WNetOpenEnumW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static int WNetOpenEnumW(int dwScope, int dwType, int dwUsage, MemorySegment lpNetResource, MemorySegment lphEnum) {
        var mh$ = WNetOpenEnumW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetOpenEnumW", dwScope, dwType, dwUsage, lpNetResource, lphEnum);
            }
            return (int)mh$.invokeExact(dwScope, dwType, dwUsage, lpNetResource, lphEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetEnumResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetEnumResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetEnumResourceA$descriptor() {
        return WNetEnumResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetEnumResourceA$handle() {
        return WNetEnumResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetEnumResourceA$address() {
        return WNetEnumResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetEnumResourceA(MemorySegment hEnum, MemorySegment lpcCount, MemorySegment lpBuffer, MemorySegment lpBufferSize) {
        var mh$ = WNetEnumResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetEnumResourceA", hEnum, lpcCount, lpBuffer, lpBufferSize);
            }
            return (int)mh$.invokeExact(hEnum, lpcCount, lpBuffer, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetEnumResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetEnumResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetEnumResourceW$descriptor() {
        return WNetEnumResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetEnumResourceW$handle() {
        return WNetEnumResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetEnumResourceW$address() {
        return WNetEnumResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetEnumResourceW(MemorySegment hEnum, MemorySegment lpcCount, MemorySegment lpBuffer, MemorySegment lpBufferSize) {
        var mh$ = WNetEnumResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetEnumResourceW", hEnum, lpcCount, lpBuffer, lpBufferSize);
            }
            return (int)mh$.invokeExact(hEnum, lpcCount, lpBuffer, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCloseEnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetCloseEnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCloseEnum(HANDLE hEnum)
     * }
     */
    public static FunctionDescriptor WNetCloseEnum$descriptor() {
        return WNetCloseEnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCloseEnum(HANDLE hEnum)
     * }
     */
    public static MethodHandle WNetCloseEnum$handle() {
        return WNetCloseEnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCloseEnum(HANDLE hEnum)
     * }
     */
    public static MemorySegment WNetCloseEnum$address() {
        return WNetCloseEnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCloseEnum(HANDLE hEnum)
     * }
     */
    public static int WNetCloseEnum(MemorySegment hEnum) {
        var mh$ = WNetCloseEnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCloseEnum", hEnum);
            }
            return (int)mh$.invokeExact(hEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetResourceParentA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetResourceParentA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static FunctionDescriptor WNetGetResourceParentA$descriptor() {
        return WNetGetResourceParentA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static MethodHandle WNetGetResourceParentA$handle() {
        return WNetGetResourceParentA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static MemorySegment WNetGetResourceParentA$address() {
        return WNetGetResourceParentA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static int WNetGetResourceParentA(MemorySegment lpNetResource, MemorySegment lpBuffer, MemorySegment lpcbBuffer) {
        var mh$ = WNetGetResourceParentA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetResourceParentA", lpNetResource, lpBuffer, lpcbBuffer);
            }
            return (int)mh$.invokeExact(lpNetResource, lpBuffer, lpcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetResourceParentW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetResourceParentW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static FunctionDescriptor WNetGetResourceParentW$descriptor() {
        return WNetGetResourceParentW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static MethodHandle WNetGetResourceParentW$handle() {
        return WNetGetResourceParentW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static MemorySegment WNetGetResourceParentW$address() {
        return WNetGetResourceParentW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static int WNetGetResourceParentW(MemorySegment lpNetResource, MemorySegment lpBuffer, MemorySegment lpcbBuffer) {
        var mh$ = WNetGetResourceParentW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetResourceParentW", lpNetResource, lpBuffer, lpcbBuffer);
            }
            return (int)mh$.invokeExact(lpNetResource, lpBuffer, lpcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetResourceInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetResourceInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPSTR *lplpSystem)
     * }
     */
    public static FunctionDescriptor WNetGetResourceInformationA$descriptor() {
        return WNetGetResourceInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPSTR *lplpSystem)
     * }
     */
    public static MethodHandle WNetGetResourceInformationA$handle() {
        return WNetGetResourceInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPSTR *lplpSystem)
     * }
     */
    public static MemorySegment WNetGetResourceInformationA$address() {
        return WNetGetResourceInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPSTR *lplpSystem)
     * }
     */
    public static int WNetGetResourceInformationA(MemorySegment lpNetResource, MemorySegment lpBuffer, MemorySegment lpcbBuffer, MemorySegment lplpSystem) {
        var mh$ = WNetGetResourceInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetResourceInformationA", lpNetResource, lpBuffer, lpcbBuffer, lplpSystem);
            }
            return (int)mh$.invokeExact(lpNetResource, lpBuffer, lpcbBuffer, lplpSystem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetResourceInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetResourceInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPWSTR *lplpSystem)
     * }
     */
    public static FunctionDescriptor WNetGetResourceInformationW$descriptor() {
        return WNetGetResourceInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPWSTR *lplpSystem)
     * }
     */
    public static MethodHandle WNetGetResourceInformationW$handle() {
        return WNetGetResourceInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPWSTR *lplpSystem)
     * }
     */
    public static MemorySegment WNetGetResourceInformationW$address() {
        return WNetGetResourceInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPWSTR *lplpSystem)
     * }
     */
    public static int WNetGetResourceInformationW(MemorySegment lpNetResource, MemorySegment lpBuffer, MemorySegment lpcbBuffer, MemorySegment lplpSystem) {
        var mh$ = WNetGetResourceInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetResourceInformationW", lpNetResource, lpBuffer, lpcbBuffer, lplpSystem);
            }
            return (int)mh$.invokeExact(lpNetResource, lpBuffer, lpcbBuffer, lplpSystem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _UNIVERSAL_NAME_INFOA {
     *     LPSTR lpUniversalName;
     * } *LPUNIVERSAL_NAME_INFOA
     * }
     */
    public static final AddressLayout LPUNIVERSAL_NAME_INFOA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UNIVERSAL_NAME_INFOW {
     *     LPWSTR lpUniversalName;
     * } *LPUNIVERSAL_NAME_INFOW
     * }
     */
    public static final AddressLayout LPUNIVERSAL_NAME_INFOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO
     * }
     */
    public static final AddressLayout LPUNIVERSAL_NAME_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REMOTE_NAME_INFOA {
     *     LPSTR lpUniversalName;
     *     LPSTR lpConnectionName;
     *     LPSTR lpRemainingPath;
     * } *LPREMOTE_NAME_INFOA
     * }
     */
    public static final AddressLayout LPREMOTE_NAME_INFOA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REMOTE_NAME_INFOW {
     *     LPWSTR lpUniversalName;
     *     LPWSTR lpConnectionName;
     *     LPWSTR lpRemainingPath;
     * } *LPREMOTE_NAME_INFOW
     * }
     */
    public static final AddressLayout LPREMOTE_NAME_INFOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO
     * }
     */
    public static final AddressLayout LPREMOTE_NAME_INFO = winapi.C_POINTER;

    private static class WNetGetUniversalNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetUniversalNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameA(LPCSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetGetUniversalNameA$descriptor() {
        return WNetGetUniversalNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameA(LPCSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetGetUniversalNameA$handle() {
        return WNetGetUniversalNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameA(LPCSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetGetUniversalNameA$address() {
        return WNetGetUniversalNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameA(LPCSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetGetUniversalNameA(MemorySegment lpLocalPath, int dwInfoLevel, MemorySegment lpBuffer, MemorySegment lpBufferSize) {
        var mh$ = WNetGetUniversalNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetUniversalNameA", lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize);
            }
            return (int)mh$.invokeExact(lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetUniversalNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetUniversalNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameW(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetGetUniversalNameW$descriptor() {
        return WNetGetUniversalNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameW(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetGetUniversalNameW$handle() {
        return WNetGetUniversalNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameW(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetGetUniversalNameW$address() {
        return WNetGetUniversalNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameW(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetGetUniversalNameW(MemorySegment lpLocalPath, int dwInfoLevel, MemorySegment lpBuffer, MemorySegment lpBufferSize) {
        var mh$ = WNetGetUniversalNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetUniversalNameW", lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize);
            }
            return (int)mh$.invokeExact(lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetUserA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetUserA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetUserA(LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static FunctionDescriptor WNetGetUserA$descriptor() {
        return WNetGetUserA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetUserA(LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static MethodHandle WNetGetUserA$handle() {
        return WNetGetUserA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetUserA(LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static MemorySegment WNetGetUserA$address() {
        return WNetGetUserA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetUserA(LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static int WNetGetUserA(MemorySegment lpName, MemorySegment lpUserName, MemorySegment lpnLength) {
        var mh$ = WNetGetUserA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetUserA", lpName, lpUserName, lpnLength);
            }
            return (int)mh$.invokeExact(lpName, lpUserName, lpnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetUserW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetUserW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetUserW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static FunctionDescriptor WNetGetUserW$descriptor() {
        return WNetGetUserW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetUserW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static MethodHandle WNetGetUserW$handle() {
        return WNetGetUserW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetUserW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static MemorySegment WNetGetUserW$address() {
        return WNetGetUserW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetUserW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static int WNetGetUserW(MemorySegment lpName, MemorySegment lpUserName, MemorySegment lpnLength) {
        var mh$ = WNetGetUserW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetUserW", lpName, lpUserName, lpnLength);
            }
            return (int)mh$.invokeExact(lpName, lpUserName, lpnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetProviderNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetProviderNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameA(DWORD dwNetType, LPSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetGetProviderNameA$descriptor() {
        return WNetGetProviderNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameA(DWORD dwNetType, LPSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetGetProviderNameA$handle() {
        return WNetGetProviderNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameA(DWORD dwNetType, LPSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetGetProviderNameA$address() {
        return WNetGetProviderNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameA(DWORD dwNetType, LPSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetGetProviderNameA(int dwNetType, MemorySegment lpProviderName, MemorySegment lpBufferSize) {
        var mh$ = WNetGetProviderNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetProviderNameA", dwNetType, lpProviderName, lpBufferSize);
            }
            return (int)mh$.invokeExact(dwNetType, lpProviderName, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetProviderNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetProviderNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameW(DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetGetProviderNameW$descriptor() {
        return WNetGetProviderNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameW(DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetGetProviderNameW$handle() {
        return WNetGetProviderNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameW(DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetGetProviderNameW$address() {
        return WNetGetProviderNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameW(DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetGetProviderNameW(int dwNetType, MemorySegment lpProviderName, MemorySegment lpBufferSize) {
        var mh$ = WNetGetProviderNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetProviderNameW", dwNetType, lpProviderName, lpBufferSize);
            }
            return (int)mh$.invokeExact(dwNetType, lpProviderName, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NETINFOSTRUCT {
     *     DWORD cbStructure;
     *     DWORD dwProviderVersion;
     *     DWORD dwStatus;
     *     DWORD dwCharacteristics;
     *     ULONG_PTR dwHandle;
     *     WORD wNetType;
     *     DWORD dwPrinters;
     *     DWORD dwDrives;
     * } *LPNETINFOSTRUCT
     * }
     */
    public static final AddressLayout LPNETINFOSTRUCT = winapi.C_POINTER;

    private static class WNetGetNetworkInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetNetworkInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationA(LPCSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static FunctionDescriptor WNetGetNetworkInformationA$descriptor() {
        return WNetGetNetworkInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationA(LPCSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static MethodHandle WNetGetNetworkInformationA$handle() {
        return WNetGetNetworkInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationA(LPCSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static MemorySegment WNetGetNetworkInformationA$address() {
        return WNetGetNetworkInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationA(LPCSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static int WNetGetNetworkInformationA(MemorySegment lpProvider, MemorySegment lpNetInfoStruct) {
        var mh$ = WNetGetNetworkInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetNetworkInformationA", lpProvider, lpNetInfoStruct);
            }
            return (int)mh$.invokeExact(lpProvider, lpNetInfoStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetNetworkInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetNetworkInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationW(LPCWSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static FunctionDescriptor WNetGetNetworkInformationW$descriptor() {
        return WNetGetNetworkInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationW(LPCWSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static MethodHandle WNetGetNetworkInformationW$handle() {
        return WNetGetNetworkInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationW(LPCWSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static MemorySegment WNetGetNetworkInformationW$address() {
        return WNetGetNetworkInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationW(LPCWSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static int WNetGetNetworkInformationW(MemorySegment lpProvider, MemorySegment lpNetInfoStruct) {
        var mh$ = WNetGetNetworkInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetNetworkInformationW", lpProvider, lpNetInfoStruct);
            }
            return (int)mh$.invokeExact(lpProvider, lpNetInfoStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetLastErrorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetLastErrorA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorA(LPDWORD lpError, LPSTR lpErrorBuf, DWORD nErrorBufSize, LPSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static FunctionDescriptor WNetGetLastErrorA$descriptor() {
        return WNetGetLastErrorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorA(LPDWORD lpError, LPSTR lpErrorBuf, DWORD nErrorBufSize, LPSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static MethodHandle WNetGetLastErrorA$handle() {
        return WNetGetLastErrorA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorA(LPDWORD lpError, LPSTR lpErrorBuf, DWORD nErrorBufSize, LPSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static MemorySegment WNetGetLastErrorA$address() {
        return WNetGetLastErrorA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorA(LPDWORD lpError, LPSTR lpErrorBuf, DWORD nErrorBufSize, LPSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static int WNetGetLastErrorA(MemorySegment lpError, MemorySegment lpErrorBuf, int nErrorBufSize, MemorySegment lpNameBuf, int nNameBufSize) {
        var mh$ = WNetGetLastErrorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetLastErrorA", lpError, lpErrorBuf, nErrorBufSize, lpNameBuf, nNameBufSize);
            }
            return (int)mh$.invokeExact(lpError, lpErrorBuf, nErrorBufSize, lpNameBuf, nNameBufSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetLastErrorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WNetGetLastErrorW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorW(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD nErrorBufSize, LPWSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static FunctionDescriptor WNetGetLastErrorW$descriptor() {
        return WNetGetLastErrorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorW(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD nErrorBufSize, LPWSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static MethodHandle WNetGetLastErrorW$handle() {
        return WNetGetLastErrorW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorW(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD nErrorBufSize, LPWSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static MemorySegment WNetGetLastErrorW$address() {
        return WNetGetLastErrorW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorW(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD nErrorBufSize, LPWSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static int WNetGetLastErrorW(MemorySegment lpError, MemorySegment lpErrorBuf, int nErrorBufSize, MemorySegment lpNameBuf, int nNameBufSize) {
        var mh$ = WNetGetLastErrorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetLastErrorW", lpError, lpErrorBuf, nErrorBufSize, lpNameBuf, nNameBufSize);
            }
            return (int)mh$.invokeExact(lpError, lpErrorBuf, nErrorBufSize, lpNameBuf, nNameBufSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NETCONNECTINFOSTRUCT {
     *     DWORD cbStructure;
     *     DWORD dwFlags;
     *     DWORD dwSpeed;
     *     DWORD dwDelay;
     *     DWORD dwOptDataSize;
     * } *LPNETCONNECTINFOSTRUCT
     * }
     */
    public static final AddressLayout LPNETCONNECTINFOSTRUCT = winapi.C_POINTER;

    private static class MultinetGetConnectionPerformanceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("MultinetGetConnectionPerformanceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCEA lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static FunctionDescriptor MultinetGetConnectionPerformanceA$descriptor() {
        return MultinetGetConnectionPerformanceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCEA lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static MethodHandle MultinetGetConnectionPerformanceA$handle() {
        return MultinetGetConnectionPerformanceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCEA lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static MemorySegment MultinetGetConnectionPerformanceA$address() {
        return MultinetGetConnectionPerformanceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCEA lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static int MultinetGetConnectionPerformanceA(MemorySegment lpNetResource, MemorySegment lpNetConnectInfoStruct) {
        var mh$ = MultinetGetConnectionPerformanceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MultinetGetConnectionPerformanceA", lpNetResource, lpNetConnectInfoStruct);
            }
            return (int)mh$.invokeExact(lpNetResource, lpNetConnectInfoStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MultinetGetConnectionPerformanceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("MultinetGetConnectionPerformanceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCEW lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static FunctionDescriptor MultinetGetConnectionPerformanceW$descriptor() {
        return MultinetGetConnectionPerformanceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCEW lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static MethodHandle MultinetGetConnectionPerformanceW$handle() {
        return MultinetGetConnectionPerformanceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCEW lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static MemorySegment MultinetGetConnectionPerformanceW$address() {
        return MultinetGetConnectionPerformanceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCEW lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static int MultinetGetConnectionPerformanceW(MemorySegment lpNetResource, MemorySegment lpNetConnectInfoStruct) {
        var mh$ = MultinetGetConnectionPerformanceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MultinetGetConnectionPerformanceW", lpNetResource, lpNetConnectInfoStruct);
            }
            return (int)mh$.invokeExact(lpNetResource, lpNetConnectInfoStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeSetQualityOfService {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeSetQualityOfService");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeSetQualityOfService(HWND hwndClient, const SECURITY_QUALITY_OF_SERVICE *pqosNew, PSECURITY_QUALITY_OF_SERVICE pqosPrev)
     * }
     */
    public static FunctionDescriptor DdeSetQualityOfService$descriptor() {
        return DdeSetQualityOfService.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeSetQualityOfService(HWND hwndClient, const SECURITY_QUALITY_OF_SERVICE *pqosNew, PSECURITY_QUALITY_OF_SERVICE pqosPrev)
     * }
     */
    public static MethodHandle DdeSetQualityOfService$handle() {
        return DdeSetQualityOfService.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeSetQualityOfService(HWND hwndClient, const SECURITY_QUALITY_OF_SERVICE *pqosNew, PSECURITY_QUALITY_OF_SERVICE pqosPrev)
     * }
     */
    public static MemorySegment DdeSetQualityOfService$address() {
        return DdeSetQualityOfService.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeSetQualityOfService(HWND hwndClient, const SECURITY_QUALITY_OF_SERVICE *pqosNew, PSECURITY_QUALITY_OF_SERVICE pqosPrev)
     * }
     */
    public static int DdeSetQualityOfService(MemorySegment hwndClient, MemorySegment pqosNew, MemorySegment pqosPrev) {
        var mh$ = DdeSetQualityOfService.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeSetQualityOfService", hwndClient, pqosNew, pqosPrev);
            }
            return (int)mh$.invokeExact(hwndClient, pqosNew, pqosPrev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateDdeClientWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ImpersonateDdeClientWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateDdeClientWindow(HWND hWndClient, HWND hWndServer)
     * }
     */
    public static FunctionDescriptor ImpersonateDdeClientWindow$descriptor() {
        return ImpersonateDdeClientWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateDdeClientWindow(HWND hWndClient, HWND hWndServer)
     * }
     */
    public static MethodHandle ImpersonateDdeClientWindow$handle() {
        return ImpersonateDdeClientWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateDdeClientWindow(HWND hWndClient, HWND hWndServer)
     * }
     */
    public static MemorySegment ImpersonateDdeClientWindow$address() {
        return ImpersonateDdeClientWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateDdeClientWindow(HWND hWndClient, HWND hWndServer)
     * }
     */
    public static int ImpersonateDdeClientWindow(MemorySegment hWndClient, MemorySegment hWndServer) {
        var mh$ = ImpersonateDdeClientWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateDdeClientWindow", hWndClient, hWndServer);
            }
            return (int)mh$.invokeExact(hWndClient, hWndServer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PackDDElParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PackDDElParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPARAM PackDDElParam(UINT msg, UINT_PTR uiLo, UINT_PTR uiHi)
     * }
     */
    public static FunctionDescriptor PackDDElParam$descriptor() {
        return PackDDElParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPARAM PackDDElParam(UINT msg, UINT_PTR uiLo, UINT_PTR uiHi)
     * }
     */
    public static MethodHandle PackDDElParam$handle() {
        return PackDDElParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPARAM PackDDElParam(UINT msg, UINT_PTR uiLo, UINT_PTR uiHi)
     * }
     */
    public static MemorySegment PackDDElParam$address() {
        return PackDDElParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPARAM PackDDElParam(UINT msg, UINT_PTR uiLo, UINT_PTR uiHi)
     * }
     */
    public static long PackDDElParam(int msg, long uiLo, long uiHi) {
        var mh$ = PackDDElParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PackDDElParam", msg, uiLo, uiHi);
            }
            return (long)mh$.invokeExact(msg, uiLo, uiHi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnpackDDElParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("UnpackDDElParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnpackDDElParam(UINT msg, LPARAM lParam, PUINT_PTR puiLo, PUINT_PTR puiHi)
     * }
     */
    public static FunctionDescriptor UnpackDDElParam$descriptor() {
        return UnpackDDElParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnpackDDElParam(UINT msg, LPARAM lParam, PUINT_PTR puiLo, PUINT_PTR puiHi)
     * }
     */
    public static MethodHandle UnpackDDElParam$handle() {
        return UnpackDDElParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnpackDDElParam(UINT msg, LPARAM lParam, PUINT_PTR puiLo, PUINT_PTR puiHi)
     * }
     */
    public static MemorySegment UnpackDDElParam$address() {
        return UnpackDDElParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnpackDDElParam(UINT msg, LPARAM lParam, PUINT_PTR puiLo, PUINT_PTR puiHi)
     * }
     */
    public static int UnpackDDElParam(int msg, long lParam, MemorySegment puiLo, MemorySegment puiHi) {
        var mh$ = UnpackDDElParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnpackDDElParam", msg, lParam, puiLo, puiHi);
            }
            return (int)mh$.invokeExact(msg, lParam, puiLo, puiHi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeDDElParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FreeDDElParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeDDElParam(UINT msg, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor FreeDDElParam$descriptor() {
        return FreeDDElParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeDDElParam(UINT msg, LPARAM lParam)
     * }
     */
    public static MethodHandle FreeDDElParam$handle() {
        return FreeDDElParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeDDElParam(UINT msg, LPARAM lParam)
     * }
     */
    public static MemorySegment FreeDDElParam$address() {
        return FreeDDElParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeDDElParam(UINT msg, LPARAM lParam)
     * }
     */
    public static int FreeDDElParam(int msg, long lParam) {
        var mh$ = FreeDDElParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeDDElParam", msg, lParam);
            }
            return (int)mh$.invokeExact(msg, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReuseDDElParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReuseDDElParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPARAM ReuseDDElParam(LPARAM lParam, UINT msgIn, UINT msgOut, UINT_PTR uiLo, UINT_PTR uiHi)
     * }
     */
    public static FunctionDescriptor ReuseDDElParam$descriptor() {
        return ReuseDDElParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPARAM ReuseDDElParam(LPARAM lParam, UINT msgIn, UINT msgOut, UINT_PTR uiLo, UINT_PTR uiHi)
     * }
     */
    public static MethodHandle ReuseDDElParam$handle() {
        return ReuseDDElParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPARAM ReuseDDElParam(LPARAM lParam, UINT msgIn, UINT msgOut, UINT_PTR uiLo, UINT_PTR uiHi)
     * }
     */
    public static MemorySegment ReuseDDElParam$address() {
        return ReuseDDElParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPARAM ReuseDDElParam(LPARAM lParam, UINT msgIn, UINT msgOut, UINT_PTR uiLo, UINT_PTR uiHi)
     * }
     */
    public static long ReuseDDElParam(long lParam, int msgIn, int msgOut, long uiLo, long uiHi) {
        var mh$ = ReuseDDElParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReuseDDElParam", lParam, msgIn, msgOut, uiLo, uiHi);
            }
            return (long)mh$.invokeExact(lParam, msgIn, msgOut, uiLo, uiHi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HCONVLIST__ {
     *     int unused;
     * } *HCONVLIST
     * }
     */
    public static final AddressLayout HCONVLIST = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HCONV__ {
     *     int unused;
     * } *HCONV
     * }
     */
    public static final AddressLayout HCONV = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HSZ__ {
     *     int unused;
     * } *HSZ
     * }
     */
    public static final AddressLayout HSZ = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HDDEDATA__ {
     *     int unused;
     * } *HDDEDATA
     * }
     */
    public static final AddressLayout HDDEDATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHSZPAIR {
     *     HSZ hszSvc;
     *     HSZ hszTopic;
     * } *PHSZPAIR
     * }
     */
    public static final AddressLayout PHSZPAIR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCONVCONTEXT {
     *     UINT cb;
     *     UINT wFlags;
     *     UINT wCountryID;
     *     int iCodePage;
     *     DWORD dwLangID;
     *     DWORD dwSecurity;
     *     SECURITY_QUALITY_OF_SERVICE qos;
     * } *PCONVCONTEXT
     * }
     */
    public static final AddressLayout PCONVCONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCONVINFO {
     *     DWORD cb;
     *     DWORD_PTR hUser;
     *     HCONV hConvPartner;
     *     HSZ hszSvcPartner;
     *     HSZ hszServiceReq;
     *     HSZ hszTopic;
     *     HSZ hszItem;
     *     UINT wFmt;
     *     UINT wType;
     *     UINT wStatus;
     *     UINT wConvst;
     *     UINT wLastError;
     *     HCONVLIST hConvList;
     *     CONVCONTEXT ConvCtxt;
     *     HWND hwnd;
     *     HWND hwndPartner;
     * } *PCONVINFO
     * }
     */
    public static final AddressLayout PCONVINFO = winapi.C_POINTER;

    private static class DdeInitializeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeInitializeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes)
     * }
     */
    public static FunctionDescriptor DdeInitializeA$descriptor() {
        return DdeInitializeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes)
     * }
     */
    public static MethodHandle DdeInitializeA$handle() {
        return DdeInitializeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes)
     * }
     */
    public static MemorySegment DdeInitializeA$address() {
        return DdeInitializeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes)
     * }
     */
    public static int DdeInitializeA(MemorySegment pidInst, MemorySegment pfnCallback, int afCmd, int ulRes) {
        var mh$ = DdeInitializeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeInitializeA", pidInst, pfnCallback, afCmd, ulRes);
            }
            return (int)mh$.invokeExact(pidInst, pfnCallback, afCmd, ulRes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeInitializeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeInitializeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes)
     * }
     */
    public static FunctionDescriptor DdeInitializeW$descriptor() {
        return DdeInitializeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes)
     * }
     */
    public static MethodHandle DdeInitializeW$handle() {
        return DdeInitializeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes)
     * }
     */
    public static MemorySegment DdeInitializeW$address() {
        return DdeInitializeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes)
     * }
     */
    public static int DdeInitializeW(MemorySegment pidInst, MemorySegment pfnCallback, int afCmd, int ulRes) {
        var mh$ = DdeInitializeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeInitializeW", pidInst, pfnCallback, afCmd, ulRes);
            }
            return (int)mh$.invokeExact(pidInst, pfnCallback, afCmd, ulRes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeUninitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeUninitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeUninitialize(DWORD idInst)
     * }
     */
    public static FunctionDescriptor DdeUninitialize$descriptor() {
        return DdeUninitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeUninitialize(DWORD idInst)
     * }
     */
    public static MethodHandle DdeUninitialize$handle() {
        return DdeUninitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeUninitialize(DWORD idInst)
     * }
     */
    public static MemorySegment DdeUninitialize$address() {
        return DdeUninitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeUninitialize(DWORD idInst)
     * }
     */
    public static int DdeUninitialize(int idInst) {
        var mh$ = DdeUninitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeUninitialize", idInst);
            }
            return (int)mh$.invokeExact(idInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeConnectList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeConnectList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCONVLIST DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic, HCONVLIST hConvList, PCONVCONTEXT pCC)
     * }
     */
    public static FunctionDescriptor DdeConnectList$descriptor() {
        return DdeConnectList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCONVLIST DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic, HCONVLIST hConvList, PCONVCONTEXT pCC)
     * }
     */
    public static MethodHandle DdeConnectList$handle() {
        return DdeConnectList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCONVLIST DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic, HCONVLIST hConvList, PCONVCONTEXT pCC)
     * }
     */
    public static MemorySegment DdeConnectList$address() {
        return DdeConnectList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCONVLIST DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic, HCONVLIST hConvList, PCONVCONTEXT pCC)
     * }
     */
    public static MemorySegment DdeConnectList(int idInst, MemorySegment hszService, MemorySegment hszTopic, MemorySegment hConvList, MemorySegment pCC) {
        var mh$ = DdeConnectList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeConnectList", idInst, hszService, hszTopic, hConvList, pCC);
            }
            return (MemorySegment)mh$.invokeExact(idInst, hszService, hszTopic, hConvList, pCC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeQueryNextServer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeQueryNextServer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCONV DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev)
     * }
     */
    public static FunctionDescriptor DdeQueryNextServer$descriptor() {
        return DdeQueryNextServer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCONV DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev)
     * }
     */
    public static MethodHandle DdeQueryNextServer$handle() {
        return DdeQueryNextServer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCONV DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev)
     * }
     */
    public static MemorySegment DdeQueryNextServer$address() {
        return DdeQueryNextServer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCONV DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev)
     * }
     */
    public static MemorySegment DdeQueryNextServer(MemorySegment hConvList, MemorySegment hConvPrev) {
        var mh$ = DdeQueryNextServer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeQueryNextServer", hConvList, hConvPrev);
            }
            return (MemorySegment)mh$.invokeExact(hConvList, hConvPrev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeDisconnectList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeDisconnectList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeDisconnectList(HCONVLIST hConvList)
     * }
     */
    public static FunctionDescriptor DdeDisconnectList$descriptor() {
        return DdeDisconnectList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeDisconnectList(HCONVLIST hConvList)
     * }
     */
    public static MethodHandle DdeDisconnectList$handle() {
        return DdeDisconnectList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeDisconnectList(HCONVLIST hConvList)
     * }
     */
    public static MemorySegment DdeDisconnectList$address() {
        return DdeDisconnectList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeDisconnectList(HCONVLIST hConvList)
     * }
     */
    public static int DdeDisconnectList(MemorySegment hConvList) {
        var mh$ = DdeDisconnectList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeDisconnectList", hConvList);
            }
            return (int)mh$.invokeExact(hConvList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeConnect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeConnect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCONV DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic, PCONVCONTEXT pCC)
     * }
     */
    public static FunctionDescriptor DdeConnect$descriptor() {
        return DdeConnect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCONV DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic, PCONVCONTEXT pCC)
     * }
     */
    public static MethodHandle DdeConnect$handle() {
        return DdeConnect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCONV DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic, PCONVCONTEXT pCC)
     * }
     */
    public static MemorySegment DdeConnect$address() {
        return DdeConnect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCONV DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic, PCONVCONTEXT pCC)
     * }
     */
    public static MemorySegment DdeConnect(int idInst, MemorySegment hszService, MemorySegment hszTopic, MemorySegment pCC) {
        var mh$ = DdeConnect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeConnect", idInst, hszService, hszTopic, pCC);
            }
            return (MemorySegment)mh$.invokeExact(idInst, hszService, hszTopic, pCC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeDisconnect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeDisconnect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeDisconnect(HCONV hConv)
     * }
     */
    public static FunctionDescriptor DdeDisconnect$descriptor() {
        return DdeDisconnect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeDisconnect(HCONV hConv)
     * }
     */
    public static MethodHandle DdeDisconnect$handle() {
        return DdeDisconnect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeDisconnect(HCONV hConv)
     * }
     */
    public static MemorySegment DdeDisconnect$address() {
        return DdeDisconnect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeDisconnect(HCONV hConv)
     * }
     */
    public static int DdeDisconnect(MemorySegment hConv) {
        var mh$ = DdeDisconnect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeDisconnect", hConv);
            }
            return (int)mh$.invokeExact(hConv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeReconnect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeReconnect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCONV DdeReconnect(HCONV hConv)
     * }
     */
    public static FunctionDescriptor DdeReconnect$descriptor() {
        return DdeReconnect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCONV DdeReconnect(HCONV hConv)
     * }
     */
    public static MethodHandle DdeReconnect$handle() {
        return DdeReconnect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCONV DdeReconnect(HCONV hConv)
     * }
     */
    public static MemorySegment DdeReconnect$address() {
        return DdeReconnect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCONV DdeReconnect(HCONV hConv)
     * }
     */
    public static MemorySegment DdeReconnect(MemorySegment hConv) {
        var mh$ = DdeReconnect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeReconnect", hConv);
            }
            return (MemorySegment)mh$.invokeExact(hConv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeQueryConvInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeQueryConvInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo)
     * }
     */
    public static FunctionDescriptor DdeQueryConvInfo$descriptor() {
        return DdeQueryConvInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo)
     * }
     */
    public static MethodHandle DdeQueryConvInfo$handle() {
        return DdeQueryConvInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo)
     * }
     */
    public static MemorySegment DdeQueryConvInfo$address() {
        return DdeQueryConvInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo)
     * }
     */
    public static int DdeQueryConvInfo(MemorySegment hConv, int idTransaction, MemorySegment pConvInfo) {
        var mh$ = DdeQueryConvInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeQueryConvInfo", hConv, idTransaction, pConvInfo);
            }
            return (int)mh$.invokeExact(hConv, idTransaction, pConvInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeSetUserHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeSetUserHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeSetUserHandle(HCONV hConv, DWORD id, DWORD_PTR hUser)
     * }
     */
    public static FunctionDescriptor DdeSetUserHandle$descriptor() {
        return DdeSetUserHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeSetUserHandle(HCONV hConv, DWORD id, DWORD_PTR hUser)
     * }
     */
    public static MethodHandle DdeSetUserHandle$handle() {
        return DdeSetUserHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeSetUserHandle(HCONV hConv, DWORD id, DWORD_PTR hUser)
     * }
     */
    public static MemorySegment DdeSetUserHandle$address() {
        return DdeSetUserHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeSetUserHandle(HCONV hConv, DWORD id, DWORD_PTR hUser)
     * }
     */
    public static int DdeSetUserHandle(MemorySegment hConv, int id, long hUser) {
        var mh$ = DdeSetUserHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeSetUserHandle", hConv, id, hUser);
            }
            return (int)mh$.invokeExact(hConv, id, hUser);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeAbandonTransaction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeAbandonTransaction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction)
     * }
     */
    public static FunctionDescriptor DdeAbandonTransaction$descriptor() {
        return DdeAbandonTransaction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction)
     * }
     */
    public static MethodHandle DdeAbandonTransaction$handle() {
        return DdeAbandonTransaction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction)
     * }
     */
    public static MemorySegment DdeAbandonTransaction$address() {
        return DdeAbandonTransaction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction)
     * }
     */
    public static int DdeAbandonTransaction(int idInst, MemorySegment hConv, int idTransaction) {
        var mh$ = DdeAbandonTransaction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeAbandonTransaction", idInst, hConv, idTransaction);
            }
            return (int)mh$.invokeExact(idInst, hConv, idTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdePostAdvise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdePostAdvise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem)
     * }
     */
    public static FunctionDescriptor DdePostAdvise$descriptor() {
        return DdePostAdvise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem)
     * }
     */
    public static MethodHandle DdePostAdvise$handle() {
        return DdePostAdvise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem)
     * }
     */
    public static MemorySegment DdePostAdvise$address() {
        return DdePostAdvise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem)
     * }
     */
    public static int DdePostAdvise(int idInst, MemorySegment hszTopic, MemorySegment hszItem) {
        var mh$ = DdePostAdvise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdePostAdvise", idInst, hszTopic, hszItem);
            }
            return (int)mh$.invokeExact(idInst, hszTopic, hszItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeEnableCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeEnableCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd)
     * }
     */
    public static FunctionDescriptor DdeEnableCallback$descriptor() {
        return DdeEnableCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd)
     * }
     */
    public static MethodHandle DdeEnableCallback$handle() {
        return DdeEnableCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd)
     * }
     */
    public static MemorySegment DdeEnableCallback$address() {
        return DdeEnableCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd)
     * }
     */
    public static int DdeEnableCallback(int idInst, MemorySegment hConv, int wCmd) {
        var mh$ = DdeEnableCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeEnableCallback", idInst, hConv, wCmd);
            }
            return (int)mh$.invokeExact(idInst, hConv, wCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeImpersonateClient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeImpersonateClient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeImpersonateClient(HCONV hConv)
     * }
     */
    public static FunctionDescriptor DdeImpersonateClient$descriptor() {
        return DdeImpersonateClient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeImpersonateClient(HCONV hConv)
     * }
     */
    public static MethodHandle DdeImpersonateClient$handle() {
        return DdeImpersonateClient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeImpersonateClient(HCONV hConv)
     * }
     */
    public static MemorySegment DdeImpersonateClient$address() {
        return DdeImpersonateClient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeImpersonateClient(HCONV hConv)
     * }
     */
    public static int DdeImpersonateClient(MemorySegment hConv) {
        var mh$ = DdeImpersonateClient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeImpersonateClient", hConv);
            }
            return (int)mh$.invokeExact(hConv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeNameService {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeNameService");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDDEDATA DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd)
     * }
     */
    public static FunctionDescriptor DdeNameService$descriptor() {
        return DdeNameService.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDDEDATA DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd)
     * }
     */
    public static MethodHandle DdeNameService$handle() {
        return DdeNameService.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDDEDATA DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd)
     * }
     */
    public static MemorySegment DdeNameService$address() {
        return DdeNameService.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDDEDATA DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd)
     * }
     */
    public static MemorySegment DdeNameService(int idInst, MemorySegment hsz1, MemorySegment hsz2, int afCmd) {
        var mh$ = DdeNameService.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeNameService", idInst, hsz1, hsz2, afCmd);
            }
            return (MemorySegment)mh$.invokeExact(idInst, hsz1, hsz2, afCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeClientTransaction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeClientTransaction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDDEDATA DdeClientTransaction(LPBYTE pData, DWORD cbData, HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType, DWORD dwTimeout, LPDWORD pdwResult)
     * }
     */
    public static FunctionDescriptor DdeClientTransaction$descriptor() {
        return DdeClientTransaction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDDEDATA DdeClientTransaction(LPBYTE pData, DWORD cbData, HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType, DWORD dwTimeout, LPDWORD pdwResult)
     * }
     */
    public static MethodHandle DdeClientTransaction$handle() {
        return DdeClientTransaction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDDEDATA DdeClientTransaction(LPBYTE pData, DWORD cbData, HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType, DWORD dwTimeout, LPDWORD pdwResult)
     * }
     */
    public static MemorySegment DdeClientTransaction$address() {
        return DdeClientTransaction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDDEDATA DdeClientTransaction(LPBYTE pData, DWORD cbData, HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType, DWORD dwTimeout, LPDWORD pdwResult)
     * }
     */
    public static MemorySegment DdeClientTransaction(MemorySegment pData, int cbData, MemorySegment hConv, MemorySegment hszItem, int wFmt, int wType, int dwTimeout, MemorySegment pdwResult) {
        var mh$ = DdeClientTransaction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeClientTransaction", pData, cbData, hConv, hszItem, wFmt, wType, dwTimeout, pdwResult);
            }
            return (MemorySegment)mh$.invokeExact(pData, cbData, hConv, hszItem, wFmt, wType, dwTimeout, pdwResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeCreateDataHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeCreateDataHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDDEDATA DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb, DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd)
     * }
     */
    public static FunctionDescriptor DdeCreateDataHandle$descriptor() {
        return DdeCreateDataHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDDEDATA DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb, DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd)
     * }
     */
    public static MethodHandle DdeCreateDataHandle$handle() {
        return DdeCreateDataHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDDEDATA DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb, DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd)
     * }
     */
    public static MemorySegment DdeCreateDataHandle$address() {
        return DdeCreateDataHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDDEDATA DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb, DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd)
     * }
     */
    public static MemorySegment DdeCreateDataHandle(int idInst, MemorySegment pSrc, int cb, int cbOff, MemorySegment hszItem, int wFmt, int afCmd) {
        var mh$ = DdeCreateDataHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeCreateDataHandle", idInst, pSrc, cb, cbOff, hszItem, wFmt, afCmd);
            }
            return (MemorySegment)mh$.invokeExact(idInst, pSrc, cb, cbOff, hszItem, wFmt, afCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeAddData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeAddData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDDEDATA DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff)
     * }
     */
    public static FunctionDescriptor DdeAddData$descriptor() {
        return DdeAddData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDDEDATA DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff)
     * }
     */
    public static MethodHandle DdeAddData$handle() {
        return DdeAddData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDDEDATA DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff)
     * }
     */
    public static MemorySegment DdeAddData$address() {
        return DdeAddData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDDEDATA DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff)
     * }
     */
    public static MemorySegment DdeAddData(MemorySegment hData, MemorySegment pSrc, int cb, int cbOff) {
        var mh$ = DdeAddData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeAddData", hData, pSrc, cb, cbOff);
            }
            return (MemorySegment)mh$.invokeExact(hData, pSrc, cb, cbOff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff)
     * }
     */
    public static FunctionDescriptor DdeGetData$descriptor() {
        return DdeGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff)
     * }
     */
    public static MethodHandle DdeGetData$handle() {
        return DdeGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff)
     * }
     */
    public static MemorySegment DdeGetData$address() {
        return DdeGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff)
     * }
     */
    public static int DdeGetData(MemorySegment hData, MemorySegment pDst, int cbMax, int cbOff) {
        var mh$ = DdeGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeGetData", hData, pDst, cbMax, cbOff);
            }
            return (int)mh$.invokeExact(hData, pDst, cbMax, cbOff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeAccessData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeAccessData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPBYTE DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize)
     * }
     */
    public static FunctionDescriptor DdeAccessData$descriptor() {
        return DdeAccessData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPBYTE DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize)
     * }
     */
    public static MethodHandle DdeAccessData$handle() {
        return DdeAccessData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPBYTE DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize)
     * }
     */
    public static MemorySegment DdeAccessData$address() {
        return DdeAccessData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPBYTE DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize)
     * }
     */
    public static MemorySegment DdeAccessData(MemorySegment hData, MemorySegment pcbDataSize) {
        var mh$ = DdeAccessData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeAccessData", hData, pcbDataSize);
            }
            return (MemorySegment)mh$.invokeExact(hData, pcbDataSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeUnaccessData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeUnaccessData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeUnaccessData(HDDEDATA hData)
     * }
     */
    public static FunctionDescriptor DdeUnaccessData$descriptor() {
        return DdeUnaccessData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeUnaccessData(HDDEDATA hData)
     * }
     */
    public static MethodHandle DdeUnaccessData$handle() {
        return DdeUnaccessData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeUnaccessData(HDDEDATA hData)
     * }
     */
    public static MemorySegment DdeUnaccessData$address() {
        return DdeUnaccessData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeUnaccessData(HDDEDATA hData)
     * }
     */
    public static int DdeUnaccessData(MemorySegment hData) {
        var mh$ = DdeUnaccessData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeUnaccessData", hData);
            }
            return (int)mh$.invokeExact(hData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeFreeDataHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeFreeDataHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeFreeDataHandle(HDDEDATA hData)
     * }
     */
    public static FunctionDescriptor DdeFreeDataHandle$descriptor() {
        return DdeFreeDataHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeFreeDataHandle(HDDEDATA hData)
     * }
     */
    public static MethodHandle DdeFreeDataHandle$handle() {
        return DdeFreeDataHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeFreeDataHandle(HDDEDATA hData)
     * }
     */
    public static MemorySegment DdeFreeDataHandle$address() {
        return DdeFreeDataHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeFreeDataHandle(HDDEDATA hData)
     * }
     */
    public static int DdeFreeDataHandle(MemorySegment hData) {
        var mh$ = DdeFreeDataHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeFreeDataHandle", hData);
            }
            return (int)mh$.invokeExact(hData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeGetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeGetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT DdeGetLastError(DWORD idInst)
     * }
     */
    public static FunctionDescriptor DdeGetLastError$descriptor() {
        return DdeGetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT DdeGetLastError(DWORD idInst)
     * }
     */
    public static MethodHandle DdeGetLastError$handle() {
        return DdeGetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT DdeGetLastError(DWORD idInst)
     * }
     */
    public static MemorySegment DdeGetLastError$address() {
        return DdeGetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT DdeGetLastError(DWORD idInst)
     * }
     */
    public static int DdeGetLastError(int idInst) {
        var mh$ = DdeGetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeGetLastError", idInst);
            }
            return (int)mh$.invokeExact(idInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeCreateStringHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeCreateStringHandleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HSZ DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage)
     * }
     */
    public static FunctionDescriptor DdeCreateStringHandleA$descriptor() {
        return DdeCreateStringHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HSZ DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage)
     * }
     */
    public static MethodHandle DdeCreateStringHandleA$handle() {
        return DdeCreateStringHandleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HSZ DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage)
     * }
     */
    public static MemorySegment DdeCreateStringHandleA$address() {
        return DdeCreateStringHandleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HSZ DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage)
     * }
     */
    public static MemorySegment DdeCreateStringHandleA(int idInst, MemorySegment psz, int iCodePage) {
        var mh$ = DdeCreateStringHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeCreateStringHandleA", idInst, psz, iCodePage);
            }
            return (MemorySegment)mh$.invokeExact(idInst, psz, iCodePage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeCreateStringHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeCreateStringHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HSZ DdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage)
     * }
     */
    public static FunctionDescriptor DdeCreateStringHandleW$descriptor() {
        return DdeCreateStringHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HSZ DdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage)
     * }
     */
    public static MethodHandle DdeCreateStringHandleW$handle() {
        return DdeCreateStringHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HSZ DdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage)
     * }
     */
    public static MemorySegment DdeCreateStringHandleW$address() {
        return DdeCreateStringHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HSZ DdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage)
     * }
     */
    public static MemorySegment DdeCreateStringHandleW(int idInst, MemorySegment psz, int iCodePage) {
        var mh$ = DdeCreateStringHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeCreateStringHandleW", idInst, psz, iCodePage);
            }
            return (MemorySegment)mh$.invokeExact(idInst, psz, iCodePage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeQueryStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeQueryStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage)
     * }
     */
    public static FunctionDescriptor DdeQueryStringA$descriptor() {
        return DdeQueryStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage)
     * }
     */
    public static MethodHandle DdeQueryStringA$handle() {
        return DdeQueryStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage)
     * }
     */
    public static MemorySegment DdeQueryStringA$address() {
        return DdeQueryStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage)
     * }
     */
    public static int DdeQueryStringA(int idInst, MemorySegment hsz, MemorySegment psz, int cchMax, int iCodePage) {
        var mh$ = DdeQueryStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeQueryStringA", idInst, hsz, psz, cchMax, iCodePage);
            }
            return (int)mh$.invokeExact(idInst, hsz, psz, cchMax, iCodePage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeQueryStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeQueryStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage)
     * }
     */
    public static FunctionDescriptor DdeQueryStringW$descriptor() {
        return DdeQueryStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage)
     * }
     */
    public static MethodHandle DdeQueryStringW$handle() {
        return DdeQueryStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage)
     * }
     */
    public static MemorySegment DdeQueryStringW$address() {
        return DdeQueryStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage)
     * }
     */
    public static int DdeQueryStringW(int idInst, MemorySegment hsz, MemorySegment psz, int cchMax, int iCodePage) {
        var mh$ = DdeQueryStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeQueryStringW", idInst, hsz, psz, cchMax, iCodePage);
            }
            return (int)mh$.invokeExact(idInst, hsz, psz, cchMax, iCodePage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeFreeStringHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeFreeStringHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeFreeStringHandle(DWORD idInst, HSZ hsz)
     * }
     */
    public static FunctionDescriptor DdeFreeStringHandle$descriptor() {
        return DdeFreeStringHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeFreeStringHandle(DWORD idInst, HSZ hsz)
     * }
     */
    public static MethodHandle DdeFreeStringHandle$handle() {
        return DdeFreeStringHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeFreeStringHandle(DWORD idInst, HSZ hsz)
     * }
     */
    public static MemorySegment DdeFreeStringHandle$address() {
        return DdeFreeStringHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeFreeStringHandle(DWORD idInst, HSZ hsz)
     * }
     */
    public static int DdeFreeStringHandle(int idInst, MemorySegment hsz) {
        var mh$ = DdeFreeStringHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeFreeStringHandle", idInst, hsz);
            }
            return (int)mh$.invokeExact(idInst, hsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeKeepStringHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeKeepStringHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DdeKeepStringHandle(DWORD idInst, HSZ hsz)
     * }
     */
    public static FunctionDescriptor DdeKeepStringHandle$descriptor() {
        return DdeKeepStringHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DdeKeepStringHandle(DWORD idInst, HSZ hsz)
     * }
     */
    public static MethodHandle DdeKeepStringHandle$handle() {
        return DdeKeepStringHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DdeKeepStringHandle(DWORD idInst, HSZ hsz)
     * }
     */
    public static MemorySegment DdeKeepStringHandle$address() {
        return DdeKeepStringHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DdeKeepStringHandle(DWORD idInst, HSZ hsz)
     * }
     */
    public static int DdeKeepStringHandle(int idInst, MemorySegment hsz) {
        var mh$ = DdeKeepStringHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeKeepStringHandle", idInst, hsz);
            }
            return (int)mh$.invokeExact(idInst, hsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DdeCmpStringHandles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DdeCmpStringHandles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DdeCmpStringHandles(HSZ hsz1, HSZ hsz2)
     * }
     */
    public static FunctionDescriptor DdeCmpStringHandles$descriptor() {
        return DdeCmpStringHandles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DdeCmpStringHandles(HSZ hsz1, HSZ hsz2)
     * }
     */
    public static MethodHandle DdeCmpStringHandles$handle() {
        return DdeCmpStringHandles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DdeCmpStringHandles(HSZ hsz1, HSZ hsz2)
     * }
     */
    public static MemorySegment DdeCmpStringHandles$address() {
        return DdeCmpStringHandles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DdeCmpStringHandles(HSZ hsz1, HSZ hsz2)
     * }
     */
    public static int DdeCmpStringHandles(MemorySegment hsz1, MemorySegment hsz2) {
        var mh$ = DdeCmpStringHandles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DdeCmpStringHandles", hsz1, hsz2);
            }
            return (int)mh$.invokeExact(hsz1, hsz2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDDEML_MSG_HOOK_DATA {
     *     UINT_PTR uiLo;
     *     UINT_PTR uiHi;
     *     DWORD cbData;
     *     DWORD Data[8];
     * } *PDDEML_MSG_HOOK_DATA
     * }
     */
    public static final AddressLayout PDDEML_MSG_HOOK_DATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONMSGSTRUCT {
     *     UINT cb;
     *     HWND hwndTo;
     *     DWORD dwTime;
     *     HANDLE hTask;
     *     UINT wMsg;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DDEML_MSG_HOOK_DATA dmhd;
     * } *PMONMSGSTRUCT
     * }
     */
    public static final AddressLayout PMONMSGSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONCBSTRUCT {
     *     UINT cb;
     *     DWORD dwTime;
     *     HANDLE hTask;
     *     DWORD dwRet;
     *     UINT wType;
     *     UINT wFmt;
     *     HCONV hConv;
     *     HSZ hsz1;
     *     HSZ hsz2;
     *     HDDEDATA hData;
     *     ULONG_PTR dwData1;
     *     ULONG_PTR dwData2;
     *     CONVCONTEXT cc;
     *     DWORD cbData;
     *     DWORD Data[8];
     * } *PMONCBSTRUCT
     * }
     */
    public static final AddressLayout PMONCBSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONHSZSTRUCTA {
     *     UINT cb;
     *     BOOL fsAction;
     *     DWORD dwTime;
     *     HSZ hsz;
     *     HANDLE hTask;
     *     CHAR str[1];
     * } *PMONHSZSTRUCTA
     * }
     */
    public static final AddressLayout PMONHSZSTRUCTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONHSZSTRUCTW {
     *     UINT cb;
     *     BOOL fsAction;
     *     DWORD dwTime;
     *     HSZ hsz;
     *     HANDLE hTask;
     *     WCHAR str[1];
     * } *PMONHSZSTRUCTW
     * }
     */
    public static final AddressLayout PMONHSZSTRUCTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMONHSZSTRUCTA PMONHSZSTRUCT
     * }
     */
    public static final AddressLayout PMONHSZSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONERRSTRUCT {
     *     UINT cb;
     *     UINT wLastError;
     *     DWORD dwTime;
     *     HANDLE hTask;
     * } *PMONERRSTRUCT
     * }
     */
    public static final AddressLayout PMONERRSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONLINKSTRUCT {
     *     UINT cb;
     *     DWORD dwTime;
     *     HANDLE hTask;
     *     BOOL fEstablished;
     *     BOOL fNoData;
     *     HSZ hszSvc;
     *     HSZ hszTopic;
     *     HSZ hszItem;
     *     UINT wFmt;
     *     BOOL fServer;
     *     HCONV hConvServer;
     *     HCONV hConvClient;
     * } *PMONLINKSTRUCT
     * }
     */
    public static final AddressLayout PMONLINKSTRUCT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONCONVSTRUCT {
     *     UINT cb;
     *     BOOL fConnect;
     *     DWORD dwTime;
     *     HANDLE hTask;
     *     HSZ hszSvc;
     *     HSZ hszTopic;
     *     HCONV hConvClient;
     *     HCONV hConvServer;
     * } *PMONCONVSTRUCT
     * }
     */
    public static final AddressLayout PMONCONVSTRUCT = winapi.C_POINTER;

    private static class LZStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("LZStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT LZStart()
     * }
     */
    public static FunctionDescriptor LZStart$descriptor() {
        return LZStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT LZStart()
     * }
     */
    public static MethodHandle LZStart$handle() {
        return LZStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT LZStart()
     * }
     */
    public static MemorySegment LZStart$address() {
        return LZStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT LZStart()
     * }
     */
    public static int LZStart() {
        var mh$ = LZStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZStart");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZDone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = winapi.findOrThrow("LZDone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LZDone()
     * }
     */
    public static FunctionDescriptor LZDone$descriptor() {
        return LZDone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LZDone()
     * }
     */
    public static MethodHandle LZDone$handle() {
        return LZDone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LZDone()
     * }
     */
    public static MemorySegment LZDone$address() {
        return LZDone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LZDone()
     * }
     */
    public static void LZDone() {
        var mh$ = LZDone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZDone");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyLZFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CopyLZFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CopyLZFile(INT hfSource, INT hfDest)
     * }
     */
    public static FunctionDescriptor CopyLZFile$descriptor() {
        return CopyLZFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CopyLZFile(INT hfSource, INT hfDest)
     * }
     */
    public static MethodHandle CopyLZFile$handle() {
        return CopyLZFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CopyLZFile(INT hfSource, INT hfDest)
     * }
     */
    public static MemorySegment CopyLZFile$address() {
        return CopyLZFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CopyLZFile(INT hfSource, INT hfDest)
     * }
     */
    public static int CopyLZFile(int hfSource, int hfDest) {
        var mh$ = CopyLZFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyLZFile", hfSource, hfDest);
            }
            return (int)mh$.invokeExact(hfSource, hfDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LZCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG LZCopy(INT hfSource, INT hfDest)
     * }
     */
    public static FunctionDescriptor LZCopy$descriptor() {
        return LZCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG LZCopy(INT hfSource, INT hfDest)
     * }
     */
    public static MethodHandle LZCopy$handle() {
        return LZCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG LZCopy(INT hfSource, INT hfDest)
     * }
     */
    public static MemorySegment LZCopy$address() {
        return LZCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG LZCopy(INT hfSource, INT hfDest)
     * }
     */
    public static int LZCopy(int hfSource, int hfDest) {
        var mh$ = LZCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZCopy", hfSource, hfDest);
            }
            return (int)mh$.invokeExact(hfSource, hfDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LZInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT LZInit(INT hfSource)
     * }
     */
    public static FunctionDescriptor LZInit$descriptor() {
        return LZInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT LZInit(INT hfSource)
     * }
     */
    public static MethodHandle LZInit$handle() {
        return LZInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT LZInit(INT hfSource)
     * }
     */
    public static MemorySegment LZInit$address() {
        return LZInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT LZInit(INT hfSource)
     * }
     */
    public static int LZInit(int hfSource) {
        var mh$ = LZInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZInit", hfSource);
            }
            return (int)mh$.invokeExact(hfSource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExpandedNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetExpandedNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer)
     * }
     */
    public static FunctionDescriptor GetExpandedNameA$descriptor() {
        return GetExpandedNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer)
     * }
     */
    public static MethodHandle GetExpandedNameA$handle() {
        return GetExpandedNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer)
     * }
     */
    public static MemorySegment GetExpandedNameA$address() {
        return GetExpandedNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer)
     * }
     */
    public static int GetExpandedNameA(MemorySegment lpszSource, MemorySegment lpszBuffer) {
        var mh$ = GetExpandedNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExpandedNameA", lpszSource, lpszBuffer);
            }
            return (int)mh$.invokeExact(lpszSource, lpszBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExpandedNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetExpandedNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT GetExpandedNameW(LPWSTR lpszSource, LPWSTR lpszBuffer)
     * }
     */
    public static FunctionDescriptor GetExpandedNameW$descriptor() {
        return GetExpandedNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT GetExpandedNameW(LPWSTR lpszSource, LPWSTR lpszBuffer)
     * }
     */
    public static MethodHandle GetExpandedNameW$handle() {
        return GetExpandedNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT GetExpandedNameW(LPWSTR lpszSource, LPWSTR lpszBuffer)
     * }
     */
    public static MemorySegment GetExpandedNameW$address() {
        return GetExpandedNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT GetExpandedNameW(LPWSTR lpszSource, LPWSTR lpszBuffer)
     * }
     */
    public static int GetExpandedNameW(MemorySegment lpszSource, MemorySegment lpszBuffer) {
        var mh$ = GetExpandedNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExpandedNameW", lpszSource, lpszBuffer);
            }
            return (int)mh$.invokeExact(lpszSource, lpszBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZOpenFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_SHORT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LZOpenFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
     * }
     */
    public static FunctionDescriptor LZOpenFileA$descriptor() {
        return LZOpenFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
     * }
     */
    public static MethodHandle LZOpenFileA$handle() {
        return LZOpenFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
     * }
     */
    public static MemorySegment LZOpenFileA$address() {
        return LZOpenFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
     * }
     */
    public static int LZOpenFileA(MemorySegment lpFileName, MemorySegment lpReOpenBuf, short wStyle) {
        var mh$ = LZOpenFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZOpenFileA", lpFileName, lpReOpenBuf, wStyle);
            }
            return (int)mh$.invokeExact(lpFileName, lpReOpenBuf, wStyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZOpenFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_SHORT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LZOpenFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT LZOpenFileW(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
     * }
     */
    public static FunctionDescriptor LZOpenFileW$descriptor() {
        return LZOpenFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT LZOpenFileW(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
     * }
     */
    public static MethodHandle LZOpenFileW$handle() {
        return LZOpenFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT LZOpenFileW(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
     * }
     */
    public static MemorySegment LZOpenFileW$address() {
        return LZOpenFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT LZOpenFileW(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
     * }
     */
    public static int LZOpenFileW(MemorySegment lpFileName, MemorySegment lpReOpenBuf, short wStyle) {
        var mh$ = LZOpenFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZOpenFileW", lpFileName, lpReOpenBuf, wStyle);
            }
            return (int)mh$.invokeExact(lpFileName, lpReOpenBuf, wStyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZSeek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LZSeek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG LZSeek(INT hFile, LONG lOffset, INT iOrigin)
     * }
     */
    public static FunctionDescriptor LZSeek$descriptor() {
        return LZSeek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG LZSeek(INT hFile, LONG lOffset, INT iOrigin)
     * }
     */
    public static MethodHandle LZSeek$handle() {
        return LZSeek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG LZSeek(INT hFile, LONG lOffset, INT iOrigin)
     * }
     */
    public static MemorySegment LZSeek$address() {
        return LZSeek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG LZSeek(INT hFile, LONG lOffset, INT iOrigin)
     * }
     */
    public static int LZSeek(int hFile, int lOffset, int iOrigin) {
        var mh$ = LZSeek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZSeek", hFile, lOffset, iOrigin);
            }
            return (int)mh$.invokeExact(hFile, lOffset, iOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LZRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT LZRead(INT hFile, CHAR *lpBuffer, INT cbRead)
     * }
     */
    public static FunctionDescriptor LZRead$descriptor() {
        return LZRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT LZRead(INT hFile, CHAR *lpBuffer, INT cbRead)
     * }
     */
    public static MethodHandle LZRead$handle() {
        return LZRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * INT LZRead(INT hFile, CHAR *lpBuffer, INT cbRead)
     * }
     */
    public static MemorySegment LZRead$address() {
        return LZRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * INT LZRead(INT hFile, CHAR *lpBuffer, INT cbRead)
     * }
     */
    public static int LZRead(int hFile, MemorySegment lpBuffer, int cbRead) {
        var mh$ = LZRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZRead", hFile, lpBuffer, cbRead);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, cbRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LZClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LZClose(INT hFile)
     * }
     */
    public static FunctionDescriptor LZClose$descriptor() {
        return LZClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LZClose(INT hFile)
     * }
     */
    public static MethodHandle LZClose$handle() {
        return LZClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LZClose(INT hFile)
     * }
     */
    public static MemorySegment LZClose$address() {
        return LZClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LZClose(INT hFile)
     * }
     */
    public static void LZClose(int hFile) {
        var mh$ = LZClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZClose", hFile);
            }
            mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef UINT MMVERSION
     * }
     */
    public static final OfInt MMVERSION = winapi.C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT MMRESULT
     * }
     */
    public static final OfInt MMRESULT = winapi.C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT *LPUINT
     * }
     */
    public static final AddressLayout LPUINT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct mmtime_tag {
     *     UINT wType;
     *     union {
     *         DWORD ms;
     *         DWORD sample;
     *         DWORD cb;
     *         DWORD ticks;
     *         struct {
     *             BYTE hour;
     *             BYTE min;
     *             BYTE sec;
     *             BYTE frame;
     *             BYTE fps;
     *             BYTE dummy;
     *             BYTE pad[2];
     *         } smpte;
     *         struct {
     *             DWORD songptrpos;
     *         } midi;
     *     } u;
     * } *PMMTIME
     * }
     */
    public static final AddressLayout PMMTIME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct mmtime_tag {
     *     UINT wType;
     *     union {
     *         DWORD ms;
     *         DWORD sample;
     *         DWORD cb;
     *         DWORD ticks;
     *         struct {
     *             BYTE hour;
     *             BYTE min;
     *             BYTE sec;
     *             BYTE frame;
     *             BYTE fps;
     *             BYTE dummy;
     *             BYTE pad[2];
     *         } smpte;
     *         struct {
     *             DWORD songptrpos;
     *         } midi;
     *     } u;
     * } *NPMMTIME
     * }
     */
    public static final AddressLayout NPMMTIME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct mmtime_tag {
     *     UINT wType;
     *     union {
     *         DWORD ms;
     *         DWORD sample;
     *         DWORD cb;
     *         DWORD ticks;
     *         struct {
     *             BYTE hour;
     *             BYTE min;
     *             BYTE sec;
     *             BYTE frame;
     *             BYTE fps;
     *             BYTE dummy;
     *             BYTE pad[2];
     *         } smpte;
     *         struct {
     *             DWORD songptrpos;
     *         } midi;
     *     } u;
     * } *LPMMTIME
     * }
     */
    public static final AddressLayout LPMMTIME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HDRVR__ {
     *     int unused;
     * } *HDRVR
     * }
     */
    public static final AddressLayout HDRVR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD MCIERROR
     * }
     */
    public static final OfInt MCIERROR = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef UINT MCIDEVICEID
     * }
     */
    public static final OfInt MCIDEVICEID = winapi.C_INT;

    private static class mciSendCommandA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciSendCommandA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MCIERROR mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static FunctionDescriptor mciSendCommandA$descriptor() {
        return mciSendCommandA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MCIERROR mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static MethodHandle mciSendCommandA$handle() {
        return mciSendCommandA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MCIERROR mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static MemorySegment mciSendCommandA$address() {
        return mciSendCommandA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MCIERROR mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static int mciSendCommandA(int mciId, int uMsg, long dwParam1, long dwParam2) {
        var mh$ = mciSendCommandA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciSendCommandA", mciId, uMsg, dwParam1, dwParam2);
            }
            return (int)mh$.invokeExact(mciId, uMsg, dwParam1, dwParam2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciSendCommandW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciSendCommandW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MCIERROR mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static FunctionDescriptor mciSendCommandW$descriptor() {
        return mciSendCommandW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MCIERROR mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static MethodHandle mciSendCommandW$handle() {
        return mciSendCommandW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MCIERROR mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static MemorySegment mciSendCommandW$address() {
        return mciSendCommandW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MCIERROR mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static int mciSendCommandW(int mciId, int uMsg, long dwParam1, long dwParam2) {
        var mh$ = mciSendCommandW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciSendCommandW", mciId, uMsg, dwParam1, dwParam2);
            }
            return (int)mh$.invokeExact(mciId, uMsg, dwParam1, dwParam2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciSendStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciSendStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MCIERROR mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback)
     * }
     */
    public static FunctionDescriptor mciSendStringA$descriptor() {
        return mciSendStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MCIERROR mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback)
     * }
     */
    public static MethodHandle mciSendStringA$handle() {
        return mciSendStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MCIERROR mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback)
     * }
     */
    public static MemorySegment mciSendStringA$address() {
        return mciSendStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MCIERROR mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback)
     * }
     */
    public static int mciSendStringA(MemorySegment lpstrCommand, MemorySegment lpstrReturnString, int uReturnLength, MemorySegment hwndCallback) {
        var mh$ = mciSendStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciSendStringA", lpstrCommand, lpstrReturnString, uReturnLength, hwndCallback);
            }
            return (int)mh$.invokeExact(lpstrCommand, lpstrReturnString, uReturnLength, hwndCallback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciSendStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciSendStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MCIERROR mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback)
     * }
     */
    public static FunctionDescriptor mciSendStringW$descriptor() {
        return mciSendStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MCIERROR mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback)
     * }
     */
    public static MethodHandle mciSendStringW$handle() {
        return mciSendStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MCIERROR mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback)
     * }
     */
    public static MemorySegment mciSendStringW$address() {
        return mciSendStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MCIERROR mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback)
     * }
     */
    public static int mciSendStringW(MemorySegment lpstrCommand, MemorySegment lpstrReturnString, int uReturnLength, MemorySegment hwndCallback) {
        var mh$ = mciSendStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciSendStringW", lpstrCommand, lpstrReturnString, uReturnLength, hwndCallback);
            }
            return (int)mh$.invokeExact(lpstrCommand, lpstrReturnString, uReturnLength, hwndCallback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciGetDeviceIDA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciGetDeviceIDA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDA(LPCSTR pszDevice)
     * }
     */
    public static FunctionDescriptor mciGetDeviceIDA$descriptor() {
        return mciGetDeviceIDA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDA(LPCSTR pszDevice)
     * }
     */
    public static MethodHandle mciGetDeviceIDA$handle() {
        return mciGetDeviceIDA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDA(LPCSTR pszDevice)
     * }
     */
    public static MemorySegment mciGetDeviceIDA$address() {
        return mciGetDeviceIDA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDA(LPCSTR pszDevice)
     * }
     */
    public static int mciGetDeviceIDA(MemorySegment pszDevice) {
        var mh$ = mciGetDeviceIDA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciGetDeviceIDA", pszDevice);
            }
            return (int)mh$.invokeExact(pszDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciGetDeviceIDW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciGetDeviceIDW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDW(LPCWSTR pszDevice)
     * }
     */
    public static FunctionDescriptor mciGetDeviceIDW$descriptor() {
        return mciGetDeviceIDW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDW(LPCWSTR pszDevice)
     * }
     */
    public static MethodHandle mciGetDeviceIDW$handle() {
        return mciGetDeviceIDW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDW(LPCWSTR pszDevice)
     * }
     */
    public static MemorySegment mciGetDeviceIDW$address() {
        return mciGetDeviceIDW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDW(LPCWSTR pszDevice)
     * }
     */
    public static int mciGetDeviceIDW(MemorySegment pszDevice) {
        var mh$ = mciGetDeviceIDW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciGetDeviceIDW", pszDevice);
            }
            return (int)mh$.invokeExact(pszDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciGetDeviceIDFromElementIDA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciGetDeviceIDFromElementIDA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType)
     * }
     */
    public static FunctionDescriptor mciGetDeviceIDFromElementIDA$descriptor() {
        return mciGetDeviceIDFromElementIDA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType)
     * }
     */
    public static MethodHandle mciGetDeviceIDFromElementIDA$handle() {
        return mciGetDeviceIDFromElementIDA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType)
     * }
     */
    public static MemorySegment mciGetDeviceIDFromElementIDA$address() {
        return mciGetDeviceIDFromElementIDA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType)
     * }
     */
    public static int mciGetDeviceIDFromElementIDA(int dwElementID, MemorySegment lpstrType) {
        var mh$ = mciGetDeviceIDFromElementIDA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciGetDeviceIDFromElementIDA", dwElementID, lpstrType);
            }
            return (int)mh$.invokeExact(dwElementID, lpstrType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciGetDeviceIDFromElementIDW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciGetDeviceIDFromElementIDW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType)
     * }
     */
    public static FunctionDescriptor mciGetDeviceIDFromElementIDW$descriptor() {
        return mciGetDeviceIDFromElementIDW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType)
     * }
     */
    public static MethodHandle mciGetDeviceIDFromElementIDW$handle() {
        return mciGetDeviceIDFromElementIDW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType)
     * }
     */
    public static MemorySegment mciGetDeviceIDFromElementIDW$address() {
        return mciGetDeviceIDFromElementIDW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MCIDEVICEID mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType)
     * }
     */
    public static int mciGetDeviceIDFromElementIDW(int dwElementID, MemorySegment lpstrType) {
        var mh$ = mciGetDeviceIDFromElementIDW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciGetDeviceIDFromElementIDW", dwElementID, lpstrType);
            }
            return (int)mh$.invokeExact(dwElementID, lpstrType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciGetErrorStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciGetErrorStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor mciGetErrorStringA$descriptor() {
        return mciGetErrorStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle mciGetErrorStringA$handle() {
        return mciGetErrorStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment mciGetErrorStringA$address() {
        return mciGetErrorStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText)
     * }
     */
    public static int mciGetErrorStringA(int mcierr, MemorySegment pszText, int cchText) {
        var mh$ = mciGetErrorStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciGetErrorStringA", mcierr, pszText, cchText);
            }
            return (int)mh$.invokeExact(mcierr, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciGetErrorStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciGetErrorStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor mciGetErrorStringW$descriptor() {
        return mciGetErrorStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle mciGetErrorStringW$handle() {
        return mciGetErrorStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment mciGetErrorStringW$address() {
        return mciGetErrorStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText)
     * }
     */
    public static int mciGetErrorStringW(int mcierr, MemorySegment pszText, int cchText) {
        var mh$ = mciGetErrorStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciGetErrorStringW", mcierr, pszText, cchText);
            }
            return (int)mh$.invokeExact(mcierr, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciSetYieldProc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciSetYieldProc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc, DWORD dwYieldData)
     * }
     */
    public static FunctionDescriptor mciSetYieldProc$descriptor() {
        return mciSetYieldProc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc, DWORD dwYieldData)
     * }
     */
    public static MethodHandle mciSetYieldProc$handle() {
        return mciSetYieldProc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc, DWORD dwYieldData)
     * }
     */
    public static MemorySegment mciSetYieldProc$address() {
        return mciSetYieldProc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc, DWORD dwYieldData)
     * }
     */
    public static int mciSetYieldProc(int mciId, MemorySegment fpYieldProc, int dwYieldData) {
        var mh$ = mciSetYieldProc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciSetYieldProc", mciId, fpYieldProc, dwYieldData);
            }
            return (int)mh$.invokeExact(mciId, fpYieldProc, dwYieldData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciGetCreatorTask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciGetCreatorTask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HTASK mciGetCreatorTask(MCIDEVICEID mciId)
     * }
     */
    public static FunctionDescriptor mciGetCreatorTask$descriptor() {
        return mciGetCreatorTask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HTASK mciGetCreatorTask(MCIDEVICEID mciId)
     * }
     */
    public static MethodHandle mciGetCreatorTask$handle() {
        return mciGetCreatorTask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HTASK mciGetCreatorTask(MCIDEVICEID mciId)
     * }
     */
    public static MemorySegment mciGetCreatorTask$address() {
        return mciGetCreatorTask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HTASK mciGetCreatorTask(MCIDEVICEID mciId)
     * }
     */
    public static MemorySegment mciGetCreatorTask(int mciId) {
        var mh$ = mciGetCreatorTask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciGetCreatorTask", mciId);
            }
            return (MemorySegment)mh$.invokeExact(mciId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciGetYieldProc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciGetYieldProc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * YIELDPROC mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData)
     * }
     */
    public static FunctionDescriptor mciGetYieldProc$descriptor() {
        return mciGetYieldProc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * YIELDPROC mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData)
     * }
     */
    public static MethodHandle mciGetYieldProc$handle() {
        return mciGetYieldProc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * YIELDPROC mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData)
     * }
     */
    public static MemorySegment mciGetYieldProc$address() {
        return mciGetYieldProc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * YIELDPROC mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData)
     * }
     */
    public static MemorySegment mciGetYieldProc(int mciId, MemorySegment pdwYieldData) {
        var mh$ = mciGetYieldProc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciGetYieldProc", mciId, pdwYieldData);
            }
            return (MemorySegment)mh$.invokeExact(mciId, pdwYieldData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_GENERIC_PARMS {
     *     DWORD_PTR dwCallback;
     * } *PMCI_GENERIC_PARMS
     * }
     */
    public static final AddressLayout PMCI_GENERIC_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_GENERIC_PARMS {
     *     DWORD_PTR dwCallback;
     * } *LPMCI_GENERIC_PARMS
     * }
     */
    public static final AddressLayout LPMCI_GENERIC_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OPEN_PARMSA {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCSTR lpstrDeviceType;
     *     LPCSTR lpstrElementName;
     *     LPCSTR lpstrAlias;
     * } *PMCI_OPEN_PARMSA
     * }
     */
    public static final AddressLayout PMCI_OPEN_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OPEN_PARMSA {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCSTR lpstrDeviceType;
     *     LPCSTR lpstrElementName;
     *     LPCSTR lpstrAlias;
     * } *LPMCI_OPEN_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_OPEN_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OPEN_PARMSW {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCWSTR lpstrDeviceType;
     *     LPCWSTR lpstrElementName;
     *     LPCWSTR lpstrAlias;
     * } *PMCI_OPEN_PARMSW
     * }
     */
    public static final AddressLayout PMCI_OPEN_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OPEN_PARMSW {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCWSTR lpstrDeviceType;
     *     LPCWSTR lpstrElementName;
     *     LPCWSTR lpstrAlias;
     * } *LPMCI_OPEN_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_OPEN_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_OPEN_PARMSA PMCI_OPEN_PARMS
     * }
     */
    public static final AddressLayout PMCI_OPEN_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_OPEN_PARMSA LPMCI_OPEN_PARMS
     * }
     */
    public static final AddressLayout LPMCI_OPEN_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_PLAY_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrom;
     *     DWORD dwTo;
     * } *PMCI_PLAY_PARMS
     * }
     */
    public static final AddressLayout PMCI_PLAY_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_PLAY_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrom;
     *     DWORD dwTo;
     * } *LPMCI_PLAY_PARMS
     * }
     */
    public static final AddressLayout LPMCI_PLAY_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SEEK_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwTo;
     * } *PMCI_SEEK_PARMS
     * }
     */
    public static final AddressLayout PMCI_SEEK_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SEEK_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwTo;
     * } *LPMCI_SEEK_PARMS
     * }
     */
    public static final AddressLayout LPMCI_SEEK_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_STATUS_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD_PTR dwReturn;
     *     DWORD dwItem;
     *     DWORD dwTrack;
     * } *PMCI_STATUS_PARMS
     * }
     */
    public static final AddressLayout PMCI_STATUS_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_STATUS_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD_PTR dwReturn;
     *     DWORD dwItem;
     *     DWORD dwTrack;
     * } *LPMCI_STATUS_PARMS
     * }
     */
    public static final AddressLayout LPMCI_STATUS_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_INFO_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPSTR lpstrReturn;
     *     DWORD dwRetSize;
     * } *LPMCI_INFO_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_INFO_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_INFO_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPWSTR lpstrReturn;
     *     DWORD dwRetSize;
     * } *LPMCI_INFO_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_INFO_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_INFO_PARMSA LPMCI_INFO_PARMS
     * }
     */
    public static final AddressLayout LPMCI_INFO_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_GETDEVCAPS_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwReturn;
     *     DWORD dwItem;
     * } *PMCI_GETDEVCAPS_PARMS
     * }
     */
    public static final AddressLayout PMCI_GETDEVCAPS_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_GETDEVCAPS_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwReturn;
     *     DWORD dwItem;
     * } *LPMCI_GETDEVCAPS_PARMS
     * }
     */
    public static final AddressLayout LPMCI_GETDEVCAPS_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SYSINFO_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPSTR lpstrReturn;
     *     DWORD dwRetSize;
     *     DWORD dwNumber;
     *     UINT wDeviceType;
     * } *PMCI_SYSINFO_PARMSA
     * }
     */
    public static final AddressLayout PMCI_SYSINFO_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SYSINFO_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPSTR lpstrReturn;
     *     DWORD dwRetSize;
     *     DWORD dwNumber;
     *     UINT wDeviceType;
     * } *LPMCI_SYSINFO_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_SYSINFO_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SYSINFO_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPWSTR lpstrReturn;
     *     DWORD dwRetSize;
     *     DWORD dwNumber;
     *     UINT wDeviceType;
     * } *PMCI_SYSINFO_PARMSW
     * }
     */
    public static final AddressLayout PMCI_SYSINFO_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SYSINFO_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPWSTR lpstrReturn;
     *     DWORD dwRetSize;
     *     DWORD dwNumber;
     *     UINT wDeviceType;
     * } *LPMCI_SYSINFO_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_SYSINFO_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_SYSINFO_PARMSA PMCI_SYSINFO_PARMS
     * }
     */
    public static final AddressLayout PMCI_SYSINFO_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_SYSINFO_PARMSA LPMCI_SYSINFO_PARMS
     * }
     */
    public static final AddressLayout LPMCI_SYSINFO_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SET_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwTimeFormat;
     *     DWORD dwAudio;
     * } *PMCI_SET_PARMS
     * }
     */
    public static final AddressLayout PMCI_SET_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SET_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwTimeFormat;
     *     DWORD dwAudio;
     * } *LPMCI_SET_PARMS
     * }
     */
    public static final AddressLayout LPMCI_SET_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_BREAK_PARMS {
     *     DWORD_PTR dwCallback;
     *     int nVirtKey;
     *     HWND hwndBreak;
     * } *PMCI_BREAK_PARMS
     * }
     */
    public static final AddressLayout PMCI_BREAK_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_BREAK_PARMS {
     *     DWORD_PTR dwCallback;
     *     int nVirtKey;
     *     HWND hwndBreak;
     * } *LPMCI_BREAK_PARMS
     * }
     */
    public static final AddressLayout LPMCI_BREAK_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SAVE_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpfilename;
     * } *PMCI_SAVE_PARMSA
     * }
     */
    public static final AddressLayout PMCI_SAVE_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SAVE_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpfilename;
     * } *LPMCI_SAVE_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_SAVE_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SAVE_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpfilename;
     * } *PMCI_SAVE_PARMSW
     * }
     */
    public static final AddressLayout PMCI_SAVE_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SAVE_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpfilename;
     * } *LPMCI_SAVE_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_SAVE_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_SAVE_PARMSA PMCI_SAVE_PARMS
     * }
     */
    public static final AddressLayout PMCI_SAVE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_SAVE_PARMSA LPMCI_SAVE_PARMS
     * }
     */
    public static final AddressLayout LPMCI_SAVE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_LOAD_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpfilename;
     * } *PMCI_LOAD_PARMSA
     * }
     */
    public static final AddressLayout PMCI_LOAD_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_LOAD_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpfilename;
     * } *LPMCI_LOAD_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_LOAD_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_LOAD_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpfilename;
     * } *PMCI_LOAD_PARMSW
     * }
     */
    public static final AddressLayout PMCI_LOAD_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_LOAD_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpfilename;
     * } *LPMCI_LOAD_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_LOAD_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_LOAD_PARMSA PMCI_LOAD_PARMS
     * }
     */
    public static final AddressLayout PMCI_LOAD_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_LOAD_PARMSA LPMCI_LOAD_PARMS
     * }
     */
    public static final AddressLayout LPMCI_LOAD_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_RECORD_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrom;
     *     DWORD dwTo;
     * } *LPMCI_RECORD_PARMS
     * }
     */
    public static final AddressLayout LPMCI_RECORD_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_VD_PLAY_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrom;
     *     DWORD dwTo;
     *     DWORD dwSpeed;
     * } *PMCI_VD_PLAY_PARMS
     * }
     */
    public static final AddressLayout PMCI_VD_PLAY_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_VD_PLAY_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrom;
     *     DWORD dwTo;
     *     DWORD dwSpeed;
     * } *LPMCI_VD_PLAY_PARMS
     * }
     */
    public static final AddressLayout LPMCI_VD_PLAY_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_VD_STEP_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrames;
     * } *PMCI_VD_STEP_PARMS
     * }
     */
    public static final AddressLayout PMCI_VD_STEP_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_VD_STEP_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrames;
     * } *LPMCI_VD_STEP_PARMS
     * }
     */
    public static final AddressLayout LPMCI_VD_STEP_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_VD_ESCAPE_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpstrCommand;
     * } *PMCI_VD_ESCAPE_PARMSA
     * }
     */
    public static final AddressLayout PMCI_VD_ESCAPE_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_VD_ESCAPE_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpstrCommand;
     * } *LPMCI_VD_ESCAPE_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_VD_ESCAPE_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_VD_ESCAPE_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpstrCommand;
     * } *PMCI_VD_ESCAPE_PARMSW
     * }
     */
    public static final AddressLayout PMCI_VD_ESCAPE_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_VD_ESCAPE_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpstrCommand;
     * } *LPMCI_VD_ESCAPE_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_VD_ESCAPE_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_VD_ESCAPE_PARMSA PMCI_VD_ESCAPE_PARMS
     * }
     */
    public static final AddressLayout PMCI_VD_ESCAPE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_VD_ESCAPE_PARMSA LPMCI_VD_ESCAPE_PARMS
     * }
     */
    public static final AddressLayout LPMCI_VD_ESCAPE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_WAVE_OPEN_PARMSA {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCSTR lpstrDeviceType;
     *     LPCSTR lpstrElementName;
     *     LPCSTR lpstrAlias;
     *     DWORD dwBufferSeconds;
     * } *PMCI_WAVE_OPEN_PARMSA
     * }
     */
    public static final AddressLayout PMCI_WAVE_OPEN_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_WAVE_OPEN_PARMSA {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCSTR lpstrDeviceType;
     *     LPCSTR lpstrElementName;
     *     LPCSTR lpstrAlias;
     *     DWORD dwBufferSeconds;
     * } *LPMCI_WAVE_OPEN_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_WAVE_OPEN_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_WAVE_OPEN_PARMSW {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCWSTR lpstrDeviceType;
     *     LPCWSTR lpstrElementName;
     *     LPCWSTR lpstrAlias;
     *     DWORD dwBufferSeconds;
     * } *PMCI_WAVE_OPEN_PARMSW
     * }
     */
    public static final AddressLayout PMCI_WAVE_OPEN_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_WAVE_OPEN_PARMSW {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCWSTR lpstrDeviceType;
     *     LPCWSTR lpstrElementName;
     *     LPCWSTR lpstrAlias;
     *     DWORD dwBufferSeconds;
     * } *LPMCI_WAVE_OPEN_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_WAVE_OPEN_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_WAVE_OPEN_PARMSA PMCI_WAVE_OPEN_PARMS
     * }
     */
    public static final AddressLayout PMCI_WAVE_OPEN_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_WAVE_OPEN_PARMSA LPMCI_WAVE_OPEN_PARMS
     * }
     */
    public static final AddressLayout LPMCI_WAVE_OPEN_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_WAVE_DELETE_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrom;
     *     DWORD dwTo;
     * } *PMCI_WAVE_DELETE_PARMS
     * }
     */
    public static final AddressLayout PMCI_WAVE_DELETE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_WAVE_DELETE_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrom;
     *     DWORD dwTo;
     * } *LPMCI_WAVE_DELETE_PARMS
     * }
     */
    public static final AddressLayout LPMCI_WAVE_DELETE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_WAVE_SET_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwTimeFormat;
     *     DWORD dwAudio;
     *     UINT wInput;
     *     UINT wOutput;
     *     WORD wFormatTag;
     *     WORD wReserved2;
     *     WORD nChannels;
     *     WORD wReserved3;
     *     DWORD nSamplesPerSec;
     *     DWORD nAvgBytesPerSec;
     *     WORD nBlockAlign;
     *     WORD wReserved4;
     *     WORD wBitsPerSample;
     *     WORD wReserved5;
     * } *PMCI_WAVE_SET_PARMS
     * }
     */
    public static final AddressLayout PMCI_WAVE_SET_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_WAVE_SET_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwTimeFormat;
     *     DWORD dwAudio;
     *     UINT wInput;
     *     UINT wOutput;
     *     WORD wFormatTag;
     *     WORD wReserved2;
     *     WORD nChannels;
     *     WORD wReserved3;
     *     DWORD nSamplesPerSec;
     *     DWORD nAvgBytesPerSec;
     *     WORD nBlockAlign;
     *     WORD wReserved4;
     *     WORD wBitsPerSample;
     *     WORD wReserved5;
     * } *LPMCI_WAVE_SET_PARMS
     * }
     */
    public static final AddressLayout LPMCI_WAVE_SET_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SEQ_SET_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwTimeFormat;
     *     DWORD dwAudio;
     *     DWORD dwTempo;
     *     DWORD dwPort;
     *     DWORD dwSlave;
     *     DWORD dwMaster;
     *     DWORD dwOffset;
     * } *PMCI_SEQ_SET_PARMS
     * }
     */
    public static final AddressLayout PMCI_SEQ_SET_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_SEQ_SET_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwTimeFormat;
     *     DWORD dwAudio;
     *     DWORD dwTempo;
     *     DWORD dwPort;
     *     DWORD dwSlave;
     *     DWORD dwMaster;
     *     DWORD dwOffset;
     * } *LPMCI_SEQ_SET_PARMS
     * }
     */
    public static final AddressLayout LPMCI_SEQ_SET_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_OPEN_PARMSA {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCSTR lpstrDeviceType;
     *     LPCSTR lpstrElementName;
     *     LPCSTR lpstrAlias;
     *     DWORD dwStyle;
     *     HWND hWndParent;
     * } *PMCI_ANIM_OPEN_PARMSA
     * }
     */
    public static final AddressLayout PMCI_ANIM_OPEN_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_OPEN_PARMSA {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCSTR lpstrDeviceType;
     *     LPCSTR lpstrElementName;
     *     LPCSTR lpstrAlias;
     *     DWORD dwStyle;
     *     HWND hWndParent;
     * } *LPMCI_ANIM_OPEN_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_ANIM_OPEN_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_OPEN_PARMSW {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCWSTR lpstrDeviceType;
     *     LPCWSTR lpstrElementName;
     *     LPCWSTR lpstrAlias;
     *     DWORD dwStyle;
     *     HWND hWndParent;
     * } *PMCI_ANIM_OPEN_PARMSW
     * }
     */
    public static final AddressLayout PMCI_ANIM_OPEN_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_OPEN_PARMSW {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCWSTR lpstrDeviceType;
     *     LPCWSTR lpstrElementName;
     *     LPCWSTR lpstrAlias;
     *     DWORD dwStyle;
     *     HWND hWndParent;
     * } *LPMCI_ANIM_OPEN_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_ANIM_OPEN_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_ANIM_OPEN_PARMSA PMCI_ANIM_OPEN_PARMS
     * }
     */
    public static final AddressLayout PMCI_ANIM_OPEN_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_ANIM_OPEN_PARMSA LPMCI_ANIM_OPEN_PARMS
     * }
     */
    public static final AddressLayout LPMCI_ANIM_OPEN_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_PLAY_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrom;
     *     DWORD dwTo;
     *     DWORD dwSpeed;
     * } *PMCI_ANIM_PLAY_PARMS
     * }
     */
    public static final AddressLayout PMCI_ANIM_PLAY_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_PLAY_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrom;
     *     DWORD dwTo;
     *     DWORD dwSpeed;
     * } *LPMCI_ANIM_PLAY_PARMS
     * }
     */
    public static final AddressLayout LPMCI_ANIM_PLAY_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_STEP_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrames;
     * } *PMCI_ANIM_STEP_PARMS
     * }
     */
    public static final AddressLayout PMCI_ANIM_STEP_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_STEP_PARMS {
     *     DWORD_PTR dwCallback;
     *     DWORD dwFrames;
     * } *LPMCI_ANIM_STEP_PARMS
     * }
     */
    public static final AddressLayout LPMCI_ANIM_STEP_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_WINDOW_PARMSA {
     *     DWORD_PTR dwCallback;
     *     HWND hWnd;
     *     UINT nCmdShow;
     *     LPCSTR lpstrText;
     * } *PMCI_ANIM_WINDOW_PARMSA
     * }
     */
    public static final AddressLayout PMCI_ANIM_WINDOW_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_WINDOW_PARMSA {
     *     DWORD_PTR dwCallback;
     *     HWND hWnd;
     *     UINT nCmdShow;
     *     LPCSTR lpstrText;
     * } *LPMCI_ANIM_WINDOW_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_ANIM_WINDOW_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_WINDOW_PARMSW {
     *     DWORD_PTR dwCallback;
     *     HWND hWnd;
     *     UINT nCmdShow;
     *     LPCWSTR lpstrText;
     * } *PMCI_ANIM_WINDOW_PARMSW
     * }
     */
    public static final AddressLayout PMCI_ANIM_WINDOW_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_WINDOW_PARMSW {
     *     DWORD_PTR dwCallback;
     *     HWND hWnd;
     *     UINT nCmdShow;
     *     LPCWSTR lpstrText;
     * } *LPMCI_ANIM_WINDOW_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_ANIM_WINDOW_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_ANIM_WINDOW_PARMSA PMCI_ANIM_WINDOW_PARMS
     * }
     */
    public static final AddressLayout PMCI_ANIM_WINDOW_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_ANIM_WINDOW_PARMSA LPMCI_ANIM_WINDOW_PARMS
     * }
     */
    public static final AddressLayout LPMCI_ANIM_WINDOW_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef MCI_ANIM_RECT_PARMS *PMCI_ANIM_RECT_PARMS
     * }
     */
    public static final AddressLayout PMCI_ANIM_RECT_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef MCI_ANIM_RECT_PARMS *LPMCI_ANIM_RECT_PARMS
     * }
     */
    public static final AddressLayout LPMCI_ANIM_RECT_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_UPDATE_PARMS {
     *     DWORD_PTR dwCallback;
     *     RECT rc;
     *     HDC hDC;
     * } *PMCI_ANIM_UPDATE_PARMS
     * }
     */
    public static final AddressLayout PMCI_ANIM_UPDATE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_ANIM_UPDATE_PARMS {
     *     DWORD_PTR dwCallback;
     *     RECT rc;
     *     HDC hDC;
     * } *LPMCI_ANIM_UPDATE_PARMS
     * }
     */
    public static final AddressLayout LPMCI_ANIM_UPDATE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_OPEN_PARMSA {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCSTR lpstrDeviceType;
     *     LPCSTR lpstrElementName;
     *     LPCSTR lpstrAlias;
     *     DWORD dwStyle;
     *     HWND hWndParent;
     * } *PMCI_OVLY_OPEN_PARMSA
     * }
     */
    public static final AddressLayout PMCI_OVLY_OPEN_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_OPEN_PARMSA {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCSTR lpstrDeviceType;
     *     LPCSTR lpstrElementName;
     *     LPCSTR lpstrAlias;
     *     DWORD dwStyle;
     *     HWND hWndParent;
     * } *LPMCI_OVLY_OPEN_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_OVLY_OPEN_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_OPEN_PARMSW {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCWSTR lpstrDeviceType;
     *     LPCWSTR lpstrElementName;
     *     LPCWSTR lpstrAlias;
     *     DWORD dwStyle;
     *     HWND hWndParent;
     * } *PMCI_OVLY_OPEN_PARMSW
     * }
     */
    public static final AddressLayout PMCI_OVLY_OPEN_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_OPEN_PARMSW {
     *     DWORD_PTR dwCallback;
     *     MCIDEVICEID wDeviceID;
     *     LPCWSTR lpstrDeviceType;
     *     LPCWSTR lpstrElementName;
     *     LPCWSTR lpstrAlias;
     *     DWORD dwStyle;
     *     HWND hWndParent;
     * } *LPMCI_OVLY_OPEN_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_OVLY_OPEN_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_OVLY_OPEN_PARMSA PMCI_OVLY_OPEN_PARMS
     * }
     */
    public static final AddressLayout PMCI_OVLY_OPEN_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_OVLY_OPEN_PARMSA LPMCI_OVLY_OPEN_PARMS
     * }
     */
    public static final AddressLayout LPMCI_OVLY_OPEN_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_WINDOW_PARMSA {
     *     DWORD_PTR dwCallback;
     *     HWND hWnd;
     *     UINT nCmdShow;
     *     LPCSTR lpstrText;
     * } *PMCI_OVLY_WINDOW_PARMSA
     * }
     */
    public static final AddressLayout PMCI_OVLY_WINDOW_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_WINDOW_PARMSA {
     *     DWORD_PTR dwCallback;
     *     HWND hWnd;
     *     UINT nCmdShow;
     *     LPCSTR lpstrText;
     * } *LPMCI_OVLY_WINDOW_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_OVLY_WINDOW_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_WINDOW_PARMSW {
     *     DWORD_PTR dwCallback;
     *     HWND hWnd;
     *     UINT nCmdShow;
     *     LPCWSTR lpstrText;
     * } *PMCI_OVLY_WINDOW_PARMSW
     * }
     */
    public static final AddressLayout PMCI_OVLY_WINDOW_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_WINDOW_PARMSW {
     *     DWORD_PTR dwCallback;
     *     HWND hWnd;
     *     UINT nCmdShow;
     *     LPCWSTR lpstrText;
     * } *LPMCI_OVLY_WINDOW_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_OVLY_WINDOW_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_OVLY_WINDOW_PARMSA PMCI_OVLY_WINDOW_PARMS
     * }
     */
    public static final AddressLayout PMCI_OVLY_WINDOW_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_OVLY_WINDOW_PARMSA LPMCI_OVLY_WINDOW_PARMS
     * }
     */
    public static final AddressLayout LPMCI_OVLY_WINDOW_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_RECT_PARMS {
     *     DWORD_PTR dwCallback;
     *     RECT rc;
     * } *PMCI_OVLY_RECT_PARMS
     * }
     */
    public static final AddressLayout PMCI_OVLY_RECT_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_RECT_PARMS {
     *     DWORD_PTR dwCallback;
     *     RECT rc;
     * } *LPMCI_OVLY_RECT_PARMS
     * }
     */
    public static final AddressLayout LPMCI_OVLY_RECT_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_SAVE_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpfilename;
     *     RECT rc;
     * } *PMCI_OVLY_SAVE_PARMSA
     * }
     */
    public static final AddressLayout PMCI_OVLY_SAVE_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_SAVE_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpfilename;
     *     RECT rc;
     * } *LPMCI_OVLY_SAVE_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_OVLY_SAVE_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_SAVE_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpfilename;
     *     RECT rc;
     * } *PMCI_OVLY_SAVE_PARMSW
     * }
     */
    public static final AddressLayout PMCI_OVLY_SAVE_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_SAVE_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpfilename;
     *     RECT rc;
     * } *LPMCI_OVLY_SAVE_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_OVLY_SAVE_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_OVLY_SAVE_PARMSA PMCI_OVLY_SAVE_PARMS
     * }
     */
    public static final AddressLayout PMCI_OVLY_SAVE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_OVLY_SAVE_PARMSA LPMCI_OVLY_SAVE_PARMS
     * }
     */
    public static final AddressLayout LPMCI_OVLY_SAVE_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_LOAD_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpfilename;
     *     RECT rc;
     * } *PMCI_OVLY_LOAD_PARMSA
     * }
     */
    public static final AddressLayout PMCI_OVLY_LOAD_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_LOAD_PARMSA {
     *     DWORD_PTR dwCallback;
     *     LPCSTR lpfilename;
     *     RECT rc;
     * } *LPMCI_OVLY_LOAD_PARMSA
     * }
     */
    public static final AddressLayout LPMCI_OVLY_LOAD_PARMSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_LOAD_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpfilename;
     *     RECT rc;
     * } *PMCI_OVLY_LOAD_PARMSW
     * }
     */
    public static final AddressLayout PMCI_OVLY_LOAD_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMCI_OVLY_LOAD_PARMSW {
     *     DWORD_PTR dwCallback;
     *     LPCWSTR lpfilename;
     *     RECT rc;
     * } *LPMCI_OVLY_LOAD_PARMSW
     * }
     */
    public static final AddressLayout LPMCI_OVLY_LOAD_PARMSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMCI_OVLY_LOAD_PARMSA PMCI_OVLY_LOAD_PARMS
     * }
     */
    public static final AddressLayout PMCI_OVLY_LOAD_PARMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMCI_OVLY_LOAD_PARMSA LPMCI_OVLY_LOAD_PARMS
     * }
     */
    public static final AddressLayout LPMCI_OVLY_LOAD_PARMS = winapi.C_POINTER;

    private static class mciGetDriverData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciGetDriverData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD_PTR mciGetDriverData(MCIDEVICEID wDeviceID)
     * }
     */
    public static FunctionDescriptor mciGetDriverData$descriptor() {
        return mciGetDriverData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD_PTR mciGetDriverData(MCIDEVICEID wDeviceID)
     * }
     */
    public static MethodHandle mciGetDriverData$handle() {
        return mciGetDriverData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD_PTR mciGetDriverData(MCIDEVICEID wDeviceID)
     * }
     */
    public static MemorySegment mciGetDriverData$address() {
        return mciGetDriverData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD_PTR mciGetDriverData(MCIDEVICEID wDeviceID)
     * }
     */
    public static long mciGetDriverData(int wDeviceID) {
        var mh$ = mciGetDriverData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciGetDriverData", wDeviceID);
            }
            return (long)mh$.invokeExact(wDeviceID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciLoadCommandResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciLoadCommandResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT mciLoadCommandResource(HANDLE hInstance, LPCWSTR lpResName, UINT wType)
     * }
     */
    public static FunctionDescriptor mciLoadCommandResource$descriptor() {
        return mciLoadCommandResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT mciLoadCommandResource(HANDLE hInstance, LPCWSTR lpResName, UINT wType)
     * }
     */
    public static MethodHandle mciLoadCommandResource$handle() {
        return mciLoadCommandResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT mciLoadCommandResource(HANDLE hInstance, LPCWSTR lpResName, UINT wType)
     * }
     */
    public static MemorySegment mciLoadCommandResource$address() {
        return mciLoadCommandResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT mciLoadCommandResource(HANDLE hInstance, LPCWSTR lpResName, UINT wType)
     * }
     */
    public static int mciLoadCommandResource(MemorySegment hInstance, MemorySegment lpResName, int wType) {
        var mh$ = mciLoadCommandResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciLoadCommandResource", hInstance, lpResName, wType);
            }
            return (int)mh$.invokeExact(hInstance, lpResName, wType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciSetDriverData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciSetDriverData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData)
     * }
     */
    public static FunctionDescriptor mciSetDriverData$descriptor() {
        return mciSetDriverData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData)
     * }
     */
    public static MethodHandle mciSetDriverData$handle() {
        return mciSetDriverData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData)
     * }
     */
    public static MemorySegment mciSetDriverData$address() {
        return mciSetDriverData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData)
     * }
     */
    public static int mciSetDriverData(int wDeviceID, long dwData) {
        var mh$ = mciSetDriverData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciSetDriverData", wDeviceID, dwData);
            }
            return (int)mh$.invokeExact(wDeviceID, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciDriverYield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciDriverYield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT mciDriverYield(MCIDEVICEID wDeviceID)
     * }
     */
    public static FunctionDescriptor mciDriverYield$descriptor() {
        return mciDriverYield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT mciDriverYield(MCIDEVICEID wDeviceID)
     * }
     */
    public static MethodHandle mciDriverYield$handle() {
        return mciDriverYield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT mciDriverYield(MCIDEVICEID wDeviceID)
     * }
     */
    public static MemorySegment mciDriverYield$address() {
        return mciDriverYield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT mciDriverYield(MCIDEVICEID wDeviceID)
     * }
     */
    public static int mciDriverYield(int wDeviceID) {
        var mh$ = mciDriverYield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciDriverYield", wDeviceID);
            }
            return (int)mh$.invokeExact(wDeviceID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciDriverNotify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciDriverNotify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL mciDriverNotify(HANDLE hwndCallback, MCIDEVICEID wDeviceID, UINT uStatus)
     * }
     */
    public static FunctionDescriptor mciDriverNotify$descriptor() {
        return mciDriverNotify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL mciDriverNotify(HANDLE hwndCallback, MCIDEVICEID wDeviceID, UINT uStatus)
     * }
     */
    public static MethodHandle mciDriverNotify$handle() {
        return mciDriverNotify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL mciDriverNotify(HANDLE hwndCallback, MCIDEVICEID wDeviceID, UINT uStatus)
     * }
     */
    public static MemorySegment mciDriverNotify$address() {
        return mciDriverNotify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL mciDriverNotify(HANDLE hwndCallback, MCIDEVICEID wDeviceID, UINT uStatus)
     * }
     */
    public static int mciDriverNotify(MemorySegment hwndCallback, int wDeviceID, int uStatus) {
        var mh$ = mciDriverNotify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciDriverNotify", hwndCallback, wDeviceID, uStatus);
            }
            return (int)mh$.invokeExact(hwndCallback, wDeviceID, uStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mciFreeCommandResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mciFreeCommandResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL mciFreeCommandResource(UINT wTable)
     * }
     */
    public static FunctionDescriptor mciFreeCommandResource$descriptor() {
        return mciFreeCommandResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL mciFreeCommandResource(UINT wTable)
     * }
     */
    public static MethodHandle mciFreeCommandResource$handle() {
        return mciFreeCommandResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL mciFreeCommandResource(UINT wTable)
     * }
     */
    public static MemorySegment mciFreeCommandResource$address() {
        return mciFreeCommandResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL mciFreeCommandResource(UINT wTable)
     * }
     */
    public static int mciFreeCommandResource(int wTable) {
        var mh$ = mciFreeCommandResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mciFreeCommandResource", wTable);
            }
            return (int)mh$.invokeExact(wTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct DRVCONFIGINFOEX {
     *     DWORD dwDCISize;
     *     LPCWSTR lpszDCISectionName;
     *     LPCWSTR lpszDCIAliasName;
     *     DWORD dnDevNode;
     * } *PDRVCONFIGINFOEX
     * }
     */
    public static final AddressLayout PDRVCONFIGINFOEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct DRVCONFIGINFOEX {
     *     DWORD dwDCISize;
     *     LPCWSTR lpszDCISectionName;
     *     LPCWSTR lpszDCIAliasName;
     *     DWORD dnDevNode;
     * } *NPDRVCONFIGINFOEX
     * }
     */
    public static final AddressLayout NPDRVCONFIGINFOEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct DRVCONFIGINFOEX {
     *     DWORD dwDCISize;
     *     LPCWSTR lpszDCISectionName;
     *     LPCWSTR lpszDCIAliasName;
     *     DWORD dnDevNode;
     * } *LPDRVCONFIGINFOEX
     * }
     */
    public static final AddressLayout LPDRVCONFIGINFOEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDRVCONFIGINFO {
     *     DWORD dwDCISize;
     *     LPCWSTR lpszDCISectionName;
     *     LPCWSTR lpszDCIAliasName;
     * } *PDRVCONFIGINFO
     * }
     */
    public static final AddressLayout PDRVCONFIGINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDRVCONFIGINFO {
     *     DWORD dwDCISize;
     *     LPCWSTR lpszDCISectionName;
     *     LPCWSTR lpszDCIAliasName;
     * } *NPDRVCONFIGINFO
     * }
     */
    public static final AddressLayout NPDRVCONFIGINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDRVCONFIGINFO {
     *     DWORD dwDCISize;
     *     LPCWSTR lpszDCISectionName;
     *     LPCWSTR lpszDCIAliasName;
     * } *LPDRVCONFIGINFO
     * }
     */
    public static final AddressLayout LPDRVCONFIGINFO = winapi.C_POINTER;

    private static class CloseDriver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CloseDriver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static FunctionDescriptor CloseDriver$descriptor() {
        return CloseDriver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static MethodHandle CloseDriver$handle() {
        return CloseDriver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static MemorySegment CloseDriver$address() {
        return CloseDriver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static long CloseDriver(MemorySegment hDriver, long lParam1, long lParam2) {
        var mh$ = CloseDriver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseDriver", hDriver, lParam1, lParam2);
            }
            return (long)mh$.invokeExact(hDriver, lParam1, lParam2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenDriver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenDriver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDRVR OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LPARAM lParam2)
     * }
     */
    public static FunctionDescriptor OpenDriver$descriptor() {
        return OpenDriver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDRVR OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LPARAM lParam2)
     * }
     */
    public static MethodHandle OpenDriver$handle() {
        return OpenDriver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDRVR OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LPARAM lParam2)
     * }
     */
    public static MemorySegment OpenDriver$address() {
        return OpenDriver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDRVR OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LPARAM lParam2)
     * }
     */
    public static MemorySegment OpenDriver(MemorySegment szDriverName, MemorySegment szSectionName, long lParam2) {
        var mh$ = OpenDriver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDriver", szDriverName, szSectionName, lParam2);
            }
            return (MemorySegment)mh$.invokeExact(szDriverName, szSectionName, lParam2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendDriverMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SendDriverMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static FunctionDescriptor SendDriverMessage$descriptor() {
        return SendDriverMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static MethodHandle SendDriverMessage$handle() {
        return SendDriverMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static MemorySegment SendDriverMessage$address() {
        return SendDriverMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static long SendDriverMessage(MemorySegment hDriver, int message, long lParam1, long lParam2) {
        var mh$ = SendDriverMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendDriverMessage", hDriver, message, lParam1, lParam2);
            }
            return (long)mh$.invokeExact(hDriver, message, lParam1, lParam2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrvGetModuleHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DrvGetModuleHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE DrvGetModuleHandle(HDRVR hDriver)
     * }
     */
    public static FunctionDescriptor DrvGetModuleHandle$descriptor() {
        return DrvGetModuleHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE DrvGetModuleHandle(HDRVR hDriver)
     * }
     */
    public static MethodHandle DrvGetModuleHandle$handle() {
        return DrvGetModuleHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE DrvGetModuleHandle(HDRVR hDriver)
     * }
     */
    public static MemorySegment DrvGetModuleHandle$address() {
        return DrvGetModuleHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE DrvGetModuleHandle(HDRVR hDriver)
     * }
     */
    public static MemorySegment DrvGetModuleHandle(MemorySegment hDriver) {
        var mh$ = DrvGetModuleHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrvGetModuleHandle", hDriver);
            }
            return (MemorySegment)mh$.invokeExact(hDriver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDriverModuleHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDriverModuleHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE GetDriverModuleHandle(HDRVR hDriver)
     * }
     */
    public static FunctionDescriptor GetDriverModuleHandle$descriptor() {
        return GetDriverModuleHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE GetDriverModuleHandle(HDRVR hDriver)
     * }
     */
    public static MethodHandle GetDriverModuleHandle$handle() {
        return GetDriverModuleHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE GetDriverModuleHandle(HDRVR hDriver)
     * }
     */
    public static MemorySegment GetDriverModuleHandle$address() {
        return GetDriverModuleHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE GetDriverModuleHandle(HDRVR hDriver)
     * }
     */
    public static MemorySegment GetDriverModuleHandle(MemorySegment hDriver) {
        var mh$ = GetDriverModuleHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDriverModuleHandle", hDriver);
            }
            return (MemorySegment)mh$.invokeExact(hDriver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefDriverProc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DefDriverProc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefDriverProc(DWORD_PTR dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static FunctionDescriptor DefDriverProc$descriptor() {
        return DefDriverProc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefDriverProc(DWORD_PTR dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static MethodHandle DefDriverProc$handle() {
        return DefDriverProc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefDriverProc(DWORD_PTR dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static MemorySegment DefDriverProc$address() {
        return DefDriverProc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefDriverProc(DWORD_PTR dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static long DefDriverProc(long dwDriverIdentifier, MemorySegment hdrvr, int uMsg, long lParam1, long lParam2) {
        var mh$ = DefDriverProc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefDriverProc", dwDriverIdentifier, hdrvr, uMsg, lParam1, lParam2);
            }
            return (long)mh$.invokeExact(dwDriverIdentifier, hdrvr, uMsg, lParam1, lParam2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriverCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DriverCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags, HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static FunctionDescriptor DriverCallback$descriptor() {
        return DriverCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags, HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static MethodHandle DriverCallback$handle() {
        return DriverCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags, HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static MemorySegment DriverCallback$address() {
        return DriverCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags, HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static int DriverCallback(long dwCallback, int dwFlags, MemorySegment hDevice, int dwMsg, long dwUser, long dwParam1, long dwParam2) {
        var mh$ = DriverCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriverCallback", dwCallback, dwFlags, hDevice, dwMsg, dwUser, dwParam1, dwParam2);
            }
            return (int)mh$.invokeExact(dwCallback, dwFlags, hDevice, dwMsg, dwUser, dwParam1, dwParam2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sndOpenSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("sndOpenSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG sndOpenSound(LPCWSTR EventName, LPCWSTR AppName, INT32 Flags, PHANDLE FileHandle)
     * }
     */
    public static FunctionDescriptor sndOpenSound$descriptor() {
        return sndOpenSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG sndOpenSound(LPCWSTR EventName, LPCWSTR AppName, INT32 Flags, PHANDLE FileHandle)
     * }
     */
    public static MethodHandle sndOpenSound$handle() {
        return sndOpenSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG sndOpenSound(LPCWSTR EventName, LPCWSTR AppName, INT32 Flags, PHANDLE FileHandle)
     * }
     */
    public static MemorySegment sndOpenSound$address() {
        return sndOpenSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG sndOpenSound(LPCWSTR EventName, LPCWSTR AppName, INT32 Flags, PHANDLE FileHandle)
     * }
     */
    public static int sndOpenSound(MemorySegment EventName, MemorySegment AppName, int Flags, MemorySegment FileHandle) {
        var mh$ = sndOpenSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sndOpenSound", EventName, AppName, Flags, FileHandle);
            }
            return (int)mh$.invokeExact(EventName, AppName, Flags, FileHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmDrvInstall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmDrvInstall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT mmDrvInstall(HDRVR hDriver, LPCWSTR wszDrvEntry, DRIVERMSGPROC drvMessage, UINT wFlags)
     * }
     */
    public static FunctionDescriptor mmDrvInstall$descriptor() {
        return mmDrvInstall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT mmDrvInstall(HDRVR hDriver, LPCWSTR wszDrvEntry, DRIVERMSGPROC drvMessage, UINT wFlags)
     * }
     */
    public static MethodHandle mmDrvInstall$handle() {
        return mmDrvInstall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT mmDrvInstall(HDRVR hDriver, LPCWSTR wszDrvEntry, DRIVERMSGPROC drvMessage, UINT wFlags)
     * }
     */
    public static MemorySegment mmDrvInstall$address() {
        return mmDrvInstall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT mmDrvInstall(HDRVR hDriver, LPCWSTR wszDrvEntry, DRIVERMSGPROC drvMessage, UINT wFlags)
     * }
     */
    public static int mmDrvInstall(MemorySegment hDriver, MemorySegment wszDrvEntry, MemorySegment drvMessage, int wFlags) {
        var mh$ = mmDrvInstall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmDrvInstall", hDriver, wszDrvEntry, drvMessage, wFlags);
            }
            return (int)mh$.invokeExact(hDriver, wszDrvEntry, drvMessage, wFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD FOURCC
     * }
     */
    public static final OfInt FOURCC = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *HPSTR
     * }
     */
    public static final AddressLayout HPSTR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMMIO__ {
     *     int unused;
     * } *HMMIO
     * }
     */
    public static final AddressLayout HMMIO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MMIOINFO {
     *     DWORD dwFlags;
     *     FOURCC fccIOProc;
     *     LPMMIOPROC pIOProc;
     *     UINT wErrorRet;
     *     HTASK htask;
     *     LONG cchBuffer;
     *     HPSTR pchBuffer;
     *     HPSTR pchNext;
     *     HPSTR pchEndRead;
     *     HPSTR pchEndWrite;
     *     LONG lBufOffset;
     *     LONG lDiskOffset;
     *     DWORD adwInfo[3];
     *     DWORD dwReserved1;
     *     DWORD dwReserved2;
     *     HMMIO hmmio;
     * } *PMMIOINFO
     * }
     */
    public static final AddressLayout PMMIOINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MMIOINFO {
     *     DWORD dwFlags;
     *     FOURCC fccIOProc;
     *     LPMMIOPROC pIOProc;
     *     UINT wErrorRet;
     *     HTASK htask;
     *     LONG cchBuffer;
     *     HPSTR pchBuffer;
     *     HPSTR pchNext;
     *     HPSTR pchEndRead;
     *     HPSTR pchEndWrite;
     *     LONG lBufOffset;
     *     LONG lDiskOffset;
     *     DWORD adwInfo[3];
     *     DWORD dwReserved1;
     *     DWORD dwReserved2;
     *     HMMIO hmmio;
     * } *NPMMIOINFO
     * }
     */
    public static final AddressLayout NPMMIOINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MMIOINFO {
     *     DWORD dwFlags;
     *     FOURCC fccIOProc;
     *     LPMMIOPROC pIOProc;
     *     UINT wErrorRet;
     *     HTASK htask;
     *     LONG cchBuffer;
     *     HPSTR pchBuffer;
     *     HPSTR pchNext;
     *     HPSTR pchEndRead;
     *     HPSTR pchEndWrite;
     *     LONG lBufOffset;
     *     LONG lDiskOffset;
     *     DWORD adwInfo[3];
     *     DWORD dwReserved1;
     *     DWORD dwReserved2;
     *     HMMIO hmmio;
     * } *LPMMIOINFO
     * }
     */
    public static final AddressLayout LPMMIOINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MMIOINFO *LPCMMIOINFO
     * }
     */
    public static final AddressLayout LPCMMIOINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MMCKINFO {
     *     FOURCC ckid;
     *     DWORD cksize;
     *     FOURCC fccType;
     *     DWORD dwDataOffset;
     *     DWORD dwFlags;
     * } *PMMCKINFO
     * }
     */
    public static final AddressLayout PMMCKINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MMCKINFO {
     *     FOURCC ckid;
     *     DWORD cksize;
     *     FOURCC fccType;
     *     DWORD dwDataOffset;
     *     DWORD dwFlags;
     * } *NPMMCKINFO
     * }
     */
    public static final AddressLayout NPMMCKINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MMCKINFO {
     *     FOURCC ckid;
     *     DWORD cksize;
     *     FOURCC fccType;
     *     DWORD dwDataOffset;
     *     DWORD dwFlags;
     * } *LPMMCKINFO
     * }
     */
    public static final AddressLayout LPMMCKINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MMCKINFO *LPCMMCKINFO
     * }
     */
    public static final AddressLayout LPCMMCKINFO = winapi.C_POINTER;

    private static class mmioStringToFOURCCA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioStringToFOURCCA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FOURCC mmioStringToFOURCCA(LPCSTR sz, UINT uFlags)
     * }
     */
    public static FunctionDescriptor mmioStringToFOURCCA$descriptor() {
        return mmioStringToFOURCCA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FOURCC mmioStringToFOURCCA(LPCSTR sz, UINT uFlags)
     * }
     */
    public static MethodHandle mmioStringToFOURCCA$handle() {
        return mmioStringToFOURCCA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FOURCC mmioStringToFOURCCA(LPCSTR sz, UINT uFlags)
     * }
     */
    public static MemorySegment mmioStringToFOURCCA$address() {
        return mmioStringToFOURCCA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FOURCC mmioStringToFOURCCA(LPCSTR sz, UINT uFlags)
     * }
     */
    public static int mmioStringToFOURCCA(MemorySegment sz, int uFlags) {
        var mh$ = mmioStringToFOURCCA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioStringToFOURCCA", sz, uFlags);
            }
            return (int)mh$.invokeExact(sz, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioStringToFOURCCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioStringToFOURCCW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FOURCC mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags)
     * }
     */
    public static FunctionDescriptor mmioStringToFOURCCW$descriptor() {
        return mmioStringToFOURCCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FOURCC mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags)
     * }
     */
    public static MethodHandle mmioStringToFOURCCW$handle() {
        return mmioStringToFOURCCW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FOURCC mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags)
     * }
     */
    public static MemorySegment mmioStringToFOURCCW$address() {
        return mmioStringToFOURCCW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FOURCC mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags)
     * }
     */
    public static int mmioStringToFOURCCW(MemorySegment sz, int uFlags) {
        var mh$ = mmioStringToFOURCCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioStringToFOURCCW", sz, uFlags);
            }
            return (int)mh$.invokeExact(sz, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioInstallIOProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioInstallIOProcA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPMMIOPROC mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor mmioInstallIOProcA$descriptor() {
        return mmioInstallIOProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPMMIOPROC mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle mmioInstallIOProcA$handle() {
        return mmioInstallIOProcA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPMMIOPROC mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment mmioInstallIOProcA$address() {
        return mmioInstallIOProcA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPMMIOPROC mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment mmioInstallIOProcA(int fccIOProc, MemorySegment pIOProc, int dwFlags) {
        var mh$ = mmioInstallIOProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioInstallIOProcA", fccIOProc, pIOProc, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(fccIOProc, pIOProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioInstallIOProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioInstallIOProcW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPMMIOPROC mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor mmioInstallIOProcW$descriptor() {
        return mmioInstallIOProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPMMIOPROC mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle mmioInstallIOProcW$handle() {
        return mmioInstallIOProcW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPMMIOPROC mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment mmioInstallIOProcW$address() {
        return mmioInstallIOProcW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPMMIOPROC mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment mmioInstallIOProcW(int fccIOProc, MemorySegment pIOProc, int dwFlags) {
        var mh$ = mmioInstallIOProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioInstallIOProcW", fccIOProc, pIOProc, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(fccIOProc, pIOProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioOpenA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioOpenA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMMIO mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen)
     * }
     */
    public static FunctionDescriptor mmioOpenA$descriptor() {
        return mmioOpenA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMMIO mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen)
     * }
     */
    public static MethodHandle mmioOpenA$handle() {
        return mmioOpenA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMMIO mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen)
     * }
     */
    public static MemorySegment mmioOpenA$address() {
        return mmioOpenA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMMIO mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen)
     * }
     */
    public static MemorySegment mmioOpenA(MemorySegment pszFileName, MemorySegment pmmioinfo, int fdwOpen) {
        var mh$ = mmioOpenA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioOpenA", pszFileName, pmmioinfo, fdwOpen);
            }
            return (MemorySegment)mh$.invokeExact(pszFileName, pmmioinfo, fdwOpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioOpenW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioOpenW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMMIO mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen)
     * }
     */
    public static FunctionDescriptor mmioOpenW$descriptor() {
        return mmioOpenW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMMIO mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen)
     * }
     */
    public static MethodHandle mmioOpenW$handle() {
        return mmioOpenW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMMIO mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen)
     * }
     */
    public static MemorySegment mmioOpenW$address() {
        return mmioOpenW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMMIO mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen)
     * }
     */
    public static MemorySegment mmioOpenW(MemorySegment pszFileName, MemorySegment pmmioinfo, int fdwOpen) {
        var mh$ = mmioOpenW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioOpenW", pszFileName, pmmioinfo, fdwOpen);
            }
            return (MemorySegment)mh$.invokeExact(pszFileName, pmmioinfo, fdwOpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioRenameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioRenameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename)
     * }
     */
    public static FunctionDescriptor mmioRenameA$descriptor() {
        return mmioRenameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename)
     * }
     */
    public static MethodHandle mmioRenameA$handle() {
        return mmioRenameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename)
     * }
     */
    public static MemorySegment mmioRenameA$address() {
        return mmioRenameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename)
     * }
     */
    public static int mmioRenameA(MemorySegment pszFileName, MemorySegment pszNewFileName, MemorySegment pmmioinfo, int fdwRename) {
        var mh$ = mmioRenameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioRenameA", pszFileName, pszNewFileName, pmmioinfo, fdwRename);
            }
            return (int)mh$.invokeExact(pszFileName, pszNewFileName, pmmioinfo, fdwRename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioRenameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioRenameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename)
     * }
     */
    public static FunctionDescriptor mmioRenameW$descriptor() {
        return mmioRenameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename)
     * }
     */
    public static MethodHandle mmioRenameW$handle() {
        return mmioRenameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename)
     * }
     */
    public static MemorySegment mmioRenameW$address() {
        return mmioRenameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename)
     * }
     */
    public static int mmioRenameW(MemorySegment pszFileName, MemorySegment pszNewFileName, MemorySegment pmmioinfo, int fdwRename) {
        var mh$ = mmioRenameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioRenameW", pszFileName, pszNewFileName, pmmioinfo, fdwRename);
            }
            return (int)mh$.invokeExact(pszFileName, pszNewFileName, pmmioinfo, fdwRename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioClose(HMMIO hmmio, UINT fuClose)
     * }
     */
    public static FunctionDescriptor mmioClose$descriptor() {
        return mmioClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioClose(HMMIO hmmio, UINT fuClose)
     * }
     */
    public static MethodHandle mmioClose$handle() {
        return mmioClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioClose(HMMIO hmmio, UINT fuClose)
     * }
     */
    public static MemorySegment mmioClose$address() {
        return mmioClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioClose(HMMIO hmmio, UINT fuClose)
     * }
     */
    public static int mmioClose(MemorySegment hmmio, int fuClose) {
        var mh$ = mmioClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioClose", hmmio, fuClose);
            }
            return (int)mh$.invokeExact(hmmio, fuClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG mmioRead(HMMIO hmmio, HPSTR pch, LONG cch)
     * }
     */
    public static FunctionDescriptor mmioRead$descriptor() {
        return mmioRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG mmioRead(HMMIO hmmio, HPSTR pch, LONG cch)
     * }
     */
    public static MethodHandle mmioRead$handle() {
        return mmioRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG mmioRead(HMMIO hmmio, HPSTR pch, LONG cch)
     * }
     */
    public static MemorySegment mmioRead$address() {
        return mmioRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG mmioRead(HMMIO hmmio, HPSTR pch, LONG cch)
     * }
     */
    public static int mmioRead(MemorySegment hmmio, MemorySegment pch, int cch) {
        var mh$ = mmioRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioRead", hmmio, pch, cch);
            }
            return (int)mh$.invokeExact(hmmio, pch, cch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG mmioWrite(HMMIO hmmio, const char *pch, LONG cch)
     * }
     */
    public static FunctionDescriptor mmioWrite$descriptor() {
        return mmioWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG mmioWrite(HMMIO hmmio, const char *pch, LONG cch)
     * }
     */
    public static MethodHandle mmioWrite$handle() {
        return mmioWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG mmioWrite(HMMIO hmmio, const char *pch, LONG cch)
     * }
     */
    public static MemorySegment mmioWrite$address() {
        return mmioWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG mmioWrite(HMMIO hmmio, const char *pch, LONG cch)
     * }
     */
    public static int mmioWrite(MemorySegment hmmio, MemorySegment pch, int cch) {
        var mh$ = mmioWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioWrite", hmmio, pch, cch);
            }
            return (int)mh$.invokeExact(hmmio, pch, cch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioSeek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioSeek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin)
     * }
     */
    public static FunctionDescriptor mmioSeek$descriptor() {
        return mmioSeek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin)
     * }
     */
    public static MethodHandle mmioSeek$handle() {
        return mmioSeek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin)
     * }
     */
    public static MemorySegment mmioSeek$address() {
        return mmioSeek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin)
     * }
     */
    public static int mmioSeek(MemorySegment hmmio, int lOffset, int iOrigin) {
        var mh$ = mmioSeek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioSeek", hmmio, lOffset, iOrigin);
            }
            return (int)mh$.invokeExact(hmmio, lOffset, iOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioGetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioGetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo)
     * }
     */
    public static FunctionDescriptor mmioGetInfo$descriptor() {
        return mmioGetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo)
     * }
     */
    public static MethodHandle mmioGetInfo$handle() {
        return mmioGetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo)
     * }
     */
    public static MemorySegment mmioGetInfo$address() {
        return mmioGetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo)
     * }
     */
    public static int mmioGetInfo(MemorySegment hmmio, MemorySegment pmmioinfo, int fuInfo) {
        var mh$ = mmioGetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioGetInfo", hmmio, pmmioinfo, fuInfo);
            }
            return (int)mh$.invokeExact(hmmio, pmmioinfo, fuInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioSetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioSetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo)
     * }
     */
    public static FunctionDescriptor mmioSetInfo$descriptor() {
        return mmioSetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo)
     * }
     */
    public static MethodHandle mmioSetInfo$handle() {
        return mmioSetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo)
     * }
     */
    public static MemorySegment mmioSetInfo$address() {
        return mmioSetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo)
     * }
     */
    public static int mmioSetInfo(MemorySegment hmmio, MemorySegment pmmioinfo, int fuInfo) {
        var mh$ = mmioSetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioSetInfo", hmmio, pmmioinfo, fuInfo);
            }
            return (int)mh$.invokeExact(hmmio, pmmioinfo, fuInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioSetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioSetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT fuBuffer)
     * }
     */
    public static FunctionDescriptor mmioSetBuffer$descriptor() {
        return mmioSetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT fuBuffer)
     * }
     */
    public static MethodHandle mmioSetBuffer$handle() {
        return mmioSetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT fuBuffer)
     * }
     */
    public static MemorySegment mmioSetBuffer$address() {
        return mmioSetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT fuBuffer)
     * }
     */
    public static int mmioSetBuffer(MemorySegment hmmio, MemorySegment pchBuffer, int cchBuffer, int fuBuffer) {
        var mh$ = mmioSetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioSetBuffer", hmmio, pchBuffer, cchBuffer, fuBuffer);
            }
            return (int)mh$.invokeExact(hmmio, pchBuffer, cchBuffer, fuBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioFlush(HMMIO hmmio, UINT fuFlush)
     * }
     */
    public static FunctionDescriptor mmioFlush$descriptor() {
        return mmioFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioFlush(HMMIO hmmio, UINT fuFlush)
     * }
     */
    public static MethodHandle mmioFlush$handle() {
        return mmioFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioFlush(HMMIO hmmio, UINT fuFlush)
     * }
     */
    public static MemorySegment mmioFlush$address() {
        return mmioFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioFlush(HMMIO hmmio, UINT fuFlush)
     * }
     */
    public static int mmioFlush(MemorySegment hmmio, int fuFlush) {
        var mh$ = mmioFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioFlush", hmmio, fuFlush);
            }
            return (int)mh$.invokeExact(hmmio, fuFlush);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioAdvance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioAdvance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance)
     * }
     */
    public static FunctionDescriptor mmioAdvance$descriptor() {
        return mmioAdvance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance)
     * }
     */
    public static MethodHandle mmioAdvance$handle() {
        return mmioAdvance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance)
     * }
     */
    public static MemorySegment mmioAdvance$address() {
        return mmioAdvance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance)
     * }
     */
    public static int mmioAdvance(MemorySegment hmmio, MemorySegment pmmioinfo, int fuAdvance) {
        var mh$ = mmioAdvance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioAdvance", hmmio, pmmioinfo, fuAdvance);
            }
            return (int)mh$.invokeExact(hmmio, pmmioinfo, fuAdvance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioSendMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioSendMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT mmioSendMessage(HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static FunctionDescriptor mmioSendMessage$descriptor() {
        return mmioSendMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT mmioSendMessage(HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static MethodHandle mmioSendMessage$handle() {
        return mmioSendMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT mmioSendMessage(HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static MemorySegment mmioSendMessage$address() {
        return mmioSendMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT mmioSendMessage(HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
     * }
     */
    public static long mmioSendMessage(MemorySegment hmmio, int uMsg, long lParam1, long lParam2) {
        var mh$ = mmioSendMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioSendMessage", hmmio, uMsg, lParam1, lParam2);
            }
            return (long)mh$.invokeExact(hmmio, uMsg, lParam1, lParam2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioDescend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioDescend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki, const MMCKINFO *pmmckiParent, UINT fuDescend)
     * }
     */
    public static FunctionDescriptor mmioDescend$descriptor() {
        return mmioDescend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki, const MMCKINFO *pmmckiParent, UINT fuDescend)
     * }
     */
    public static MethodHandle mmioDescend$handle() {
        return mmioDescend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki, const MMCKINFO *pmmckiParent, UINT fuDescend)
     * }
     */
    public static MemorySegment mmioDescend$address() {
        return mmioDescend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki, const MMCKINFO *pmmckiParent, UINT fuDescend)
     * }
     */
    public static int mmioDescend(MemorySegment hmmio, MemorySegment pmmcki, MemorySegment pmmckiParent, int fuDescend) {
        var mh$ = mmioDescend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioDescend", hmmio, pmmcki, pmmckiParent, fuDescend);
            }
            return (int)mh$.invokeExact(hmmio, pmmcki, pmmckiParent, fuDescend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioAscend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioAscend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend)
     * }
     */
    public static FunctionDescriptor mmioAscend$descriptor() {
        return mmioAscend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend)
     * }
     */
    public static MethodHandle mmioAscend$handle() {
        return mmioAscend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend)
     * }
     */
    public static MemorySegment mmioAscend$address() {
        return mmioAscend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend)
     * }
     */
    public static int mmioAscend(MemorySegment hmmio, MemorySegment pmmcki, int fuAscend) {
        var mh$ = mmioAscend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioAscend", hmmio, pmmcki, fuAscend);
            }
            return (int)mh$.invokeExact(hmmio, pmmcki, fuAscend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mmioCreateChunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mmioCreateChunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate)
     * }
     */
    public static FunctionDescriptor mmioCreateChunk$descriptor() {
        return mmioCreateChunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate)
     * }
     */
    public static MethodHandle mmioCreateChunk$handle() {
        return mmioCreateChunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate)
     * }
     */
    public static MemorySegment mmioCreateChunk$address() {
        return mmioCreateChunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate)
     * }
     */
    public static int mmioCreateChunk(MemorySegment hmmio, MemorySegment pmmcki, int fuCreate) {
        var mh$ = mmioCreateChunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mmioCreateChunk", hmmio, pmmcki, fuCreate);
            }
            return (int)mh$.invokeExact(hmmio, pmmcki, fuCreate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timeSetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("timeSetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT timeSetEvent(UINT uDelay, UINT uResolution, LPTIMECALLBACK fptc, DWORD_PTR dwUser, UINT fuEvent)
     * }
     */
    public static FunctionDescriptor timeSetEvent$descriptor() {
        return timeSetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT timeSetEvent(UINT uDelay, UINT uResolution, LPTIMECALLBACK fptc, DWORD_PTR dwUser, UINT fuEvent)
     * }
     */
    public static MethodHandle timeSetEvent$handle() {
        return timeSetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT timeSetEvent(UINT uDelay, UINT uResolution, LPTIMECALLBACK fptc, DWORD_PTR dwUser, UINT fuEvent)
     * }
     */
    public static MemorySegment timeSetEvent$address() {
        return timeSetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT timeSetEvent(UINT uDelay, UINT uResolution, LPTIMECALLBACK fptc, DWORD_PTR dwUser, UINT fuEvent)
     * }
     */
    public static int timeSetEvent(int uDelay, int uResolution, MemorySegment fptc, long dwUser, int fuEvent) {
        var mh$ = timeSetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timeSetEvent", uDelay, uResolution, fptc, dwUser, fuEvent);
            }
            return (int)mh$.invokeExact(uDelay, uResolution, fptc, dwUser, fuEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timeKillEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("timeKillEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT timeKillEvent(UINT uTimerID)
     * }
     */
    public static FunctionDescriptor timeKillEvent$descriptor() {
        return timeKillEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT timeKillEvent(UINT uTimerID)
     * }
     */
    public static MethodHandle timeKillEvent$handle() {
        return timeKillEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT timeKillEvent(UINT uTimerID)
     * }
     */
    public static MemorySegment timeKillEvent$address() {
        return timeKillEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT timeKillEvent(UINT uTimerID)
     * }
     */
    public static int timeKillEvent(int uTimerID) {
        var mh$ = timeKillEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timeKillEvent", uTimerID);
            }
            return (int)mh$.invokeExact(uTimerID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sndPlaySoundA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("sndPlaySoundA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL sndPlaySoundA(LPCSTR pszSound, UINT fuSound)
     * }
     */
    public static FunctionDescriptor sndPlaySoundA$descriptor() {
        return sndPlaySoundA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL sndPlaySoundA(LPCSTR pszSound, UINT fuSound)
     * }
     */
    public static MethodHandle sndPlaySoundA$handle() {
        return sndPlaySoundA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL sndPlaySoundA(LPCSTR pszSound, UINT fuSound)
     * }
     */
    public static MemorySegment sndPlaySoundA$address() {
        return sndPlaySoundA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL sndPlaySoundA(LPCSTR pszSound, UINT fuSound)
     * }
     */
    public static int sndPlaySoundA(MemorySegment pszSound, int fuSound) {
        var mh$ = sndPlaySoundA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sndPlaySoundA", pszSound, fuSound);
            }
            return (int)mh$.invokeExact(pszSound, fuSound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sndPlaySoundW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("sndPlaySoundW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL sndPlaySoundW(LPCWSTR pszSound, UINT fuSound)
     * }
     */
    public static FunctionDescriptor sndPlaySoundW$descriptor() {
        return sndPlaySoundW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL sndPlaySoundW(LPCWSTR pszSound, UINT fuSound)
     * }
     */
    public static MethodHandle sndPlaySoundW$handle() {
        return sndPlaySoundW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL sndPlaySoundW(LPCWSTR pszSound, UINT fuSound)
     * }
     */
    public static MemorySegment sndPlaySoundW$address() {
        return sndPlaySoundW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL sndPlaySoundW(LPCWSTR pszSound, UINT fuSound)
     * }
     */
    public static int sndPlaySoundW(MemorySegment pszSound, int fuSound) {
        var mh$ = sndPlaySoundW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sndPlaySoundW", pszSound, fuSound);
            }
            return (int)mh$.invokeExact(pszSound, fuSound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlaySoundA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PlaySoundA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound)
     * }
     */
    public static FunctionDescriptor PlaySoundA$descriptor() {
        return PlaySoundA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound)
     * }
     */
    public static MethodHandle PlaySoundA$handle() {
        return PlaySoundA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound)
     * }
     */
    public static MemorySegment PlaySoundA$address() {
        return PlaySoundA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound)
     * }
     */
    public static int PlaySoundA(MemorySegment pszSound, MemorySegment hmod, int fdwSound) {
        var mh$ = PlaySoundA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlaySoundA", pszSound, hmod, fdwSound);
            }
            return (int)mh$.invokeExact(pszSound, hmod, fdwSound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlaySoundW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PlaySoundW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound)
     * }
     */
    public static FunctionDescriptor PlaySoundW$descriptor() {
        return PlaySoundW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound)
     * }
     */
    public static MethodHandle PlaySoundW$handle() {
        return PlaySoundW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound)
     * }
     */
    public static MemorySegment PlaySoundW$address() {
        return PlaySoundW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound)
     * }
     */
    public static int PlaySoundW(MemorySegment pszSound, MemorySegment hmod, int fdwSound) {
        var mh$ = PlaySoundW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlaySoundW", pszSound, hmod, fdwSound);
            }
            return (int)mh$.invokeExact(pszSound, hmod, fdwSound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HWAVE__ {
     *     int unused;
     * } *HWAVE
     * }
     */
    public static final AddressLayout HWAVE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWAVEIN__ {
     *     int unused;
     * } *HWAVEIN
     * }
     */
    public static final AddressLayout HWAVEIN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWAVEOUT__ {
     *     int unused;
     * } *HWAVEOUT
     * }
     */
    public static final AddressLayout HWAVEOUT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HWAVEIN *LPHWAVEIN
     * }
     */
    public static final AddressLayout LPHWAVEIN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HWAVEOUT *LPHWAVEOUT
     * }
     */
    public static final AddressLayout LPHWAVEOUT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct wavehdr_tag {
     *     LPSTR lpData;
     *     DWORD dwBufferLength;
     *     DWORD dwBytesRecorded;
     *     DWORD_PTR dwUser;
     *     DWORD dwFlags;
     *     DWORD dwLoops;
     *     struct wavehdr_tag *lpNext;
     *     DWORD_PTR reserved;
     * } *PWAVEHDR
     * }
     */
    public static final AddressLayout PWAVEHDR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct wavehdr_tag {
     *     LPSTR lpData;
     *     DWORD dwBufferLength;
     *     DWORD dwBytesRecorded;
     *     DWORD_PTR dwUser;
     *     DWORD dwFlags;
     *     DWORD dwLoops;
     *     struct wavehdr_tag *lpNext;
     *     DWORD_PTR reserved;
     * } *NPWAVEHDR
     * }
     */
    public static final AddressLayout NPWAVEHDR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct wavehdr_tag {
     *     LPSTR lpData;
     *     DWORD dwBufferLength;
     *     DWORD dwBytesRecorded;
     *     DWORD_PTR dwUser;
     *     DWORD dwFlags;
     *     DWORD dwLoops;
     *     struct wavehdr_tag *lpNext;
     *     DWORD_PTR reserved;
     * } *LPWAVEHDR
     * }
     */
    public static final AddressLayout LPWAVEHDR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *PWAVEOUTCAPSA
     * }
     */
    public static final AddressLayout PWAVEOUTCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *NPWAVEOUTCAPSA
     * }
     */
    public static final AddressLayout NPWAVEOUTCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *LPWAVEOUTCAPSA
     * }
     */
    public static final AddressLayout LPWAVEOUTCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *PWAVEOUTCAPSW
     * }
     */
    public static final AddressLayout PWAVEOUTCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *NPWAVEOUTCAPSW
     * }
     */
    public static final AddressLayout NPWAVEOUTCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *LPWAVEOUTCAPSW
     * }
     */
    public static final AddressLayout LPWAVEOUTCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWAVEOUTCAPSA PWAVEOUTCAPS
     * }
     */
    public static final AddressLayout PWAVEOUTCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWAVEOUTCAPSA NPWAVEOUTCAPS
     * }
     */
    public static final AddressLayout NPWAVEOUTCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWAVEOUTCAPSA LPWAVEOUTCAPS
     * }
     */
    public static final AddressLayout LPWAVEOUTCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PWAVEOUTCAPS2A
     * }
     */
    public static final AddressLayout PWAVEOUTCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPWAVEOUTCAPS2A
     * }
     */
    public static final AddressLayout NPWAVEOUTCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPWAVEOUTCAPS2A
     * }
     */
    public static final AddressLayout LPWAVEOUTCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PWAVEOUTCAPS2W
     * }
     */
    public static final AddressLayout PWAVEOUTCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPWAVEOUTCAPS2W
     * }
     */
    public static final AddressLayout NPWAVEOUTCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEOUTCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPWAVEOUTCAPS2W
     * }
     */
    public static final AddressLayout LPWAVEOUTCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWAVEOUTCAPS2A PWAVEOUTCAPS2
     * }
     */
    public static final AddressLayout PWAVEOUTCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWAVEOUTCAPS2A NPWAVEOUTCAPS2
     * }
     */
    public static final AddressLayout NPWAVEOUTCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWAVEOUTCAPS2A LPWAVEOUTCAPS2
     * }
     */
    public static final AddressLayout LPWAVEOUTCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     * } *PWAVEINCAPSA
     * }
     */
    public static final AddressLayout PWAVEINCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     * } *NPWAVEINCAPSA
     * }
     */
    public static final AddressLayout NPWAVEINCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     * } *LPWAVEINCAPSA
     * }
     */
    public static final AddressLayout LPWAVEINCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     * } *PWAVEINCAPSW
     * }
     */
    public static final AddressLayout PWAVEINCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     * } *NPWAVEINCAPSW
     * }
     */
    public static final AddressLayout NPWAVEINCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     * } *LPWAVEINCAPSW
     * }
     */
    public static final AddressLayout LPWAVEINCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWAVEINCAPSA PWAVEINCAPS
     * }
     */
    public static final AddressLayout PWAVEINCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWAVEINCAPSA NPWAVEINCAPS
     * }
     */
    public static final AddressLayout NPWAVEINCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWAVEINCAPSA LPWAVEINCAPS
     * }
     */
    public static final AddressLayout LPWAVEINCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PWAVEINCAPS2A
     * }
     */
    public static final AddressLayout PWAVEINCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPWAVEINCAPS2A
     * }
     */
    public static final AddressLayout NPWAVEINCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPWAVEINCAPS2A
     * }
     */
    public static final AddressLayout LPWAVEINCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PWAVEINCAPS2W
     * }
     */
    public static final AddressLayout PWAVEINCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPWAVEINCAPS2W
     * }
     */
    public static final AddressLayout NPWAVEINCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWAVEINCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwFormats;
     *     WORD wChannels;
     *     WORD wReserved1;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPWAVEINCAPS2W
     * }
     */
    public static final AddressLayout LPWAVEINCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWAVEINCAPS2A PWAVEINCAPS2
     * }
     */
    public static final AddressLayout PWAVEINCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWAVEINCAPS2A NPWAVEINCAPS2
     * }
     */
    public static final AddressLayout NPWAVEINCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWAVEINCAPS2A LPWAVEINCAPS2
     * }
     */
    public static final AddressLayout LPWAVEINCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct waveformat_tag {
     *     WORD wFormatTag;
     *     WORD nChannels;
     *     DWORD nSamplesPerSec;
     *     DWORD nAvgBytesPerSec;
     *     WORD nBlockAlign;
     * } *PWAVEFORMAT
     * }
     */
    public static final AddressLayout PWAVEFORMAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct waveformat_tag {
     *     WORD wFormatTag;
     *     WORD nChannels;
     *     DWORD nSamplesPerSec;
     *     DWORD nAvgBytesPerSec;
     *     WORD nBlockAlign;
     * } *NPWAVEFORMAT
     * }
     */
    public static final AddressLayout NPWAVEFORMAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct waveformat_tag {
     *     WORD wFormatTag;
     *     WORD nChannels;
     *     DWORD nSamplesPerSec;
     *     DWORD nAvgBytesPerSec;
     *     WORD nBlockAlign;
     * } *LPWAVEFORMAT
     * }
     */
    public static final AddressLayout LPWAVEFORMAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct pcmwaveformat_tag {
     *     WAVEFORMAT wf;
     *     WORD wBitsPerSample;
     * } *PPCMWAVEFORMAT
     * }
     */
    public static final AddressLayout PPCMWAVEFORMAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct pcmwaveformat_tag {
     *     WAVEFORMAT wf;
     *     WORD wBitsPerSample;
     * } *NPPCMWAVEFORMAT
     * }
     */
    public static final AddressLayout NPPCMWAVEFORMAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct pcmwaveformat_tag {
     *     WAVEFORMAT wf;
     *     WORD wBitsPerSample;
     * } *LPPCMWAVEFORMAT
     * }
     */
    public static final AddressLayout LPPCMWAVEFORMAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tWAVEFORMATEX {
     *     WORD wFormatTag;
     *     WORD nChannels;
     *     DWORD nSamplesPerSec;
     *     DWORD nAvgBytesPerSec;
     *     WORD nBlockAlign;
     *     WORD wBitsPerSample;
     *     WORD cbSize;
     * } *PWAVEFORMATEX
     * }
     */
    public static final AddressLayout PWAVEFORMATEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tWAVEFORMATEX {
     *     WORD wFormatTag;
     *     WORD nChannels;
     *     DWORD nSamplesPerSec;
     *     DWORD nAvgBytesPerSec;
     *     WORD nBlockAlign;
     *     WORD wBitsPerSample;
     *     WORD cbSize;
     * } *NPWAVEFORMATEX
     * }
     */
    public static final AddressLayout NPWAVEFORMATEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tWAVEFORMATEX {
     *     WORD wFormatTag;
     *     WORD nChannels;
     *     DWORD nSamplesPerSec;
     *     DWORD nAvgBytesPerSec;
     *     WORD nBlockAlign;
     *     WORD wBitsPerSample;
     *     WORD cbSize;
     * } *LPWAVEFORMATEX
     * }
     */
    public static final AddressLayout LPWAVEFORMATEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const WAVEFORMATEX *LPCWAVEFORMATEX
     * }
     */
    public static final AddressLayout LPCWAVEFORMATEX = winapi.C_POINTER;

    private static class waveOutGetNumDevs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetNumDevs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT waveOutGetNumDevs()
     * }
     */
    public static FunctionDescriptor waveOutGetNumDevs$descriptor() {
        return waveOutGetNumDevs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT waveOutGetNumDevs()
     * }
     */
    public static MethodHandle waveOutGetNumDevs$handle() {
        return waveOutGetNumDevs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT waveOutGetNumDevs()
     * }
     */
    public static MemorySegment waveOutGetNumDevs$address() {
        return waveOutGetNumDevs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT waveOutGetNumDevs()
     * }
     */
    public static int waveOutGetNumDevs() {
        var mh$ = waveOutGetNumDevs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetNumDevs");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutGetDevCapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetDevCapsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetDevCapsA(UINT_PTR uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc)
     * }
     */
    public static FunctionDescriptor waveOutGetDevCapsA$descriptor() {
        return waveOutGetDevCapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetDevCapsA(UINT_PTR uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc)
     * }
     */
    public static MethodHandle waveOutGetDevCapsA$handle() {
        return waveOutGetDevCapsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetDevCapsA(UINT_PTR uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc)
     * }
     */
    public static MemorySegment waveOutGetDevCapsA$address() {
        return waveOutGetDevCapsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutGetDevCapsA(UINT_PTR uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc)
     * }
     */
    public static int waveOutGetDevCapsA(long uDeviceID, MemorySegment pwoc, int cbwoc) {
        var mh$ = waveOutGetDevCapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetDevCapsA", uDeviceID, pwoc, cbwoc);
            }
            return (int)mh$.invokeExact(uDeviceID, pwoc, cbwoc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutGetDevCapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetDevCapsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetDevCapsW(UINT_PTR uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc)
     * }
     */
    public static FunctionDescriptor waveOutGetDevCapsW$descriptor() {
        return waveOutGetDevCapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetDevCapsW(UINT_PTR uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc)
     * }
     */
    public static MethodHandle waveOutGetDevCapsW$handle() {
        return waveOutGetDevCapsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetDevCapsW(UINT_PTR uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc)
     * }
     */
    public static MemorySegment waveOutGetDevCapsW$address() {
        return waveOutGetDevCapsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutGetDevCapsW(UINT_PTR uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc)
     * }
     */
    public static int waveOutGetDevCapsW(long uDeviceID, MemorySegment pwoc, int cbwoc) {
        var mh$ = waveOutGetDevCapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetDevCapsW", uDeviceID, pwoc, cbwoc);
            }
            return (int)mh$.invokeExact(uDeviceID, pwoc, cbwoc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutGetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume)
     * }
     */
    public static FunctionDescriptor waveOutGetVolume$descriptor() {
        return waveOutGetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume)
     * }
     */
    public static MethodHandle waveOutGetVolume$handle() {
        return waveOutGetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume)
     * }
     */
    public static MemorySegment waveOutGetVolume$address() {
        return waveOutGetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume)
     * }
     */
    public static int waveOutGetVolume(MemorySegment hwo, MemorySegment pdwVolume) {
        var mh$ = waveOutGetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetVolume", hwo, pdwVolume);
            }
            return (int)mh$.invokeExact(hwo, pdwVolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutSetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutSetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume)
     * }
     */
    public static FunctionDescriptor waveOutSetVolume$descriptor() {
        return waveOutSetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume)
     * }
     */
    public static MethodHandle waveOutSetVolume$handle() {
        return waveOutSetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume)
     * }
     */
    public static MemorySegment waveOutSetVolume$address() {
        return waveOutSetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume)
     * }
     */
    public static int waveOutSetVolume(MemorySegment hwo, int dwVolume) {
        var mh$ = waveOutSetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutSetVolume", hwo, dwVolume);
            }
            return (int)mh$.invokeExact(hwo, dwVolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutGetErrorTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetErrorTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor waveOutGetErrorTextA$descriptor() {
        return waveOutGetErrorTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle waveOutGetErrorTextA$handle() {
        return waveOutGetErrorTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment waveOutGetErrorTextA$address() {
        return waveOutGetErrorTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static int waveOutGetErrorTextA(int mmrError, MemorySegment pszText, int cchText) {
        var mh$ = waveOutGetErrorTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetErrorTextA", mmrError, pszText, cchText);
            }
            return (int)mh$.invokeExact(mmrError, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutGetErrorTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetErrorTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor waveOutGetErrorTextW$descriptor() {
        return waveOutGetErrorTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle waveOutGetErrorTextW$handle() {
        return waveOutGetErrorTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment waveOutGetErrorTextW$address() {
        return waveOutGetErrorTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static int waveOutGetErrorTextW(int mmrError, MemorySegment pszText, int cchText) {
        var mh$ = waveOutGetErrorTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetErrorTextW", mmrError, pszText, cchText);
            }
            return (int)mh$.invokeExact(mmrError, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutOpen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutOpen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static FunctionDescriptor waveOutOpen$descriptor() {
        return waveOutOpen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MethodHandle waveOutOpen$handle() {
        return waveOutOpen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MemorySegment waveOutOpen$address() {
        return waveOutOpen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static int waveOutOpen(MemorySegment phwo, int uDeviceID, MemorySegment pwfx, long dwCallback, long dwInstance, int fdwOpen) {
        var mh$ = waveOutOpen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutOpen", phwo, uDeviceID, pwfx, dwCallback, dwInstance, fdwOpen);
            }
            return (int)mh$.invokeExact(phwo, uDeviceID, pwfx, dwCallback, dwInstance, fdwOpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutClose(HWAVEOUT hwo)
     * }
     */
    public static FunctionDescriptor waveOutClose$descriptor() {
        return waveOutClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutClose(HWAVEOUT hwo)
     * }
     */
    public static MethodHandle waveOutClose$handle() {
        return waveOutClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutClose(HWAVEOUT hwo)
     * }
     */
    public static MemorySegment waveOutClose$address() {
        return waveOutClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutClose(HWAVEOUT hwo)
     * }
     */
    public static int waveOutClose(MemorySegment hwo) {
        var mh$ = waveOutClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutClose", hwo);
            }
            return (int)mh$.invokeExact(hwo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutPrepareHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutPrepareHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static FunctionDescriptor waveOutPrepareHeader$descriptor() {
        return waveOutPrepareHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MethodHandle waveOutPrepareHeader$handle() {
        return waveOutPrepareHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MemorySegment waveOutPrepareHeader$address() {
        return waveOutPrepareHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static int waveOutPrepareHeader(MemorySegment hwo, MemorySegment pwh, int cbwh) {
        var mh$ = waveOutPrepareHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutPrepareHeader", hwo, pwh, cbwh);
            }
            return (int)mh$.invokeExact(hwo, pwh, cbwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutUnprepareHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutUnprepareHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static FunctionDescriptor waveOutUnprepareHeader$descriptor() {
        return waveOutUnprepareHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MethodHandle waveOutUnprepareHeader$handle() {
        return waveOutUnprepareHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MemorySegment waveOutUnprepareHeader$address() {
        return waveOutUnprepareHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static int waveOutUnprepareHeader(MemorySegment hwo, MemorySegment pwh, int cbwh) {
        var mh$ = waveOutUnprepareHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutUnprepareHeader", hwo, pwh, cbwh);
            }
            return (int)mh$.invokeExact(hwo, pwh, cbwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static FunctionDescriptor waveOutWrite$descriptor() {
        return waveOutWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MethodHandle waveOutWrite$handle() {
        return waveOutWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MemorySegment waveOutWrite$address() {
        return waveOutWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static int waveOutWrite(MemorySegment hwo, MemorySegment pwh, int cbwh) {
        var mh$ = waveOutWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutWrite", hwo, pwh, cbwh);
            }
            return (int)mh$.invokeExact(hwo, pwh, cbwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutPause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutPause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutPause(HWAVEOUT hwo)
     * }
     */
    public static FunctionDescriptor waveOutPause$descriptor() {
        return waveOutPause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutPause(HWAVEOUT hwo)
     * }
     */
    public static MethodHandle waveOutPause$handle() {
        return waveOutPause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutPause(HWAVEOUT hwo)
     * }
     */
    public static MemorySegment waveOutPause$address() {
        return waveOutPause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutPause(HWAVEOUT hwo)
     * }
     */
    public static int waveOutPause(MemorySegment hwo) {
        var mh$ = waveOutPause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutPause", hwo);
            }
            return (int)mh$.invokeExact(hwo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutRestart(HWAVEOUT hwo)
     * }
     */
    public static FunctionDescriptor waveOutRestart$descriptor() {
        return waveOutRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutRestart(HWAVEOUT hwo)
     * }
     */
    public static MethodHandle waveOutRestart$handle() {
        return waveOutRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutRestart(HWAVEOUT hwo)
     * }
     */
    public static MemorySegment waveOutRestart$address() {
        return waveOutRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutRestart(HWAVEOUT hwo)
     * }
     */
    public static int waveOutRestart(MemorySegment hwo) {
        var mh$ = waveOutRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutRestart", hwo);
            }
            return (int)mh$.invokeExact(hwo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutReset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutReset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutReset(HWAVEOUT hwo)
     * }
     */
    public static FunctionDescriptor waveOutReset$descriptor() {
        return waveOutReset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutReset(HWAVEOUT hwo)
     * }
     */
    public static MethodHandle waveOutReset$handle() {
        return waveOutReset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutReset(HWAVEOUT hwo)
     * }
     */
    public static MemorySegment waveOutReset$address() {
        return waveOutReset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutReset(HWAVEOUT hwo)
     * }
     */
    public static int waveOutReset(MemorySegment hwo) {
        var mh$ = waveOutReset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutReset", hwo);
            }
            return (int)mh$.invokeExact(hwo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutBreakLoop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutBreakLoop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutBreakLoop(HWAVEOUT hwo)
     * }
     */
    public static FunctionDescriptor waveOutBreakLoop$descriptor() {
        return waveOutBreakLoop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutBreakLoop(HWAVEOUT hwo)
     * }
     */
    public static MethodHandle waveOutBreakLoop$handle() {
        return waveOutBreakLoop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutBreakLoop(HWAVEOUT hwo)
     * }
     */
    public static MemorySegment waveOutBreakLoop$address() {
        return waveOutBreakLoop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutBreakLoop(HWAVEOUT hwo)
     * }
     */
    public static int waveOutBreakLoop(MemorySegment hwo) {
        var mh$ = waveOutBreakLoop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutBreakLoop", hwo);
            }
            return (int)mh$.invokeExact(hwo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutGetPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static FunctionDescriptor waveOutGetPosition$descriptor() {
        return waveOutGetPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static MethodHandle waveOutGetPosition$handle() {
        return waveOutGetPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static MemorySegment waveOutGetPosition$address() {
        return waveOutGetPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static int waveOutGetPosition(MemorySegment hwo, MemorySegment pmmt, int cbmmt) {
        var mh$ = waveOutGetPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetPosition", hwo, pmmt, cbmmt);
            }
            return (int)mh$.invokeExact(hwo, pmmt, cbmmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutGetPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch)
     * }
     */
    public static FunctionDescriptor waveOutGetPitch$descriptor() {
        return waveOutGetPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch)
     * }
     */
    public static MethodHandle waveOutGetPitch$handle() {
        return waveOutGetPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch)
     * }
     */
    public static MemorySegment waveOutGetPitch$address() {
        return waveOutGetPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch)
     * }
     */
    public static int waveOutGetPitch(MemorySegment hwo, MemorySegment pdwPitch) {
        var mh$ = waveOutGetPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetPitch", hwo, pdwPitch);
            }
            return (int)mh$.invokeExact(hwo, pdwPitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutSetPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutSetPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch)
     * }
     */
    public static FunctionDescriptor waveOutSetPitch$descriptor() {
        return waveOutSetPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch)
     * }
     */
    public static MethodHandle waveOutSetPitch$handle() {
        return waveOutSetPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch)
     * }
     */
    public static MemorySegment waveOutSetPitch$address() {
        return waveOutSetPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch)
     * }
     */
    public static int waveOutSetPitch(MemorySegment hwo, int dwPitch) {
        var mh$ = waveOutSetPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutSetPitch", hwo, dwPitch);
            }
            return (int)mh$.invokeExact(hwo, dwPitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutGetPlaybackRate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetPlaybackRate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate)
     * }
     */
    public static FunctionDescriptor waveOutGetPlaybackRate$descriptor() {
        return waveOutGetPlaybackRate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate)
     * }
     */
    public static MethodHandle waveOutGetPlaybackRate$handle() {
        return waveOutGetPlaybackRate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate)
     * }
     */
    public static MemorySegment waveOutGetPlaybackRate$address() {
        return waveOutGetPlaybackRate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate)
     * }
     */
    public static int waveOutGetPlaybackRate(MemorySegment hwo, MemorySegment pdwRate) {
        var mh$ = waveOutGetPlaybackRate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetPlaybackRate", hwo, pdwRate);
            }
            return (int)mh$.invokeExact(hwo, pdwRate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutSetPlaybackRate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutSetPlaybackRate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate)
     * }
     */
    public static FunctionDescriptor waveOutSetPlaybackRate$descriptor() {
        return waveOutSetPlaybackRate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate)
     * }
     */
    public static MethodHandle waveOutSetPlaybackRate$handle() {
        return waveOutSetPlaybackRate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate)
     * }
     */
    public static MemorySegment waveOutSetPlaybackRate$address() {
        return waveOutSetPlaybackRate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate)
     * }
     */
    public static int waveOutSetPlaybackRate(MemorySegment hwo, int dwRate) {
        var mh$ = waveOutSetPlaybackRate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutSetPlaybackRate", hwo, dwRate);
            }
            return (int)mh$.invokeExact(hwo, dwRate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutGetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutGetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID)
     * }
     */
    public static FunctionDescriptor waveOutGetID$descriptor() {
        return waveOutGetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID)
     * }
     */
    public static MethodHandle waveOutGetID$handle() {
        return waveOutGetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID)
     * }
     */
    public static MemorySegment waveOutGetID$address() {
        return waveOutGetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID)
     * }
     */
    public static int waveOutGetID(MemorySegment hwo, MemorySegment puDeviceID) {
        var mh$ = waveOutGetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutGetID", hwo, puDeviceID);
            }
            return (int)mh$.invokeExact(hwo, puDeviceID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveOutMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveOutMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static FunctionDescriptor waveOutMessage$descriptor() {
        return waveOutMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MethodHandle waveOutMessage$handle() {
        return waveOutMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MemorySegment waveOutMessage$address() {
        return waveOutMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static int waveOutMessage(MemorySegment hwo, int uMsg, long dw1, long dw2) {
        var mh$ = waveOutMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveOutMessage", hwo, uMsg, dw1, dw2);
            }
            return (int)mh$.invokeExact(hwo, uMsg, dw1, dw2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInGetNumDevs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInGetNumDevs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT waveInGetNumDevs()
     * }
     */
    public static FunctionDescriptor waveInGetNumDevs$descriptor() {
        return waveInGetNumDevs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT waveInGetNumDevs()
     * }
     */
    public static MethodHandle waveInGetNumDevs$handle() {
        return waveInGetNumDevs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT waveInGetNumDevs()
     * }
     */
    public static MemorySegment waveInGetNumDevs$address() {
        return waveInGetNumDevs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT waveInGetNumDevs()
     * }
     */
    public static int waveInGetNumDevs() {
        var mh$ = waveInGetNumDevs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInGetNumDevs");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInGetDevCapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInGetDevCapsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInGetDevCapsA(UINT_PTR uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic)
     * }
     */
    public static FunctionDescriptor waveInGetDevCapsA$descriptor() {
        return waveInGetDevCapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInGetDevCapsA(UINT_PTR uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic)
     * }
     */
    public static MethodHandle waveInGetDevCapsA$handle() {
        return waveInGetDevCapsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInGetDevCapsA(UINT_PTR uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic)
     * }
     */
    public static MemorySegment waveInGetDevCapsA$address() {
        return waveInGetDevCapsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInGetDevCapsA(UINT_PTR uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic)
     * }
     */
    public static int waveInGetDevCapsA(long uDeviceID, MemorySegment pwic, int cbwic) {
        var mh$ = waveInGetDevCapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInGetDevCapsA", uDeviceID, pwic, cbwic);
            }
            return (int)mh$.invokeExact(uDeviceID, pwic, cbwic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInGetDevCapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInGetDevCapsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInGetDevCapsW(UINT_PTR uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic)
     * }
     */
    public static FunctionDescriptor waveInGetDevCapsW$descriptor() {
        return waveInGetDevCapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInGetDevCapsW(UINT_PTR uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic)
     * }
     */
    public static MethodHandle waveInGetDevCapsW$handle() {
        return waveInGetDevCapsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInGetDevCapsW(UINT_PTR uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic)
     * }
     */
    public static MemorySegment waveInGetDevCapsW$address() {
        return waveInGetDevCapsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInGetDevCapsW(UINT_PTR uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic)
     * }
     */
    public static int waveInGetDevCapsW(long uDeviceID, MemorySegment pwic, int cbwic) {
        var mh$ = waveInGetDevCapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInGetDevCapsW", uDeviceID, pwic, cbwic);
            }
            return (int)mh$.invokeExact(uDeviceID, pwic, cbwic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInGetErrorTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInGetErrorTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor waveInGetErrorTextA$descriptor() {
        return waveInGetErrorTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle waveInGetErrorTextA$handle() {
        return waveInGetErrorTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment waveInGetErrorTextA$address() {
        return waveInGetErrorTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static int waveInGetErrorTextA(int mmrError, MemorySegment pszText, int cchText) {
        var mh$ = waveInGetErrorTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInGetErrorTextA", mmrError, pszText, cchText);
            }
            return (int)mh$.invokeExact(mmrError, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInGetErrorTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInGetErrorTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor waveInGetErrorTextW$descriptor() {
        return waveInGetErrorTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle waveInGetErrorTextW$handle() {
        return waveInGetErrorTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment waveInGetErrorTextW$address() {
        return waveInGetErrorTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static int waveInGetErrorTextW(int mmrError, MemorySegment pszText, int cchText) {
        var mh$ = waveInGetErrorTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInGetErrorTextW", mmrError, pszText, cchText);
            }
            return (int)mh$.invokeExact(mmrError, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInOpen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInOpen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInOpen(LPHWAVEIN phwi, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static FunctionDescriptor waveInOpen$descriptor() {
        return waveInOpen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInOpen(LPHWAVEIN phwi, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MethodHandle waveInOpen$handle() {
        return waveInOpen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInOpen(LPHWAVEIN phwi, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MemorySegment waveInOpen$address() {
        return waveInOpen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInOpen(LPHWAVEIN phwi, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static int waveInOpen(MemorySegment phwi, int uDeviceID, MemorySegment pwfx, long dwCallback, long dwInstance, int fdwOpen) {
        var mh$ = waveInOpen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInOpen", phwi, uDeviceID, pwfx, dwCallback, dwInstance, fdwOpen);
            }
            return (int)mh$.invokeExact(phwi, uDeviceID, pwfx, dwCallback, dwInstance, fdwOpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInClose(HWAVEIN hwi)
     * }
     */
    public static FunctionDescriptor waveInClose$descriptor() {
        return waveInClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInClose(HWAVEIN hwi)
     * }
     */
    public static MethodHandle waveInClose$handle() {
        return waveInClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInClose(HWAVEIN hwi)
     * }
     */
    public static MemorySegment waveInClose$address() {
        return waveInClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInClose(HWAVEIN hwi)
     * }
     */
    public static int waveInClose(MemorySegment hwi) {
        var mh$ = waveInClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInClose", hwi);
            }
            return (int)mh$.invokeExact(hwi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInPrepareHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInPrepareHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static FunctionDescriptor waveInPrepareHeader$descriptor() {
        return waveInPrepareHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MethodHandle waveInPrepareHeader$handle() {
        return waveInPrepareHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MemorySegment waveInPrepareHeader$address() {
        return waveInPrepareHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static int waveInPrepareHeader(MemorySegment hwi, MemorySegment pwh, int cbwh) {
        var mh$ = waveInPrepareHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInPrepareHeader", hwi, pwh, cbwh);
            }
            return (int)mh$.invokeExact(hwi, pwh, cbwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInUnprepareHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInUnprepareHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static FunctionDescriptor waveInUnprepareHeader$descriptor() {
        return waveInUnprepareHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MethodHandle waveInUnprepareHeader$handle() {
        return waveInUnprepareHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MemorySegment waveInUnprepareHeader$address() {
        return waveInUnprepareHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static int waveInUnprepareHeader(MemorySegment hwi, MemorySegment pwh, int cbwh) {
        var mh$ = waveInUnprepareHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInUnprepareHeader", hwi, pwh, cbwh);
            }
            return (int)mh$.invokeExact(hwi, pwh, cbwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInAddBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInAddBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static FunctionDescriptor waveInAddBuffer$descriptor() {
        return waveInAddBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MethodHandle waveInAddBuffer$handle() {
        return waveInAddBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static MemorySegment waveInAddBuffer$address() {
        return waveInAddBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh)
     * }
     */
    public static int waveInAddBuffer(MemorySegment hwi, MemorySegment pwh, int cbwh) {
        var mh$ = waveInAddBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInAddBuffer", hwi, pwh, cbwh);
            }
            return (int)mh$.invokeExact(hwi, pwh, cbwh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInStart(HWAVEIN hwi)
     * }
     */
    public static FunctionDescriptor waveInStart$descriptor() {
        return waveInStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInStart(HWAVEIN hwi)
     * }
     */
    public static MethodHandle waveInStart$handle() {
        return waveInStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInStart(HWAVEIN hwi)
     * }
     */
    public static MemorySegment waveInStart$address() {
        return waveInStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInStart(HWAVEIN hwi)
     * }
     */
    public static int waveInStart(MemorySegment hwi) {
        var mh$ = waveInStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInStart", hwi);
            }
            return (int)mh$.invokeExact(hwi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInStop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInStop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInStop(HWAVEIN hwi)
     * }
     */
    public static FunctionDescriptor waveInStop$descriptor() {
        return waveInStop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInStop(HWAVEIN hwi)
     * }
     */
    public static MethodHandle waveInStop$handle() {
        return waveInStop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInStop(HWAVEIN hwi)
     * }
     */
    public static MemorySegment waveInStop$address() {
        return waveInStop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInStop(HWAVEIN hwi)
     * }
     */
    public static int waveInStop(MemorySegment hwi) {
        var mh$ = waveInStop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInStop", hwi);
            }
            return (int)mh$.invokeExact(hwi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInReset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInReset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInReset(HWAVEIN hwi)
     * }
     */
    public static FunctionDescriptor waveInReset$descriptor() {
        return waveInReset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInReset(HWAVEIN hwi)
     * }
     */
    public static MethodHandle waveInReset$handle() {
        return waveInReset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInReset(HWAVEIN hwi)
     * }
     */
    public static MemorySegment waveInReset$address() {
        return waveInReset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInReset(HWAVEIN hwi)
     * }
     */
    public static int waveInReset(MemorySegment hwi) {
        var mh$ = waveInReset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInReset", hwi);
            }
            return (int)mh$.invokeExact(hwi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInGetPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInGetPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static FunctionDescriptor waveInGetPosition$descriptor() {
        return waveInGetPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static MethodHandle waveInGetPosition$handle() {
        return waveInGetPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static MemorySegment waveInGetPosition$address() {
        return waveInGetPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static int waveInGetPosition(MemorySegment hwi, MemorySegment pmmt, int cbmmt) {
        var mh$ = waveInGetPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInGetPosition", hwi, pmmt, cbmmt);
            }
            return (int)mh$.invokeExact(hwi, pmmt, cbmmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInGetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInGetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInGetID(HWAVEIN hwi, LPUINT puDeviceID)
     * }
     */
    public static FunctionDescriptor waveInGetID$descriptor() {
        return waveInGetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInGetID(HWAVEIN hwi, LPUINT puDeviceID)
     * }
     */
    public static MethodHandle waveInGetID$handle() {
        return waveInGetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInGetID(HWAVEIN hwi, LPUINT puDeviceID)
     * }
     */
    public static MemorySegment waveInGetID$address() {
        return waveInGetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInGetID(HWAVEIN hwi, LPUINT puDeviceID)
     * }
     */
    public static int waveInGetID(MemorySegment hwi, MemorySegment puDeviceID) {
        var mh$ = waveInGetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInGetID", hwi, puDeviceID);
            }
            return (int)mh$.invokeExact(hwi, puDeviceID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waveInMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("waveInMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static FunctionDescriptor waveInMessage$descriptor() {
        return waveInMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MethodHandle waveInMessage$handle() {
        return waveInMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MemorySegment waveInMessage$address() {
        return waveInMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static int waveInMessage(MemorySegment hwi, int uMsg, long dw1, long dw2) {
        var mh$ = waveInMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waveInMessage", hwi, uMsg, dw1, dw2);
            }
            return (int)mh$.invokeExact(hwi, uMsg, dw1, dw2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HMIDI__ {
     *     int unused;
     * } *HMIDI
     * }
     */
    public static final AddressLayout HMIDI = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMIDIIN__ {
     *     int unused;
     * } *HMIDIIN
     * }
     */
    public static final AddressLayout HMIDIIN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMIDIOUT__ {
     *     int unused;
     * } *HMIDIOUT
     * }
     */
    public static final AddressLayout HMIDIOUT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMIDISTRM__ {
     *     int unused;
     * } *HMIDISTRM
     * }
     */
    public static final AddressLayout HMIDISTRM = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HMIDI *LPHMIDI
     * }
     */
    public static final AddressLayout LPHMIDI = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HMIDIIN *LPHMIDIIN
     * }
     */
    public static final AddressLayout LPHMIDIIN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HMIDIOUT *LPHMIDIOUT
     * }
     */
    public static final AddressLayout LPHMIDIOUT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HMIDISTRM *LPHMIDISTRM
     * }
     */
    public static final AddressLayout LPHMIDISTRM = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WORD *LPPATCHARRAY
     * }
     */
    public static final AddressLayout LPPATCHARRAY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WORD *LPKEYARRAY
     * }
     */
    public static final AddressLayout LPKEYARRAY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     * } *PMIDIOUTCAPSA
     * }
     */
    public static final AddressLayout PMIDIOUTCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     * } *NPMIDIOUTCAPSA
     * }
     */
    public static final AddressLayout NPMIDIOUTCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     * } *LPMIDIOUTCAPSA
     * }
     */
    public static final AddressLayout LPMIDIOUTCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     * } *PMIDIOUTCAPSW
     * }
     */
    public static final AddressLayout PMIDIOUTCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     * } *NPMIDIOUTCAPSW
     * }
     */
    public static final AddressLayout NPMIDIOUTCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     * } *LPMIDIOUTCAPSW
     * }
     */
    public static final AddressLayout LPMIDIOUTCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIDIOUTCAPSA PMIDIOUTCAPS
     * }
     */
    public static final AddressLayout PMIDIOUTCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPMIDIOUTCAPSA NPMIDIOUTCAPS
     * }
     */
    public static final AddressLayout NPMIDIOUTCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIDIOUTCAPSA LPMIDIOUTCAPS
     * }
     */
    public static final AddressLayout LPMIDIOUTCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PMIDIOUTCAPS2A
     * }
     */
    public static final AddressLayout PMIDIOUTCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPMIDIOUTCAPS2A
     * }
     */
    public static final AddressLayout NPMIDIOUTCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPMIDIOUTCAPS2A
     * }
     */
    public static final AddressLayout LPMIDIOUTCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PMIDIOUTCAPS2W
     * }
     */
    public static final AddressLayout PMIDIOUTCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPMIDIOUTCAPS2W
     * }
     */
    public static final AddressLayout NPMIDIOUTCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIOUTCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wVoices;
     *     WORD wNotes;
     *     WORD wChannelMask;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPMIDIOUTCAPS2W
     * }
     */
    public static final AddressLayout LPMIDIOUTCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIDIOUTCAPS2A PMIDIOUTCAPS2
     * }
     */
    public static final AddressLayout PMIDIOUTCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPMIDIOUTCAPS2A NPMIDIOUTCAPS2
     * }
     */
    public static final AddressLayout NPMIDIOUTCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIDIOUTCAPS2A LPMIDIOUTCAPS2
     * }
     */
    public static final AddressLayout LPMIDIOUTCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwSupport;
     * } *PMIDIINCAPSA
     * }
     */
    public static final AddressLayout PMIDIINCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwSupport;
     * } *NPMIDIINCAPSA
     * }
     */
    public static final AddressLayout NPMIDIINCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwSupport;
     * } *LPMIDIINCAPSA
     * }
     */
    public static final AddressLayout LPMIDIINCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwSupport;
     * } *PMIDIINCAPSW
     * }
     */
    public static final AddressLayout PMIDIINCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwSupport;
     * } *NPMIDIINCAPSW
     * }
     */
    public static final AddressLayout NPMIDIINCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwSupport;
     * } *LPMIDIINCAPSW
     * }
     */
    public static final AddressLayout LPMIDIINCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIDIINCAPSA PMIDIINCAPS
     * }
     */
    public static final AddressLayout PMIDIINCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPMIDIINCAPSA NPMIDIINCAPS
     * }
     */
    public static final AddressLayout NPMIDIINCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIDIINCAPSA LPMIDIINCAPS
     * }
     */
    public static final AddressLayout LPMIDIINCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PMIDIINCAPS2A
     * }
     */
    public static final AddressLayout PMIDIINCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPMIDIINCAPS2A
     * }
     */
    public static final AddressLayout NPMIDIINCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPMIDIINCAPS2A
     * }
     */
    public static final AddressLayout LPMIDIINCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PMIDIINCAPS2W
     * }
     */
    public static final AddressLayout PMIDIINCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPMIDIINCAPS2W
     * }
     */
    public static final AddressLayout NPMIDIINCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIDIINCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPMIDIINCAPS2W
     * }
     */
    public static final AddressLayout LPMIDIINCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIDIINCAPS2A PMIDIINCAPS2
     * }
     */
    public static final AddressLayout PMIDIINCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPMIDIINCAPS2A NPMIDIINCAPS2
     * }
     */
    public static final AddressLayout NPMIDIINCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIDIINCAPS2A LPMIDIINCAPS2
     * }
     */
    public static final AddressLayout LPMIDIINCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct midihdr_tag {
     *     LPSTR lpData;
     *     DWORD dwBufferLength;
     *     DWORD dwBytesRecorded;
     *     DWORD_PTR dwUser;
     *     DWORD dwFlags;
     *     struct midihdr_tag *lpNext;
     *     DWORD_PTR reserved;
     *     DWORD dwOffset;
     *     DWORD_PTR dwReserved[8];
     * } *PMIDIHDR
     * }
     */
    public static final AddressLayout PMIDIHDR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct midihdr_tag {
     *     LPSTR lpData;
     *     DWORD dwBufferLength;
     *     DWORD dwBytesRecorded;
     *     DWORD_PTR dwUser;
     *     DWORD dwFlags;
     *     struct midihdr_tag *lpNext;
     *     DWORD_PTR reserved;
     *     DWORD dwOffset;
     *     DWORD_PTR dwReserved[8];
     * } *NPMIDIHDR
     * }
     */
    public static final AddressLayout NPMIDIHDR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct midihdr_tag {
     *     LPSTR lpData;
     *     DWORD dwBufferLength;
     *     DWORD dwBytesRecorded;
     *     DWORD_PTR dwUser;
     *     DWORD dwFlags;
     *     struct midihdr_tag *lpNext;
     *     DWORD_PTR reserved;
     *     DWORD dwOffset;
     *     DWORD_PTR dwReserved[8];
     * } *LPMIDIHDR
     * }
     */
    public static final AddressLayout LPMIDIHDR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct midiproptimediv_tag {
     *     DWORD cbStruct;
     *     DWORD dwTimeDiv;
     * } *LPMIDIPROPTIMEDIV
     * }
     */
    public static final AddressLayout LPMIDIPROPTIMEDIV = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct midiproptempo_tag {
     *     DWORD cbStruct;
     *     DWORD dwTempo;
     * } *LPMIDIPROPTEMPO
     * }
     */
    public static final AddressLayout LPMIDIPROPTEMPO = winapi.C_POINTER;

    private static class midiOutGetNumDevs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutGetNumDevs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT midiOutGetNumDevs()
     * }
     */
    public static FunctionDescriptor midiOutGetNumDevs$descriptor() {
        return midiOutGetNumDevs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT midiOutGetNumDevs()
     * }
     */
    public static MethodHandle midiOutGetNumDevs$handle() {
        return midiOutGetNumDevs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT midiOutGetNumDevs()
     * }
     */
    public static MemorySegment midiOutGetNumDevs$address() {
        return midiOutGetNumDevs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT midiOutGetNumDevs()
     * }
     */
    public static int midiOutGetNumDevs() {
        var mh$ = midiOutGetNumDevs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutGetNumDevs");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiStreamOpen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiStreamOpen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiStreamOpen(LPHMIDISTRM phms, LPUINT puDeviceID, DWORD cMidi, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static FunctionDescriptor midiStreamOpen$descriptor() {
        return midiStreamOpen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiStreamOpen(LPHMIDISTRM phms, LPUINT puDeviceID, DWORD cMidi, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MethodHandle midiStreamOpen$handle() {
        return midiStreamOpen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiStreamOpen(LPHMIDISTRM phms, LPUINT puDeviceID, DWORD cMidi, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MemorySegment midiStreamOpen$address() {
        return midiStreamOpen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiStreamOpen(LPHMIDISTRM phms, LPUINT puDeviceID, DWORD cMidi, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static int midiStreamOpen(MemorySegment phms, MemorySegment puDeviceID, int cMidi, long dwCallback, long dwInstance, int fdwOpen) {
        var mh$ = midiStreamOpen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiStreamOpen", phms, puDeviceID, cMidi, dwCallback, dwInstance, fdwOpen);
            }
            return (int)mh$.invokeExact(phms, puDeviceID, cMidi, dwCallback, dwInstance, fdwOpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiStreamClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiStreamClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiStreamClose(HMIDISTRM hms)
     * }
     */
    public static FunctionDescriptor midiStreamClose$descriptor() {
        return midiStreamClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiStreamClose(HMIDISTRM hms)
     * }
     */
    public static MethodHandle midiStreamClose$handle() {
        return midiStreamClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiStreamClose(HMIDISTRM hms)
     * }
     */
    public static MemorySegment midiStreamClose$address() {
        return midiStreamClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiStreamClose(HMIDISTRM hms)
     * }
     */
    public static int midiStreamClose(MemorySegment hms) {
        var mh$ = midiStreamClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiStreamClose", hms);
            }
            return (int)mh$.invokeExact(hms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiStreamProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiStreamProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiStreamProperty(HMIDISTRM hms, LPBYTE lppropdata, DWORD dwProperty)
     * }
     */
    public static FunctionDescriptor midiStreamProperty$descriptor() {
        return midiStreamProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiStreamProperty(HMIDISTRM hms, LPBYTE lppropdata, DWORD dwProperty)
     * }
     */
    public static MethodHandle midiStreamProperty$handle() {
        return midiStreamProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiStreamProperty(HMIDISTRM hms, LPBYTE lppropdata, DWORD dwProperty)
     * }
     */
    public static MemorySegment midiStreamProperty$address() {
        return midiStreamProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiStreamProperty(HMIDISTRM hms, LPBYTE lppropdata, DWORD dwProperty)
     * }
     */
    public static int midiStreamProperty(MemorySegment hms, MemorySegment lppropdata, int dwProperty) {
        var mh$ = midiStreamProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiStreamProperty", hms, lppropdata, dwProperty);
            }
            return (int)mh$.invokeExact(hms, lppropdata, dwProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiStreamPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiStreamPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiStreamPosition(HMIDISTRM hms, LPMMTIME lpmmt, UINT cbmmt)
     * }
     */
    public static FunctionDescriptor midiStreamPosition$descriptor() {
        return midiStreamPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiStreamPosition(HMIDISTRM hms, LPMMTIME lpmmt, UINT cbmmt)
     * }
     */
    public static MethodHandle midiStreamPosition$handle() {
        return midiStreamPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiStreamPosition(HMIDISTRM hms, LPMMTIME lpmmt, UINT cbmmt)
     * }
     */
    public static MemorySegment midiStreamPosition$address() {
        return midiStreamPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiStreamPosition(HMIDISTRM hms, LPMMTIME lpmmt, UINT cbmmt)
     * }
     */
    public static int midiStreamPosition(MemorySegment hms, MemorySegment lpmmt, int cbmmt) {
        var mh$ = midiStreamPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiStreamPosition", hms, lpmmt, cbmmt);
            }
            return (int)mh$.invokeExact(hms, lpmmt, cbmmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiStreamOut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiStreamOut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiStreamOut(HMIDISTRM hms, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static FunctionDescriptor midiStreamOut$descriptor() {
        return midiStreamOut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiStreamOut(HMIDISTRM hms, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MethodHandle midiStreamOut$handle() {
        return midiStreamOut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiStreamOut(HMIDISTRM hms, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MemorySegment midiStreamOut$address() {
        return midiStreamOut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiStreamOut(HMIDISTRM hms, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static int midiStreamOut(MemorySegment hms, MemorySegment pmh, int cbmh) {
        var mh$ = midiStreamOut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiStreamOut", hms, pmh, cbmh);
            }
            return (int)mh$.invokeExact(hms, pmh, cbmh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiStreamPause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiStreamPause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiStreamPause(HMIDISTRM hms)
     * }
     */
    public static FunctionDescriptor midiStreamPause$descriptor() {
        return midiStreamPause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiStreamPause(HMIDISTRM hms)
     * }
     */
    public static MethodHandle midiStreamPause$handle() {
        return midiStreamPause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiStreamPause(HMIDISTRM hms)
     * }
     */
    public static MemorySegment midiStreamPause$address() {
        return midiStreamPause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiStreamPause(HMIDISTRM hms)
     * }
     */
    public static int midiStreamPause(MemorySegment hms) {
        var mh$ = midiStreamPause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiStreamPause", hms);
            }
            return (int)mh$.invokeExact(hms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiStreamRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiStreamRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiStreamRestart(HMIDISTRM hms)
     * }
     */
    public static FunctionDescriptor midiStreamRestart$descriptor() {
        return midiStreamRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiStreamRestart(HMIDISTRM hms)
     * }
     */
    public static MethodHandle midiStreamRestart$handle() {
        return midiStreamRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiStreamRestart(HMIDISTRM hms)
     * }
     */
    public static MemorySegment midiStreamRestart$address() {
        return midiStreamRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiStreamRestart(HMIDISTRM hms)
     * }
     */
    public static int midiStreamRestart(MemorySegment hms) {
        var mh$ = midiStreamRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiStreamRestart", hms);
            }
            return (int)mh$.invokeExact(hms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiStreamStop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiStreamStop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiStreamStop(HMIDISTRM hms)
     * }
     */
    public static FunctionDescriptor midiStreamStop$descriptor() {
        return midiStreamStop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiStreamStop(HMIDISTRM hms)
     * }
     */
    public static MethodHandle midiStreamStop$handle() {
        return midiStreamStop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiStreamStop(HMIDISTRM hms)
     * }
     */
    public static MemorySegment midiStreamStop$address() {
        return midiStreamStop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiStreamStop(HMIDISTRM hms)
     * }
     */
    public static int midiStreamStop(MemorySegment hms) {
        var mh$ = midiStreamStop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiStreamStop", hms);
            }
            return (int)mh$.invokeExact(hms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiConnect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiConnect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiConnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved)
     * }
     */
    public static FunctionDescriptor midiConnect$descriptor() {
        return midiConnect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiConnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved)
     * }
     */
    public static MethodHandle midiConnect$handle() {
        return midiConnect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiConnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved)
     * }
     */
    public static MemorySegment midiConnect$address() {
        return midiConnect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiConnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved)
     * }
     */
    public static int midiConnect(MemorySegment hmi, MemorySegment hmo, MemorySegment pReserved) {
        var mh$ = midiConnect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiConnect", hmi, hmo, pReserved);
            }
            return (int)mh$.invokeExact(hmi, hmo, pReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiDisconnect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiDisconnect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiDisconnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved)
     * }
     */
    public static FunctionDescriptor midiDisconnect$descriptor() {
        return midiDisconnect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiDisconnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved)
     * }
     */
    public static MethodHandle midiDisconnect$handle() {
        return midiDisconnect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiDisconnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved)
     * }
     */
    public static MemorySegment midiDisconnect$address() {
        return midiDisconnect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiDisconnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved)
     * }
     */
    public static int midiDisconnect(MemorySegment hmi, MemorySegment hmo, MemorySegment pReserved) {
        var mh$ = midiDisconnect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiDisconnect", hmi, hmo, pReserved);
            }
            return (int)mh$.invokeExact(hmi, hmo, pReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutGetDevCapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutGetDevCapsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetDevCapsA(UINT_PTR uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc)
     * }
     */
    public static FunctionDescriptor midiOutGetDevCapsA$descriptor() {
        return midiOutGetDevCapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetDevCapsA(UINT_PTR uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc)
     * }
     */
    public static MethodHandle midiOutGetDevCapsA$handle() {
        return midiOutGetDevCapsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetDevCapsA(UINT_PTR uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc)
     * }
     */
    public static MemorySegment midiOutGetDevCapsA$address() {
        return midiOutGetDevCapsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutGetDevCapsA(UINT_PTR uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc)
     * }
     */
    public static int midiOutGetDevCapsA(long uDeviceID, MemorySegment pmoc, int cbmoc) {
        var mh$ = midiOutGetDevCapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutGetDevCapsA", uDeviceID, pmoc, cbmoc);
            }
            return (int)mh$.invokeExact(uDeviceID, pmoc, cbmoc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutGetDevCapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutGetDevCapsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetDevCapsW(UINT_PTR uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc)
     * }
     */
    public static FunctionDescriptor midiOutGetDevCapsW$descriptor() {
        return midiOutGetDevCapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetDevCapsW(UINT_PTR uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc)
     * }
     */
    public static MethodHandle midiOutGetDevCapsW$handle() {
        return midiOutGetDevCapsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetDevCapsW(UINT_PTR uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc)
     * }
     */
    public static MemorySegment midiOutGetDevCapsW$address() {
        return midiOutGetDevCapsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutGetDevCapsW(UINT_PTR uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc)
     * }
     */
    public static int midiOutGetDevCapsW(long uDeviceID, MemorySegment pmoc, int cbmoc) {
        var mh$ = midiOutGetDevCapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutGetDevCapsW", uDeviceID, pmoc, cbmoc);
            }
            return (int)mh$.invokeExact(uDeviceID, pmoc, cbmoc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutGetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutGetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume)
     * }
     */
    public static FunctionDescriptor midiOutGetVolume$descriptor() {
        return midiOutGetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume)
     * }
     */
    public static MethodHandle midiOutGetVolume$handle() {
        return midiOutGetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume)
     * }
     */
    public static MemorySegment midiOutGetVolume$address() {
        return midiOutGetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume)
     * }
     */
    public static int midiOutGetVolume(MemorySegment hmo, MemorySegment pdwVolume) {
        var mh$ = midiOutGetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutGetVolume", hmo, pdwVolume);
            }
            return (int)mh$.invokeExact(hmo, pdwVolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutSetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutSetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume)
     * }
     */
    public static FunctionDescriptor midiOutSetVolume$descriptor() {
        return midiOutSetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume)
     * }
     */
    public static MethodHandle midiOutSetVolume$handle() {
        return midiOutSetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume)
     * }
     */
    public static MemorySegment midiOutSetVolume$address() {
        return midiOutSetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume)
     * }
     */
    public static int midiOutSetVolume(MemorySegment hmo, int dwVolume) {
        var mh$ = midiOutSetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutSetVolume", hmo, dwVolume);
            }
            return (int)mh$.invokeExact(hmo, dwVolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutGetErrorTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutGetErrorTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor midiOutGetErrorTextA$descriptor() {
        return midiOutGetErrorTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle midiOutGetErrorTextA$handle() {
        return midiOutGetErrorTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment midiOutGetErrorTextA$address() {
        return midiOutGetErrorTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static int midiOutGetErrorTextA(int mmrError, MemorySegment pszText, int cchText) {
        var mh$ = midiOutGetErrorTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutGetErrorTextA", mmrError, pszText, cchText);
            }
            return (int)mh$.invokeExact(mmrError, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutGetErrorTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutGetErrorTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor midiOutGetErrorTextW$descriptor() {
        return midiOutGetErrorTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle midiOutGetErrorTextW$handle() {
        return midiOutGetErrorTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment midiOutGetErrorTextW$address() {
        return midiOutGetErrorTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static int midiOutGetErrorTextW(int mmrError, MemorySegment pszText, int cchText) {
        var mh$ = midiOutGetErrorTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutGetErrorTextW", mmrError, pszText, cchText);
            }
            return (int)mh$.invokeExact(mmrError, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutOpen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutOpen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static FunctionDescriptor midiOutOpen$descriptor() {
        return midiOutOpen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MethodHandle midiOutOpen$handle() {
        return midiOutOpen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MemorySegment midiOutOpen$address() {
        return midiOutOpen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static int midiOutOpen(MemorySegment phmo, int uDeviceID, long dwCallback, long dwInstance, int fdwOpen) {
        var mh$ = midiOutOpen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutOpen", phmo, uDeviceID, dwCallback, dwInstance, fdwOpen);
            }
            return (int)mh$.invokeExact(phmo, uDeviceID, dwCallback, dwInstance, fdwOpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutClose(HMIDIOUT hmo)
     * }
     */
    public static FunctionDescriptor midiOutClose$descriptor() {
        return midiOutClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutClose(HMIDIOUT hmo)
     * }
     */
    public static MethodHandle midiOutClose$handle() {
        return midiOutClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutClose(HMIDIOUT hmo)
     * }
     */
    public static MemorySegment midiOutClose$address() {
        return midiOutClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutClose(HMIDIOUT hmo)
     * }
     */
    public static int midiOutClose(MemorySegment hmo) {
        var mh$ = midiOutClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutClose", hmo);
            }
            return (int)mh$.invokeExact(hmo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutPrepareHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutPrepareHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static FunctionDescriptor midiOutPrepareHeader$descriptor() {
        return midiOutPrepareHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MethodHandle midiOutPrepareHeader$handle() {
        return midiOutPrepareHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MemorySegment midiOutPrepareHeader$address() {
        return midiOutPrepareHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static int midiOutPrepareHeader(MemorySegment hmo, MemorySegment pmh, int cbmh) {
        var mh$ = midiOutPrepareHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutPrepareHeader", hmo, pmh, cbmh);
            }
            return (int)mh$.invokeExact(hmo, pmh, cbmh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutUnprepareHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutUnprepareHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static FunctionDescriptor midiOutUnprepareHeader$descriptor() {
        return midiOutUnprepareHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MethodHandle midiOutUnprepareHeader$handle() {
        return midiOutUnprepareHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MemorySegment midiOutUnprepareHeader$address() {
        return midiOutUnprepareHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static int midiOutUnprepareHeader(MemorySegment hmo, MemorySegment pmh, int cbmh) {
        var mh$ = midiOutUnprepareHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutUnprepareHeader", hmo, pmh, cbmh);
            }
            return (int)mh$.invokeExact(hmo, pmh, cbmh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutShortMsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutShortMsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg)
     * }
     */
    public static FunctionDescriptor midiOutShortMsg$descriptor() {
        return midiOutShortMsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg)
     * }
     */
    public static MethodHandle midiOutShortMsg$handle() {
        return midiOutShortMsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg)
     * }
     */
    public static MemorySegment midiOutShortMsg$address() {
        return midiOutShortMsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg)
     * }
     */
    public static int midiOutShortMsg(MemorySegment hmo, int dwMsg) {
        var mh$ = midiOutShortMsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutShortMsg", hmo, dwMsg);
            }
            return (int)mh$.invokeExact(hmo, dwMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutLongMsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutLongMsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static FunctionDescriptor midiOutLongMsg$descriptor() {
        return midiOutLongMsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MethodHandle midiOutLongMsg$handle() {
        return midiOutLongMsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MemorySegment midiOutLongMsg$address() {
        return midiOutLongMsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static int midiOutLongMsg(MemorySegment hmo, MemorySegment pmh, int cbmh) {
        var mh$ = midiOutLongMsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutLongMsg", hmo, pmh, cbmh);
            }
            return (int)mh$.invokeExact(hmo, pmh, cbmh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutReset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutReset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutReset(HMIDIOUT hmo)
     * }
     */
    public static FunctionDescriptor midiOutReset$descriptor() {
        return midiOutReset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutReset(HMIDIOUT hmo)
     * }
     */
    public static MethodHandle midiOutReset$handle() {
        return midiOutReset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutReset(HMIDIOUT hmo)
     * }
     */
    public static MemorySegment midiOutReset$address() {
        return midiOutReset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutReset(HMIDIOUT hmo)
     * }
     */
    public static int midiOutReset(MemorySegment hmo) {
        var mh$ = midiOutReset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutReset", hmo);
            }
            return (int)mh$.invokeExact(hmo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutCachePatches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutCachePatches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache)
     * }
     */
    public static FunctionDescriptor midiOutCachePatches$descriptor() {
        return midiOutCachePatches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache)
     * }
     */
    public static MethodHandle midiOutCachePatches$handle() {
        return midiOutCachePatches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache)
     * }
     */
    public static MemorySegment midiOutCachePatches$address() {
        return midiOutCachePatches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache)
     * }
     */
    public static int midiOutCachePatches(MemorySegment hmo, int uBank, MemorySegment pwpa, int fuCache) {
        var mh$ = midiOutCachePatches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutCachePatches", hmo, uBank, pwpa, fuCache);
            }
            return (int)mh$.invokeExact(hmo, uBank, pwpa, fuCache);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutCacheDrumPatches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutCacheDrumPatches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache)
     * }
     */
    public static FunctionDescriptor midiOutCacheDrumPatches$descriptor() {
        return midiOutCacheDrumPatches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache)
     * }
     */
    public static MethodHandle midiOutCacheDrumPatches$handle() {
        return midiOutCacheDrumPatches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache)
     * }
     */
    public static MemorySegment midiOutCacheDrumPatches$address() {
        return midiOutCacheDrumPatches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache)
     * }
     */
    public static int midiOutCacheDrumPatches(MemorySegment hmo, int uPatch, MemorySegment pwkya, int fuCache) {
        var mh$ = midiOutCacheDrumPatches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutCacheDrumPatches", hmo, uPatch, pwkya, fuCache);
            }
            return (int)mh$.invokeExact(hmo, uPatch, pwkya, fuCache);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutGetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutGetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID)
     * }
     */
    public static FunctionDescriptor midiOutGetID$descriptor() {
        return midiOutGetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID)
     * }
     */
    public static MethodHandle midiOutGetID$handle() {
        return midiOutGetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID)
     * }
     */
    public static MemorySegment midiOutGetID$address() {
        return midiOutGetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID)
     * }
     */
    public static int midiOutGetID(MemorySegment hmo, MemorySegment puDeviceID) {
        var mh$ = midiOutGetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutGetID", hmo, puDeviceID);
            }
            return (int)mh$.invokeExact(hmo, puDeviceID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiOutMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiOutMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static FunctionDescriptor midiOutMessage$descriptor() {
        return midiOutMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MethodHandle midiOutMessage$handle() {
        return midiOutMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MemorySegment midiOutMessage$address() {
        return midiOutMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static int midiOutMessage(MemorySegment hmo, int uMsg, long dw1, long dw2) {
        var mh$ = midiOutMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiOutMessage", hmo, uMsg, dw1, dw2);
            }
            return (int)mh$.invokeExact(hmo, uMsg, dw1, dw2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInGetNumDevs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInGetNumDevs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT midiInGetNumDevs()
     * }
     */
    public static FunctionDescriptor midiInGetNumDevs$descriptor() {
        return midiInGetNumDevs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT midiInGetNumDevs()
     * }
     */
    public static MethodHandle midiInGetNumDevs$handle() {
        return midiInGetNumDevs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT midiInGetNumDevs()
     * }
     */
    public static MemorySegment midiInGetNumDevs$address() {
        return midiInGetNumDevs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT midiInGetNumDevs()
     * }
     */
    public static int midiInGetNumDevs() {
        var mh$ = midiInGetNumDevs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInGetNumDevs");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInGetDevCapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInGetDevCapsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInGetDevCapsA(UINT_PTR uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic)
     * }
     */
    public static FunctionDescriptor midiInGetDevCapsA$descriptor() {
        return midiInGetDevCapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInGetDevCapsA(UINT_PTR uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic)
     * }
     */
    public static MethodHandle midiInGetDevCapsA$handle() {
        return midiInGetDevCapsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInGetDevCapsA(UINT_PTR uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic)
     * }
     */
    public static MemorySegment midiInGetDevCapsA$address() {
        return midiInGetDevCapsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInGetDevCapsA(UINT_PTR uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic)
     * }
     */
    public static int midiInGetDevCapsA(long uDeviceID, MemorySegment pmic, int cbmic) {
        var mh$ = midiInGetDevCapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInGetDevCapsA", uDeviceID, pmic, cbmic);
            }
            return (int)mh$.invokeExact(uDeviceID, pmic, cbmic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInGetDevCapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInGetDevCapsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInGetDevCapsW(UINT_PTR uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic)
     * }
     */
    public static FunctionDescriptor midiInGetDevCapsW$descriptor() {
        return midiInGetDevCapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInGetDevCapsW(UINT_PTR uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic)
     * }
     */
    public static MethodHandle midiInGetDevCapsW$handle() {
        return midiInGetDevCapsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInGetDevCapsW(UINT_PTR uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic)
     * }
     */
    public static MemorySegment midiInGetDevCapsW$address() {
        return midiInGetDevCapsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInGetDevCapsW(UINT_PTR uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic)
     * }
     */
    public static int midiInGetDevCapsW(long uDeviceID, MemorySegment pmic, int cbmic) {
        var mh$ = midiInGetDevCapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInGetDevCapsW", uDeviceID, pmic, cbmic);
            }
            return (int)mh$.invokeExact(uDeviceID, pmic, cbmic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInGetErrorTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInGetErrorTextA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor midiInGetErrorTextA$descriptor() {
        return midiInGetErrorTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle midiInGetErrorTextA$handle() {
        return midiInGetErrorTextA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment midiInGetErrorTextA$address() {
        return midiInGetErrorTextA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText)
     * }
     */
    public static int midiInGetErrorTextA(int mmrError, MemorySegment pszText, int cchText) {
        var mh$ = midiInGetErrorTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInGetErrorTextA", mmrError, pszText, cchText);
            }
            return (int)mh$.invokeExact(mmrError, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInGetErrorTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInGetErrorTextW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static FunctionDescriptor midiInGetErrorTextW$descriptor() {
        return midiInGetErrorTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MethodHandle midiInGetErrorTextW$handle() {
        return midiInGetErrorTextW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static MemorySegment midiInGetErrorTextW$address() {
        return midiInGetErrorTextW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
     * }
     */
    public static int midiInGetErrorTextW(int mmrError, MemorySegment pszText, int cchText) {
        var mh$ = midiInGetErrorTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInGetErrorTextW", mmrError, pszText, cchText);
            }
            return (int)mh$.invokeExact(mmrError, pszText, cchText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInOpen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInOpen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInOpen(LPHMIDIIN phmi, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static FunctionDescriptor midiInOpen$descriptor() {
        return midiInOpen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInOpen(LPHMIDIIN phmi, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MethodHandle midiInOpen$handle() {
        return midiInOpen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInOpen(LPHMIDIIN phmi, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MemorySegment midiInOpen$address() {
        return midiInOpen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInOpen(LPHMIDIIN phmi, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static int midiInOpen(MemorySegment phmi, int uDeviceID, long dwCallback, long dwInstance, int fdwOpen) {
        var mh$ = midiInOpen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInOpen", phmi, uDeviceID, dwCallback, dwInstance, fdwOpen);
            }
            return (int)mh$.invokeExact(phmi, uDeviceID, dwCallback, dwInstance, fdwOpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInClose(HMIDIIN hmi)
     * }
     */
    public static FunctionDescriptor midiInClose$descriptor() {
        return midiInClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInClose(HMIDIIN hmi)
     * }
     */
    public static MethodHandle midiInClose$handle() {
        return midiInClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInClose(HMIDIIN hmi)
     * }
     */
    public static MemorySegment midiInClose$address() {
        return midiInClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInClose(HMIDIIN hmi)
     * }
     */
    public static int midiInClose(MemorySegment hmi) {
        var mh$ = midiInClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInClose", hmi);
            }
            return (int)mh$.invokeExact(hmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInPrepareHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInPrepareHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static FunctionDescriptor midiInPrepareHeader$descriptor() {
        return midiInPrepareHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MethodHandle midiInPrepareHeader$handle() {
        return midiInPrepareHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MemorySegment midiInPrepareHeader$address() {
        return midiInPrepareHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static int midiInPrepareHeader(MemorySegment hmi, MemorySegment pmh, int cbmh) {
        var mh$ = midiInPrepareHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInPrepareHeader", hmi, pmh, cbmh);
            }
            return (int)mh$.invokeExact(hmi, pmh, cbmh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInUnprepareHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInUnprepareHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static FunctionDescriptor midiInUnprepareHeader$descriptor() {
        return midiInUnprepareHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MethodHandle midiInUnprepareHeader$handle() {
        return midiInUnprepareHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MemorySegment midiInUnprepareHeader$address() {
        return midiInUnprepareHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static int midiInUnprepareHeader(MemorySegment hmi, MemorySegment pmh, int cbmh) {
        var mh$ = midiInUnprepareHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInUnprepareHeader", hmi, pmh, cbmh);
            }
            return (int)mh$.invokeExact(hmi, pmh, cbmh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInAddBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInAddBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static FunctionDescriptor midiInAddBuffer$descriptor() {
        return midiInAddBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MethodHandle midiInAddBuffer$handle() {
        return midiInAddBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static MemorySegment midiInAddBuffer$address() {
        return midiInAddBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh)
     * }
     */
    public static int midiInAddBuffer(MemorySegment hmi, MemorySegment pmh, int cbmh) {
        var mh$ = midiInAddBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInAddBuffer", hmi, pmh, cbmh);
            }
            return (int)mh$.invokeExact(hmi, pmh, cbmh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInStart(HMIDIIN hmi)
     * }
     */
    public static FunctionDescriptor midiInStart$descriptor() {
        return midiInStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInStart(HMIDIIN hmi)
     * }
     */
    public static MethodHandle midiInStart$handle() {
        return midiInStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInStart(HMIDIIN hmi)
     * }
     */
    public static MemorySegment midiInStart$address() {
        return midiInStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInStart(HMIDIIN hmi)
     * }
     */
    public static int midiInStart(MemorySegment hmi) {
        var mh$ = midiInStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInStart", hmi);
            }
            return (int)mh$.invokeExact(hmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInStop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInStop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInStop(HMIDIIN hmi)
     * }
     */
    public static FunctionDescriptor midiInStop$descriptor() {
        return midiInStop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInStop(HMIDIIN hmi)
     * }
     */
    public static MethodHandle midiInStop$handle() {
        return midiInStop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInStop(HMIDIIN hmi)
     * }
     */
    public static MemorySegment midiInStop$address() {
        return midiInStop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInStop(HMIDIIN hmi)
     * }
     */
    public static int midiInStop(MemorySegment hmi) {
        var mh$ = midiInStop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInStop", hmi);
            }
            return (int)mh$.invokeExact(hmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInReset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInReset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInReset(HMIDIIN hmi)
     * }
     */
    public static FunctionDescriptor midiInReset$descriptor() {
        return midiInReset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInReset(HMIDIIN hmi)
     * }
     */
    public static MethodHandle midiInReset$handle() {
        return midiInReset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInReset(HMIDIIN hmi)
     * }
     */
    public static MemorySegment midiInReset$address() {
        return midiInReset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInReset(HMIDIIN hmi)
     * }
     */
    public static int midiInReset(MemorySegment hmi) {
        var mh$ = midiInReset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInReset", hmi);
            }
            return (int)mh$.invokeExact(hmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInGetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInGetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInGetID(HMIDIIN hmi, LPUINT puDeviceID)
     * }
     */
    public static FunctionDescriptor midiInGetID$descriptor() {
        return midiInGetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInGetID(HMIDIIN hmi, LPUINT puDeviceID)
     * }
     */
    public static MethodHandle midiInGetID$handle() {
        return midiInGetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInGetID(HMIDIIN hmi, LPUINT puDeviceID)
     * }
     */
    public static MemorySegment midiInGetID$address() {
        return midiInGetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInGetID(HMIDIIN hmi, LPUINT puDeviceID)
     * }
     */
    public static int midiInGetID(MemorySegment hmi, MemorySegment puDeviceID) {
        var mh$ = midiInGetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInGetID", hmi, puDeviceID);
            }
            return (int)mh$.invokeExact(hmi, puDeviceID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class midiInMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("midiInMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static FunctionDescriptor midiInMessage$descriptor() {
        return midiInMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MethodHandle midiInMessage$handle() {
        return midiInMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MemorySegment midiInMessage$address() {
        return midiInMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static int midiInMessage(MemorySegment hmi, int uMsg, long dw1, long dw2) {
        var mh$ = midiInMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("midiInMessage", hmi, uMsg, dw1, dw2);
            }
            return (int)mh$.invokeExact(hmi, uMsg, dw1, dw2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *PAUXCAPSA
     * }
     */
    public static final AddressLayout PAUXCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *NPAUXCAPSA
     * }
     */
    public static final AddressLayout NPAUXCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *LPAUXCAPSA
     * }
     */
    public static final AddressLayout LPAUXCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *PAUXCAPSW
     * }
     */
    public static final AddressLayout PAUXCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *NPAUXCAPSW
     * }
     */
    public static final AddressLayout NPAUXCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     * } *LPAUXCAPSW
     * }
     */
    public static final AddressLayout LPAUXCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAUXCAPSA PAUXCAPS
     * }
     */
    public static final AddressLayout PAUXCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPAUXCAPSA NPAUXCAPS
     * }
     */
    public static final AddressLayout NPAUXCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAUXCAPSA LPAUXCAPS
     * }
     */
    public static final AddressLayout LPAUXCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PAUXCAPS2A
     * }
     */
    public static final AddressLayout PAUXCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPAUXCAPS2A
     * }
     */
    public static final AddressLayout NPAUXCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPAUXCAPS2A
     * }
     */
    public static final AddressLayout LPAUXCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PAUXCAPS2W
     * }
     */
    public static final AddressLayout PAUXCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *NPAUXCAPS2W
     * }
     */
    public static final AddressLayout NPAUXCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUXCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     WORD wTechnology;
     *     WORD wReserved1;
     *     DWORD dwSupport;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPAUXCAPS2W
     * }
     */
    public static final AddressLayout LPAUXCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAUXCAPS2A PAUXCAPS2
     * }
     */
    public static final AddressLayout PAUXCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPAUXCAPS2A NPAUXCAPS2
     * }
     */
    public static final AddressLayout NPAUXCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAUXCAPS2A LPAUXCAPS2
     * }
     */
    public static final AddressLayout LPAUXCAPS2 = winapi.C_POINTER;

    private static class auxGetNumDevs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("auxGetNumDevs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT auxGetNumDevs()
     * }
     */
    public static FunctionDescriptor auxGetNumDevs$descriptor() {
        return auxGetNumDevs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT auxGetNumDevs()
     * }
     */
    public static MethodHandle auxGetNumDevs$handle() {
        return auxGetNumDevs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT auxGetNumDevs()
     * }
     */
    public static MemorySegment auxGetNumDevs$address() {
        return auxGetNumDevs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT auxGetNumDevs()
     * }
     */
    public static int auxGetNumDevs() {
        var mh$ = auxGetNumDevs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auxGetNumDevs");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auxGetDevCapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("auxGetDevCapsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT auxGetDevCapsA(UINT_PTR uDeviceID, LPAUXCAPSA pac, UINT cbac)
     * }
     */
    public static FunctionDescriptor auxGetDevCapsA$descriptor() {
        return auxGetDevCapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT auxGetDevCapsA(UINT_PTR uDeviceID, LPAUXCAPSA pac, UINT cbac)
     * }
     */
    public static MethodHandle auxGetDevCapsA$handle() {
        return auxGetDevCapsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT auxGetDevCapsA(UINT_PTR uDeviceID, LPAUXCAPSA pac, UINT cbac)
     * }
     */
    public static MemorySegment auxGetDevCapsA$address() {
        return auxGetDevCapsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT auxGetDevCapsA(UINT_PTR uDeviceID, LPAUXCAPSA pac, UINT cbac)
     * }
     */
    public static int auxGetDevCapsA(long uDeviceID, MemorySegment pac, int cbac) {
        var mh$ = auxGetDevCapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auxGetDevCapsA", uDeviceID, pac, cbac);
            }
            return (int)mh$.invokeExact(uDeviceID, pac, cbac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auxGetDevCapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("auxGetDevCapsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT auxGetDevCapsW(UINT_PTR uDeviceID, LPAUXCAPSW pac, UINT cbac)
     * }
     */
    public static FunctionDescriptor auxGetDevCapsW$descriptor() {
        return auxGetDevCapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT auxGetDevCapsW(UINT_PTR uDeviceID, LPAUXCAPSW pac, UINT cbac)
     * }
     */
    public static MethodHandle auxGetDevCapsW$handle() {
        return auxGetDevCapsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT auxGetDevCapsW(UINT_PTR uDeviceID, LPAUXCAPSW pac, UINT cbac)
     * }
     */
    public static MemorySegment auxGetDevCapsW$address() {
        return auxGetDevCapsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT auxGetDevCapsW(UINT_PTR uDeviceID, LPAUXCAPSW pac, UINT cbac)
     * }
     */
    public static int auxGetDevCapsW(long uDeviceID, MemorySegment pac, int cbac) {
        var mh$ = auxGetDevCapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auxGetDevCapsW", uDeviceID, pac, cbac);
            }
            return (int)mh$.invokeExact(uDeviceID, pac, cbac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auxSetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("auxSetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT auxSetVolume(UINT uDeviceID, DWORD dwVolume)
     * }
     */
    public static FunctionDescriptor auxSetVolume$descriptor() {
        return auxSetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT auxSetVolume(UINT uDeviceID, DWORD dwVolume)
     * }
     */
    public static MethodHandle auxSetVolume$handle() {
        return auxSetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT auxSetVolume(UINT uDeviceID, DWORD dwVolume)
     * }
     */
    public static MemorySegment auxSetVolume$address() {
        return auxSetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT auxSetVolume(UINT uDeviceID, DWORD dwVolume)
     * }
     */
    public static int auxSetVolume(int uDeviceID, int dwVolume) {
        var mh$ = auxSetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auxSetVolume", uDeviceID, dwVolume);
            }
            return (int)mh$.invokeExact(uDeviceID, dwVolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auxGetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("auxGetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume)
     * }
     */
    public static FunctionDescriptor auxGetVolume$descriptor() {
        return auxGetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume)
     * }
     */
    public static MethodHandle auxGetVolume$handle() {
        return auxGetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume)
     * }
     */
    public static MemorySegment auxGetVolume$address() {
        return auxGetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume)
     * }
     */
    public static int auxGetVolume(int uDeviceID, MemorySegment pdwVolume) {
        var mh$ = auxGetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auxGetVolume", uDeviceID, pdwVolume);
            }
            return (int)mh$.invokeExact(uDeviceID, pdwVolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class auxOutMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("auxOutMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static FunctionDescriptor auxOutMessage$descriptor() {
        return auxOutMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MethodHandle auxOutMessage$handle() {
        return auxOutMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static MemorySegment auxOutMessage$address() {
        return auxOutMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2)
     * }
     */
    public static int auxOutMessage(int uDeviceID, int uMsg, long dw1, long dw2) {
        var mh$ = auxOutMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("auxOutMessage", uDeviceID, uMsg, dw1, dw2);
            }
            return (int)mh$.invokeExact(uDeviceID, uMsg, dw1, dw2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HMIXEROBJ__ {
     *     int unused;
     * } *HMIXEROBJ
     * }
     */
    public static final AddressLayout HMIXEROBJ = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HMIXEROBJ *LPHMIXEROBJ
     * }
     */
    public static final AddressLayout LPHMIXEROBJ = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMIXER__ {
     *     int unused;
     * } *HMIXER
     * }
     */
    public static final AddressLayout HMIXER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HMIXER *LPHMIXER
     * }
     */
    public static final AddressLayout LPHMIXER = winapi.C_POINTER;

    private static class mixerGetNumDevs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetNumDevs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT mixerGetNumDevs()
     * }
     */
    public static FunctionDescriptor mixerGetNumDevs$descriptor() {
        return mixerGetNumDevs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT mixerGetNumDevs()
     * }
     */
    public static MethodHandle mixerGetNumDevs$handle() {
        return mixerGetNumDevs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT mixerGetNumDevs()
     * }
     */
    public static MemorySegment mixerGetNumDevs$address() {
        return mixerGetNumDevs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT mixerGetNumDevs()
     * }
     */
    public static int mixerGetNumDevs() {
        var mh$ = mixerGetNumDevs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetNumDevs");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD fdwSupport;
     *     DWORD cDestinations;
     * } *PMIXERCAPSA
     * }
     */
    public static final AddressLayout PMIXERCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD fdwSupport;
     *     DWORD cDestinations;
     * } *LPMIXERCAPSA
     * }
     */
    public static final AddressLayout LPMIXERCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD fdwSupport;
     *     DWORD cDestinations;
     * } *PMIXERCAPSW
     * }
     */
    public static final AddressLayout PMIXERCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD fdwSupport;
     *     DWORD cDestinations;
     * } *LPMIXERCAPSW
     * }
     */
    public static final AddressLayout LPMIXERCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIXERCAPSA PMIXERCAPS
     * }
     */
    public static final AddressLayout PMIXERCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIXERCAPSA LPMIXERCAPS
     * }
     */
    public static final AddressLayout LPMIXERCAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD fdwSupport;
     *     DWORD cDestinations;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PMIXERCAPS2A
     * }
     */
    public static final AddressLayout PMIXERCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCAPS2A {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     CHAR szPname[32];
     *     DWORD fdwSupport;
     *     DWORD cDestinations;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPMIXERCAPS2A
     * }
     */
    public static final AddressLayout LPMIXERCAPS2A = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD fdwSupport;
     *     DWORD cDestinations;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *PMIXERCAPS2W
     * }
     */
    public static final AddressLayout PMIXERCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCAPS2W {
     *     WORD wMid;
     *     WORD wPid;
     *     MMVERSION vDriverVersion;
     *     WCHAR szPname[32];
     *     DWORD fdwSupport;
     *     DWORD cDestinations;
     *     GUID ManufacturerGuid;
     *     GUID ProductGuid;
     *     GUID NameGuid;
     * } *LPMIXERCAPS2W
     * }
     */
    public static final AddressLayout LPMIXERCAPS2W = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIXERCAPS2A PMIXERCAPS2
     * }
     */
    public static final AddressLayout PMIXERCAPS2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIXERCAPS2A LPMIXERCAPS2
     * }
     */
    public static final AddressLayout LPMIXERCAPS2 = winapi.C_POINTER;

    private static class mixerGetDevCapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetDevCapsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerGetDevCapsA(UINT_PTR uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps)
     * }
     */
    public static FunctionDescriptor mixerGetDevCapsA$descriptor() {
        return mixerGetDevCapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerGetDevCapsA(UINT_PTR uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps)
     * }
     */
    public static MethodHandle mixerGetDevCapsA$handle() {
        return mixerGetDevCapsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerGetDevCapsA(UINT_PTR uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps)
     * }
     */
    public static MemorySegment mixerGetDevCapsA$address() {
        return mixerGetDevCapsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerGetDevCapsA(UINT_PTR uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps)
     * }
     */
    public static int mixerGetDevCapsA(long uMxId, MemorySegment pmxcaps, int cbmxcaps) {
        var mh$ = mixerGetDevCapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetDevCapsA", uMxId, pmxcaps, cbmxcaps);
            }
            return (int)mh$.invokeExact(uMxId, pmxcaps, cbmxcaps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mixerGetDevCapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetDevCapsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerGetDevCapsW(UINT_PTR uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps)
     * }
     */
    public static FunctionDescriptor mixerGetDevCapsW$descriptor() {
        return mixerGetDevCapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerGetDevCapsW(UINT_PTR uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps)
     * }
     */
    public static MethodHandle mixerGetDevCapsW$handle() {
        return mixerGetDevCapsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerGetDevCapsW(UINT_PTR uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps)
     * }
     */
    public static MemorySegment mixerGetDevCapsW$address() {
        return mixerGetDevCapsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerGetDevCapsW(UINT_PTR uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps)
     * }
     */
    public static int mixerGetDevCapsW(long uMxId, MemorySegment pmxcaps, int cbmxcaps) {
        var mh$ = mixerGetDevCapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetDevCapsW", uMxId, pmxcaps, cbmxcaps);
            }
            return (int)mh$.invokeExact(uMxId, pmxcaps, cbmxcaps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mixerOpen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerOpen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static FunctionDescriptor mixerOpen$descriptor() {
        return mixerOpen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MethodHandle mixerOpen$handle() {
        return mixerOpen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static MemorySegment mixerOpen$address() {
        return mixerOpen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
     * }
     */
    public static int mixerOpen(MemorySegment phmx, int uMxId, long dwCallback, long dwInstance, int fdwOpen) {
        var mh$ = mixerOpen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerOpen", phmx, uMxId, dwCallback, dwInstance, fdwOpen);
            }
            return (int)mh$.invokeExact(phmx, uMxId, dwCallback, dwInstance, fdwOpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mixerClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerClose(HMIXER hmx)
     * }
     */
    public static FunctionDescriptor mixerClose$descriptor() {
        return mixerClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerClose(HMIXER hmx)
     * }
     */
    public static MethodHandle mixerClose$handle() {
        return mixerClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerClose(HMIXER hmx)
     * }
     */
    public static MemorySegment mixerClose$address() {
        return mixerClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerClose(HMIXER hmx)
     * }
     */
    public static int mixerClose(MemorySegment hmx) {
        var mh$ = mixerClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerClose", hmx);
            }
            return (int)mh$.invokeExact(hmx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mixerMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD mixerMessage(HMIXER hmx, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static FunctionDescriptor mixerMessage$descriptor() {
        return mixerMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD mixerMessage(HMIXER hmx, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static MethodHandle mixerMessage$handle() {
        return mixerMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD mixerMessage(HMIXER hmx, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static MemorySegment mixerMessage$address() {
        return mixerMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD mixerMessage(HMIXER hmx, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
     * }
     */
    public static int mixerMessage(MemorySegment hmx, int uMsg, long dwParam1, long dwParam2) {
        var mh$ = mixerMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerMessage", hmx, uMsg, dwParam1, dwParam2);
            }
            return (int)mh$.invokeExact(hmx, uMsg, dwParam1, dwParam2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERLINEA {
     *     DWORD cbStruct;
     *     DWORD dwDestination;
     *     DWORD dwSource;
     *     DWORD dwLineID;
     *     DWORD fdwLine;
     *     DWORD_PTR dwUser;
     *     DWORD dwComponentType;
     *     DWORD cChannels;
     *     DWORD cConnections;
     *     DWORD cControls;
     *     CHAR szShortName[16];
     *     CHAR szName[64];
     *     struct {
     *         DWORD dwType;
     *         DWORD dwDeviceID;
     *         WORD wMid;
     *         WORD wPid;
     *         MMVERSION vDriverVersion;
     *         CHAR szPname[32];
     *     } Target;
     * } *PMIXERLINEA
     * }
     */
    public static final AddressLayout PMIXERLINEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERLINEA {
     *     DWORD cbStruct;
     *     DWORD dwDestination;
     *     DWORD dwSource;
     *     DWORD dwLineID;
     *     DWORD fdwLine;
     *     DWORD_PTR dwUser;
     *     DWORD dwComponentType;
     *     DWORD cChannels;
     *     DWORD cConnections;
     *     DWORD cControls;
     *     CHAR szShortName[16];
     *     CHAR szName[64];
     *     struct {
     *         DWORD dwType;
     *         DWORD dwDeviceID;
     *         WORD wMid;
     *         WORD wPid;
     *         MMVERSION vDriverVersion;
     *         CHAR szPname[32];
     *     } Target;
     * } *LPMIXERLINEA
     * }
     */
    public static final AddressLayout LPMIXERLINEA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERLINEW {
     *     DWORD cbStruct;
     *     DWORD dwDestination;
     *     DWORD dwSource;
     *     DWORD dwLineID;
     *     DWORD fdwLine;
     *     DWORD_PTR dwUser;
     *     DWORD dwComponentType;
     *     DWORD cChannels;
     *     DWORD cConnections;
     *     DWORD cControls;
     *     WCHAR szShortName[16];
     *     WCHAR szName[64];
     *     struct {
     *         DWORD dwType;
     *         DWORD dwDeviceID;
     *         WORD wMid;
     *         WORD wPid;
     *         MMVERSION vDriverVersion;
     *         WCHAR szPname[32];
     *     } Target;
     * } *PMIXERLINEW
     * }
     */
    public static final AddressLayout PMIXERLINEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERLINEW {
     *     DWORD cbStruct;
     *     DWORD dwDestination;
     *     DWORD dwSource;
     *     DWORD dwLineID;
     *     DWORD fdwLine;
     *     DWORD_PTR dwUser;
     *     DWORD dwComponentType;
     *     DWORD cChannels;
     *     DWORD cConnections;
     *     DWORD cControls;
     *     WCHAR szShortName[16];
     *     WCHAR szName[64];
     *     struct {
     *         DWORD dwType;
     *         DWORD dwDeviceID;
     *         WORD wMid;
     *         WORD wPid;
     *         MMVERSION vDriverVersion;
     *         WCHAR szPname[32];
     *     } Target;
     * } *LPMIXERLINEW
     * }
     */
    public static final AddressLayout LPMIXERLINEW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIXERLINEA PMIXERLINE
     * }
     */
    public static final AddressLayout PMIXERLINE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIXERLINEA LPMIXERLINE
     * }
     */
    public static final AddressLayout LPMIXERLINE = winapi.C_POINTER;

    private static class mixerGetLineInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetLineInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo)
     * }
     */
    public static FunctionDescriptor mixerGetLineInfoA$descriptor() {
        return mixerGetLineInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo)
     * }
     */
    public static MethodHandle mixerGetLineInfoA$handle() {
        return mixerGetLineInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo)
     * }
     */
    public static MemorySegment mixerGetLineInfoA$address() {
        return mixerGetLineInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo)
     * }
     */
    public static int mixerGetLineInfoA(MemorySegment hmxobj, MemorySegment pmxl, int fdwInfo) {
        var mh$ = mixerGetLineInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetLineInfoA", hmxobj, pmxl, fdwInfo);
            }
            return (int)mh$.invokeExact(hmxobj, pmxl, fdwInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mixerGetLineInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetLineInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo)
     * }
     */
    public static FunctionDescriptor mixerGetLineInfoW$descriptor() {
        return mixerGetLineInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo)
     * }
     */
    public static MethodHandle mixerGetLineInfoW$handle() {
        return mixerGetLineInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo)
     * }
     */
    public static MemorySegment mixerGetLineInfoW$address() {
        return mixerGetLineInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo)
     * }
     */
    public static int mixerGetLineInfoW(MemorySegment hmxobj, MemorySegment pmxl, int fdwInfo) {
        var mh$ = mixerGetLineInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetLineInfoW", hmxobj, pmxl, fdwInfo);
            }
            return (int)mh$.invokeExact(hmxobj, pmxl, fdwInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mixerGetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerGetID(HMIXEROBJ hmxobj, UINT *puMxId, DWORD fdwId)
     * }
     */
    public static FunctionDescriptor mixerGetID$descriptor() {
        return mixerGetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerGetID(HMIXEROBJ hmxobj, UINT *puMxId, DWORD fdwId)
     * }
     */
    public static MethodHandle mixerGetID$handle() {
        return mixerGetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerGetID(HMIXEROBJ hmxobj, UINT *puMxId, DWORD fdwId)
     * }
     */
    public static MemorySegment mixerGetID$address() {
        return mixerGetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerGetID(HMIXEROBJ hmxobj, UINT *puMxId, DWORD fdwId)
     * }
     */
    public static int mixerGetID(MemorySegment hmxobj, MemorySegment puMxId, int fdwId) {
        var mh$ = mixerGetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetID", hmxobj, puMxId, fdwId);
            }
            return (int)mh$.invokeExact(hmxobj, puMxId, fdwId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCONTROLA {
     *     DWORD cbStruct;
     *     DWORD dwControlID;
     *     DWORD dwControlType;
     *     DWORD fdwControl;
     *     DWORD cMultipleItems;
     *     CHAR szShortName[16];
     *     CHAR szName[64];
     *     union {
     *         struct {
     *             LONG lMinimum;
     *             LONG lMaximum;
     *         };
     *         struct {
     *             DWORD dwMinimum;
     *             DWORD dwMaximum;
     *         };
     *         DWORD dwReserved[6];
     *     } Bounds;
     *     union {
     *         DWORD cSteps;
     *         DWORD cbCustomData;
     *         DWORD dwReserved[6];
     *     } Metrics;
     * } *PMIXERCONTROLA
     * }
     */
    public static final AddressLayout PMIXERCONTROLA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCONTROLA {
     *     DWORD cbStruct;
     *     DWORD dwControlID;
     *     DWORD dwControlType;
     *     DWORD fdwControl;
     *     DWORD cMultipleItems;
     *     CHAR szShortName[16];
     *     CHAR szName[64];
     *     union {
     *         struct {
     *             LONG lMinimum;
     *             LONG lMaximum;
     *         };
     *         struct {
     *             DWORD dwMinimum;
     *             DWORD dwMaximum;
     *         };
     *         DWORD dwReserved[6];
     *     } Bounds;
     *     union {
     *         DWORD cSteps;
     *         DWORD cbCustomData;
     *         DWORD dwReserved[6];
     *     } Metrics;
     * } *LPMIXERCONTROLA
     * }
     */
    public static final AddressLayout LPMIXERCONTROLA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCONTROLW {
     *     DWORD cbStruct;
     *     DWORD dwControlID;
     *     DWORD dwControlType;
     *     DWORD fdwControl;
     *     DWORD cMultipleItems;
     *     WCHAR szShortName[16];
     *     WCHAR szName[64];
     *     union {
     *         struct {
     *             LONG lMinimum;
     *             LONG lMaximum;
     *         };
     *         struct {
     *             DWORD dwMinimum;
     *             DWORD dwMaximum;
     *         };
     *         DWORD dwReserved[6];
     *     } Bounds;
     *     union {
     *         DWORD cSteps;
     *         DWORD cbCustomData;
     *         DWORD dwReserved[6];
     *     } Metrics;
     * } *PMIXERCONTROLW
     * }
     */
    public static final AddressLayout PMIXERCONTROLW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCONTROLW {
     *     DWORD cbStruct;
     *     DWORD dwControlID;
     *     DWORD dwControlType;
     *     DWORD fdwControl;
     *     DWORD cMultipleItems;
     *     WCHAR szShortName[16];
     *     WCHAR szName[64];
     *     union {
     *         struct {
     *             LONG lMinimum;
     *             LONG lMaximum;
     *         };
     *         struct {
     *             DWORD dwMinimum;
     *             DWORD dwMaximum;
     *         };
     *         DWORD dwReserved[6];
     *     } Bounds;
     *     union {
     *         DWORD cSteps;
     *         DWORD cbCustomData;
     *         DWORD dwReserved[6];
     *     } Metrics;
     * } *LPMIXERCONTROLW
     * }
     */
    public static final AddressLayout LPMIXERCONTROLW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIXERCONTROLA PMIXERCONTROL
     * }
     */
    public static final AddressLayout PMIXERCONTROL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIXERCONTROLA LPMIXERCONTROL
     * }
     */
    public static final AddressLayout LPMIXERCONTROL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERLINECONTROLSA {
     *     DWORD cbStruct;
     *     DWORD dwLineID;
     *     union {
     *         DWORD dwControlID;
     *         DWORD dwControlType;
     *     };
     *     DWORD cControls;
     *     DWORD cbmxctrl;
     *     LPMIXERCONTROLA pamxctrl;
     * } *PMIXERLINECONTROLSA
     * }
     */
    public static final AddressLayout PMIXERLINECONTROLSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERLINECONTROLSA {
     *     DWORD cbStruct;
     *     DWORD dwLineID;
     *     union {
     *         DWORD dwControlID;
     *         DWORD dwControlType;
     *     };
     *     DWORD cControls;
     *     DWORD cbmxctrl;
     *     LPMIXERCONTROLA pamxctrl;
     * } *LPMIXERLINECONTROLSA
     * }
     */
    public static final AddressLayout LPMIXERLINECONTROLSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERLINECONTROLSW {
     *     DWORD cbStruct;
     *     DWORD dwLineID;
     *     union {
     *         DWORD dwControlID;
     *         DWORD dwControlType;
     *     };
     *     DWORD cControls;
     *     DWORD cbmxctrl;
     *     LPMIXERCONTROLW pamxctrl;
     * } *PMIXERLINECONTROLSW
     * }
     */
    public static final AddressLayout PMIXERLINECONTROLSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERLINECONTROLSW {
     *     DWORD cbStruct;
     *     DWORD dwLineID;
     *     union {
     *         DWORD dwControlID;
     *         DWORD dwControlType;
     *     };
     *     DWORD cControls;
     *     DWORD cbmxctrl;
     *     LPMIXERCONTROLW pamxctrl;
     * } *LPMIXERLINECONTROLSW
     * }
     */
    public static final AddressLayout LPMIXERLINECONTROLSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIXERLINECONTROLSA PMIXERLINECONTROLS
     * }
     */
    public static final AddressLayout PMIXERLINECONTROLS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIXERLINECONTROLSA LPMIXERLINECONTROLS
     * }
     */
    public static final AddressLayout LPMIXERLINECONTROLS = winapi.C_POINTER;

    private static class mixerGetLineControlsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetLineControlsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls)
     * }
     */
    public static FunctionDescriptor mixerGetLineControlsA$descriptor() {
        return mixerGetLineControlsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls)
     * }
     */
    public static MethodHandle mixerGetLineControlsA$handle() {
        return mixerGetLineControlsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls)
     * }
     */
    public static MemorySegment mixerGetLineControlsA$address() {
        return mixerGetLineControlsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls)
     * }
     */
    public static int mixerGetLineControlsA(MemorySegment hmxobj, MemorySegment pmxlc, int fdwControls) {
        var mh$ = mixerGetLineControlsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetLineControlsA", hmxobj, pmxlc, fdwControls);
            }
            return (int)mh$.invokeExact(hmxobj, pmxlc, fdwControls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mixerGetLineControlsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetLineControlsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls)
     * }
     */
    public static FunctionDescriptor mixerGetLineControlsW$descriptor() {
        return mixerGetLineControlsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls)
     * }
     */
    public static MethodHandle mixerGetLineControlsW$handle() {
        return mixerGetLineControlsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls)
     * }
     */
    public static MemorySegment mixerGetLineControlsW$address() {
        return mixerGetLineControlsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls)
     * }
     */
    public static int mixerGetLineControlsW(MemorySegment hmxobj, MemorySegment pmxlc, int fdwControls) {
        var mh$ = mixerGetLineControlsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetLineControlsW", hmxobj, pmxlc, fdwControls);
            }
            return (int)mh$.invokeExact(hmxobj, pmxlc, fdwControls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tMIXERCONTROLDETAILS {
     *     DWORD cbStruct;
     *     DWORD dwControlID;
     *     DWORD cChannels;
     *     union {
     *         HWND hwndOwner;
     *         DWORD cMultipleItems;
     *     };
     *     DWORD cbDetails;
     *     LPVOID paDetails;
     * } *PMIXERCONTROLDETAILS
     * }
     */
    public static final AddressLayout PMIXERCONTROLDETAILS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tMIXERCONTROLDETAILS {
     *     DWORD cbStruct;
     *     DWORD dwControlID;
     *     DWORD cChannels;
     *     union {
     *         HWND hwndOwner;
     *         DWORD cMultipleItems;
     *     };
     *     DWORD cbDetails;
     *     LPVOID paDetails;
     * } *LPMIXERCONTROLDETAILS
     * }
     */
    public static final AddressLayout LPMIXERCONTROLDETAILS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA {
     *     DWORD dwParam1;
     *     DWORD dwParam2;
     *     CHAR szName[64];
     * } *PMIXERCONTROLDETAILS_LISTTEXTA
     * }
     */
    public static final AddressLayout PMIXERCONTROLDETAILS_LISTTEXTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA {
     *     DWORD dwParam1;
     *     DWORD dwParam2;
     *     CHAR szName[64];
     * } *LPMIXERCONTROLDETAILS_LISTTEXTA
     * }
     */
    public static final AddressLayout LPMIXERCONTROLDETAILS_LISTTEXTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW {
     *     DWORD dwParam1;
     *     DWORD dwParam2;
     *     WCHAR szName[64];
     * } *PMIXERCONTROLDETAILS_LISTTEXTW
     * }
     */
    public static final AddressLayout PMIXERCONTROLDETAILS_LISTTEXTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW {
     *     DWORD dwParam1;
     *     DWORD dwParam2;
     *     WCHAR szName[64];
     * } *LPMIXERCONTROLDETAILS_LISTTEXTW
     * }
     */
    public static final AddressLayout LPMIXERCONTROLDETAILS_LISTTEXTW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMIXERCONTROLDETAILS_LISTTEXTA PMIXERCONTROLDETAILS_LISTTEXT
     * }
     */
    public static final AddressLayout PMIXERCONTROLDETAILS_LISTTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMIXERCONTROLDETAILS_LISTTEXTA LPMIXERCONTROLDETAILS_LISTTEXT
     * }
     */
    public static final AddressLayout LPMIXERCONTROLDETAILS_LISTTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tMIXERCONTROLDETAILS_BOOLEAN {
     *     LONG fValue;
     * } *PMIXERCONTROLDETAILS_BOOLEAN
     * }
     */
    public static final AddressLayout PMIXERCONTROLDETAILS_BOOLEAN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tMIXERCONTROLDETAILS_BOOLEAN {
     *     LONG fValue;
     * } *LPMIXERCONTROLDETAILS_BOOLEAN
     * }
     */
    public static final AddressLayout LPMIXERCONTROLDETAILS_BOOLEAN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tMIXERCONTROLDETAILS_SIGNED {
     *     LONG lValue;
     * } *PMIXERCONTROLDETAILS_SIGNED
     * }
     */
    public static final AddressLayout PMIXERCONTROLDETAILS_SIGNED = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tMIXERCONTROLDETAILS_SIGNED {
     *     LONG lValue;
     * } *LPMIXERCONTROLDETAILS_SIGNED
     * }
     */
    public static final AddressLayout LPMIXERCONTROLDETAILS_SIGNED = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tMIXERCONTROLDETAILS_UNSIGNED {
     *     DWORD dwValue;
     * } *PMIXERCONTROLDETAILS_UNSIGNED
     * }
     */
    public static final AddressLayout PMIXERCONTROLDETAILS_UNSIGNED = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tMIXERCONTROLDETAILS_UNSIGNED {
     *     DWORD dwValue;
     * } *LPMIXERCONTROLDETAILS_UNSIGNED
     * }
     */
    public static final AddressLayout LPMIXERCONTROLDETAILS_UNSIGNED = winapi.C_POINTER;

    private static class mixerGetControlDetailsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetControlDetailsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static FunctionDescriptor mixerGetControlDetailsA$descriptor() {
        return mixerGetControlDetailsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static MethodHandle mixerGetControlDetailsA$handle() {
        return mixerGetControlDetailsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static MemorySegment mixerGetControlDetailsA$address() {
        return mixerGetControlDetailsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static int mixerGetControlDetailsA(MemorySegment hmxobj, MemorySegment pmxcd, int fdwDetails) {
        var mh$ = mixerGetControlDetailsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetControlDetailsA", hmxobj, pmxcd, fdwDetails);
            }
            return (int)mh$.invokeExact(hmxobj, pmxcd, fdwDetails);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mixerGetControlDetailsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerGetControlDetailsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static FunctionDescriptor mixerGetControlDetailsW$descriptor() {
        return mixerGetControlDetailsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static MethodHandle mixerGetControlDetailsW$handle() {
        return mixerGetControlDetailsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static MemorySegment mixerGetControlDetailsW$address() {
        return mixerGetControlDetailsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static int mixerGetControlDetailsW(MemorySegment hmxobj, MemorySegment pmxcd, int fdwDetails) {
        var mh$ = mixerGetControlDetailsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerGetControlDetailsW", hmxobj, pmxcd, fdwDetails);
            }
            return (int)mh$.invokeExact(hmxobj, pmxcd, fdwDetails);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mixerSetControlDetails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("mixerSetControlDetails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static FunctionDescriptor mixerSetControlDetails$descriptor() {
        return mixerSetControlDetails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static MethodHandle mixerSetControlDetails$handle() {
        return mixerSetControlDetails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static MemorySegment mixerSetControlDetails$address() {
        return mixerSetControlDetails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails)
     * }
     */
    public static int mixerSetControlDetails(MemorySegment hmxobj, MemorySegment pmxcd, int fdwDetails) {
        var mh$ = mixerSetControlDetails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mixerSetControlDetails", hmxobj, pmxcd, fdwDetails);
            }
            return (int)mh$.invokeExact(hmxobj, pmxcd, fdwDetails);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct timecaps_tag {
     *     UINT wPeriodMin;
     *     UINT wPeriodMax;
     * } *PTIMECAPS
     * }
     */
    public static final AddressLayout PTIMECAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct timecaps_tag {
     *     UINT wPeriodMin;
     *     UINT wPeriodMax;
     * } *NPTIMECAPS
     * }
     */
    public static final AddressLayout NPTIMECAPS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct timecaps_tag {
     *     UINT wPeriodMin;
     *     UINT wPeriodMax;
     * } *LPTIMECAPS
     * }
     */
    public static final AddressLayout LPTIMECAPS = winapi.C_POINTER;

    private static class timeGetSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("timeGetSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static FunctionDescriptor timeGetSystemTime$descriptor() {
        return timeGetSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static MethodHandle timeGetSystemTime$handle() {
        return timeGetSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static MemorySegment timeGetSystemTime$address() {
        return timeGetSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt)
     * }
     */
    public static int timeGetSystemTime(MemorySegment pmmt, int cbmmt) {
        var mh$ = timeGetSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timeGetSystemTime", pmmt, cbmmt);
            }
            return (int)mh$.invokeExact(pmmt, cbmmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timeGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("timeGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD timeGetTime()
     * }
     */
    public static FunctionDescriptor timeGetTime$descriptor() {
        return timeGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD timeGetTime()
     * }
     */
    public static MethodHandle timeGetTime$handle() {
        return timeGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD timeGetTime()
     * }
     */
    public static MemorySegment timeGetTime$address() {
        return timeGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD timeGetTime()
     * }
     */
    public static int timeGetTime() {
        var mh$ = timeGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timeGetTime");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timeGetDevCaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("timeGetDevCaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc)
     * }
     */
    public static FunctionDescriptor timeGetDevCaps$descriptor() {
        return timeGetDevCaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc)
     * }
     */
    public static MethodHandle timeGetDevCaps$handle() {
        return timeGetDevCaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc)
     * }
     */
    public static MemorySegment timeGetDevCaps$address() {
        return timeGetDevCaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc)
     * }
     */
    public static int timeGetDevCaps(MemorySegment ptc, int cbtc) {
        var mh$ = timeGetDevCaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timeGetDevCaps", ptc, cbtc);
            }
            return (int)mh$.invokeExact(ptc, cbtc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timeBeginPeriod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("timeBeginPeriod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT timeBeginPeriod(UINT uPeriod)
     * }
     */
    public static FunctionDescriptor timeBeginPeriod$descriptor() {
        return timeBeginPeriod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT timeBeginPeriod(UINT uPeriod)
     * }
     */
    public static MethodHandle timeBeginPeriod$handle() {
        return timeBeginPeriod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT timeBeginPeriod(UINT uPeriod)
     * }
     */
    public static MemorySegment timeBeginPeriod$address() {
        return timeBeginPeriod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT timeBeginPeriod(UINT uPeriod)
     * }
     */
    public static int timeBeginPeriod(int uPeriod) {
        var mh$ = timeBeginPeriod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timeBeginPeriod", uPeriod);
            }
            return (int)mh$.invokeExact(uPeriod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timeEndPeriod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("timeEndPeriod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * MMRESULT timeEndPeriod(UINT uPeriod)
     * }
     */
    public static FunctionDescriptor timeEndPeriod$descriptor() {
        return timeEndPeriod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * MMRESULT timeEndPeriod(UINT uPeriod)
     * }
     */
    public static MethodHandle timeEndPeriod$handle() {
        return timeEndPeriod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * MMRESULT timeEndPeriod(UINT uPeriod)
     * }
     */
    public static MemorySegment timeEndPeriod$address() {
        return timeEndPeriod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * MMRESULT timeEndPeriod(UINT uPeriod)
     * }
     */
    public static int timeEndPeriod(int uPeriod) {
        var mh$ = timeEndPeriod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timeEndPeriod", uPeriod);
            }
            return (int)mh$.invokeExact(uPeriod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagJOYCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     CHAR szPname[32];
     *     UINT wXmin;
     *     UINT wXmax;
     *     UINT wYmin;
     *     UINT wYmax;
     *     UINT wZmin;
     *     UINT wZmax;
     *     UINT wNumButtons;
     *     UINT wPeriodMin;
     *     UINT wPeriodMax;
     *     UINT wRmin;
     *     UINT wRmax;
     *     UINT wUmin;
     *     UINT wUmax;
     *     UINT wVmin;
     *     UINT wVmax;
     *     UINT wCaps;
     *     UINT wMaxAxes;
     *     UINT wNumAxes;
     *     UINT wMaxButtons;
     *     CHAR szRegKey[32];
     *     CHAR szOEMVxD[260];
     * } *PJOYCAPSA
     * }
     */
    public static final AddressLayout PJOYCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagJOYCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     CHAR szPname[32];
     *     UINT wXmin;
     *     UINT wXmax;
     *     UINT wYmin;
     *     UINT wYmax;
     *     UINT wZmin;
     *     UINT wZmax;
     *     UINT wNumButtons;
     *     UINT wPeriodMin;
     *     UINT wPeriodMax;
     *     UINT wRmin;
     *     UINT wRmax;
     *     UINT wUmin;
     *     UINT wUmax;
     *     UINT wVmin;
     *     UINT wVmax;
     *     UINT wCaps;
     *     UINT wMaxAxes;
     *     UINT wNumAxes;
     *     UINT wMaxButtons;
     *     CHAR szRegKey[32];
     *     CHAR szOEMVxD[260];
     * } *NPJOYCAPSA
     * }
     */
    public static final AddressLayout NPJOYCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagJOYCAPSA {
     *     WORD wMid;
     *     WORD wPid;
     *     CHAR szPname[32];
     *     UINT wXmin;
     *     UINT wXmax;
     *     UINT wYmin;
     *     UINT wYmax;
     *     UINT wZmin;
     *     UINT wZmax;
     *     UINT wNumButtons;
     *     UINT wPeriodMin;
     *     UINT wPeriodMax;
     *     UINT wRmin;
     *     UINT wRmax;
     *     UINT wUmin;
     *     UINT wUmax;
     *     UINT wVmin;
     *     UINT wVmax;
     *     UINT wCaps;
     *     UINT wMaxAxes;
     *     UINT wNumAxes;
     *     UINT wMaxButtons;
     *     CHAR szRegKey[32];
     *     CHAR szOEMVxD[260];
     * } *LPJOYCAPSA
     * }
     */
    public static final AddressLayout LPJOYCAPSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagJOYCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     WCHAR szPname[32];
     *     UINT wXmin;
     *     UINT wXmax;
     *     UINT wYmin;
     *     UINT wYmax;
     *     UINT wZmin;
     *     UINT wZmax;
     *     UINT wNumButtons;
     *     UINT wPeriodMin;
     *     UINT wPeriodMax;
     *     UINT wRmin;
     *     UINT wRmax;
     *     UINT wUmin;
     *     UINT wUmax;
     *     UINT wVmin;
     *     UINT wVmax;
     *     UINT wCaps;
     *     UINT wMaxAxes;
     *     UINT wNumAxes;
     *     UINT wMaxButtons;
     *     WCHAR szRegKey[32];
     *     WCHAR szOEMVxD[260];
     * } *PJOYCAPSW
     * }
     */
    public static final AddressLayout PJOYCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagJOYCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     WCHAR szPname[32];
     *     UINT wXmin;
     *     UINT wXmax;
     *     UINT wYmin;
     *     UINT wYmax;
     *     UINT wZmin;
     *     UINT wZmax;
     *     UINT wNumButtons;
     *     UINT wPeriodMin;
     *     UINT wPeriodMax;
     *     UINT wRmin;
     *     UINT wRmax;
     *     UINT wUmin;
     *     UINT wUmax;
     *     UINT wVmin;
     *     UINT wVmax;
     *     UINT wCaps;
     *     UINT wMaxAxes;
     *     UINT wNumAxes;
     *     UINT wMaxButtons;
     *     WCHAR szRegKey[32];
     *     WCHAR szOEMVxD[260];
     * } *NPJOYCAPSW
     * }
     */
    public static final AddressLayout NPJOYCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagJOYCAPSW {
     *     WORD wMid;
     *     WORD wPid;
     *     WCHAR szPname[32];
     *     UINT wXmin;
     *     UINT wXmax;
     *     UINT wYmin;
     *     UINT wYmax;
     *     UINT wZmin;
     *     UINT wZmax;
     *     UINT wNumButtons;
     *     UINT wPeriodMin;
     *     UINT wPeriodMax;
     *     UINT wRmin;
     *     UINT wRmax;
     *     UINT wUmin;
     *     UINT wUmax;
     *     UINT wVmin;
     *     UINT wVmax;
     *     UINT wCaps;
     *     UINT wMaxAxes;
     *     UINT wNumAxes;
     *     UINT wMaxButtons;
     *     WCHAR szRegKey[32];
     *     WCHAR szOEMVxD[260];
     * } *LPJOYCAPSW
     * }
     */
    public static final AddressLayout LPJOYCAPSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PJOYCAPSA PJOYCAPS
     * }
     */
    public static final AddressLayout PJOYCAPS = winapi.C_POINTER;
}

