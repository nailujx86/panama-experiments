// Generated by jextract

package net.nailuj.win;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class winapi_19 extends winapi_20 {

    winapi_19() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CSP_PROVIDER {
     *     DWORD dwKeySpec;
     *     LPWSTR pwszProviderName;
     *     CRYPT_BIT_BLOB Signature;
     * } *PCRYPT_CSP_PROVIDER
     * }
     */
    public static final AddressLayout PCRYPT_CSP_PROVIDER = winapi.C_POINTER;

    private static class CryptFormatObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptFormatObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static FunctionDescriptor CryptFormatObject$descriptor() {
        return CryptFormatObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static MethodHandle CryptFormatObject$handle() {
        return CryptFormatObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static MemorySegment CryptFormatObject$address() {
        return CryptFormatObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static int CryptFormatObject(int dwCertEncodingType, int dwFormatType, int dwFormatStrType, MemorySegment pFormatStruct, MemorySegment lpszStructType, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbFormat, MemorySegment pcbFormat) {
        var mh$ = CryptFormatObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFormatObject", dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct, lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct, lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENCODE_PARA {
     *     DWORD cbSize;
     *     PFN_CRYPT_ALLOC pfnAlloc;
     *     PFN_CRYPT_FREE pfnFree;
     * } *PCRYPT_ENCODE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_ENCODE_PARA = winapi.C_POINTER;

    private static class CryptEncodeObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptEncodeObjectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptEncodeObjectEx$descriptor() {
        return CryptEncodeObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptEncodeObjectEx$handle() {
        return CryptEncodeObjectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptEncodeObjectEx$address() {
        return CryptEncodeObjectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptEncodeObjectEx(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pvStructInfo, int dwFlags, MemorySegment pEncodePara, MemorySegment pvEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptEncodeObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncodeObjectEx", dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pvEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pvEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEncodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptEncodeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptEncodeObject$descriptor() {
        return CryptEncodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptEncodeObject$handle() {
        return CryptEncodeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptEncodeObject$address() {
        return CryptEncodeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptEncodeObject(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pvStructInfo, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptEncodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncodeObject", dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DECODE_PARA {
     *     DWORD cbSize;
     *     PFN_CRYPT_ALLOC pfnAlloc;
     *     PFN_CRYPT_FREE pfnFree;
     * } *PCRYPT_DECODE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_DECODE_PARA = winapi.C_POINTER;

    private static class CryptDecodeObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptDecodeObjectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static FunctionDescriptor CryptDecodeObjectEx$descriptor() {
        return CryptDecodeObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MethodHandle CryptDecodeObjectEx$handle() {
        return CryptDecodeObjectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MemorySegment CryptDecodeObjectEx$address() {
        return CryptDecodeObjectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static int CryptDecodeObjectEx(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pbEncoded, int cbEncoded, int dwFlags, MemorySegment pDecodePara, MemorySegment pvStructInfo, MemorySegment pcbStructInfo) {
        var mh$ = CryptDecodeObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecodeObjectEx", dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptDecodeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static FunctionDescriptor CryptDecodeObject$descriptor() {
        return CryptDecodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MethodHandle CryptDecodeObject$handle() {
        return CryptDecodeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MemorySegment CryptDecodeObject$address() {
        return CryptDecodeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static int CryptDecodeObject(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pbEncoded, int cbEncoded, int dwFlags, MemorySegment pvStructInfo, MemorySegment pcbStructInfo) {
        var mh$ = CryptDecodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecodeObject", dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_EXTENSIONS {
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCERT_EXTENSIONS
     * }
     */
    public static final AddressLayout PCERT_EXTENSIONS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_KEY_ID_INFO {
     *     CRYPT_DATA_BLOB KeyId;
     *     CERT_NAME_BLOB CertIssuer;
     *     CRYPT_INTEGER_BLOB CertSerialNumber;
     * } *PCERT_AUTHORITY_KEY_ID_INFO
     * }
     */
    public static final AddressLayout PCERT_AUTHORITY_KEY_ID_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PRIVATE_KEY_VALIDITY {
     *     FILETIME NotBefore;
     *     FILETIME NotAfter;
     * } *PCERT_PRIVATE_KEY_VALIDITY
     * }
     */
    public static final AddressLayout PCERT_PRIVATE_KEY_VALIDITY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEY_ATTRIBUTES_INFO {
     *     CRYPT_DATA_BLOB KeyId;
     *     CRYPT_BIT_BLOB IntendedKeyUsage;
     *     PCERT_PRIVATE_KEY_VALIDITY pPrivateKeyUsagePeriod;
     * } *PCERT_KEY_ATTRIBUTES_INFO
     * }
     */
    public static final AddressLayout PCERT_KEY_ATTRIBUTES_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_ID {
     *     DWORD cCertPolicyElementId;
     *     LPSTR *rgpszCertPolicyElementId;
     * } *PCERT_POLICY_ID
     * }
     */
    public static final AddressLayout PCERT_POLICY_ID = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEY_USAGE_RESTRICTION_INFO {
     *     DWORD cCertPolicyId;
     *     PCERT_POLICY_ID rgCertPolicyId;
     *     CRYPT_BIT_BLOB RestrictedKeyUsage;
     * } *PCERT_KEY_USAGE_RESTRICTION_INFO
     * }
     */
    public static final AddressLayout PCERT_KEY_USAGE_RESTRICTION_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OTHER_NAME {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCERT_OTHER_NAME
     * }
     */
    public static final AddressLayout PCERT_OTHER_NAME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ALT_NAME_ENTRY {
     *     DWORD dwAltNameChoice;
     *     union {
     *         PCERT_OTHER_NAME pOtherName;
     *         LPWSTR pwszRfc822Name;
     *         LPWSTR pwszDNSName;
     *         CERT_NAME_BLOB DirectoryName;
     *         LPWSTR pwszURL;
     *         CRYPT_DATA_BLOB IPAddress;
     *         LPSTR pszRegisteredID;
     *     };
     * } *PCERT_ALT_NAME_ENTRY
     * }
     */
    public static final AddressLayout PCERT_ALT_NAME_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ALT_NAME_INFO {
     *     DWORD cAltEntry;
     *     PCERT_ALT_NAME_ENTRY rgAltEntry;
     * } *PCERT_ALT_NAME_INFO
     * }
     */
    public static final AddressLayout PCERT_ALT_NAME_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BASIC_CONSTRAINTS_INFO {
     *     CRYPT_BIT_BLOB SubjectType;
     *     BOOL fPathLenConstraint;
     *     DWORD dwPathLenConstraint;
     *     DWORD cSubtreesConstraint;
     *     CERT_NAME_BLOB *rgSubtreesConstraint;
     * } *PCERT_BASIC_CONSTRAINTS_INFO
     * }
     */
    public static final AddressLayout PCERT_BASIC_CONSTRAINTS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BASIC_CONSTRAINTS2_INFO {
     *     BOOL fCA;
     *     BOOL fPathLenConstraint;
     *     DWORD dwPathLenConstraint;
     * } *PCERT_BASIC_CONSTRAINTS2_INFO
     * }
     */
    public static final AddressLayout PCERT_BASIC_CONSTRAINTS2_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_QUALIFIER_INFO {
     *     LPSTR pszPolicyQualifierId;
     *     CRYPT_OBJID_BLOB Qualifier;
     * } *PCERT_POLICY_QUALIFIER_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_QUALIFIER_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_INFO {
     *     LPSTR pszPolicyIdentifier;
     *     DWORD cPolicyQualifier;
     *     CERT_POLICY_QUALIFIER_INFO *rgPolicyQualifier;
     * } *PCERT_POLICY_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICIES_INFO {
     *     DWORD cPolicyInfo;
     *     CERT_POLICY_INFO *rgPolicyInfo;
     * } *PCERT_POLICIES_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICIES_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE {
     *     LPSTR pszOrganization;
     *     DWORD cNoticeNumbers;
     *     int *rgNoticeNumbers;
     * } *PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE
     * }
     */
    public static final AddressLayout PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_QUALIFIER_USER_NOTICE {
     *     CERT_POLICY_QUALIFIER_NOTICE_REFERENCE *pNoticeReference;
     *     LPWSTR pszDisplayText;
     * } *PCERT_POLICY_QUALIFIER_USER_NOTICE
     * }
     */
    public static final AddressLayout PCERT_POLICY_QUALIFIER_USER_NOTICE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CPS_URLS {
     *     LPWSTR pszURL;
     *     CRYPT_ALGORITHM_IDENTIFIER *pAlgorithm;
     *     CRYPT_DATA_BLOB *pDigest;
     * } *PCPS_URLS
     * }
     */
    public static final AddressLayout PCPS_URLS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY95_QUALIFIER1 {
     *     LPWSTR pszPracticesReference;
     *     LPSTR pszNoticeIdentifier;
     *     LPSTR pszNSINoticeIdentifier;
     *     DWORD cCPSURLs;
     *     CPS_URLS *rgCPSURLs;
     * } *PCERT_POLICY95_QUALIFIER1
     * }
     */
    public static final AddressLayout PCERT_POLICY95_QUALIFIER1 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_MAPPING {
     *     LPSTR pszIssuerDomainPolicy;
     *     LPSTR pszSubjectDomainPolicy;
     * } *PCERT_POLICY_MAPPING
     * }
     */
    public static final AddressLayout PCERT_POLICY_MAPPING = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_MAPPINGS_INFO {
     *     DWORD cPolicyMapping;
     *     PCERT_POLICY_MAPPING rgPolicyMapping;
     * } *PCERT_POLICY_MAPPINGS_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_MAPPINGS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_CONSTRAINTS_INFO {
     *     BOOL fRequireExplicitPolicy;
     *     DWORD dwRequireExplicitPolicySkipCerts;
     *     BOOL fInhibitPolicyMapping;
     *     DWORD dwInhibitPolicyMappingSkipCerts;
     * } *PCERT_POLICY_CONSTRAINTS_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_CONSTRAINTS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY {
     *     LPSTR pszObjId;
     *     DWORD cValue;
     *     PCRYPT_DER_BLOB rgValue;
     * } *PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY
     * }
     */
    public static final AddressLayout PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTENT_INFO {
     *     LPSTR pszObjId;
     *     CRYPT_DER_BLOB Content;
     * } *PCRYPT_CONTENT_INFO
     * }
     */
    public static final AddressLayout PCRYPT_CONTENT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SEQUENCE_OF_ANY {
     *     DWORD cValue;
     *     PCRYPT_DER_BLOB rgValue;
     * } *PCRYPT_SEQUENCE_OF_ANY
     * }
     */
    public static final AddressLayout PCRYPT_SEQUENCE_OF_ANY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_KEY_ID2_INFO {
     *     CRYPT_DATA_BLOB KeyId;
     *     CERT_ALT_NAME_INFO AuthorityCertIssuer;
     *     CRYPT_INTEGER_BLOB AuthorityCertSerialNumber;
     * } *PCERT_AUTHORITY_KEY_ID2_INFO
     * }
     */
    public static final AddressLayout PCERT_AUTHORITY_KEY_ID2_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ACCESS_DESCRIPTION {
     *     LPSTR pszAccessMethod;
     *     CERT_ALT_NAME_ENTRY AccessLocation;
     * } *PCERT_ACCESS_DESCRIPTION
     * }
     */
    public static final AddressLayout PCERT_ACCESS_DESCRIPTION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_INFO_ACCESS {
     *     DWORD cAccDescr;
     *     PCERT_ACCESS_DESCRIPTION rgAccDescr;
     * } *PCERT_AUTHORITY_INFO_ACCESS
     * }
     */
    public static final AddressLayout PCERT_AUTHORITY_INFO_ACCESS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_INFO_ACCESS {
     *     DWORD cAccDescr;
     *     PCERT_ACCESS_DESCRIPTION rgAccDescr;
     * } *PCERT_SUBJECT_INFO_ACCESS
     * }
     */
    public static final AddressLayout PCERT_SUBJECT_INFO_ACCESS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_DIST_POINT_NAME {
     *     DWORD dwDistPointNameChoice;
     *     union {
     *         CERT_ALT_NAME_INFO FullName;
     *     };
     * } *PCRL_DIST_POINT_NAME
     * }
     */
    public static final AddressLayout PCRL_DIST_POINT_NAME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_DIST_POINT {
     *     CRL_DIST_POINT_NAME DistPointName;
     *     CRYPT_BIT_BLOB ReasonFlags;
     *     CERT_ALT_NAME_INFO CRLIssuer;
     * } *PCRL_DIST_POINT
     * }
     */
    public static final AddressLayout PCRL_DIST_POINT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_DIST_POINTS_INFO {
     *     DWORD cDistPoint;
     *     PCRL_DIST_POINT rgDistPoint;
     * } *PCRL_DIST_POINTS_INFO
     * }
     */
    public static final AddressLayout PCRL_DIST_POINTS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CROSS_CERT_DIST_POINTS_INFO {
     *     DWORD dwSyncDeltaTime;
     *     DWORD cDistPoint;
     *     PCERT_ALT_NAME_INFO rgDistPoint;
     * } *PCROSS_CERT_DIST_POINTS_INFO
     * }
     */
    public static final AddressLayout PCROSS_CERT_DIST_POINTS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PAIR {
     *     CERT_BLOB Forward;
     *     CERT_BLOB Reverse;
     * } *PCERT_PAIR
     * }
     */
    public static final AddressLayout PCERT_PAIR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_ISSUING_DIST_POINT {
     *     CRL_DIST_POINT_NAME DistPointName;
     *     BOOL fOnlyContainsUserCerts;
     *     BOOL fOnlyContainsCACerts;
     *     CRYPT_BIT_BLOB OnlySomeReasonFlags;
     *     BOOL fIndirectCRL;
     * } *PCRL_ISSUING_DIST_POINT
     * }
     */
    public static final AddressLayout PCRL_ISSUING_DIST_POINT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_GENERAL_SUBTREE {
     *     CERT_ALT_NAME_ENTRY Base;
     *     DWORD dwMinimum;
     *     BOOL fMaximum;
     *     DWORD dwMaximum;
     * } *PCERT_GENERAL_SUBTREE
     * }
     */
    public static final AddressLayout PCERT_GENERAL_SUBTREE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_NAME_CONSTRAINTS_INFO {
     *     DWORD cPermittedSubtree;
     *     PCERT_GENERAL_SUBTREE rgPermittedSubtree;
     *     DWORD cExcludedSubtree;
     *     PCERT_GENERAL_SUBTREE rgExcludedSubtree;
     * } *PCERT_NAME_CONSTRAINTS_INFO
     * }
     */
    public static final AddressLayout PCERT_NAME_CONSTRAINTS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_DSS_PARAMETERS {
     *     CRYPT_UINT_BLOB p;
     *     CRYPT_UINT_BLOB q;
     *     CRYPT_UINT_BLOB g;
     * } *PCERT_DSS_PARAMETERS
     * }
     */
    public static final AddressLayout PCERT_DSS_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_DH_PARAMETERS {
     *     CRYPT_UINT_BLOB p;
     *     CRYPT_UINT_BLOB g;
     * } *PCERT_DH_PARAMETERS
     * }
     */
    public static final AddressLayout PCERT_DH_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ECC_SIGNATURE {
     *     CRYPT_UINT_BLOB r;
     *     CRYPT_UINT_BLOB s;
     * } *PCERT_ECC_SIGNATURE
     * }
     */
    public static final AddressLayout PCERT_ECC_SIGNATURE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_X942_DH_VALIDATION_PARAMS {
     *     CRYPT_BIT_BLOB seed;
     *     DWORD pgenCounter;
     * } *PCERT_X942_DH_VALIDATION_PARAMS
     * }
     */
    public static final AddressLayout PCERT_X942_DH_VALIDATION_PARAMS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_X942_DH_PARAMETERS {
     *     CRYPT_UINT_BLOB p;
     *     CRYPT_UINT_BLOB g;
     *     CRYPT_UINT_BLOB q;
     *     CRYPT_UINT_BLOB j;
     *     PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;
     * } *PCERT_X942_DH_PARAMETERS
     * }
     */
    public static final AddressLayout PCERT_X942_DH_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_X942_OTHER_INFO {
     *     LPSTR pszContentEncryptionObjId;
     *     BYTE rgbCounter[4];
     *     BYTE rgbKeyLength[4];
     *     CRYPT_DATA_BLOB PubInfo;
     * } *PCRYPT_X942_OTHER_INFO
     * }
     */
    public static final AddressLayout PCRYPT_X942_OTHER_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ECC_CMS_SHARED_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_DATA_BLOB EntityUInfo;
     *     BYTE rgbSuppPubInfo[4];
     * } *PCRYPT_ECC_CMS_SHARED_INFO
     * }
     */
    public static final AddressLayout PCRYPT_ECC_CMS_SHARED_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RC2_CBC_PARAMETERS {
     *     DWORD dwVersion;
     *     BOOL fIV;
     *     BYTE rgbIV[8];
     * } *PCRYPT_RC2_CBC_PARAMETERS
     * }
     */
    public static final AddressLayout PCRYPT_RC2_CBC_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SMIME_CAPABILITY {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Parameters;
     * } *PCRYPT_SMIME_CAPABILITY
     * }
     */
    public static final AddressLayout PCRYPT_SMIME_CAPABILITY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SMIME_CAPABILITIES {
     *     DWORD cCapability;
     *     PCRYPT_SMIME_CAPABILITY rgCapability;
     * } *PCRYPT_SMIME_CAPABILITIES
     * }
     */
    public static final AddressLayout PCRYPT_SMIME_CAPABILITIES = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_QC_STATEMENT {
     *     LPSTR pszStatementId;
     *     CRYPT_OBJID_BLOB StatementInfo;
     * } *PCERT_QC_STATEMENT
     * }
     */
    public static final AddressLayout PCERT_QC_STATEMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_QC_STATEMENTS_EXT_INFO {
     *     DWORD cStatement;
     *     PCERT_QC_STATEMENT rgStatement;
     * } *PCERT_QC_STATEMENTS_EXT_INFO
     * }
     */
    public static final AddressLayout PCERT_QC_STATEMENTS_EXT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_MASK_GEN_ALGORITHM {
     *     LPSTR pszObjId;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     * } *PCRYPT_MASK_GEN_ALGORITHM
     * }
     */
    public static final AddressLayout PCRYPT_MASK_GEN_ALGORITHM = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RSA_SSA_PSS_PARAMETERS {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_MASK_GEN_ALGORITHM MaskGenAlgorithm;
     *     DWORD dwSaltLength;
     *     DWORD dwTrailerField;
     * } *PCRYPT_RSA_SSA_PSS_PARAMETERS
     * }
     */
    public static final AddressLayout PCRYPT_RSA_SSA_PSS_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PSOURCE_ALGORITHM {
     *     LPSTR pszObjId;
     *     CRYPT_DATA_BLOB EncodingParameters;
     * } *PCRYPT_PSOURCE_ALGORITHM
     * }
     */
    public static final AddressLayout PCRYPT_PSOURCE_ALGORITHM = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RSAES_OAEP_PARAMETERS {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_MASK_GEN_ALGORITHM MaskGenAlgorithm;
     *     CRYPT_PSOURCE_ALGORITHM PSourceAlgorithm;
     * } *PCRYPT_RSAES_OAEP_PARAMETERS
     * }
     */
    public static final AddressLayout PCRYPT_RSAES_OAEP_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_ATTRIBUTE {
     *     DWORD dwBodyPartID;
     *     CRYPT_ATTRIBUTE Attribute;
     * } *PCMC_TAGGED_ATTRIBUTE
     * }
     */
    public static final AddressLayout PCMC_TAGGED_ATTRIBUTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_CERT_REQUEST {
     *     DWORD dwBodyPartID;
     *     CRYPT_DER_BLOB SignedCertRequest;
     * } *PCMC_TAGGED_CERT_REQUEST
     * }
     */
    public static final AddressLayout PCMC_TAGGED_CERT_REQUEST = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_REQUEST {
     *     DWORD dwTaggedRequestChoice;
     *     union {
     *         PCMC_TAGGED_CERT_REQUEST pTaggedCertRequest;
     *     };
     * } *PCMC_TAGGED_REQUEST
     * }
     */
    public static final AddressLayout PCMC_TAGGED_REQUEST = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_CONTENT_INFO {
     *     DWORD dwBodyPartID;
     *     CRYPT_DER_BLOB EncodedContentInfo;
     * } *PCMC_TAGGED_CONTENT_INFO
     * }
     */
    public static final AddressLayout PCMC_TAGGED_CONTENT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_OTHER_MSG {
     *     DWORD dwBodyPartID;
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCMC_TAGGED_OTHER_MSG
     * }
     */
    public static final AddressLayout PCMC_TAGGED_OTHER_MSG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_DATA_INFO {
     *     DWORD cTaggedAttribute;
     *     PCMC_TAGGED_ATTRIBUTE rgTaggedAttribute;
     *     DWORD cTaggedRequest;
     *     PCMC_TAGGED_REQUEST rgTaggedRequest;
     *     DWORD cTaggedContentInfo;
     *     PCMC_TAGGED_CONTENT_INFO rgTaggedContentInfo;
     *     DWORD cTaggedOtherMsg;
     *     PCMC_TAGGED_OTHER_MSG rgTaggedOtherMsg;
     * } *PCMC_DATA_INFO
     * }
     */
    public static final AddressLayout PCMC_DATA_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_RESPONSE_INFO {
     *     DWORD cTaggedAttribute;
     *     PCMC_TAGGED_ATTRIBUTE rgTaggedAttribute;
     *     DWORD cTaggedContentInfo;
     *     PCMC_TAGGED_CONTENT_INFO rgTaggedContentInfo;
     *     DWORD cTaggedOtherMsg;
     *     PCMC_TAGGED_OTHER_MSG rgTaggedOtherMsg;
     * } *PCMC_RESPONSE_INFO
     * }
     */
    public static final AddressLayout PCMC_RESPONSE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_PEND_INFO {
     *     CRYPT_DATA_BLOB PendToken;
     *     FILETIME PendTime;
     * } *PCMC_PEND_INFO
     * }
     */
    public static final AddressLayout PCMC_PEND_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_STATUS_INFO {
     *     DWORD dwStatus;
     *     DWORD cBodyList;
     *     DWORD *rgdwBodyList;
     *     LPWSTR pwszStatusString;
     *     DWORD dwOtherInfoChoice;
     *     union {
     *         DWORD dwFailInfo;
     *         PCMC_PEND_INFO pPendInfo;
     *     };
     * } *PCMC_STATUS_INFO
     * }
     */
    public static final AddressLayout PCMC_STATUS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_ADD_EXTENSIONS_INFO {
     *     DWORD dwCmcDataReference;
     *     DWORD cCertReference;
     *     DWORD *rgdwCertReference;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCMC_ADD_EXTENSIONS_INFO
     * }
     */
    public static final AddressLayout PCMC_ADD_EXTENSIONS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_ADD_ATTRIBUTES_INFO {
     *     DWORD dwCmcDataReference;
     *     DWORD cCertReference;
     *     DWORD *rgdwCertReference;
     *     DWORD cAttribute;
     *     PCRYPT_ATTRIBUTE rgAttribute;
     * } *PCMC_ADD_ATTRIBUTES_INFO
     * }
     */
    public static final AddressLayout PCMC_ADD_ATTRIBUTES_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TEMPLATE_EXT {
     *     LPSTR pszObjId;
     *     DWORD dwMajorVersion;
     *     BOOL fMinorVersion;
     *     DWORD dwMinorVersion;
     * } *PCERT_TEMPLATE_EXT
     * }
     */
    public static final AddressLayout PCERT_TEMPLATE_EXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_HASHED_URL {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_HASH_BLOB Hash;
     *     LPWSTR pwszUrl;
     * } *PCERT_HASHED_URL
     * }
     */
    public static final AddressLayout PCERT_HASHED_URL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_DETAILS {
     *     LPWSTR pwszMimeType;
     *     DWORD cHashedUrl;
     *     PCERT_HASHED_URL rgHashedUrl;
     * } *PCERT_LOGOTYPE_DETAILS
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_DETAILS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_REFERENCE {
     *     DWORD cHashedUrl;
     *     PCERT_HASHED_URL rgHashedUrl;
     * } *PCERT_LOGOTYPE_REFERENCE
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_REFERENCE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_IMAGE_INFO {
     *     DWORD dwLogotypeImageInfoChoice;
     *     DWORD dwFileSize;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwLogotypeImageResolutionChoice;
     *     union {
     *         DWORD dwNumBits;
     *         DWORD dwTableSize;
     *     };
     *     LPWSTR pwszLanguage;
     * } *PCERT_LOGOTYPE_IMAGE_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_IMAGE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_IMAGE {
     *     CERT_LOGOTYPE_DETAILS LogotypeDetails;
     *     PCERT_LOGOTYPE_IMAGE_INFO pLogotypeImageInfo;
     * } *PCERT_LOGOTYPE_IMAGE
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_IMAGE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_AUDIO_INFO {
     *     DWORD dwFileSize;
     *     DWORD dwPlayTime;
     *     DWORD dwChannels;
     *     DWORD dwSampleRate;
     *     LPWSTR pwszLanguage;
     * } *PCERT_LOGOTYPE_AUDIO_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_AUDIO_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_AUDIO {
     *     CERT_LOGOTYPE_DETAILS LogotypeDetails;
     *     PCERT_LOGOTYPE_AUDIO_INFO pLogotypeAudioInfo;
     * } *PCERT_LOGOTYPE_AUDIO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_AUDIO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_DATA {
     *     DWORD cLogotypeImage;
     *     PCERT_LOGOTYPE_IMAGE rgLogotypeImage;
     *     DWORD cLogotypeAudio;
     *     PCERT_LOGOTYPE_AUDIO rgLogotypeAudio;
     * } *PCERT_LOGOTYPE_DATA
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_DATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_INFO {
     *     DWORD dwLogotypeInfoChoice;
     *     union {
     *         PCERT_LOGOTYPE_DATA pLogotypeDirectInfo;
     *         PCERT_LOGOTYPE_REFERENCE pLogotypeIndirectInfo;
     *     };
     * } *PCERT_LOGOTYPE_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OTHER_LOGOTYPE_INFO {
     *     LPSTR pszObjId;
     *     CERT_LOGOTYPE_INFO LogotypeInfo;
     * } *PCERT_OTHER_LOGOTYPE_INFO
     * }
     */
    public static final AddressLayout PCERT_OTHER_LOGOTYPE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_EXT_INFO {
     *     DWORD cCommunityLogo;
     *     PCERT_LOGOTYPE_INFO rgCommunityLogo;
     *     PCERT_LOGOTYPE_INFO pIssuerLogo;
     *     PCERT_LOGOTYPE_INFO pSubjectLogo;
     *     DWORD cOtherLogo;
     *     PCERT_OTHER_LOGOTYPE_INFO rgOtherLogo;
     * } *PCERT_LOGOTYPE_EXT_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_EXT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BIOMETRIC_DATA {
     *     DWORD dwTypeOfBiometricDataChoice;
     *     union {
     *         DWORD dwPredefined;
     *         LPSTR pszObjId;
     *     };
     *     CERT_HASHED_URL HashedUrl;
     * } *PCERT_BIOMETRIC_DATA
     * }
     */
    public static final AddressLayout PCERT_BIOMETRIC_DATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BIOMETRIC_EXT_INFO {
     *     DWORD cBiometricData;
     *     PCERT_BIOMETRIC_DATA rgBiometricData;
     * } *PCERT_BIOMETRIC_EXT_INFO
     * }
     */
    public static final AddressLayout PCERT_BIOMETRIC_EXT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_SIGNATURE_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
     *     CRYPT_BIT_BLOB Signature;
     *     DWORD cCertEncoded;
     *     PCERT_BLOB rgCertEncoded;
     * } *POCSP_SIGNATURE_INFO
     * }
     */
    public static final AddressLayout POCSP_SIGNATURE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_SIGNED_REQUEST_INFO {
     *     CRYPT_DER_BLOB ToBeSigned;
     *     POCSP_SIGNATURE_INFO pOptionalSignatureInfo;
     * } *POCSP_SIGNED_REQUEST_INFO
     * }
     */
    public static final AddressLayout POCSP_SIGNED_REQUEST_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_CERT_ID {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_HASH_BLOB IssuerNameHash;
     *     CRYPT_HASH_BLOB IssuerKeyHash;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     * } *POCSP_CERT_ID
     * }
     */
    public static final AddressLayout POCSP_CERT_ID = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_REQUEST_ENTRY {
     *     OCSP_CERT_ID CertId;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_REQUEST_ENTRY
     * }
     */
    public static final AddressLayout POCSP_REQUEST_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_REQUEST_INFO {
     *     DWORD dwVersion;
     *     PCERT_ALT_NAME_ENTRY pRequestorName;
     *     DWORD cRequestEntry;
     *     POCSP_REQUEST_ENTRY rgRequestEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_REQUEST_INFO
     * }
     */
    public static final AddressLayout POCSP_REQUEST_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_RESPONSE_INFO {
     *     DWORD dwStatus;
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *POCSP_RESPONSE_INFO
     * }
     */
    public static final AddressLayout POCSP_RESPONSE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_SIGNED_RESPONSE_INFO {
     *     CRYPT_DER_BLOB ToBeSigned;
     *     OCSP_SIGNATURE_INFO SignatureInfo;
     * } *POCSP_BASIC_SIGNED_RESPONSE_INFO
     * }
     */
    public static final AddressLayout POCSP_BASIC_SIGNED_RESPONSE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_REVOKED_INFO {
     *     FILETIME RevocationDate;
     *     DWORD dwCrlReasonCode;
     * } *POCSP_BASIC_REVOKED_INFO
     * }
     */
    public static final AddressLayout POCSP_BASIC_REVOKED_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_RESPONSE_ENTRY {
     *     OCSP_CERT_ID CertId;
     *     DWORD dwCertStatus;
     *     union {
     *         POCSP_BASIC_REVOKED_INFO pRevokedInfo;
     *     };
     *     FILETIME ThisUpdate;
     *     FILETIME NextUpdate;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_BASIC_RESPONSE_ENTRY
     * }
     */
    public static final AddressLayout POCSP_BASIC_RESPONSE_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_RESPONSE_INFO {
     *     DWORD dwVersion;
     *     DWORD dwResponderIdChoice;
     *     union {
     *         CERT_NAME_BLOB ByNameResponderId;
     *         CRYPT_HASH_BLOB ByKeyResponderId;
     *     };
     *     FILETIME ProducedAt;
     *     DWORD cResponseEntry;
     *     POCSP_BASIC_RESPONSE_ENTRY rgResponseEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_BASIC_RESPONSE_INFO
     * }
     */
    public static final AddressLayout POCSP_BASIC_RESPONSE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SUPPORTED_ALGORITHM_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_BIT_BLOB IntendedKeyUsage;
     *     CERT_POLICIES_INFO IntendedCertPolicies;
     * } *PCERT_SUPPORTED_ALGORITHM_INFO
     * }
     */
    public static final AddressLayout PCERT_SUPPORTED_ALGORITHM_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TPM_SPECIFICATION_INFO {
     *     LPWSTR pwszFamily;
     *     DWORD dwLevel;
     *     DWORD dwRevision;
     * } *PCERT_TPM_SPECIFICATION_INFO
     * }
     */
    public static final AddressLayout PCERT_TPM_SPECIFICATION_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTOIDFUNCSET
     * }
     */
    public static final AddressLayout HCRYPTOIDFUNCSET = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTOIDFUNCADDR
     * }
     */
    public static final AddressLayout HCRYPTOIDFUNCADDR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OID_FUNC_ENTRY {
     *     LPCSTR pszOID;
     *     void *pvFuncAddr;
     * } *PCRYPT_OID_FUNC_ENTRY
     * }
     */
    public static final AddressLayout PCRYPT_OID_FUNC_ENTRY = winapi.C_POINTER;

    private static class CryptInstallOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptInstallOIDFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptInstallOIDFunctionAddress$descriptor() {
        return CryptInstallOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptInstallOIDFunctionAddress$handle() {
        return CryptInstallOIDFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptInstallOIDFunctionAddress$address() {
        return CryptInstallOIDFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static int CryptInstallOIDFunctionAddress(MemorySegment hModule, int dwEncodingType, MemorySegment pszFuncName, int cFuncEntry, MemorySegment rgFuncEntry, int dwFlags) {
        var mh$ = CryptInstallOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInstallOIDFunctionAddress", hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags);
            }
            return (int)mh$.invokeExact(hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptInitOIDFunctionSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptInitOIDFunctionSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptInitOIDFunctionSet$descriptor() {
        return CryptInitOIDFunctionSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptInitOIDFunctionSet$handle() {
        return CryptInitOIDFunctionSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptInitOIDFunctionSet$address() {
        return CryptInitOIDFunctionSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptInitOIDFunctionSet(MemorySegment pszFuncName, int dwFlags) {
        var mh$ = CryptInitOIDFunctionSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInitOIDFunctionSet", pszFuncName, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(pszFuncName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetOIDFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static FunctionDescriptor CryptGetOIDFunctionAddress$descriptor() {
        return CryptGetOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MethodHandle CryptGetOIDFunctionAddress$handle() {
        return CryptGetOIDFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MemorySegment CryptGetOIDFunctionAddress$address() {
        return CryptGetOIDFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static int CryptGetOIDFunctionAddress(MemorySegment hFuncSet, int dwEncodingType, MemorySegment pszOID, int dwFlags, MemorySegment ppvFuncAddr, MemorySegment phFuncAddr) {
        var mh$ = CryptGetOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetOIDFunctionAddress", hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr);
            }
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultOIDDllList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetDefaultOIDDllList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultOIDDllList$descriptor() {
        return CryptGetDefaultOIDDllList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static MethodHandle CryptGetDefaultOIDDllList$handle() {
        return CryptGetDefaultOIDDllList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static MemorySegment CryptGetDefaultOIDDllList$address() {
        return CryptGetDefaultOIDDllList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static int CryptGetDefaultOIDDllList(MemorySegment hFuncSet, int dwEncodingType, MemorySegment pwszDllList, MemorySegment pcchDllList) {
        var mh$ = CryptGetDefaultOIDDllList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultOIDDllList", hFuncSet, dwEncodingType, pwszDllList, pcchDllList);
            }
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDllList, pcchDllList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetDefaultOIDFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultOIDFunctionAddress$descriptor() {
        return CryptGetDefaultOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MethodHandle CryptGetDefaultOIDFunctionAddress$handle() {
        return CryptGetDefaultOIDFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MemorySegment CryptGetDefaultOIDFunctionAddress$address() {
        return CryptGetDefaultOIDFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static int CryptGetDefaultOIDFunctionAddress(MemorySegment hFuncSet, int dwEncodingType, MemorySegment pwszDll, int dwFlags, MemorySegment ppvFuncAddr, MemorySegment phFuncAddr) {
        var mh$ = CryptGetDefaultOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultOIDFunctionAddress", hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr);
            }
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFreeOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptFreeOIDFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptFreeOIDFunctionAddress$descriptor() {
        return CryptFreeOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptFreeOIDFunctionAddress$handle() {
        return CryptFreeOIDFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptFreeOIDFunctionAddress$address() {
        return CryptFreeOIDFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static int CryptFreeOIDFunctionAddress(MemorySegment hFuncAddr, int dwFlags) {
        var mh$ = CryptFreeOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFreeOIDFunctionAddress", hFuncAddr, dwFlags);
            }
            return (int)mh$.invokeExact(hFuncAddr, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRegisterOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptRegisterOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static FunctionDescriptor CryptRegisterOIDFunction$descriptor() {
        return CryptRegisterOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static MethodHandle CryptRegisterOIDFunction$handle() {
        return CryptRegisterOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static MemorySegment CryptRegisterOIDFunction$address() {
        return CryptRegisterOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static int CryptRegisterOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, MemorySegment pwszDll, MemorySegment pszOverrideFuncName) {
        var mh$ = CryptRegisterOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRegisterOIDFunction", dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnregisterOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptUnregisterOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static FunctionDescriptor CryptUnregisterOIDFunction$descriptor() {
        return CryptUnregisterOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static MethodHandle CryptUnregisterOIDFunction$handle() {
        return CryptUnregisterOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static MemorySegment CryptUnregisterOIDFunction$address() {
        return CryptUnregisterOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static int CryptUnregisterOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID) {
        var mh$ = CryptUnregisterOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnregisterOIDFunction", dwEncodingType, pszFuncName, pszOID);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRegisterDefaultOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptRegisterDefaultOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static FunctionDescriptor CryptRegisterDefaultOIDFunction$descriptor() {
        return CryptRegisterDefaultOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static MethodHandle CryptRegisterDefaultOIDFunction$handle() {
        return CryptRegisterDefaultOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static MemorySegment CryptRegisterDefaultOIDFunction$address() {
        return CryptRegisterDefaultOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static int CryptRegisterDefaultOIDFunction(int dwEncodingType, MemorySegment pszFuncName, int dwIndex, MemorySegment pwszDll) {
        var mh$ = CryptRegisterDefaultOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRegisterDefaultOIDFunction", dwEncodingType, pszFuncName, dwIndex, pwszDll);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, dwIndex, pwszDll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnregisterDefaultOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptUnregisterDefaultOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static FunctionDescriptor CryptUnregisterDefaultOIDFunction$descriptor() {
        return CryptUnregisterDefaultOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static MethodHandle CryptUnregisterDefaultOIDFunction$handle() {
        return CryptUnregisterDefaultOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static MemorySegment CryptUnregisterDefaultOIDFunction$address() {
        return CryptUnregisterDefaultOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static int CryptUnregisterDefaultOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pwszDll) {
        var mh$ = CryptUnregisterDefaultOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnregisterDefaultOIDFunction", dwEncodingType, pszFuncName, pwszDll);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pwszDll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetOIDFunctionValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptSetOIDFunctionValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static FunctionDescriptor CryptSetOIDFunctionValue$descriptor() {
        return CryptSetOIDFunctionValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static MethodHandle CryptSetOIDFunctionValue$handle() {
        return CryptSetOIDFunctionValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static MemorySegment CryptSetOIDFunctionValue$address() {
        return CryptSetOIDFunctionValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static int CryptSetOIDFunctionValue(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, MemorySegment pwszValueName, int dwValueType, MemorySegment pbValueData, int cbValueData) {
        var mh$ = CryptSetOIDFunctionValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetOIDFunctionValue", dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetOIDFunctionValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetOIDFunctionValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static FunctionDescriptor CryptGetOIDFunctionValue$descriptor() {
        return CryptGetOIDFunctionValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static MethodHandle CryptGetOIDFunctionValue$handle() {
        return CryptGetOIDFunctionValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static MemorySegment CryptGetOIDFunctionValue$address() {
        return CryptGetOIDFunctionValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static int CryptGetOIDFunctionValue(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, MemorySegment pwszValueName, MemorySegment pdwValueType, MemorySegment pbValueData, MemorySegment pcbValueData) {
        var mh$ = CryptGetOIDFunctionValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetOIDFunctionValue", dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptEnumOIDFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static FunctionDescriptor CryptEnumOIDFunction$descriptor() {
        return CryptEnumOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static MethodHandle CryptEnumOIDFunction$handle() {
        return CryptEnumOIDFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static MemorySegment CryptEnumOIDFunction$address() {
        return CryptEnumOIDFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static int CryptEnumOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, int dwFlags, MemorySegment pvArg, MemorySegment pfnEnumOIDFunc) {
        var mh$ = CryptEnumOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumOIDFunction", dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OID_INFO {
     *     DWORD cbSize;
     *     LPCSTR pszOID;
     *     LPCWSTR pwszName;
     *     DWORD dwGroupId;
     *     union {
     *         DWORD dwValue;
     *         ALG_ID Algid;
     *         DWORD dwLength;
     *     };
     *     CRYPT_DATA_BLOB ExtraInfo;
     * } *PCRYPT_OID_INFO
     * }
     */
    public static final AddressLayout PCRYPT_OID_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CRYPT_OID_INFO *PCCRYPT_OID_INFO
     * }
     */
    public static final AddressLayout PCCRYPT_OID_INFO = winapi.C_POINTER;

    private static class CryptFindOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptFindOIDInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static FunctionDescriptor CryptFindOIDInfo$descriptor() {
        return CryptFindOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static MethodHandle CryptFindOIDInfo$handle() {
        return CryptFindOIDInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static MemorySegment CryptFindOIDInfo$address() {
        return CryptFindOIDInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static MemorySegment CryptFindOIDInfo(int dwKeyType, MemorySegment pvKey, int dwGroupId) {
        var mh$ = CryptFindOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFindOIDInfo", dwKeyType, pvKey, dwGroupId);
            }
            return (MemorySegment)mh$.invokeExact(dwKeyType, pvKey, dwGroupId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRegisterOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptRegisterOIDInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptRegisterOIDInfo$descriptor() {
        return CryptRegisterOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptRegisterOIDInfo$handle() {
        return CryptRegisterOIDInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptRegisterOIDInfo$address() {
        return CryptRegisterOIDInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static int CryptRegisterOIDInfo(MemorySegment pInfo, int dwFlags) {
        var mh$ = CryptRegisterOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRegisterOIDInfo", pInfo, dwFlags);
            }
            return (int)mh$.invokeExact(pInfo, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnregisterOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptUnregisterOIDInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static FunctionDescriptor CryptUnregisterOIDInfo$descriptor() {
        return CryptUnregisterOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static MethodHandle CryptUnregisterOIDInfo$handle() {
        return CryptUnregisterOIDInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static MemorySegment CryptUnregisterOIDInfo$address() {
        return CryptUnregisterOIDInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static int CryptUnregisterOIDInfo(MemorySegment pInfo) {
        var mh$ = CryptUnregisterOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnregisterOIDInfo", pInfo);
            }
            return (int)mh$.invokeExact(pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptEnumOIDInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static FunctionDescriptor CryptEnumOIDInfo$descriptor() {
        return CryptEnumOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static MethodHandle CryptEnumOIDInfo$handle() {
        return CryptEnumOIDInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static MemorySegment CryptEnumOIDInfo$address() {
        return CryptEnumOIDInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static int CryptEnumOIDInfo(int dwGroupId, int dwFlags, MemorySegment pvArg, MemorySegment pfnEnumOIDInfo) {
        var mh$ = CryptEnumOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumOIDInfo", dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo);
            }
            return (int)mh$.invokeExact(dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFindLocalizedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptFindLocalizedName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static FunctionDescriptor CryptFindLocalizedName$descriptor() {
        return CryptFindLocalizedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static MethodHandle CryptFindLocalizedName$handle() {
        return CryptFindLocalizedName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static MemorySegment CryptFindLocalizedName$address() {
        return CryptFindLocalizedName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static MemorySegment CryptFindLocalizedName(MemorySegment pwszCryptName) {
        var mh$ = CryptFindLocalizedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFindLocalizedName", pwszCryptName);
            }
            return (MemorySegment)mh$.invokeExact(pwszCryptName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STRONG_SIGN_SERIALIZED_INFO {
     *     DWORD dwFlags;
     *     LPWSTR pwszCNGSignHashAlgids;
     *     LPWSTR pwszCNGPubKeyMinBitLengths;
     * } *PCERT_STRONG_SIGN_SERIALIZED_INFO
     * }
     */
    public static final AddressLayout PCERT_STRONG_SIGN_SERIALIZED_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STRONG_SIGN_PARA {
     *     DWORD cbSize;
     *     DWORD dwInfoChoice;
     *     union {
     *         void *pvInfo;
     *         PCERT_STRONG_SIGN_SERIALIZED_INFO pSerializedInfo;
     *         LPSTR pszOID;
     *     };
     * } *PCERT_STRONG_SIGN_PARA
     * }
     */
    public static final AddressLayout PCERT_STRONG_SIGN_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_STRONG_SIGN_PARA *PCCERT_STRONG_SIGN_PARA
     * }
     */
    public static final AddressLayout PCCERT_STRONG_SIGN_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTMSG
     * }
     */
    public static final AddressLayout HCRYPTMSG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ISSUER_SERIAL_NUMBER {
     *     CERT_NAME_BLOB Issuer;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     * } *PCERT_ISSUER_SERIAL_NUMBER
     * }
     */
    public static final AddressLayout PCERT_ISSUER_SERIAL_NUMBER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ID {
     *     DWORD dwIdChoice;
     *     union {
     *         CERT_ISSUER_SERIAL_NUMBER IssuerSerialNumber;
     *         CRYPT_HASH_BLOB KeyId;
     *         CRYPT_HASH_BLOB HashId;
     *     };
     * } *PCERT_ID
     * }
     */
    public static final AddressLayout PCERT_ID = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNER_ENCODE_INFO {
     *     DWORD cbSize;
     *     PCERT_INFO pCertInfo;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     *     DWORD cAuthAttr;
     *     PCRYPT_ATTRIBUTE rgAuthAttr;
     *     DWORD cUnauthAttr;
     *     PCRYPT_ATTRIBUTE rgUnauthAttr;
     * } *PCMSG_SIGNER_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNER_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNED_ENCODE_INFO {
     *     DWORD cbSize;
     *     DWORD cSigners;
     *     PCMSG_SIGNER_ENCODE_INFO rgSigners;
     *     DWORD cCertEncoded;
     *     PCERT_BLOB rgCertEncoded;
     *     DWORD cCrlEncoded;
     *     PCRL_BLOB rgCrlEncoded;
     * } *PCMSG_SIGNED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNED_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RECIPIENT_ENCODE_INFO *PCMSG_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_RECIPIENT_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_ENVELOPED_ENCODE_INFO {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     *     DWORD cRecipients;
     *     PCERT_INFO *rgpRecipients;
     * } *PCMSG_ENVELOPED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_ENVELOPED_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     void *pvKeyEncryptionAuxInfo;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_BIT_BLOB RecipientPublicKey;
     *     CERT_ID RecipientId;
     * } *PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_BIT_BLOB RecipientPublicKey;
     *     CERT_ID RecipientId;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     void *pvKeyEncryptionAuxInfo;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyWrapAlgorithm;
     *     void *pvKeyWrapAuxInfo;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     DWORD dwKeySpec;
     *     DWORD dwKeyChoice;
     *     union {
     *         PCRYPT_ALGORITHM_IDENTIFIER pEphemeralAlgorithm;
     *         PCERT_ID pSenderId;
     *     };
     *     CRYPT_DATA_BLOB UserKeyingMaterial;
     *     DWORD cRecipientEncryptedKeys;
     *     PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *rgpRecipientEncryptedKeys;
     * } *PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     void *pvKeyEncryptionAuxInfo;
     *     HCRYPTPROV hCryptProv;
     *     DWORD dwKeyChoice;
     *     union {
     *         HCRYPTKEY hKeyEncryptionKey;
     *         void *pvKeyEncryptionKey;
     *     };
     *     CRYPT_DATA_BLOB KeyId;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RC2_AUX_INFO {
     *     DWORD cbSize;
     *     DWORD dwBitLen;
     * } *PCMSG_RC2_AUX_INFO
     * }
     */
    public static final AddressLayout PCMSG_RC2_AUX_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SP3_COMPATIBLE_AUX_INFO {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     * } *PCMSG_SP3_COMPATIBLE_AUX_INFO
     * }
     */
    public static final AddressLayout PCMSG_SP3_COMPATIBLE_AUX_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RC4_AUX_INFO {
     *     DWORD cbSize;
     *     DWORD dwBitLen;
     * } *PCMSG_RC4_AUX_INFO
     * }
     */
    public static final AddressLayout PCMSG_RC4_AUX_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO {
     *     DWORD cbSize;
     *     CMSG_SIGNED_ENCODE_INFO SignedInfo;
     *     CMSG_ENVELOPED_ENCODE_INFO EnvelopedInfo;
     * } *PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_HASHED_ENCODE_INFO {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     * } *PCMSG_HASHED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_HASHED_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_ENCRYPTED_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     * } *PCMSG_ENCRYPTED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_ENCRYPTED_ENCODE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_STREAM_INFO {
     *     DWORD cbContent;
     *     PFN_CMSG_STREAM_OUTPUT pfnStreamOutput;
     *     void *pvArg;
     * } *PCMSG_STREAM_INFO
     * }
     */
    public static final AddressLayout PCMSG_STREAM_INFO = winapi.C_POINTER;

    private static class CryptMsgOpenToEncode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgOpenToEncode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static FunctionDescriptor CryptMsgOpenToEncode$descriptor() {
        return CryptMsgOpenToEncode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MethodHandle CryptMsgOpenToEncode$handle() {
        return CryptMsgOpenToEncode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToEncode$address() {
        return CryptMsgOpenToEncode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToEncode(int dwMsgEncodingType, int dwFlags, int dwMsgType, MemorySegment pvMsgEncodeInfo, MemorySegment pszInnerContentObjID, MemorySegment pStreamInfo) {
        var mh$ = CryptMsgOpenToEncode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgOpenToEncode", dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgCalculateEncodedLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgCalculateEncodedLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static FunctionDescriptor CryptMsgCalculateEncodedLength$descriptor() {
        return CryptMsgCalculateEncodedLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static MethodHandle CryptMsgCalculateEncodedLength$handle() {
        return CryptMsgCalculateEncodedLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static MemorySegment CryptMsgCalculateEncodedLength$address() {
        return CryptMsgCalculateEncodedLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static int CryptMsgCalculateEncodedLength(int dwMsgEncodingType, int dwFlags, int dwMsgType, MemorySegment pvMsgEncodeInfo, MemorySegment pszInnerContentObjID, int cbData) {
        var mh$ = CryptMsgCalculateEncodedLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgCalculateEncodedLength", dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgOpenToDecode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgOpenToDecode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static FunctionDescriptor CryptMsgOpenToDecode$descriptor() {
        return CryptMsgOpenToDecode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MethodHandle CryptMsgOpenToDecode$handle() {
        return CryptMsgOpenToDecode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToDecode$address() {
        return CryptMsgOpenToDecode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToDecode(int dwMsgEncodingType, int dwFlags, int dwMsgType, long hCryptProv, MemorySegment pRecipientInfo, MemorySegment pStreamInfo) {
        var mh$ = CryptMsgOpenToDecode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgOpenToDecode", dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgDuplicate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgDuplicate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static FunctionDescriptor CryptMsgDuplicate$descriptor() {
        return CryptMsgDuplicate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MethodHandle CryptMsgDuplicate$handle() {
        return CryptMsgDuplicate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MemorySegment CryptMsgDuplicate$address() {
        return CryptMsgDuplicate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MemorySegment CryptMsgDuplicate(MemorySegment hCryptMsg) {
        var mh$ = CryptMsgDuplicate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgDuplicate", hCryptMsg);
            }
            return (MemorySegment)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static FunctionDescriptor CryptMsgClose$descriptor() {
        return CryptMsgClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MethodHandle CryptMsgClose$handle() {
        return CryptMsgClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MemorySegment CryptMsgClose$address() {
        return CryptMsgClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static int CryptMsgClose(MemorySegment hCryptMsg) {
        var mh$ = CryptMsgClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgClose", hCryptMsg);
            }
            return (int)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgUpdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgUpdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static FunctionDescriptor CryptMsgUpdate$descriptor() {
        return CryptMsgUpdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static MethodHandle CryptMsgUpdate$handle() {
        return CryptMsgUpdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static MemorySegment CryptMsgUpdate$address() {
        return CryptMsgUpdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static int CryptMsgUpdate(MemorySegment hCryptMsg, MemorySegment pbData, int cbData, int fFinal) {
        var mh$ = CryptMsgUpdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgUpdate", hCryptMsg, pbData, cbData, fFinal);
            }
            return (int)mh$.invokeExact(hCryptMsg, pbData, cbData, fFinal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgGetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgGetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CryptMsgGetParam$descriptor() {
        return CryptMsgGetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CryptMsgGetParam$handle() {
        return CryptMsgGetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CryptMsgGetParam$address() {
        return CryptMsgGetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CryptMsgGetParam(MemorySegment hCryptMsg, int dwParamType, int dwIndex, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CryptMsgGetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgGetParam", hCryptMsg, dwParamType, dwIndex, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hCryptMsg, dwParamType, dwIndex, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNER_INFO {
     *     DWORD dwVersion;
     *     CERT_NAME_BLOB Issuer;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedHash;
     *     CRYPT_ATTRIBUTES AuthAttrs;
     *     CRYPT_ATTRIBUTES UnauthAttrs;
     * } *PCMSG_SIGNER_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNER_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CMS_SIGNER_INFO {
     *     DWORD dwVersion;
     *     CERT_ID SignerId;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedHash;
     *     CRYPT_ATTRIBUTES AuthAttrs;
     *     CRYPT_ATTRIBUTES UnauthAttrs;
     * } *PCMSG_CMS_SIGNER_INFO
     * }
     */
    public static final AddressLayout PCMSG_CMS_SIGNER_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CRYPT_ATTRIBUTES *PCMSG_ATTR
     * }
     */
    public static final AddressLayout PCMSG_ATTR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_TRANS_RECIPIENT_INFO {
     *     DWORD dwVersion;
     *     CERT_ID RecipientId;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     * } *PCMSG_KEY_TRANS_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_TRANS_RECIPIENT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO {
     *     CERT_ID RecipientId;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO
     * }
     */
    public static final AddressLayout PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_RECIPIENT_INFO {
     *     DWORD dwVersion;
     *     DWORD dwOriginatorChoice;
     *     union {
     *         CERT_ID OriginatorCertId;
     *         CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
     *     };
     *     CRYPT_DATA_BLOB UserKeyingMaterial;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     DWORD cRecipientEncryptedKeys;
     *     PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *rgpRecipientEncryptedKeys;
     * } *PCMSG_KEY_AGREE_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_RECIPIENT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_MAIL_LIST_RECIPIENT_INFO {
     *     DWORD dwVersion;
     *     CRYPT_DATA_BLOB KeyId;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_MAIL_LIST_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_MAIL_LIST_RECIPIENT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CMS_RECIPIENT_INFO {
     *     DWORD dwRecipientChoice;
     *     union {
     *         PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans;
     *         PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree;
     *         PCMSG_MAIL_LIST_RECIPIENT_INFO pMailList;
     *     };
     * } *PCMSG_CMS_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_CMS_RECIPIENT_INFO = winapi.C_POINTER;

    private static class CryptMsgControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static FunctionDescriptor CryptMsgControl$descriptor() {
        return CryptMsgControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MethodHandle CryptMsgControl$handle() {
        return CryptMsgControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MemorySegment CryptMsgControl$address() {
        return CryptMsgControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static int CryptMsgControl(MemorySegment hCryptMsg, int dwFlags, int dwCtrlType, MemorySegment pvCtrlPara) {
        var mh$ = CryptMsgControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgControl", hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara);
            }
            return (int)mh$.invokeExact(hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     DWORD dwSignerIndex;
     *     DWORD dwSignerType;
     *     void *pvSigner;
     * } *PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_DECRYPT_PARA {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     DWORD dwRecipientIndex;
     * } *PCMSG_CTRL_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_DECRYPT_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans;
     *     DWORD dwRecipientIndex;
     * } *PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree;
     *     DWORD dwRecipientIndex;
     *     DWORD dwRecipientEncryptedKeyIndex;
     *     CRYPT_BIT_BLOB OriginatorPublicKey;
     * } *PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA {
     *     DWORD cbSize;
     *     HCRYPTPROV hCryptProv;
     *     PCMSG_MAIL_LIST_RECIPIENT_INFO pMailList;
     *     DWORD dwRecipientIndex;
     *     DWORD dwKeyChoice;
     *     union {
     *         HCRYPTKEY hKeyEncryptionKey;
     *         void *pvKeyEncryptionKey;
     *     };
     * } *PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA {
     *     DWORD cbSize;
     *     DWORD dwSignerIndex;
     *     CRYPT_DATA_BLOB blob;
     * } *PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA {
     *     DWORD cbSize;
     *     DWORD dwSignerIndex;
     *     DWORD dwUnauthAttrIndex;
     * } *PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = winapi.C_POINTER;

    private static class CryptMsgVerifyCountersignatureEncoded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgVerifyCountersignatureEncoded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static FunctionDescriptor CryptMsgVerifyCountersignatureEncoded$descriptor() {
        return CryptMsgVerifyCountersignatureEncoded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static MethodHandle CryptMsgVerifyCountersignatureEncoded$handle() {
        return CryptMsgVerifyCountersignatureEncoded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static MemorySegment CryptMsgVerifyCountersignatureEncoded$address() {
        return CryptMsgVerifyCountersignatureEncoded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static int CryptMsgVerifyCountersignatureEncoded(long hCryptProv, int dwEncodingType, MemorySegment pbSignerInfo, int cbSignerInfo, MemorySegment pbSignerInfoCountersignature, int cbSignerInfoCountersignature, MemorySegment pciCountersigner) {
        var mh$ = CryptMsgVerifyCountersignatureEncoded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgVerifyCountersignatureEncoded", hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner);
            }
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgVerifyCountersignatureEncodedEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgVerifyCountersignatureEncodedEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static FunctionDescriptor CryptMsgVerifyCountersignatureEncodedEx$descriptor() {
        return CryptMsgVerifyCountersignatureEncodedEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MethodHandle CryptMsgVerifyCountersignatureEncodedEx$handle() {
        return CryptMsgVerifyCountersignatureEncodedEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MemorySegment CryptMsgVerifyCountersignatureEncodedEx$address() {
        return CryptMsgVerifyCountersignatureEncodedEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static int CryptMsgVerifyCountersignatureEncodedEx(long hCryptProv, int dwEncodingType, MemorySegment pbSignerInfo, int cbSignerInfo, MemorySegment pbSignerInfoCountersignature, int cbSignerInfoCountersignature, int dwSignerType, MemorySegment pvSigner, int dwFlags, MemorySegment pvExtra) {
        var mh$ = CryptMsgVerifyCountersignatureEncodedEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgVerifyCountersignatureEncodedEx", hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra);
            }
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgCountersign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgCountersign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static FunctionDescriptor CryptMsgCountersign$descriptor() {
        return CryptMsgCountersign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static MethodHandle CryptMsgCountersign$handle() {
        return CryptMsgCountersign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static MemorySegment CryptMsgCountersign$address() {
        return CryptMsgCountersign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static int CryptMsgCountersign(MemorySegment hCryptMsg, int dwIndex, int cCountersigners, MemorySegment rgCountersigners) {
        var mh$ = CryptMsgCountersign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgCountersign", hCryptMsg, dwIndex, cCountersigners, rgCountersigners);
            }
            return (int)mh$.invokeExact(hCryptMsg, dwIndex, cCountersigners, rgCountersigners);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgCountersignEncoded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgCountersignEncoded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static FunctionDescriptor CryptMsgCountersignEncoded$descriptor() {
        return CryptMsgCountersignEncoded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static MethodHandle CryptMsgCountersignEncoded$handle() {
        return CryptMsgCountersignEncoded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static MemorySegment CryptMsgCountersignEncoded$address() {
        return CryptMsgCountersignEncoded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static int CryptMsgCountersignEncoded(int dwEncodingType, MemorySegment pbSignerInfo, int cbSignerInfo, int cCountersigners, MemorySegment rgCountersigners, MemorySegment pbCountersignature, MemorySegment pcbCountersignature) {
        var mh$ = CryptMsgCountersignEncoded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgCountersignEncoded", dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature);
            }
            return (int)mh$.invokeExact(dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CONTENT_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     *     DWORD cRecipients;
     *     PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients;
     *     PFN_CMSG_ALLOC pfnAlloc;
     *     PFN_CMSG_FREE pfnFree;
     *     DWORD dwEncryptFlags;
     *     union {
     *         HCRYPTKEY hContentEncryptKey;
     *         BCRYPT_KEY_HANDLE hCNGContentEncryptKey;
     *     };
     *     DWORD dwFlags;
     *     BOOL fCNG;
     *     BYTE *pbCNGContentEncryptKeyObject;
     *     BYTE *pbContentEncryptKey;
     *     DWORD cbContentEncryptKey;
     * } *PCMSG_CONTENT_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_CONTENT_ENCRYPT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_TRANS_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     DWORD dwRecipientIndex;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     DWORD dwFlags;
     * } *PCMSG_KEY_TRANS_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_TRANS_ENCRYPT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     CRYPT_DATA_BLOB EncryptedKey;
     * } *PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     DWORD dwRecipientIndex;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB UserKeyingMaterial;
     *     DWORD dwOriginatorChoice;
     *     union {
     *         CERT_ID OriginatorCertId;
     *         CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
     *     };
     *     DWORD cKeyAgreeKeyEncryptInfo;
     *     PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *rgpKeyAgreeKeyEncryptInfo;
     *     DWORD dwFlags;
     * } *PCMSG_KEY_AGREE_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_ENCRYPT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_MAIL_LIST_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     DWORD dwRecipientIndex;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     DWORD dwFlags;
     * } *PCMSG_MAIL_LIST_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_MAIL_LIST_ENCRYPT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CNG_CONTENT_DECRYPT_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     PFN_CMSG_ALLOC pfnAlloc;
     *     PFN_CMSG_FREE pfnFree;
     *     NCRYPT_KEY_HANDLE hNCryptKey;
     *     BYTE *pbContentEncryptKey;
     *     DWORD cbContentEncryptKey;
     *     BCRYPT_KEY_HANDLE hCNGContentEncryptKey;
     *     BYTE *pbCNGContentEncryptKeyObject;
     * } *PCMSG_CNG_CONTENT_DECRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_CNG_CONTENT_DECRYPT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCERTSTORE
     * }
     */
    public static final AddressLayout HCERTSTORE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CONTEXT {
     *     DWORD dwCertEncodingType;
     *     BYTE *pbCertEncoded;
     *     DWORD cbCertEncoded;
     *     PCERT_INFO pCertInfo;
     *     HCERTSTORE hCertStore;
     * } *PCERT_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_CONTEXT *PCCERT_CONTEXT
     * }
     */
    public static final AddressLayout PCCERT_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_CONTEXT {
     *     DWORD dwCertEncodingType;
     *     BYTE *pbCrlEncoded;
     *     DWORD cbCrlEncoded;
     *     PCRL_INFO pCrlInfo;
     *     HCERTSTORE hCertStore;
     * } *PCRL_CONTEXT
     * }
     */
    public static final AddressLayout PCRL_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CRL_CONTEXT *PCCRL_CONTEXT
     * }
     */
    public static final AddressLayout PCCRL_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_CONTEXT {
     *     DWORD dwMsgAndCertEncodingType;
     *     BYTE *pbCtlEncoded;
     *     DWORD cbCtlEncoded;
     *     PCTL_INFO pCtlInfo;
     *     HCERTSTORE hCertStore;
     *     HCRYPTMSG hCryptMsg;
     *     BYTE *pbCtlContent;
     *     DWORD cbCtlContent;
     * } *PCTL_CONTEXT
     * }
     */
    public static final AddressLayout PCTL_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CTL_CONTEXT *PCCTL_CONTEXT
     * }
     */
    public static final AddressLayout PCCTL_CONTEXT = winapi.C_POINTER;
    private static final int KeyTypeOther = (int)0L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeOther = 0
     * }
     */
    public static int KeyTypeOther() {
        return KeyTypeOther;
    }
    private static final int KeyTypeVirtualSmartCard = (int)1L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeVirtualSmartCard = 1
     * }
     */
    public static int KeyTypeVirtualSmartCard() {
        return KeyTypeVirtualSmartCard;
    }
    private static final int KeyTypePhysicalSmartCard = (int)2L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePhysicalSmartCard = 2
     * }
     */
    public static int KeyTypePhysicalSmartCard() {
        return KeyTypePhysicalSmartCard;
    }
    private static final int KeyTypePassport = (int)3L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePassport = 3
     * }
     */
    public static int KeyTypePassport() {
        return KeyTypePassport;
    }
    private static final int KeyTypePassportRemote = (int)4L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePassportRemote = 4
     * }
     */
    public static int KeyTypePassportRemote() {
        return KeyTypePassportRemote;
    }
    private static final int KeyTypePassportSmartCard = (int)5L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePassportSmartCard = 5
     * }
     */
    public static int KeyTypePassportSmartCard() {
        return KeyTypePassportSmartCard;
    }
    private static final int KeyTypeHardware = (int)6L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeHardware = 6
     * }
     */
    public static int KeyTypeHardware() {
        return KeyTypeHardware;
    }
    private static final int KeyTypeSoftware = (int)7L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeSoftware = 7
     * }
     */
    public static int KeyTypeSoftware() {
        return KeyTypeSoftware;
    }
    private static final int KeyTypeSelfSigned = (int)8L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeSelfSigned = 8
     * }
     */
    public static int KeyTypeSelfSigned() {
        return KeyTypeSelfSigned;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_PROV_PARAM {
     *     DWORD dwParam;
     *     BYTE *pbData;
     *     DWORD cbData;
     *     DWORD dwFlags;
     * } *PCRYPT_KEY_PROV_PARAM
     * }
     */
    public static final AddressLayout PCRYPT_KEY_PROV_PARAM = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_PROV_INFO {
     *     LPWSTR pwszContainerName;
     *     LPWSTR pwszProvName;
     *     DWORD dwProvType;
     *     DWORD dwFlags;
     *     DWORD cProvParam;
     *     PCRYPT_KEY_PROV_PARAM rgProvParam;
     *     DWORD dwKeySpec;
     * } *PCRYPT_KEY_PROV_INFO
     * }
     */
    public static final AddressLayout PCRYPT_KEY_PROV_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEY_CONTEXT {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     * } *PCERT_KEY_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_KEY_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ROOT_INFO_LUID {
     *     DWORD LowPart;
     *     LONG HighPart;
     * } *PROOT_INFO_LUID
     * }
     */
    public static final AddressLayout PROOT_INFO_LUID = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SMART_CARD_ROOT_INFO {
     *     BYTE rgbCardID[16];
     *     ROOT_INFO_LUID luid;
     * } *PCRYPT_SMART_CARD_ROOT_INFO
     * }
     */
    public static final AddressLayout PCRYPT_SMART_CARD_ROOT_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SYSTEM_STORE_RELOCATE_PARA {
     *     union {
     *         HKEY hKeyBase;
     *         void *pvBase;
     *     };
     *     union {
     *         void *pvSystemStore;
     *         LPCSTR pszSystemStore;
     *         LPCWSTR pwszSystemStore;
     *     };
     * } *PCERT_SYSTEM_STORE_RELOCATE_PARA
     * }
     */
    public static final AddressLayout PCERT_SYSTEM_STORE_RELOCATE_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REGISTRY_STORE_CLIENT_GPT_PARA {
     *     HKEY hKeyBase;
     *     LPWSTR pwszRegPath;
     * } *PCERT_REGISTRY_STORE_CLIENT_GPT_PARA
     * }
     */
    public static final AddressLayout PCERT_REGISTRY_STORE_CLIENT_GPT_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REGISTRY_STORE_ROAMING_PARA {
     *     HKEY hKey;
     *     LPWSTR pwszStoreDirectory;
     * } *PCERT_REGISTRY_STORE_ROAMING_PARA
     * }
     */
    public static final AddressLayout PCERT_REGISTRY_STORE_ROAMING_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LDAP_STORE_OPENED_PARA {
     *     void *pvLdapSessionHandle;
     *     LPCWSTR pwszLdapUrl;
     * } *PCERT_LDAP_STORE_OPENED_PARA
     * }
     */
    public static final AddressLayout PCERT_LDAP_STORE_OPENED_PARA = winapi.C_POINTER;

    private static class CertOpenStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertOpenStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static FunctionDescriptor CertOpenStore$descriptor() {
        return CertOpenStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static MethodHandle CertOpenStore$handle() {
        return CertOpenStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static MemorySegment CertOpenStore$address() {
        return CertOpenStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static MemorySegment CertOpenStore(MemorySegment lpszStoreProvider, int dwEncodingType, long hCryptProv, int dwFlags, MemorySegment pvPara) {
        var mh$ = CertOpenStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenStore", lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara);
            }
            return (MemorySegment)mh$.invokeExact(lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *HCERTSTOREPROV
     * }
     */
    public static final AddressLayout HCERTSTOREPROV = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STORE_PROV_INFO {
     *     DWORD cbSize;
     *     DWORD cStoreProvFunc;
     *     void **rgpvStoreProvFunc;
     *     HCERTSTOREPROV hStoreProv;
     *     DWORD dwStoreProvFlags;
     *     HCRYPTOIDFUNCADDR hStoreProvFuncAddr2;
     * } *PCERT_STORE_PROV_INFO
     * }
     */
    public static final AddressLayout PCERT_STORE_PROV_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STORE_PROV_FIND_INFO {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     DWORD dwFindFlags;
     *     DWORD dwFindType;
     *     const void *pvFindPara;
     * } *PCERT_STORE_PROV_FIND_INFO
     * }
     */
    public static final AddressLayout PCERT_STORE_PROV_FIND_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_STORE_PROV_FIND_INFO *PCCERT_STORE_PROV_FIND_INFO
     * }
     */
    public static final AddressLayout PCCERT_STORE_PROV_FIND_INFO = winapi.C_POINTER;

    private static class CertDuplicateStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertDuplicateStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static FunctionDescriptor CertDuplicateStore$descriptor() {
        return CertDuplicateStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static MethodHandle CertDuplicateStore$handle() {
        return CertDuplicateStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static MemorySegment CertDuplicateStore$address() {
        return CertDuplicateStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static MemorySegment CertDuplicateStore(MemorySegment hCertStore) {
        var mh$ = CertDuplicateStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateStore", hCertStore);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSaveStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSaveStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertSaveStore$descriptor() {
        return CertSaveStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertSaveStore$handle() {
        return CertSaveStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertSaveStore$address() {
        return CertSaveStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static int CertSaveStore(MemorySegment hCertStore, int dwEncodingType, int dwSaveAs, int dwSaveTo, MemorySegment pvSaveToPara, int dwFlags) {
        var mh$ = CertSaveStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSaveStore", hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags);
            }
            return (int)mh$.invokeExact(hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCloseStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCloseStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertCloseStore$descriptor() {
        return CertCloseStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertCloseStore$handle() {
        return CertCloseStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertCloseStore$address() {
        return CertCloseStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static int CertCloseStore(MemorySegment hCertStore, int dwFlags) {
        var mh$ = CertCloseStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCloseStore", hCertStore, dwFlags);
            }
            return (int)mh$.invokeExact(hCertStore, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetSubjectCertificateFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetSubjectCertificateFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static FunctionDescriptor CertGetSubjectCertificateFromStore$descriptor() {
        return CertGetSubjectCertificateFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static MethodHandle CertGetSubjectCertificateFromStore$handle() {
        return CertGetSubjectCertificateFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static MemorySegment CertGetSubjectCertificateFromStore$address() {
        return CertGetSubjectCertificateFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static MemorySegment CertGetSubjectCertificateFromStore(MemorySegment hCertStore, int dwCertEncodingType, MemorySegment pCertId) {
        var mh$ = CertGetSubjectCertificateFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetSubjectCertificateFromStore", hCertStore, dwCertEncodingType, pCertId);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, pCertId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCertificatesInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumCertificatesInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static FunctionDescriptor CertEnumCertificatesInStore$descriptor() {
        return CertEnumCertificatesInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MethodHandle CertEnumCertificatesInStore$handle() {
        return CertEnumCertificatesInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertEnumCertificatesInStore$address() {
        return CertEnumCertificatesInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertEnumCertificatesInStore(MemorySegment hCertStore, MemorySegment pPrevCertContext) {
        var mh$ = CertEnumCertificatesInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCertificatesInStore", hCertStore, pPrevCertContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pPrevCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindCertificateInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindCertificateInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static FunctionDescriptor CertFindCertificateInStore$descriptor() {
        return CertFindCertificateInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MethodHandle CertFindCertificateInStore$handle() {
        return CertFindCertificateInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertFindCertificateInStore$address() {
        return CertFindCertificateInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertFindCertificateInStore(MemorySegment hCertStore, int dwCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevCertContext) {
        var mh$ = CertFindCertificateInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCertificateInStore", hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetIssuerCertificateFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetIssuerCertificateFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CertGetIssuerCertificateFromStore$descriptor() {
        return CertGetIssuerCertificateFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CertGetIssuerCertificateFromStore$handle() {
        return CertGetIssuerCertificateFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetIssuerCertificateFromStore$address() {
        return CertGetIssuerCertificateFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetIssuerCertificateFromStore(MemorySegment hCertStore, MemorySegment pSubjectContext, MemorySegment pPrevIssuerContext, MemorySegment pdwFlags) {
        var mh$ = CertGetIssuerCertificateFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetIssuerCertificateFromStore", hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifySubjectCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertVerifySubjectCertificateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CertVerifySubjectCertificateContext$descriptor() {
        return CertVerifySubjectCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CertVerifySubjectCertificateContext$handle() {
        return CertVerifySubjectCertificateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertVerifySubjectCertificateContext$address() {
        return CertVerifySubjectCertificateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static int CertVerifySubjectCertificateContext(MemorySegment pSubject, MemorySegment pIssuer, MemorySegment pdwFlags) {
        var mh$ = CertVerifySubjectCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifySubjectCertificateContext", pSubject, pIssuer, pdwFlags);
            }
            return (int)mh$.invokeExact(pSubject, pIssuer, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDuplicateCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertDuplicateCertificateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCertificateContext$descriptor() {
        return CertDuplicateCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MethodHandle CertDuplicateCertificateContext$handle() {
        return CertDuplicateCertificateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MemorySegment CertDuplicateCertificateContext$address() {
        return CertDuplicateCertificateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MemorySegment CertDuplicateCertificateContext(MemorySegment pCertContext) {
        var mh$ = CertDuplicateCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCertificateContext", pCertContext);
            }
            return (MemorySegment)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCreateCertificateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static FunctionDescriptor CertCreateCertificateContext$descriptor() {
        return CertCreateCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MethodHandle CertCreateCertificateContext$handle() {
        return CertCreateCertificateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MemorySegment CertCreateCertificateContext$address() {
        return CertCreateCertificateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MemorySegment CertCreateCertificateContext(int dwCertEncodingType, MemorySegment pbCertEncoded, int cbCertEncoded) {
        var mh$ = CertCreateCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCertificateContext", dwCertEncodingType, pbCertEncoded, cbCertEncoded);
            }
            return (MemorySegment)mh$.invokeExact(dwCertEncodingType, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFreeCertificateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static FunctionDescriptor CertFreeCertificateContext$descriptor() {
        return CertFreeCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MethodHandle CertFreeCertificateContext$handle() {
        return CertFreeCertificateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MemorySegment CertFreeCertificateContext$address() {
        return CertFreeCertificateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static int CertFreeCertificateContext(MemorySegment pCertContext) {
        var mh$ = CertFreeCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCertificateContext", pCertContext);
            }
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCertificateContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSetCertificateContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetCertificateContextProperty$descriptor() {
        return CertSetCertificateContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetCertificateContextProperty$handle() {
        return CertSetCertificateContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MemorySegment CertSetCertificateContextProperty$address() {
        return CertSetCertificateContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetCertificateContextProperty(MemorySegment pCertContext, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetCertificateContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCertificateContextProperty", pCertContext, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(pCertContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCertificateContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetCertificateContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetCertificateContextProperty$descriptor() {
        return CertGetCertificateContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetCertificateContextProperty$handle() {
        return CertGetCertificateContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CertGetCertificateContextProperty$address() {
        return CertGetCertificateContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetCertificateContextProperty(MemorySegment pCertContext, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetCertificateContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCertificateContextProperty", pCertContext, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pCertContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCertificateContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumCertificateContextProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static FunctionDescriptor CertEnumCertificateContextProperties$descriptor() {
        return CertEnumCertificateContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static MethodHandle CertEnumCertificateContextProperties$handle() {
        return CertEnumCertificateContextProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static MemorySegment CertEnumCertificateContextProperties$address() {
        return CertEnumCertificateContextProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static int CertEnumCertificateContextProperties(MemorySegment pCertContext, int dwPropId) {
        var mh$ = CertEnumCertificateContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCertificateContextProperties", pCertContext, dwPropId);
            }
            return (int)mh$.invokeExact(pCertContext, dwPropId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCTLEntryFromCertificateContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCreateCTLEntryFromCertificateContextProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static FunctionDescriptor CertCreateCTLEntryFromCertificateContextProperties$descriptor() {
        return CertCreateCTLEntryFromCertificateContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static MethodHandle CertCreateCTLEntryFromCertificateContextProperties$handle() {
        return CertCreateCTLEntryFromCertificateContextProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static MemorySegment CertCreateCTLEntryFromCertificateContextProperties$address() {
        return CertCreateCTLEntryFromCertificateContextProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static int CertCreateCTLEntryFromCertificateContextProperties(MemorySegment pCertContext, int cOptAttr, MemorySegment rgOptAttr, int dwFlags, MemorySegment pvReserved, MemorySegment pCtlEntry, MemorySegment pcbCtlEntry) {
        var mh$ = CertCreateCTLEntryFromCertificateContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCTLEntryFromCertificateContextProperties", pCertContext, cOptAttr, rgOptAttr, dwFlags, pvReserved, pCtlEntry, pcbCtlEntry);
            }
            return (int)mh$.invokeExact(pCertContext, cOptAttr, rgOptAttr, dwFlags, pvReserved, pCtlEntry, pcbCtlEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCertificateContextPropertiesFromCTLEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSetCertificateContextPropertiesFromCTLEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertSetCertificateContextPropertiesFromCTLEntry$descriptor() {
        return CertSetCertificateContextPropertiesFromCTLEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertSetCertificateContextPropertiesFromCTLEntry$handle() {
        return CertSetCertificateContextPropertiesFromCTLEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertSetCertificateContextPropertiesFromCTLEntry$address() {
        return CertSetCertificateContextPropertiesFromCTLEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static int CertSetCertificateContextPropertiesFromCTLEntry(MemorySegment pCertContext, MemorySegment pCtlEntry, int dwFlags) {
        var mh$ = CertSetCertificateContextPropertiesFromCTLEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCertificateContextPropertiesFromCTLEntry", pCertContext, pCtlEntry, dwFlags);
            }
            return (int)mh$.invokeExact(pCertContext, pCtlEntry, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCRLFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetCRLFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CertGetCRLFromStore$descriptor() {
        return CertGetCRLFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CertGetCRLFromStore$handle() {
        return CertGetCRLFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetCRLFromStore$address() {
        return CertGetCRLFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetCRLFromStore(MemorySegment hCertStore, MemorySegment pIssuerContext, MemorySegment pPrevCrlContext, MemorySegment pdwFlags) {
        var mh$ = CertGetCRLFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCRLFromStore", hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCRLsInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumCRLsInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static FunctionDescriptor CertEnumCRLsInStore$descriptor() {
        return CertEnumCRLsInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MethodHandle CertEnumCRLsInStore$handle() {
        return CertEnumCRLsInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertEnumCRLsInStore$address() {
        return CertEnumCRLsInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertEnumCRLsInStore(MemorySegment hCertStore, MemorySegment pPrevCrlContext) {
        var mh$ = CertEnumCRLsInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCRLsInStore", hCertStore, pPrevCrlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pPrevCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindCRLInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindCRLInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static FunctionDescriptor CertFindCRLInStore$descriptor() {
        return CertFindCRLInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MethodHandle CertFindCRLInStore$handle() {
        return CertFindCRLInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertFindCRLInStore$address() {
        return CertFindCRLInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertFindCRLInStore(MemorySegment hCertStore, int dwCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevCrlContext) {
        var mh$ = CertFindCRLInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCRLInStore", hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_FIND_ISSUED_FOR_PARA {
     *     PCCERT_CONTEXT pSubjectCert;
     *     PCCERT_CONTEXT pIssuerCert;
     * } *PCRL_FIND_ISSUED_FOR_PARA
     * }
     */
    public static final AddressLayout PCRL_FIND_ISSUED_FOR_PARA = winapi.C_POINTER;

    private static class CertDuplicateCRLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertDuplicateCRLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCRLContext$descriptor() {
        return CertDuplicateCRLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MethodHandle CertDuplicateCRLContext$handle() {
        return CertDuplicateCRLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MemorySegment CertDuplicateCRLContext$address() {
        return CertDuplicateCRLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MemorySegment CertDuplicateCRLContext(MemorySegment pCrlContext) {
        var mh$ = CertDuplicateCRLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCRLContext", pCrlContext);
            }
            return (MemorySegment)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCRLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCreateCRLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static FunctionDescriptor CertCreateCRLContext$descriptor() {
        return CertCreateCRLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static MethodHandle CertCreateCRLContext$handle() {
        return CertCreateCRLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static MemorySegment CertCreateCRLContext$address() {
        return CertCreateCRLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static MemorySegment CertCreateCRLContext(int dwCertEncodingType, MemorySegment pbCrlEncoded, int cbCrlEncoded) {
        var mh$ = CertCreateCRLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCRLContext", dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);
            }
            return (MemorySegment)mh$.invokeExact(dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCRLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFreeCRLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static FunctionDescriptor CertFreeCRLContext$descriptor() {
        return CertFreeCRLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MethodHandle CertFreeCRLContext$handle() {
        return CertFreeCRLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MemorySegment CertFreeCRLContext$address() {
        return CertFreeCRLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static int CertFreeCRLContext(MemorySegment pCrlContext) {
        var mh$ = CertFreeCRLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCRLContext", pCrlContext);
            }
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCRLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSetCRLContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetCRLContextProperty$descriptor() {
        return CertSetCRLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetCRLContextProperty$handle() {
        return CertSetCRLContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MemorySegment CertSetCRLContextProperty$address() {
        return CertSetCRLContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetCRLContextProperty(MemorySegment pCrlContext, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetCRLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCRLContextProperty", pCrlContext, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(pCrlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCRLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetCRLContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetCRLContextProperty$descriptor() {
        return CertGetCRLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetCRLContextProperty$handle() {
        return CertGetCRLContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CertGetCRLContextProperty$address() {
        return CertGetCRLContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetCRLContextProperty(MemorySegment pCrlContext, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetCRLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCRLContextProperty", pCrlContext, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pCrlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCRLContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumCRLContextProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static FunctionDescriptor CertEnumCRLContextProperties$descriptor() {
        return CertEnumCRLContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static MethodHandle CertEnumCRLContextProperties$handle() {
        return CertEnumCRLContextProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static MemorySegment CertEnumCRLContextProperties$address() {
        return CertEnumCRLContextProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static int CertEnumCRLContextProperties(MemorySegment pCrlContext, int dwPropId) {
        var mh$ = CertEnumCRLContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCRLContextProperties", pCrlContext, dwPropId);
            }
            return (int)mh$.invokeExact(pCrlContext, dwPropId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindCertificateInCRL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindCertificateInCRL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static FunctionDescriptor CertFindCertificateInCRL$descriptor() {
        return CertFindCertificateInCRL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static MethodHandle CertFindCertificateInCRL$handle() {
        return CertFindCertificateInCRL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static MemorySegment CertFindCertificateInCRL$address() {
        return CertFindCertificateInCRL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static int CertFindCertificateInCRL(MemorySegment pCert, MemorySegment pCrlContext, int dwFlags, MemorySegment pvReserved, MemorySegment ppCrlEntry) {
        var mh$ = CertFindCertificateInCRL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCertificateInCRL", pCert, pCrlContext, dwFlags, pvReserved, ppCrlEntry);
            }
            return (int)mh$.invokeExact(pCert, pCrlContext, dwFlags, pvReserved, ppCrlEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertIsValidCRLForCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertIsValidCRLForCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CertIsValidCRLForCertificate$descriptor() {
        return CertIsValidCRLForCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CertIsValidCRLForCertificate$handle() {
        return CertIsValidCRLForCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CertIsValidCRLForCertificate$address() {
        return CertIsValidCRLForCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CertIsValidCRLForCertificate(MemorySegment pCert, MemorySegment pCrl, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CertIsValidCRLForCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsValidCRLForCertificate", pCert, pCrl, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pCert, pCrl, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCertificateToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddEncodedCertificateToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCertificateToStore$descriptor() {
        return CertAddEncodedCertificateToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static MethodHandle CertAddEncodedCertificateToStore$handle() {
        return CertAddEncodedCertificateToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static MemorySegment CertAddEncodedCertificateToStore$address() {
        return CertAddEncodedCertificateToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static int CertAddEncodedCertificateToStore(MemorySegment hCertStore, int dwCertEncodingType, MemorySegment pbCertEncoded, int cbCertEncoded, int dwAddDisposition, MemorySegment ppCertContext) {
        var mh$ = CertAddEncodedCertificateToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCertificateToStore", hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext);
            }
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCertificateContextToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddCertificateContextToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCertificateContextToStore$descriptor() {
        return CertAddCertificateContextToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCertificateContextToStore$handle() {
        return CertAddCertificateContextToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCertificateContextToStore$address() {
        return CertAddCertificateContextToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCertificateContextToStore(MemorySegment hCertStore, MemorySegment pCertContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCertificateContextToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCertificateContextToStore", hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddSerializedElementToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddSerializedElementToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static FunctionDescriptor CertAddSerializedElementToStore$descriptor() {
        return CertAddSerializedElementToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static MethodHandle CertAddSerializedElementToStore$handle() {
        return CertAddSerializedElementToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static MemorySegment CertAddSerializedElementToStore$address() {
        return CertAddSerializedElementToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static int CertAddSerializedElementToStore(MemorySegment hCertStore, MemorySegment pbElement, int cbElement, int dwAddDisposition, int dwFlags, int dwContextTypeFlags, MemorySegment pdwContextType, MemorySegment ppvContext) {
        var mh$ = CertAddSerializedElementToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddSerializedElementToStore", hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext);
            }
            return (int)mh$.invokeExact(hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDeleteCertificateFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertDeleteCertificateFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static FunctionDescriptor CertDeleteCertificateFromStore$descriptor() {
        return CertDeleteCertificateFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MethodHandle CertDeleteCertificateFromStore$handle() {
        return CertDeleteCertificateFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MemorySegment CertDeleteCertificateFromStore$address() {
        return CertDeleteCertificateFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static int CertDeleteCertificateFromStore(MemorySegment pCertContext) {
        var mh$ = CertDeleteCertificateFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDeleteCertificateFromStore", pCertContext);
            }
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCRLToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddEncodedCRLToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCRLToStore$descriptor() {
        return CertAddEncodedCRLToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static MethodHandle CertAddEncodedCRLToStore$handle() {
        return CertAddEncodedCRLToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static MemorySegment CertAddEncodedCRLToStore$address() {
        return CertAddEncodedCRLToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static int CertAddEncodedCRLToStore(MemorySegment hCertStore, int dwCertEncodingType, MemorySegment pbCrlEncoded, int cbCrlEncoded, int dwAddDisposition, MemorySegment ppCrlContext) {
        var mh$ = CertAddEncodedCRLToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCRLToStore", hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext);
            }
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCRLContextToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddCRLContextToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCRLContextToStore$descriptor() {
        return CertAddCRLContextToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCRLContextToStore$handle() {
        return CertAddCRLContextToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCRLContextToStore$address() {
        return CertAddCRLContextToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCRLContextToStore(MemorySegment hCertStore, MemorySegment pCrlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCRLContextToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCRLContextToStore", hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDeleteCRLFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertDeleteCRLFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static FunctionDescriptor CertDeleteCRLFromStore$descriptor() {
        return CertDeleteCRLFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MethodHandle CertDeleteCRLFromStore$handle() {
        return CertDeleteCRLFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MemorySegment CertDeleteCRLFromStore$address() {
        return CertDeleteCRLFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static int CertDeleteCRLFromStore(MemorySegment pCrlContext) {
        var mh$ = CertDeleteCRLFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDeleteCRLFromStore", pCrlContext);
            }
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSerializeCertificateStoreElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSerializeCertificateStoreElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static FunctionDescriptor CertSerializeCertificateStoreElement$descriptor() {
        return CertSerializeCertificateStoreElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MethodHandle CertSerializeCertificateStoreElement$handle() {
        return CertSerializeCertificateStoreElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MemorySegment CertSerializeCertificateStoreElement$address() {
        return CertSerializeCertificateStoreElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static int CertSerializeCertificateStoreElement(MemorySegment pCertContext, int dwFlags, MemorySegment pbElement, MemorySegment pcbElement) {
        var mh$ = CertSerializeCertificateStoreElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSerializeCertificateStoreElement", pCertContext, dwFlags, pbElement, pcbElement);
            }
            return (int)mh$.invokeExact(pCertContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSerializeCRLStoreElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSerializeCRLStoreElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static FunctionDescriptor CertSerializeCRLStoreElement$descriptor() {
        return CertSerializeCRLStoreElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MethodHandle CertSerializeCRLStoreElement$handle() {
        return CertSerializeCRLStoreElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MemorySegment CertSerializeCRLStoreElement$address() {
        return CertSerializeCRLStoreElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static int CertSerializeCRLStoreElement(MemorySegment pCrlContext, int dwFlags, MemorySegment pbElement, MemorySegment pcbElement) {
        var mh$ = CertSerializeCRLStoreElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSerializeCRLStoreElement", pCrlContext, dwFlags, pbElement, pcbElement);
            }
            return (int)mh$.invokeExact(pCrlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDuplicateCTLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertDuplicateCTLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCTLContext$descriptor() {
        return CertDuplicateCTLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MethodHandle CertDuplicateCTLContext$handle() {
        return CertDuplicateCTLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MemorySegment CertDuplicateCTLContext$address() {
        return CertDuplicateCTLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MemorySegment CertDuplicateCTLContext(MemorySegment pCtlContext) {
        var mh$ = CertDuplicateCTLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCTLContext", pCtlContext);
            }
            return (MemorySegment)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCTLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCreateCTLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static FunctionDescriptor CertCreateCTLContext$descriptor() {
        return CertCreateCTLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static MethodHandle CertCreateCTLContext$handle() {
        return CertCreateCTLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static MemorySegment CertCreateCTLContext$address() {
        return CertCreateCTLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static MemorySegment CertCreateCTLContext(int dwMsgAndCertEncodingType, MemorySegment pbCtlEncoded, int cbCtlEncoded) {
        var mh$ = CertCreateCTLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCTLContext", dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCTLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFreeCTLContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static FunctionDescriptor CertFreeCTLContext$descriptor() {
        return CertFreeCTLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MethodHandle CertFreeCTLContext$handle() {
        return CertFreeCTLContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MemorySegment CertFreeCTLContext$address() {
        return CertFreeCTLContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static int CertFreeCTLContext(MemorySegment pCtlContext) {
        var mh$ = CertFreeCTLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCTLContext", pCtlContext);
            }
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCTLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSetCTLContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetCTLContextProperty$descriptor() {
        return CertSetCTLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetCTLContextProperty$handle() {
        return CertSetCTLContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MemorySegment CertSetCTLContextProperty$address() {
        return CertSetCTLContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetCTLContextProperty(MemorySegment pCtlContext, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetCTLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCTLContextProperty", pCtlContext, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(pCtlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCTLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetCTLContextProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetCTLContextProperty$descriptor() {
        return CertGetCTLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetCTLContextProperty$handle() {
        return CertGetCTLContextProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CertGetCTLContextProperty$address() {
        return CertGetCTLContextProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetCTLContextProperty(MemorySegment pCtlContext, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetCTLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCTLContextProperty", pCtlContext, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pCtlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCTLContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumCTLContextProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static FunctionDescriptor CertEnumCTLContextProperties$descriptor() {
        return CertEnumCTLContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static MethodHandle CertEnumCTLContextProperties$handle() {
        return CertEnumCTLContextProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static MemorySegment CertEnumCTLContextProperties$address() {
        return CertEnumCTLContextProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static int CertEnumCTLContextProperties(MemorySegment pCtlContext, int dwPropId) {
        var mh$ = CertEnumCTLContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCTLContextProperties", pCtlContext, dwPropId);
            }
            return (int)mh$.invokeExact(pCtlContext, dwPropId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCTLsInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumCTLsInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static FunctionDescriptor CertEnumCTLsInStore$descriptor() {
        return CertEnumCTLsInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MethodHandle CertEnumCTLsInStore$handle() {
        return CertEnumCTLsInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertEnumCTLsInStore$address() {
        return CertEnumCTLsInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertEnumCTLsInStore(MemorySegment hCertStore, MemorySegment pPrevCtlContext) {
        var mh$ = CertEnumCTLsInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCTLsInStore", hCertStore, pPrevCtlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pPrevCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindSubjectInCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindSubjectInCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertFindSubjectInCTL$descriptor() {
        return CertFindSubjectInCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertFindSubjectInCTL$handle() {
        return CertFindSubjectInCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertFindSubjectInCTL$address() {
        return CertFindSubjectInCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertFindSubjectInCTL(int dwEncodingType, int dwSubjectType, MemorySegment pvSubject, MemorySegment pCtlContext, int dwFlags) {
        var mh$ = CertFindSubjectInCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindSubjectInCTL", dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_ANY_SUBJECT_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
     *     CRYPT_DATA_BLOB SubjectIdentifier;
     * } *PCTL_ANY_SUBJECT_INFO
     * }
     */
    public static final AddressLayout PCTL_ANY_SUBJECT_INFO = winapi.C_POINTER;

    private static class CertFindCTLInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindCTLInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static FunctionDescriptor CertFindCTLInStore$descriptor() {
        return CertFindCTLInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MethodHandle CertFindCTLInStore$handle() {
        return CertFindCTLInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertFindCTLInStore$address() {
        return CertFindCTLInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertFindCTLInStore(MemorySegment hCertStore, int dwMsgAndCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevCtlContext) {
        var mh$ = CertFindCTLInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCTLInStore", hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_FIND_USAGE_PARA {
     *     DWORD cbSize;
     *     CTL_USAGE SubjectUsage;
     *     CRYPT_DATA_BLOB ListIdentifier;
     *     PCERT_INFO pSigner;
     * } *PCTL_FIND_USAGE_PARA
     * }
     */
    public static final AddressLayout PCTL_FIND_USAGE_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_FIND_SUBJECT_PARA {
     *     DWORD cbSize;
     *     PCTL_FIND_USAGE_PARA pUsagePara;
     *     DWORD dwSubjectType;
     *     void *pvSubject;
     * } *PCTL_FIND_SUBJECT_PARA
     * }
     */
    public static final AddressLayout PCTL_FIND_SUBJECT_PARA = winapi.C_POINTER;

    private static class CertAddEncodedCTLToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddEncodedCTLToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCTLToStore$descriptor() {
        return CertAddEncodedCTLToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static MethodHandle CertAddEncodedCTLToStore$handle() {
        return CertAddEncodedCTLToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static MemorySegment CertAddEncodedCTLToStore$address() {
        return CertAddEncodedCTLToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static int CertAddEncodedCTLToStore(MemorySegment hCertStore, int dwMsgAndCertEncodingType, MemorySegment pbCtlEncoded, int cbCtlEncoded, int dwAddDisposition, MemorySegment ppCtlContext) {
        var mh$ = CertAddEncodedCTLToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCTLToStore", hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext);
            }
            return (int)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCTLContextToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddCTLContextToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCTLContextToStore$descriptor() {
        return CertAddCTLContextToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCTLContextToStore$handle() {
        return CertAddCTLContextToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCTLContextToStore$address() {
        return CertAddCTLContextToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCTLContextToStore(MemorySegment hCertStore, MemorySegment pCtlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCTLContextToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCTLContextToStore", hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSerializeCTLStoreElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSerializeCTLStoreElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static FunctionDescriptor CertSerializeCTLStoreElement$descriptor() {
        return CertSerializeCTLStoreElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MethodHandle CertSerializeCTLStoreElement$handle() {
        return CertSerializeCTLStoreElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MemorySegment CertSerializeCTLStoreElement$address() {
        return CertSerializeCTLStoreElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static int CertSerializeCTLStoreElement(MemorySegment pCtlContext, int dwFlags, MemorySegment pbElement, MemorySegment pcbElement) {
        var mh$ = CertSerializeCTLStoreElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSerializeCTLStoreElement", pCtlContext, dwFlags, pbElement, pcbElement);
            }
            return (int)mh$.invokeExact(pCtlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDeleteCTLFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertDeleteCTLFromStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static FunctionDescriptor CertDeleteCTLFromStore$descriptor() {
        return CertDeleteCTLFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MethodHandle CertDeleteCTLFromStore$handle() {
        return CertDeleteCTLFromStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MemorySegment CertDeleteCTLFromStore$address() {
        return CertDeleteCTLFromStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static int CertDeleteCTLFromStore(MemorySegment pCtlContext) {
        var mh$ = CertDeleteCTLFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDeleteCTLFromStore", pCtlContext);
            }
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCertificateLinkToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddCertificateLinkToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCertificateLinkToStore$descriptor() {
        return CertAddCertificateLinkToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCertificateLinkToStore$handle() {
        return CertAddCertificateLinkToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCertificateLinkToStore$address() {
        return CertAddCertificateLinkToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCertificateLinkToStore(MemorySegment hCertStore, MemorySegment pCertContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCertificateLinkToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCertificateLinkToStore", hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCRLLinkToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddCRLLinkToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCRLLinkToStore$descriptor() {
        return CertAddCRLLinkToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCRLLinkToStore$handle() {
        return CertAddCRLLinkToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCRLLinkToStore$address() {
        return CertAddCRLLinkToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCRLLinkToStore(MemorySegment hCertStore, MemorySegment pCrlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCRLLinkToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCRLLinkToStore", hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCTLLinkToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddCTLLinkToStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCTLLinkToStore$descriptor() {
        return CertAddCTLLinkToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCTLLinkToStore$handle() {
        return CertAddCTLLinkToStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MemorySegment CertAddCTLLinkToStore$address() {
        return CertAddCTLLinkToStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCTLLinkToStore(MemorySegment hCertStore, MemorySegment pCtlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCTLLinkToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCTLLinkToStore", hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddStoreToCollection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddStoreToCollection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static FunctionDescriptor CertAddStoreToCollection$descriptor() {
        return CertAddStoreToCollection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static MethodHandle CertAddStoreToCollection$handle() {
        return CertAddStoreToCollection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static MemorySegment CertAddStoreToCollection$address() {
        return CertAddStoreToCollection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static int CertAddStoreToCollection(MemorySegment hCollectionStore, MemorySegment hSiblingStore, int dwUpdateFlags, int dwPriority) {
        var mh$ = CertAddStoreToCollection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddStoreToCollection", hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority);
            }
            return (int)mh$.invokeExact(hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRemoveStoreFromCollection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertRemoveStoreFromCollection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static FunctionDescriptor CertRemoveStoreFromCollection$descriptor() {
        return CertRemoveStoreFromCollection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static MethodHandle CertRemoveStoreFromCollection$handle() {
        return CertRemoveStoreFromCollection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static MemorySegment CertRemoveStoreFromCollection$address() {
        return CertRemoveStoreFromCollection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static void CertRemoveStoreFromCollection(MemorySegment hCollectionStore, MemorySegment hSiblingStore) {
        var mh$ = CertRemoveStoreFromCollection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRemoveStoreFromCollection", hCollectionStore, hSiblingStore);
            }
            mh$.invokeExact(hCollectionStore, hSiblingStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertControlStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertControlStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static FunctionDescriptor CertControlStore$descriptor() {
        return CertControlStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MethodHandle CertControlStore$handle() {
        return CertControlStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MemorySegment CertControlStore$address() {
        return CertControlStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static int CertControlStore(MemorySegment hCertStore, int dwFlags, int dwCtrlType, MemorySegment pvCtrlPara) {
        var mh$ = CertControlStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertControlStore", hCertStore, dwFlags, dwCtrlType, pvCtrlPara);
            }
            return (int)mh$.invokeExact(hCertStore, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetStoreProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSetStoreProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetStoreProperty$descriptor() {
        return CertSetStoreProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetStoreProperty$handle() {
        return CertSetStoreProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MemorySegment CertSetStoreProperty$address() {
        return CertSetStoreProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetStoreProperty(MemorySegment hCertStore, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetStoreProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetStoreProperty", hCertStore, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(hCertStore, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetStoreProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetStoreProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetStoreProperty$descriptor() {
        return CertGetStoreProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetStoreProperty$handle() {
        return CertGetStoreProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CertGetStoreProperty$address() {
        return CertGetStoreProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetStoreProperty(MemorySegment hCertStore, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetStoreProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetStoreProperty", hCertStore, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hCertStore, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CREATE_CONTEXT_PARA {
     *     DWORD cbSize;
     *     PFN_CRYPT_FREE pfnFree;
     *     void *pvFree;
     *     PFN_CERT_CREATE_CONTEXT_SORT_FUNC pfnSort;
     *     void *pvSort;
     * } *PCERT_CREATE_CONTEXT_PARA
     * }
     */
    public static final AddressLayout PCERT_CREATE_CONTEXT_PARA = winapi.C_POINTER;

    private static class CertCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static FunctionDescriptor CertCreateContext$descriptor() {
        return CertCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static MethodHandle CertCreateContext$handle() {
        return CertCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static MemorySegment CertCreateContext$address() {
        return CertCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static MemorySegment CertCreateContext(int dwContextType, int dwEncodingType, MemorySegment pbEncoded, int cbEncoded, int dwFlags, MemorySegment pCreatePara) {
        var mh$ = CertCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateContext", dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara);
            }
            return (MemorySegment)mh$.invokeExact(dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SYSTEM_STORE_INFO {
     *     DWORD cbSize;
     * } *PCERT_SYSTEM_STORE_INFO
     * }
     */
    public static final AddressLayout PCERT_SYSTEM_STORE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PHYSICAL_STORE_INFO {
     *     DWORD cbSize;
     *     LPSTR pszOpenStoreProvider;
     *     DWORD dwOpenEncodingType;
     *     DWORD dwOpenFlags;
     *     CRYPT_DATA_BLOB OpenParameters;
     *     DWORD dwFlags;
     *     DWORD dwPriority;
     * } *PCERT_PHYSICAL_STORE_INFO
     * }
     */
    public static final AddressLayout PCERT_PHYSICAL_STORE_INFO = winapi.C_POINTER;

    private static class CertRegisterSystemStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertRegisterSystemStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CertRegisterSystemStore$descriptor() {
        return CertRegisterSystemStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MethodHandle CertRegisterSystemStore$handle() {
        return CertRegisterSystemStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MemorySegment CertRegisterSystemStore$address() {
        return CertRegisterSystemStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static int CertRegisterSystemStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pStoreInfo, MemorySegment pvReserved) {
        var mh$ = CertRegisterSystemStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRegisterSystemStore", pvSystemStore, dwFlags, pStoreInfo, pvReserved);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRegisterPhysicalStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertRegisterPhysicalStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CertRegisterPhysicalStore$descriptor() {
        return CertRegisterPhysicalStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MethodHandle CertRegisterPhysicalStore$handle() {
        return CertRegisterPhysicalStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MemorySegment CertRegisterPhysicalStore$address() {
        return CertRegisterPhysicalStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static int CertRegisterPhysicalStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pwszStoreName, MemorySegment pStoreInfo, MemorySegment pvReserved) {
        var mh$ = CertRegisterPhysicalStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRegisterPhysicalStore", pvSystemStore, dwFlags, pwszStoreName, pStoreInfo, pvReserved);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertUnregisterSystemStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertUnregisterSystemStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertUnregisterSystemStore$descriptor() {
        return CertUnregisterSystemStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertUnregisterSystemStore$handle() {
        return CertUnregisterSystemStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertUnregisterSystemStore$address() {
        return CertUnregisterSystemStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static int CertUnregisterSystemStore(MemorySegment pvSystemStore, int dwFlags) {
        var mh$ = CertUnregisterSystemStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertUnregisterSystemStore", pvSystemStore, dwFlags);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertUnregisterPhysicalStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertUnregisterPhysicalStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static FunctionDescriptor CertUnregisterPhysicalStore$descriptor() {
        return CertUnregisterPhysicalStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static MethodHandle CertUnregisterPhysicalStore$handle() {
        return CertUnregisterPhysicalStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static MemorySegment CertUnregisterPhysicalStore$address() {
        return CertUnregisterPhysicalStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static int CertUnregisterPhysicalStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pwszStoreName) {
        var mh$ = CertUnregisterPhysicalStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertUnregisterPhysicalStore", pvSystemStore, dwFlags, pwszStoreName);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumSystemStoreLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumSystemStoreLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static FunctionDescriptor CertEnumSystemStoreLocation$descriptor() {
        return CertEnumSystemStoreLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static MethodHandle CertEnumSystemStoreLocation$handle() {
        return CertEnumSystemStoreLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static MemorySegment CertEnumSystemStoreLocation$address() {
        return CertEnumSystemStoreLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static int CertEnumSystemStoreLocation(int dwFlags, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CertEnumSystemStoreLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumSystemStoreLocation", dwFlags, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumSystemStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumSystemStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static FunctionDescriptor CertEnumSystemStore$descriptor() {
        return CertEnumSystemStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static MethodHandle CertEnumSystemStore$handle() {
        return CertEnumSystemStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static MemorySegment CertEnumSystemStore$address() {
        return CertEnumSystemStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static int CertEnumSystemStore(int dwFlags, MemorySegment pvSystemStoreLocationPara, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CertEnumSystemStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumSystemStore", dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumPhysicalStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumPhysicalStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static FunctionDescriptor CertEnumPhysicalStore$descriptor() {
        return CertEnumPhysicalStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static MethodHandle CertEnumPhysicalStore$handle() {
        return CertEnumPhysicalStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static MemorySegment CertEnumPhysicalStore$address() {
        return CertEnumPhysicalStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static int CertEnumPhysicalStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CertEnumPhysicalStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumPhysicalStore", pvSystemStore, dwFlags, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetEnhancedKeyUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetEnhancedKeyUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static FunctionDescriptor CertGetEnhancedKeyUsage$descriptor() {
        return CertGetEnhancedKeyUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static MethodHandle CertGetEnhancedKeyUsage$handle() {
        return CertGetEnhancedKeyUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static MemorySegment CertGetEnhancedKeyUsage$address() {
        return CertGetEnhancedKeyUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static int CertGetEnhancedKeyUsage(MemorySegment pCertContext, int dwFlags, MemorySegment pUsage, MemorySegment pcbUsage) {
        var mh$ = CertGetEnhancedKeyUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetEnhancedKeyUsage", pCertContext, dwFlags, pUsage, pcbUsage);
            }
            return (int)mh$.invokeExact(pCertContext, dwFlags, pUsage, pcbUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetEnhancedKeyUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSetEnhancedKeyUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static FunctionDescriptor CertSetEnhancedKeyUsage$descriptor() {
        return CertSetEnhancedKeyUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static MethodHandle CertSetEnhancedKeyUsage$handle() {
        return CertSetEnhancedKeyUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static MemorySegment CertSetEnhancedKeyUsage$address() {
        return CertSetEnhancedKeyUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static int CertSetEnhancedKeyUsage(MemorySegment pCertContext, MemorySegment pUsage) {
        var mh$ = CertSetEnhancedKeyUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetEnhancedKeyUsage", pCertContext, pUsage);
            }
            return (int)mh$.invokeExact(pCertContext, pUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEnhancedKeyUsageIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddEnhancedKeyUsageIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static FunctionDescriptor CertAddEnhancedKeyUsageIdentifier$descriptor() {
        return CertAddEnhancedKeyUsageIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MethodHandle CertAddEnhancedKeyUsageIdentifier$handle() {
        return CertAddEnhancedKeyUsageIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MemorySegment CertAddEnhancedKeyUsageIdentifier$address() {
        return CertAddEnhancedKeyUsageIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static int CertAddEnhancedKeyUsageIdentifier(MemorySegment pCertContext, MemorySegment pszUsageIdentifier) {
        var mh$ = CertAddEnhancedKeyUsageIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEnhancedKeyUsageIdentifier", pCertContext, pszUsageIdentifier);
            }
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRemoveEnhancedKeyUsageIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertRemoveEnhancedKeyUsageIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static FunctionDescriptor CertRemoveEnhancedKeyUsageIdentifier$descriptor() {
        return CertRemoveEnhancedKeyUsageIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MethodHandle CertRemoveEnhancedKeyUsageIdentifier$handle() {
        return CertRemoveEnhancedKeyUsageIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MemorySegment CertRemoveEnhancedKeyUsageIdentifier$address() {
        return CertRemoveEnhancedKeyUsageIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static int CertRemoveEnhancedKeyUsageIdentifier(MemorySegment pCertContext, MemorySegment pszUsageIdentifier) {
        var mh$ = CertRemoveEnhancedKeyUsageIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRemoveEnhancedKeyUsageIdentifier", pCertContext, pszUsageIdentifier);
            }
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetValidUsages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetValidUsages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static FunctionDescriptor CertGetValidUsages$descriptor() {
        return CertGetValidUsages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static MethodHandle CertGetValidUsages$handle() {
        return CertGetValidUsages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static MemorySegment CertGetValidUsages$address() {
        return CertGetValidUsages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static int CertGetValidUsages(int cCerts, MemorySegment rghCerts, MemorySegment cNumOIDs, MemorySegment rghOIDs, MemorySegment pcbOIDs) {
        var mh$ = CertGetValidUsages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetValidUsages", cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs);
            }
            return (int)mh$.invokeExact(cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgGetAndVerifySigner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgGetAndVerifySigner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static FunctionDescriptor CryptMsgGetAndVerifySigner$descriptor() {
        return CryptMsgGetAndVerifySigner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static MethodHandle CryptMsgGetAndVerifySigner$handle() {
        return CryptMsgGetAndVerifySigner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static MemorySegment CryptMsgGetAndVerifySigner$address() {
        return CryptMsgGetAndVerifySigner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static int CryptMsgGetAndVerifySigner(MemorySegment hCryptMsg, int cSignerStore, MemorySegment rghSignerStore, int dwFlags, MemorySegment ppSigner, MemorySegment pdwSignerIndex) {
        var mh$ = CryptMsgGetAndVerifySigner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgGetAndVerifySigner", hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex);
            }
            return (int)mh$.invokeExact(hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgSignCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgSignCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptMsgSignCTL$descriptor() {
        return CryptMsgSignCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptMsgSignCTL$handle() {
        return CryptMsgSignCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptMsgSignCTL$address() {
        return CryptMsgSignCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptMsgSignCTL(int dwMsgEncodingType, MemorySegment pbCtlContent, int cbCtlContent, MemorySegment pSignInfo, int dwFlags, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptMsgSignCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgSignCTL", dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgEncodeAndSignCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMsgEncodeAndSignCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptMsgEncodeAndSignCTL$descriptor() {
        return CryptMsgEncodeAndSignCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptMsgEncodeAndSignCTL$handle() {
        return CryptMsgEncodeAndSignCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptMsgEncodeAndSignCTL$address() {
        return CryptMsgEncodeAndSignCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptMsgEncodeAndSignCTL(int dwMsgEncodingType, MemorySegment pCtlInfo, MemorySegment pSignInfo, int dwFlags, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptMsgEncodeAndSignCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgEncodeAndSignCTL", dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindSubjectInSortedCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindSubjectInSortedCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static FunctionDescriptor CertFindSubjectInSortedCTL$descriptor() {
        return CertFindSubjectInSortedCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MethodHandle CertFindSubjectInSortedCTL$handle() {
        return CertFindSubjectInSortedCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MemorySegment CertFindSubjectInSortedCTL$address() {
        return CertFindSubjectInSortedCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static int CertFindSubjectInSortedCTL(MemorySegment pSubjectIdentifier, MemorySegment pCtlContext, int dwFlags, MemorySegment pvReserved, MemorySegment pEncodedAttributes) {
        var mh$ = CertFindSubjectInSortedCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindSubjectInSortedCTL", pSubjectIdentifier, pCtlContext, dwFlags, pvReserved, pEncodedAttributes);
            }
            return (int)mh$.invokeExact(pSubjectIdentifier, pCtlContext, dwFlags, pvReserved, pEncodedAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumSubjectInSortedCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertEnumSubjectInSortedCTL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static FunctionDescriptor CertEnumSubjectInSortedCTL$descriptor() {
        return CertEnumSubjectInSortedCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MethodHandle CertEnumSubjectInSortedCTL$handle() {
        return CertEnumSubjectInSortedCTL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MemorySegment CertEnumSubjectInSortedCTL$address() {
        return CertEnumSubjectInSortedCTL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static int CertEnumSubjectInSortedCTL(MemorySegment pCtlContext, MemorySegment ppvNextSubject, MemorySegment pSubjectIdentifier, MemorySegment pEncodedAttributes) {
        var mh$ = CertEnumSubjectInSortedCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumSubjectInSortedCTL", pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes);
            }
            return (int)mh$.invokeExact(pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_VERIFY_USAGE_PARA {
     *     DWORD cbSize;
     *     CRYPT_DATA_BLOB ListIdentifier;
     *     DWORD cCtlStore;
     *     HCERTSTORE *rghCtlStore;
     *     DWORD cSignerStore;
     *     HCERTSTORE *rghSignerStore;
     * } *PCTL_VERIFY_USAGE_PARA
     * }
     */
    public static final AddressLayout PCTL_VERIFY_USAGE_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_VERIFY_USAGE_STATUS {
     *     DWORD cbSize;
     *     DWORD dwError;
     *     DWORD dwFlags;
     *     PCCTL_CONTEXT *ppCtl;
     *     DWORD dwCtlEntryIndex;
     *     PCCERT_CONTEXT *ppSigner;
     *     DWORD dwSignerIndex;
     * } *PCTL_VERIFY_USAGE_STATUS
     * }
     */
    public static final AddressLayout PCTL_VERIFY_USAGE_STATUS = winapi.C_POINTER;

    private static class CertVerifyCTLUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertVerifyCTLUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static FunctionDescriptor CertVerifyCTLUsage$descriptor() {
        return CertVerifyCTLUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static MethodHandle CertVerifyCTLUsage$handle() {
        return CertVerifyCTLUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static MemorySegment CertVerifyCTLUsage$address() {
        return CertVerifyCTLUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static int CertVerifyCTLUsage(int dwEncodingType, int dwSubjectType, MemorySegment pvSubject, MemorySegment pSubjectUsage, int dwFlags, MemorySegment pVerifyUsagePara, MemorySegment pVerifyUsageStatus) {
        var mh$ = CertVerifyCTLUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCTLUsage", dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus);
            }
            return (int)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_CRL_INFO {
     *     DWORD cbSize;
     *     PCCRL_CONTEXT pBaseCrlContext;
     *     PCCRL_CONTEXT pDeltaCrlContext;
     *     PCRL_ENTRY pCrlEntry;
     *     BOOL fDeltaCrlEntry;
     * } *PCERT_REVOCATION_CRL_INFO
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_CRL_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_CHAIN_PARA *PCERT_REVOCATION_CHAIN_PARA
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_CHAIN_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_PARA {
     *     DWORD cbSize;
     *     PCCERT_CONTEXT pIssuerCert;
     *     DWORD cCertStore;
     *     HCERTSTORE *rgCertStore;
     *     HCERTSTORE hCrlStore;
     *     LPFILETIME pftTimeToUse;
     * } *PCERT_REVOCATION_PARA
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_STATUS {
     *     DWORD cbSize;
     *     DWORD dwIndex;
     *     DWORD dwError;
     *     DWORD dwReason;
     *     BOOL fHasFreshnessTime;
     *     DWORD dwFreshnessTime;
     * } *PCERT_REVOCATION_STATUS
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_STATUS = winapi.C_POINTER;

    private static class CertVerifyRevocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertVerifyRevocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static FunctionDescriptor CertVerifyRevocation$descriptor() {
        return CertVerifyRevocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static MethodHandle CertVerifyRevocation$handle() {
        return CertVerifyRevocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static MemorySegment CertVerifyRevocation$address() {
        return CertVerifyRevocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static int CertVerifyRevocation(int dwEncodingType, int dwRevType, int cContext, MemorySegment rgpvContext, int dwFlags, MemorySegment pRevPara, MemorySegment pRevStatus) {
        var mh$ = CertVerifyRevocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyRevocation", dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus);
            }
            return (int)mh$.invokeExact(dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCompareIntegerBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCompareIntegerBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static FunctionDescriptor CertCompareIntegerBlob$descriptor() {
        return CertCompareIntegerBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static MethodHandle CertCompareIntegerBlob$handle() {
        return CertCompareIntegerBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static MemorySegment CertCompareIntegerBlob$address() {
        return CertCompareIntegerBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static int CertCompareIntegerBlob(MemorySegment pInt1, MemorySegment pInt2) {
        var mh$ = CertCompareIntegerBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCompareIntegerBlob", pInt1, pInt2);
            }
            return (int)mh$.invokeExact(pInt1, pInt2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCompareCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCompareCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static FunctionDescriptor CertCompareCertificate$descriptor() {
        return CertCompareCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static MethodHandle CertCompareCertificate$handle() {
        return CertCompareCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static MemorySegment CertCompareCertificate$address() {
        return CertCompareCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static int CertCompareCertificate(int dwCertEncodingType, MemorySegment pCertId1, MemorySegment pCertId2) {
        var mh$ = CertCompareCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCompareCertificate", dwCertEncodingType, pCertId1, pCertId2);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId1, pCertId2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCompareCertificateName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCompareCertificateName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static FunctionDescriptor CertCompareCertificateName$descriptor() {
        return CertCompareCertificateName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static MethodHandle CertCompareCertificateName$handle() {
        return CertCompareCertificateName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static MemorySegment CertCompareCertificateName$address() {
        return CertCompareCertificateName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static int CertCompareCertificateName(int dwCertEncodingType, MemorySegment pCertName1, MemorySegment pCertName2) {
        var mh$ = CertCompareCertificateName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCompareCertificateName", dwCertEncodingType, pCertName1, pCertName2);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertName1, pCertName2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertIsRDNAttrsInCertificateName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertIsRDNAttrsInCertificateName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static FunctionDescriptor CertIsRDNAttrsInCertificateName$descriptor() {
        return CertIsRDNAttrsInCertificateName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static MethodHandle CertIsRDNAttrsInCertificateName$handle() {
        return CertIsRDNAttrsInCertificateName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static MemorySegment CertIsRDNAttrsInCertificateName$address() {
        return CertIsRDNAttrsInCertificateName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static int CertIsRDNAttrsInCertificateName(int dwCertEncodingType, int dwFlags, MemorySegment pCertName, MemorySegment pRDN) {
        var mh$ = CertIsRDNAttrsInCertificateName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsRDNAttrsInCertificateName", dwCertEncodingType, dwFlags, pCertName, pRDN);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, dwFlags, pCertName, pRDN);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertComparePublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertComparePublicKeyInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static FunctionDescriptor CertComparePublicKeyInfo$descriptor() {
        return CertComparePublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static MethodHandle CertComparePublicKeyInfo$handle() {
        return CertComparePublicKeyInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static MemorySegment CertComparePublicKeyInfo$address() {
        return CertComparePublicKeyInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static int CertComparePublicKeyInfo(int dwCertEncodingType, MemorySegment pPublicKey1, MemorySegment pPublicKey2) {
        var mh$ = CertComparePublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertComparePublicKeyInfo", dwCertEncodingType, pPublicKey1, pPublicKey2);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey1, pPublicKey2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetPublicKeyLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetPublicKeyLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static FunctionDescriptor CertGetPublicKeyLength$descriptor() {
        return CertGetPublicKeyLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MethodHandle CertGetPublicKeyLength$handle() {
        return CertGetPublicKeyLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MemorySegment CertGetPublicKeyLength$address() {
        return CertGetPublicKeyLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static int CertGetPublicKeyLength(int dwCertEncodingType, MemorySegment pPublicKey) {
        var mh$ = CertGetPublicKeyLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetPublicKeyLength", dwCertEncodingType, pPublicKey);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyCertificateSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptVerifyCertificateSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static FunctionDescriptor CryptVerifyCertificateSignature$descriptor() {
        return CryptVerifyCertificateSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MethodHandle CryptVerifyCertificateSignature$handle() {
        return CryptVerifyCertificateSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MemorySegment CryptVerifyCertificateSignature$address() {
        return CryptVerifyCertificateSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static int CryptVerifyCertificateSignature(long hCryptProv, int dwCertEncodingType, MemorySegment pbEncoded, int cbEncoded, MemorySegment pPublicKey) {
        var mh$ = CryptVerifyCertificateSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyCertificateSignature", hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyCertificateSignatureEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptVerifyCertificateSignatureEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static FunctionDescriptor CryptVerifyCertificateSignatureEx$descriptor() {
        return CryptVerifyCertificateSignatureEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MethodHandle CryptVerifyCertificateSignatureEx$handle() {
        return CryptVerifyCertificateSignatureEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MemorySegment CryptVerifyCertificateSignatureEx$address() {
        return CryptVerifyCertificateSignatureEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static int CryptVerifyCertificateSignatureEx(long hCryptProv, int dwCertEncodingType, int dwSubjectType, MemorySegment pvSubject, int dwIssuerType, MemorySegment pvIssuer, int dwFlags, MemorySegment pvExtra) {
        var mh$ = CryptVerifyCertificateSignatureEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyCertificateSignatureEx", hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO {
     *     CRYPT_DATA_BLOB CertSignHashCNGAlgPropData;
     *     CRYPT_DATA_BLOB CertIssuerPubKeyBitLengthPropData;
     * } *PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO
     * }
     */
    public static final AddressLayout PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO {
     *     DWORD cCNGHashAlgid;
     *     PCWSTR *rgpwszCNGHashAlgid;
     *     DWORD dwWeakIndex;
     * } *PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO
     * }
     */
    public static final AddressLayout PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = winapi.C_POINTER;

    private static class CertIsStrongHashToSign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertIsStrongHashToSign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static FunctionDescriptor CertIsStrongHashToSign$descriptor() {
        return CertIsStrongHashToSign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static MethodHandle CertIsStrongHashToSign$handle() {
        return CertIsStrongHashToSign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static MemorySegment CertIsStrongHashToSign$address() {
        return CertIsStrongHashToSign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static int CertIsStrongHashToSign(MemorySegment pStrongSignPara, MemorySegment pwszCNGHashAlgid, MemorySegment pSigningCert) {
        var mh$ = CertIsStrongHashToSign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsStrongHashToSign", pStrongSignPara, pwszCNGHashAlgid, pSigningCert);
            }
            return (int)mh$.invokeExact(pStrongSignPara, pwszCNGHashAlgid, pSigningCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashToBeSigned {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptHashToBeSigned");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashToBeSigned$descriptor() {
        return CryptHashToBeSigned.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashToBeSigned$handle() {
        return CryptHashToBeSigned.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashToBeSigned$address() {
        return CryptHashToBeSigned.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashToBeSigned(long hCryptProv, int dwCertEncodingType, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashToBeSigned.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashToBeSigned", hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptHashCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashCertificate$descriptor() {
        return CryptHashCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashCertificate$handle() {
        return CryptHashCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashCertificate$address() {
        return CryptHashCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashCertificate(long hCryptProv, int Algid, int dwFlags, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashCertificate", hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashCertificate2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptHashCertificate2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashCertificate2$descriptor() {
        return CryptHashCertificate2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashCertificate2$handle() {
        return CryptHashCertificate2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashCertificate2$address() {
        return CryptHashCertificate2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashCertificate2(MemorySegment pwszCNGHashAlgid, int dwFlags, MemorySegment pvReserved, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashCertificate2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashCertificate2", pwszCNGHashAlgid, dwFlags, pvReserved, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pwszCNGHashAlgid, dwFlags, pvReserved, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptSignCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static FunctionDescriptor CryptSignCertificate$descriptor() {
        return CryptSignCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static MethodHandle CryptSignCertificate$handle() {
        return CryptSignCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static MemorySegment CryptSignCertificate$address() {
        return CryptSignCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static int CryptSignCertificate(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment pbEncodedToBeSigned, int cbEncodedToBeSigned, MemorySegment pSignatureAlgorithm, MemorySegment pvHashAuxInfo, MemorySegment pbSignature, MemorySegment pcbSignature) {
        var mh$ = CryptSignCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignCertificate", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignAndEncodeCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptSignAndEncodeCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptSignAndEncodeCertificate$descriptor() {
        return CryptSignAndEncodeCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptSignAndEncodeCertificate$handle() {
        return CryptSignAndEncodeCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MemorySegment CryptSignAndEncodeCertificate$address() {
        return CryptSignAndEncodeCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptSignAndEncodeCertificate(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pvStructInfo, MemorySegment pSignatureAlgorithm, MemorySegment pvHashAuxInfo, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptSignAndEncodeCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignAndEncodeCertificate", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyTimeValidity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertVerifyTimeValidity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static FunctionDescriptor CertVerifyTimeValidity$descriptor() {
        return CertVerifyTimeValidity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static MethodHandle CertVerifyTimeValidity$handle() {
        return CertVerifyTimeValidity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static MemorySegment CertVerifyTimeValidity$address() {
        return CertVerifyTimeValidity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static int CertVerifyTimeValidity(MemorySegment pTimeToVerify, MemorySegment pCertInfo) {
        var mh$ = CertVerifyTimeValidity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyTimeValidity", pTimeToVerify, pCertInfo);
            }
            return (int)mh$.invokeExact(pTimeToVerify, pCertInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyCRLTimeValidity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertVerifyCRLTimeValidity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static FunctionDescriptor CertVerifyCRLTimeValidity$descriptor() {
        return CertVerifyCRLTimeValidity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static MethodHandle CertVerifyCRLTimeValidity$handle() {
        return CertVerifyCRLTimeValidity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static MemorySegment CertVerifyCRLTimeValidity$address() {
        return CertVerifyCRLTimeValidity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static int CertVerifyCRLTimeValidity(MemorySegment pTimeToVerify, MemorySegment pCrlInfo) {
        var mh$ = CertVerifyCRLTimeValidity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCRLTimeValidity", pTimeToVerify, pCrlInfo);
            }
            return (int)mh$.invokeExact(pTimeToVerify, pCrlInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyValidityNesting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertVerifyValidityNesting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static FunctionDescriptor CertVerifyValidityNesting$descriptor() {
        return CertVerifyValidityNesting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static MethodHandle CertVerifyValidityNesting$handle() {
        return CertVerifyValidityNesting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static MemorySegment CertVerifyValidityNesting$address() {
        return CertVerifyValidityNesting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static int CertVerifyValidityNesting(MemorySegment pSubjectInfo, MemorySegment pIssuerInfo) {
        var mh$ = CertVerifyValidityNesting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyValidityNesting", pSubjectInfo, pIssuerInfo);
            }
            return (int)mh$.invokeExact(pSubjectInfo, pIssuerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyCRLRevocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertVerifyCRLRevocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static FunctionDescriptor CertVerifyCRLRevocation$descriptor() {
        return CertVerifyCRLRevocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static MethodHandle CertVerifyCRLRevocation$handle() {
        return CertVerifyCRLRevocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static MemorySegment CertVerifyCRLRevocation$address() {
        return CertVerifyCRLRevocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static int CertVerifyCRLRevocation(int dwCertEncodingType, MemorySegment pCertId, int cCrlInfo, MemorySegment rgpCrlInfo) {
        var mh$ = CertVerifyCRLRevocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCRLRevocation", dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAlgIdToOID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAlgIdToOID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static FunctionDescriptor CertAlgIdToOID$descriptor() {
        return CertAlgIdToOID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static MethodHandle CertAlgIdToOID$handle() {
        return CertAlgIdToOID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static MemorySegment CertAlgIdToOID$address() {
        return CertAlgIdToOID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static MemorySegment CertAlgIdToOID(int dwAlgId) {
        var mh$ = CertAlgIdToOID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAlgIdToOID", dwAlgId);
            }
            return (MemorySegment)mh$.invokeExact(dwAlgId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertOIDToAlgId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertOIDToAlgId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static FunctionDescriptor CertOIDToAlgId$descriptor() {
        return CertOIDToAlgId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static MethodHandle CertOIDToAlgId$handle() {
        return CertOIDToAlgId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static MemorySegment CertOIDToAlgId$address() {
        return CertOIDToAlgId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static int CertOIDToAlgId(MemorySegment pszObjId) {
        var mh$ = CertOIDToAlgId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOIDToAlgId", pszObjId);
            }
            return (int)mh$.invokeExact(pszObjId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindExtension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindExtension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static FunctionDescriptor CertFindExtension$descriptor() {
        return CertFindExtension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static MethodHandle CertFindExtension$handle() {
        return CertFindExtension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static MemorySegment CertFindExtension$address() {
        return CertFindExtension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static MemorySegment CertFindExtension(MemorySegment pszObjId, int cExtensions, MemorySegment rgExtensions) {
        var mh$ = CertFindExtension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindExtension", pszObjId, cExtensions, rgExtensions);
            }
            return (MemorySegment)mh$.invokeExact(pszObjId, cExtensions, rgExtensions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static FunctionDescriptor CertFindAttribute$descriptor() {
        return CertFindAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static MethodHandle CertFindAttribute$handle() {
        return CertFindAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static MemorySegment CertFindAttribute$address() {
        return CertFindAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static MemorySegment CertFindAttribute(MemorySegment pszObjId, int cAttr, MemorySegment rgAttr) {
        var mh$ = CertFindAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindAttribute", pszObjId, cAttr, rgAttr);
            }
            return (MemorySegment)mh$.invokeExact(pszObjId, cAttr, rgAttr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindRDNAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindRDNAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static FunctionDescriptor CertFindRDNAttr$descriptor() {
        return CertFindRDNAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static MethodHandle CertFindRDNAttr$handle() {
        return CertFindRDNAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static MemorySegment CertFindRDNAttr$address() {
        return CertFindRDNAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static MemorySegment CertFindRDNAttr(MemorySegment pszObjId, MemorySegment pName) {
        var mh$ = CertFindRDNAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindRDNAttr", pszObjId, pName);
            }
            return (MemorySegment)mh$.invokeExact(pszObjId, pName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetIntendedKeyUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetIntendedKeyUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static FunctionDescriptor CertGetIntendedKeyUsage$descriptor() {
        return CertGetIntendedKeyUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static MethodHandle CertGetIntendedKeyUsage$handle() {
        return CertGetIntendedKeyUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static MemorySegment CertGetIntendedKeyUsage$address() {
        return CertGetIntendedKeyUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static int CertGetIntendedKeyUsage(int dwCertEncodingType, MemorySegment pCertInfo, MemorySegment pbKeyUsage, int cbKeyUsage) {
        var mh$ = CertGetIntendedKeyUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetIntendedKeyUsage", dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTDEFAULTCONTEXT
     * }
     */
    public static final AddressLayout HCRYPTDEFAULTCONTEXT = winapi.C_POINTER;

    private static class CryptInstallDefaultContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptInstallDefaultContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static FunctionDescriptor CryptInstallDefaultContext$descriptor() {
        return CryptInstallDefaultContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static MethodHandle CryptInstallDefaultContext$handle() {
        return CryptInstallDefaultContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static MemorySegment CryptInstallDefaultContext$address() {
        return CryptInstallDefaultContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static int CryptInstallDefaultContext(long hCryptProv, int dwDefaultType, MemorySegment pvDefaultPara, int dwFlags, MemorySegment pvReserved, MemorySegment phDefaultContext) {
        var mh$ = CryptInstallDefaultContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInstallDefaultContext", hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, phDefaultContext);
            }
            return (int)mh$.invokeExact(hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, phDefaultContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA {
     *     DWORD cOID;
     *     LPSTR *rgpszOID;
     * } *PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA
     * }
     */
    public static final AddressLayout PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = winapi.C_POINTER;

    private static class CryptUninstallDefaultContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptUninstallDefaultContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptUninstallDefaultContext$descriptor() {
        return CryptUninstallDefaultContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptUninstallDefaultContext$handle() {
        return CryptUninstallDefaultContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CryptUninstallDefaultContext$address() {
        return CryptUninstallDefaultContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptUninstallDefaultContext(MemorySegment hDefaultContext, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptUninstallDefaultContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUninstallDefaultContext", hDefaultContext, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(hDefaultContext, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptExportPublicKeyInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static FunctionDescriptor CryptExportPublicKeyInfo$descriptor() {
        return CryptExportPublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MethodHandle CryptExportPublicKeyInfo$handle() {
        return CryptExportPublicKeyInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MemorySegment CryptExportPublicKeyInfo$address() {
        return CryptExportPublicKeyInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static int CryptExportPublicKeyInfo(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment pInfo, MemorySegment pcbInfo) {
        var mh$ = CryptExportPublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPublicKeyInfo", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPublicKeyInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptExportPublicKeyInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static FunctionDescriptor CryptExportPublicKeyInfoEx$descriptor() {
        return CryptExportPublicKeyInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MethodHandle CryptExportPublicKeyInfoEx$handle() {
        return CryptExportPublicKeyInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MemorySegment CryptExportPublicKeyInfoEx$address() {
        return CryptExportPublicKeyInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static int CryptExportPublicKeyInfoEx(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment pszPublicKeyObjId, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pInfo, MemorySegment pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPublicKeyInfoEx", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPublicKeyInfoFromBCryptKeyHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptExportPublicKeyInfoFromBCryptKeyHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static FunctionDescriptor CryptExportPublicKeyInfoFromBCryptKeyHandle$descriptor() {
        return CryptExportPublicKeyInfoFromBCryptKeyHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MethodHandle CryptExportPublicKeyInfoFromBCryptKeyHandle$handle() {
        return CryptExportPublicKeyInfoFromBCryptKeyHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MemorySegment CryptExportPublicKeyInfoFromBCryptKeyHandle$address() {
        return CryptExportPublicKeyInfoFromBCryptKeyHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static int CryptExportPublicKeyInfoFromBCryptKeyHandle(MemorySegment hBCryptKey, int dwCertEncodingType, MemorySegment pszPublicKeyObjId, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pInfo, MemorySegment pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoFromBCryptKeyHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPublicKeyInfoFromBCryptKeyHandle", hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
            }
            return (int)mh$.invokeExact(hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptImportPublicKeyInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportPublicKeyInfo$descriptor() {
        return CryptImportPublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptImportPublicKeyInfo$handle() {
        return CryptImportPublicKeyInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MemorySegment CryptImportPublicKeyInfo$address() {
        return CryptImportPublicKeyInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptImportPublicKeyInfo(long hCryptProv, int dwCertEncodingType, MemorySegment pInfo, MemorySegment phKey) {
        var mh$ = CryptImportPublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPublicKeyInfo", hCryptProv, dwCertEncodingType, pInfo, phKey);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPublicKeyInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptImportPublicKeyInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportPublicKeyInfoEx$descriptor() {
        return CryptImportPublicKeyInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptImportPublicKeyInfoEx$handle() {
        return CryptImportPublicKeyInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MemorySegment CryptImportPublicKeyInfoEx$address() {
        return CryptImportPublicKeyInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptImportPublicKeyInfoEx(long hCryptProv, int dwCertEncodingType, MemorySegment pInfo, int aiKeyAlg, int dwFlags, MemorySegment pvAuxInfo, MemorySegment phKey) {
        var mh$ = CryptImportPublicKeyInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPublicKeyInfoEx", hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPublicKeyInfoEx2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptImportPublicKeyInfoEx2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportPublicKeyInfoEx2$descriptor() {
        return CryptImportPublicKeyInfoEx2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static MethodHandle CryptImportPublicKeyInfoEx2$handle() {
        return CryptImportPublicKeyInfoEx2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static MemorySegment CryptImportPublicKeyInfoEx2$address() {
        return CryptImportPublicKeyInfoEx2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static int CryptImportPublicKeyInfoEx2(int dwCertEncodingType, MemorySegment pInfo, int dwFlags, MemorySegment pvAuxInfo, MemorySegment phKey) {
        var mh$ = CryptImportPublicKeyInfoEx2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPublicKeyInfoEx2", dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptAcquireCertificatePrivateKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptAcquireCertificatePrivateKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static FunctionDescriptor CryptAcquireCertificatePrivateKey$descriptor() {
        return CryptAcquireCertificatePrivateKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static MethodHandle CryptAcquireCertificatePrivateKey$handle() {
        return CryptAcquireCertificatePrivateKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static MemorySegment CryptAcquireCertificatePrivateKey$address() {
        return CryptAcquireCertificatePrivateKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static int CryptAcquireCertificatePrivateKey(MemorySegment pCert, int dwFlags, MemorySegment pvParameters, MemorySegment phCryptProvOrNCryptKey, MemorySegment pdwKeySpec, MemorySegment pfCallerFreeProvOrNCryptKey) {
        var mh$ = CryptAcquireCertificatePrivateKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptAcquireCertificatePrivateKey", pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey);
            }
            return (int)mh$.invokeExact(pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFindCertificateKeyProvInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptFindCertificateKeyProvInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptFindCertificateKeyProvInfo$descriptor() {
        return CryptFindCertificateKeyProvInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptFindCertificateKeyProvInfo$handle() {
        return CryptFindCertificateKeyProvInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CryptFindCertificateKeyProvInfo$address() {
        return CryptFindCertificateKeyProvInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptFindCertificateKeyProvInfo(MemorySegment pCert, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptFindCertificateKeyProvInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFindCertificateKeyProvInfo", pCert, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pCert, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPKCS8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            _CRYPT_PKCS8_IMPORT_PARAMS.layout(),
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptImportPKCS8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static FunctionDescriptor CryptImportPKCS8$descriptor() {
        return CryptImportPKCS8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static MethodHandle CryptImportPKCS8$handle() {
        return CryptImportPKCS8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static MemorySegment CryptImportPKCS8$address() {
        return CryptImportPKCS8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static int CryptImportPKCS8(MemorySegment sPrivateKeyAndParams, int dwFlags, MemorySegment phCryptProv, MemorySegment pvAuxInfo) {
        var mh$ = CryptImportPKCS8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPKCS8", sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo);
            }
            return (int)mh$.invokeExact(sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPKCS8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptExportPKCS8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static FunctionDescriptor CryptExportPKCS8$descriptor() {
        return CryptExportPKCS8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MethodHandle CryptExportPKCS8$handle() {
        return CryptExportPKCS8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MemorySegment CryptExportPKCS8$address() {
        return CryptExportPKCS8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static int CryptExportPKCS8(long hCryptProv, int dwKeySpec, MemorySegment pszPrivateKeyObjId, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pbPrivateKeyBlob, MemorySegment pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPKCS8", hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
            }
            return (int)mh$.invokeExact(hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPKCS8Ex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptExportPKCS8Ex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static FunctionDescriptor CryptExportPKCS8Ex$descriptor() {
        return CryptExportPKCS8Ex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MethodHandle CryptExportPKCS8Ex$handle() {
        return CryptExportPKCS8Ex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MemorySegment CryptExportPKCS8Ex$address() {
        return CryptExportPKCS8Ex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static int CryptExportPKCS8Ex(MemorySegment psExportParams, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pbPrivateKeyBlob, MemorySegment pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8Ex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPKCS8Ex", psExportParams, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
            }
            return (int)mh$.invokeExact(psExportParams, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashPublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG_LONG,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptHashPublicKeyInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashPublicKeyInfo$descriptor() {
        return CryptHashPublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashPublicKeyInfo$handle() {
        return CryptHashPublicKeyInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashPublicKeyInfo$address() {
        return CryptHashPublicKeyInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashPublicKeyInfo(long hCryptProv, int Algid, int dwFlags, int dwCertEncodingType, MemorySegment pInfo, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashPublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashPublicKeyInfo", hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRDNValueToStrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertRDNValueToStrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertRDNValueToStrA$descriptor() {
        return CertRDNValueToStrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertRDNValueToStrA$handle() {
        return CertRDNValueToStrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static MemorySegment CertRDNValueToStrA$address() {
        return CertRDNValueToStrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static int CertRDNValueToStrA(int dwValueType, MemorySegment pValue, MemorySegment psz, int csz) {
        var mh$ = CertRDNValueToStrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRDNValueToStrA", dwValueType, pValue, psz, csz);
            }
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRDNValueToStrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertRDNValueToStrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertRDNValueToStrW$descriptor() {
        return CertRDNValueToStrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertRDNValueToStrW$handle() {
        return CertRDNValueToStrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static MemorySegment CertRDNValueToStrW$address() {
        return CertRDNValueToStrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static int CertRDNValueToStrW(int dwValueType, MemorySegment pValue, MemorySegment psz, int csz) {
        var mh$ = CertRDNValueToStrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRDNValueToStrW", dwValueType, pValue, psz, csz);
            }
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertNameToStrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertNameToStrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertNameToStrA$descriptor() {
        return CertNameToStrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertNameToStrA$handle() {
        return CertNameToStrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static MemorySegment CertNameToStrA$address() {
        return CertNameToStrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static int CertNameToStrA(int dwCertEncodingType, MemorySegment pName, int dwStrType, MemorySegment psz, int csz) {
        var mh$ = CertNameToStrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertNameToStrA", dwCertEncodingType, pName, dwStrType, psz, csz);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertNameToStrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertNameToStrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertNameToStrW$descriptor() {
        return CertNameToStrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertNameToStrW$handle() {
        return CertNameToStrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static MemorySegment CertNameToStrW$address() {
        return CertNameToStrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static int CertNameToStrW(int dwCertEncodingType, MemorySegment pName, int dwStrType, MemorySegment psz, int csz) {
        var mh$ = CertNameToStrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertNameToStrW", dwCertEncodingType, pName, dwStrType, psz, csz);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertStrToNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertStrToNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static FunctionDescriptor CertStrToNameA$descriptor() {
        return CertStrToNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static MethodHandle CertStrToNameA$handle() {
        return CertStrToNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static MemorySegment CertStrToNameA$address() {
        return CertStrToNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static int CertStrToNameA(int dwCertEncodingType, MemorySegment pszX500, int dwStrType, MemorySegment pvReserved, MemorySegment pbEncoded, MemorySegment pcbEncoded, MemorySegment ppszError) {
        var mh$ = CertStrToNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertStrToNameA", dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertStrToNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertStrToNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static FunctionDescriptor CertStrToNameW$descriptor() {
        return CertStrToNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static MethodHandle CertStrToNameW$handle() {
        return CertStrToNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static MemorySegment CertStrToNameW$address() {
        return CertStrToNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static int CertStrToNameW(int dwCertEncodingType, MemorySegment pszX500, int dwStrType, MemorySegment pvReserved, MemorySegment pbEncoded, MemorySegment pcbEncoded, MemorySegment ppszError) {
        var mh$ = CertStrToNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertStrToNameW", dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetNameStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetNameStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static FunctionDescriptor CertGetNameStringA$descriptor() {
        return CertGetNameStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MethodHandle CertGetNameStringA$handle() {
        return CertGetNameStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MemorySegment CertGetNameStringA$address() {
        return CertGetNameStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static int CertGetNameStringA(MemorySegment pCertContext, int dwType, int dwFlags, MemorySegment pvTypePara, MemorySegment pszNameString, int cchNameString) {
        var mh$ = CertGetNameStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetNameStringA", pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
            }
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetNameStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetNameStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static FunctionDescriptor CertGetNameStringW$descriptor() {
        return CertGetNameStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MethodHandle CertGetNameStringW$handle() {
        return CertGetNameStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MemorySegment CertGetNameStringW$address() {
        return CertGetNameStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static int CertGetNameStringW(MemorySegment pCertContext, int dwType, int dwFlags, MemorySegment pvTypePara, MemorySegment pszNameString, int cchNameString) {
        var mh$ = CertGetNameStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetNameStringW", pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
            }
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SIGN_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     PCCERT_CONTEXT pSigningCert;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     *     DWORD cMsgCert;
     *     PCCERT_CONTEXT *rgpMsgCert;
     *     DWORD cMsgCrl;
     *     PCCRL_CONTEXT *rgpMsgCrl;
     *     DWORD cAuthAttr;
     *     PCRYPT_ATTRIBUTE rgAuthAttr;
     *     DWORD cUnauthAttr;
     *     PCRYPT_ATTRIBUTE rgUnauthAttr;
     *     DWORD dwFlags;
     *     DWORD dwInnerContentType;
     * } *PCRYPT_SIGN_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_SIGN_MESSAGE_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_VERIFY_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     PFN_CRYPT_GET_SIGNER_CERTIFICATE pfnGetSignerCertificate;
     *     void *pvGetArg;
     * } *PCRYPT_VERIFY_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_VERIFY_MESSAGE_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENCRYPT_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     *     DWORD dwFlags;
     *     DWORD dwInnerContentType;
     * } *PCRYPT_ENCRYPT_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_ENCRYPT_MESSAGE_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DECRYPT_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     DWORD cCertStore;
     *     HCERTSTORE *rghCertStore;
     * } *PCRYPT_DECRYPT_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_DECRYPT_MESSAGE_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_HASH_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     * } *PCRYPT_HASH_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_HASH_MESSAGE_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_SIGN_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     *     CRYPT_ALGORITHM_IDENTIFIER PubKeyAlgorithm;
     * } *PCRYPT_KEY_SIGN_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_KEY_SIGN_MESSAGE_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_VERIFY_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     * } *PCRYPT_KEY_VERIFY_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_KEY_VERIFY_MESSAGE_PARA = winapi.C_POINTER;

    private static class CryptSignMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptSignMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptSignMessage$descriptor() {
        return CryptSignMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MethodHandle CryptSignMessage$handle() {
        return CryptSignMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MemorySegment CryptSignMessage$address() {
        return CryptSignMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static int CryptSignMessage(MemorySegment pSignPara, int fDetachedSignature, int cToBeSigned, MemorySegment rgpbToBeSigned, MemorySegment rgcbToBeSigned, MemorySegment pbSignedBlob, MemorySegment pcbSignedBlob) {
        var mh$ = CryptSignMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignMessage", pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob);
            }
            return (int)mh$.invokeExact(pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyMessageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptVerifyMessageSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptVerifyMessageSignature$descriptor() {
        return CryptVerifyMessageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptVerifyMessageSignature$handle() {
        return CryptVerifyMessageSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MemorySegment CryptVerifyMessageSignature$address() {
        return CryptVerifyMessageSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptVerifyMessageSignature(MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbSignedBlob, int cbSignedBlob, MemorySegment pbDecoded, MemorySegment pcbDecoded, MemorySegment ppSignerCert) {
        var mh$ = CryptVerifyMessageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyMessageSignature", pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert);
            }
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetMessageSignerCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetMessageSignerCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptGetMessageSignerCount$descriptor() {
        return CryptGetMessageSignerCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MethodHandle CryptGetMessageSignerCount$handle() {
        return CryptGetMessageSignerCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MemorySegment CryptGetMessageSignerCount$address() {
        return CryptGetMessageSignerCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static int CryptGetMessageSignerCount(int dwMsgEncodingType, MemorySegment pbSignedBlob, int cbSignedBlob) {
        var mh$ = CryptGetMessageSignerCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetMessageSignerCount", dwMsgEncodingType, pbSignedBlob, cbSignedBlob);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetMessageCertificates {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetMessageCertificates");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptGetMessageCertificates$descriptor() {
        return CryptGetMessageCertificates.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MethodHandle CryptGetMessageCertificates$handle() {
        return CryptGetMessageCertificates.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MemorySegment CryptGetMessageCertificates$address() {
        return CryptGetMessageCertificates.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MemorySegment CryptGetMessageCertificates(int dwMsgAndCertEncodingType, long hCryptProv, int dwFlags, MemorySegment pbSignedBlob, int cbSignedBlob) {
        var mh$ = CryptGetMessageCertificates.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetMessageCertificates", dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyDetachedMessageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptVerifyDetachedMessageSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptVerifyDetachedMessageSignature$descriptor() {
        return CryptVerifyDetachedMessageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptVerifyDetachedMessageSignature$handle() {
        return CryptVerifyDetachedMessageSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MemorySegment CryptVerifyDetachedMessageSignature$address() {
        return CryptVerifyDetachedMessageSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptVerifyDetachedMessageSignature(MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbDetachedSignBlob, int cbDetachedSignBlob, int cToBeSigned, MemorySegment rgpbToBeSigned, MemorySegment rgcbToBeSigned, MemorySegment ppSignerCert) {
        var mh$ = CryptVerifyDetachedMessageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyDetachedMessageSignature", pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert);
            }
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEncryptMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptEncryptMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static FunctionDescriptor CryptEncryptMessage$descriptor() {
        return CryptEncryptMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static MethodHandle CryptEncryptMessage$handle() {
        return CryptEncryptMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static MemorySegment CryptEncryptMessage$address() {
        return CryptEncryptMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static int CryptEncryptMessage(MemorySegment pEncryptPara, int cRecipientCert, MemorySegment rgpRecipientCert, MemorySegment pbToBeEncrypted, int cbToBeEncrypted, MemorySegment pbEncryptedBlob, MemorySegment pcbEncryptedBlob) {
        var mh$ = CryptEncryptMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncryptMessage", pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob);
            }
            return (int)mh$.invokeExact(pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecryptMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptDecryptMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static FunctionDescriptor CryptDecryptMessage$descriptor() {
        return CryptDecryptMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static MethodHandle CryptDecryptMessage$handle() {
        return CryptDecryptMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static MemorySegment CryptDecryptMessage$address() {
        return CryptDecryptMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static int CryptDecryptMessage(MemorySegment pDecryptPara, MemorySegment pbEncryptedBlob, int cbEncryptedBlob, MemorySegment pbDecrypted, MemorySegment pcbDecrypted, MemorySegment ppXchgCert) {
        var mh$ = CryptDecryptMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecryptMessage", pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert);
            }
            return (int)mh$.invokeExact(pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignAndEncryptMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptSignAndEncryptMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static FunctionDescriptor CryptSignAndEncryptMessage$descriptor() {
        return CryptSignAndEncryptMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static MethodHandle CryptSignAndEncryptMessage$handle() {
        return CryptSignAndEncryptMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static MemorySegment CryptSignAndEncryptMessage$address() {
        return CryptSignAndEncryptMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static int CryptSignAndEncryptMessage(MemorySegment pSignPara, MemorySegment pEncryptPara, int cRecipientCert, MemorySegment rgpRecipientCert, MemorySegment pbToBeSignedAndEncrypted, int cbToBeSignedAndEncrypted, MemorySegment pbSignedAndEncryptedBlob, MemorySegment pcbSignedAndEncryptedBlob) {
        var mh$ = CryptSignAndEncryptMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignAndEncryptMessage", pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob);
            }
            return (int)mh$.invokeExact(pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecryptAndVerifyMessageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptDecryptAndVerifyMessageSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptDecryptAndVerifyMessageSignature$descriptor() {
        return CryptDecryptAndVerifyMessageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptDecryptAndVerifyMessageSignature$handle() {
        return CryptDecryptAndVerifyMessageSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MemorySegment CryptDecryptAndVerifyMessageSignature$address() {
        return CryptDecryptAndVerifyMessageSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptDecryptAndVerifyMessageSignature(MemorySegment pDecryptPara, MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbEncryptedBlob, int cbEncryptedBlob, MemorySegment pbDecrypted, MemorySegment pcbDecrypted, MemorySegment ppXchgCert, MemorySegment ppSignerCert) {
        var mh$ = CryptDecryptAndVerifyMessageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecryptAndVerifyMessageSignature", pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert);
            }
            return (int)mh$.invokeExact(pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecodeMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptDecodeMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptDecodeMessage$descriptor() {
        return CryptDecodeMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptDecodeMessage$handle() {
        return CryptDecodeMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MemorySegment CryptDecodeMessage$address() {
        return CryptDecodeMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptDecodeMessage(int dwMsgTypeFlags, MemorySegment pDecryptPara, MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbEncodedBlob, int cbEncodedBlob, int dwPrevInnerContentType, MemorySegment pdwMsgType, MemorySegment pdwInnerContentType, MemorySegment pbDecoded, MemorySegment pcbDecoded, MemorySegment ppXchgCert, MemorySegment ppSignerCert) {
        var mh$ = CryptDecodeMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecodeMessage", dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert);
            }
            return (int)mh$.invokeExact(dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptHashMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashMessage$descriptor() {
        return CryptHashMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashMessage$handle() {
        return CryptHashMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptHashMessage$address() {
        return CryptHashMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashMessage(MemorySegment pHashPara, int fDetachedHash, int cToBeHashed, MemorySegment rgpbToBeHashed, MemorySegment rgcbToBeHashed, MemorySegment pbHashedBlob, MemorySegment pcbHashedBlob, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashMessage", pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyMessageHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptVerifyMessageHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptVerifyMessageHash$descriptor() {
        return CryptVerifyMessageHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptVerifyMessageHash$handle() {
        return CryptVerifyMessageHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptVerifyMessageHash$address() {
        return CryptVerifyMessageHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptVerifyMessageHash(MemorySegment pHashPara, MemorySegment pbHashedBlob, int cbHashedBlob, MemorySegment pbToBeHashed, MemorySegment pcbToBeHashed, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptVerifyMessageHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyMessageHash", pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyDetachedMessageHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptVerifyDetachedMessageHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptVerifyDetachedMessageHash$descriptor() {
        return CryptVerifyDetachedMessageHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptVerifyDetachedMessageHash$handle() {
        return CryptVerifyDetachedMessageHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MemorySegment CryptVerifyDetachedMessageHash$address() {
        return CryptVerifyDetachedMessageHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptVerifyDetachedMessageHash(MemorySegment pHashPara, MemorySegment pbDetachedHashBlob, int cbDetachedHashBlob, int cToBeHashed, MemorySegment rgpbToBeHashed, MemorySegment rgcbToBeHashed, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptVerifyDetachedMessageHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyDetachedMessageHash", pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignMessageWithKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptSignMessageWithKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptSignMessageWithKey$descriptor() {
        return CryptSignMessageWithKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MethodHandle CryptSignMessageWithKey$handle() {
        return CryptSignMessageWithKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MemorySegment CryptSignMessageWithKey$address() {
        return CryptSignMessageWithKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static int CryptSignMessageWithKey(MemorySegment pSignPara, MemorySegment pbToBeSigned, int cbToBeSigned, MemorySegment pbSignedBlob, MemorySegment pcbSignedBlob) {
        var mh$ = CryptSignMessageWithKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignMessageWithKey", pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob);
            }
            return (int)mh$.invokeExact(pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyMessageSignatureWithKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptVerifyMessageSignatureWithKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static FunctionDescriptor CryptVerifyMessageSignatureWithKey$descriptor() {
        return CryptVerifyMessageSignatureWithKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static MethodHandle CryptVerifyMessageSignatureWithKey$handle() {
        return CryptVerifyMessageSignatureWithKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static MemorySegment CryptVerifyMessageSignatureWithKey$address() {
        return CryptVerifyMessageSignatureWithKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static int CryptVerifyMessageSignatureWithKey(MemorySegment pVerifyPara, MemorySegment pPublicKeyInfo, MemorySegment pbSignedBlob, int cbSignedBlob, MemorySegment pbDecoded, MemorySegment pcbDecoded) {
        var mh$ = CryptVerifyMessageSignatureWithKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyMessageSignatureWithKey", pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded);
            }
            return (int)mh$.invokeExact(pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertOpenSystemStoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertOpenSystemStoreA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static FunctionDescriptor CertOpenSystemStoreA$descriptor() {
        return CertOpenSystemStoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static MethodHandle CertOpenSystemStoreA$handle() {
        return CertOpenSystemStoreA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreA$address() {
        return CertOpenSystemStoreA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreA(long hProv, MemorySegment szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenSystemStoreA", hProv, szSubsystemProtocol);
            }
            return (MemorySegment)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertOpenSystemStoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertOpenSystemStoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static FunctionDescriptor CertOpenSystemStoreW$descriptor() {
        return CertOpenSystemStoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static MethodHandle CertOpenSystemStoreW$handle() {
        return CertOpenSystemStoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreW$address() {
        return CertOpenSystemStoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreW(long hProv, MemorySegment szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenSystemStoreW", hProv, szSubsystemProtocol);
            }
            return (MemorySegment)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCertificateToSystemStoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddEncodedCertificateToSystemStoreA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCertificateToSystemStoreA$descriptor() {
        return CertAddEncodedCertificateToSystemStoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MethodHandle CertAddEncodedCertificateToSystemStoreA$handle() {
        return CertAddEncodedCertificateToSystemStoreA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MemorySegment CertAddEncodedCertificateToSystemStoreA$address() {
        return CertAddEncodedCertificateToSystemStoreA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static int CertAddEncodedCertificateToSystemStoreA(MemorySegment szCertStoreName, MemorySegment pbCertEncoded, int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCertificateToSystemStoreA", szCertStoreName, pbCertEncoded, cbCertEncoded);
            }
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCertificateToSystemStoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddEncodedCertificateToSystemStoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCertificateToSystemStoreW$descriptor() {
        return CertAddEncodedCertificateToSystemStoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MethodHandle CertAddEncodedCertificateToSystemStoreW$handle() {
        return CertAddEncodedCertificateToSystemStoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MemorySegment CertAddEncodedCertificateToSystemStoreW$address() {
        return CertAddEncodedCertificateToSystemStoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static int CertAddEncodedCertificateToSystemStoreW(MemorySegment szCertStoreName, MemorySegment pbCertEncoded, int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCertificateToSystemStoreW", szCertStoreName, pbCertEncoded, cbCertEncoded);
            }
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN {
     *     DWORD cCerts;
     *     PCERT_BLOB certs;
     *     CRYPT_KEY_PROV_INFO keyLocatorInfo;
     * } *PCERT_CHAIN
     * }
     */
    public static final AddressLayout PCERT_CHAIN = winapi.C_POINTER;

    private static class FindCertsByIssuer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindCertsByIssuer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static FunctionDescriptor FindCertsByIssuer$descriptor() {
        return FindCertsByIssuer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static MethodHandle FindCertsByIssuer$handle() {
        return FindCertsByIssuer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static MemorySegment FindCertsByIssuer$address() {
        return FindCertsByIssuer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static int FindCertsByIssuer(MemorySegment pCertChains, MemorySegment pcbCertChains, MemorySegment pcCertChains, MemorySegment pbEncodedIssuerName, int cbEncodedIssuerName, MemorySegment pwszPurpose, int dwKeySpec) {
        var mh$ = FindCertsByIssuer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindCertsByIssuer", pCertChains, pcbCertChains, pcCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec);
            }
            return (int)mh$.invokeExact(pCertChains, pcbCertChains, pcCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptQueryObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptQueryObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static FunctionDescriptor CryptQueryObject$descriptor() {
        return CryptQueryObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static MethodHandle CryptQueryObject$handle() {
        return CryptQueryObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static MemorySegment CryptQueryObject$address() {
        return CryptQueryObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static int CryptQueryObject(int dwObjectType, MemorySegment pvObject, int dwExpectedContentTypeFlags, int dwExpectedFormatTypeFlags, int dwFlags, MemorySegment pdwMsgAndCertEncodingType, MemorySegment pdwContentType, MemorySegment pdwFormatType, MemorySegment phCertStore, MemorySegment phMsg, MemorySegment ppvContext) {
        var mh$ = CryptQueryObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptQueryObject", dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext);
            }
            return (int)mh$.invokeExact(dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMemAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMemAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static FunctionDescriptor CryptMemAlloc$descriptor() {
        return CryptMemAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static MethodHandle CryptMemAlloc$handle() {
        return CryptMemAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemAlloc$address() {
        return CryptMemAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemAlloc(int cbSize) {
        var mh$ = CryptMemAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMemAlloc", cbSize);
            }
            return (MemorySegment)mh$.invokeExact(cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMemRealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMemRealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static FunctionDescriptor CryptMemRealloc$descriptor() {
        return CryptMemRealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static MethodHandle CryptMemRealloc$handle() {
        return CryptMemRealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemRealloc$address() {
        return CryptMemRealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemRealloc(MemorySegment pv, int cbSize) {
        var mh$ = CryptMemRealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMemRealloc", pv, cbSize);
            }
            return (MemorySegment)mh$.invokeExact(pv, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMemFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptMemFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static FunctionDescriptor CryptMemFree$descriptor() {
        return CryptMemFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static MethodHandle CryptMemFree$handle() {
        return CryptMemFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static MemorySegment CryptMemFree$address() {
        return CryptMemFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static void CryptMemFree(MemorySegment pv) {
        var mh$ = CryptMemFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMemFree", pv);
            }
            mh$.invokeExact(pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef HANDLE HCRYPTASYNC
     * }
     */
    public static final AddressLayout HCRYPTASYNC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE *PHCRYPTASYNC
     * }
     */
    public static final AddressLayout PHCRYPTASYNC = winapi.C_POINTER;

    private static class CryptCreateAsyncHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptCreateAsyncHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCreateAsyncHandle(DWORD dwFlags, PHCRYPTASYNC phAsync)
     * }
     */
    public static FunctionDescriptor CryptCreateAsyncHandle$descriptor() {
        return CryptCreateAsyncHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCreateAsyncHandle(DWORD dwFlags, PHCRYPTASYNC phAsync)
     * }
     */
    public static MethodHandle CryptCreateAsyncHandle$handle() {
        return CryptCreateAsyncHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptCreateAsyncHandle(DWORD dwFlags, PHCRYPTASYNC phAsync)
     * }
     */
    public static MemorySegment CryptCreateAsyncHandle$address() {
        return CryptCreateAsyncHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptCreateAsyncHandle(DWORD dwFlags, PHCRYPTASYNC phAsync)
     * }
     */
    public static int CryptCreateAsyncHandle(int dwFlags, MemorySegment phAsync) {
        var mh$ = CryptCreateAsyncHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCreateAsyncHandle", dwFlags, phAsync);
            }
            return (int)mh$.invokeExact(dwFlags, phAsync);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetAsyncParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptSetAsyncParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID pvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree)
     * }
     */
    public static FunctionDescriptor CryptSetAsyncParam$descriptor() {
        return CryptSetAsyncParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID pvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree)
     * }
     */
    public static MethodHandle CryptSetAsyncParam$handle() {
        return CryptSetAsyncParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID pvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree)
     * }
     */
    public static MemorySegment CryptSetAsyncParam$address() {
        return CryptSetAsyncParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID pvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree)
     * }
     */
    public static int CryptSetAsyncParam(MemorySegment hAsync, MemorySegment pszParamOid, MemorySegment pvParam, MemorySegment pfnFree) {
        var mh$ = CryptSetAsyncParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetAsyncParam", hAsync, pszParamOid, pvParam, pfnFree);
            }
            return (int)mh$.invokeExact(hAsync, pszParamOid, pvParam, pfnFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetAsyncParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetAsyncParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID *ppvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC *ppfnFree)
     * }
     */
    public static FunctionDescriptor CryptGetAsyncParam$descriptor() {
        return CryptGetAsyncParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID *ppvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC *ppfnFree)
     * }
     */
    public static MethodHandle CryptGetAsyncParam$handle() {
        return CryptGetAsyncParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID *ppvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC *ppfnFree)
     * }
     */
    public static MemorySegment CryptGetAsyncParam$address() {
        return CryptGetAsyncParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID *ppvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC *ppfnFree)
     * }
     */
    public static int CryptGetAsyncParam(MemorySegment hAsync, MemorySegment pszParamOid, MemorySegment ppvParam, MemorySegment ppfnFree) {
        var mh$ = CryptGetAsyncParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetAsyncParam", hAsync, pszParamOid, ppvParam, ppfnFree);
            }
            return (int)mh$.invokeExact(hAsync, pszParamOid, ppvParam, ppfnFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptCloseAsyncHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptCloseAsyncHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCloseAsyncHandle(HCRYPTASYNC hAsync)
     * }
     */
    public static FunctionDescriptor CryptCloseAsyncHandle$descriptor() {
        return CryptCloseAsyncHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCloseAsyncHandle(HCRYPTASYNC hAsync)
     * }
     */
    public static MethodHandle CryptCloseAsyncHandle$handle() {
        return CryptCloseAsyncHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptCloseAsyncHandle(HCRYPTASYNC hAsync)
     * }
     */
    public static MemorySegment CryptCloseAsyncHandle$address() {
        return CryptCloseAsyncHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptCloseAsyncHandle(HCRYPTASYNC hAsync)
     * }
     */
    public static int CryptCloseAsyncHandle(MemorySegment hAsync) {
        var mh$ = CryptCloseAsyncHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCloseAsyncHandle", hAsync);
            }
            return (int)mh$.invokeExact(hAsync);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_BLOB_ARRAY {
     *     DWORD cBlob;
     *     PCRYPT_DATA_BLOB rgBlob;
     * } *PCRYPT_BLOB_ARRAY
     * }
     */
    public static final AddressLayout PCRYPT_BLOB_ARRAY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CREDENTIALS {
     *     DWORD cbSize;
     *     LPCSTR pszCredentialsOid;
     *     LPVOID pvCredentials;
     * } *PCRYPT_CREDENTIALS
     * }
     */
    public static final AddressLayout PCRYPT_CREDENTIALS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PASSWORD_CREDENTIALSA {
     *     DWORD cbSize;
     *     LPSTR pszUsername;
     *     LPSTR pszPassword;
     * } *PCRYPT_PASSWORD_CREDENTIALSA
     * }
     */
    public static final AddressLayout PCRYPT_PASSWORD_CREDENTIALSA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PASSWORD_CREDENTIALSW {
     *     DWORD cbSize;
     *     LPWSTR pszUsername;
     *     LPWSTR pszPassword;
     * } *PCRYPT_PASSWORD_CREDENTIALSW
     * }
     */
    public static final AddressLayout PCRYPT_PASSWORD_CREDENTIALSW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCRYPT_PASSWORD_CREDENTIALSA PCRYPT_PASSWORD_CREDENTIALS
     * }
     */
    public static final AddressLayout PCRYPT_PASSWORD_CREDENTIALS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTNET_URL_CACHE_PRE_FETCH_INFO {
     *     DWORD cbSize;
     *     DWORD dwObjectType;
     *     DWORD dwError;
     *     DWORD dwReserved;
     *     FILETIME ThisUpdateTime;
     *     FILETIME NextUpdateTime;
     *     FILETIME PublishTime;
     * } *PCRYPTNET_URL_CACHE_PRE_FETCH_INFO
     * }
     */
    public static final AddressLayout PCRYPTNET_URL_CACHE_PRE_FETCH_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTNET_URL_CACHE_FLUSH_INFO {
     *     DWORD cbSize;
     *     DWORD dwExemptSeconds;
     *     FILETIME ExpireTime;
     * } *PCRYPTNET_URL_CACHE_FLUSH_INFO
     * }
     */
    public static final AddressLayout PCRYPTNET_URL_CACHE_FLUSH_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTNET_URL_CACHE_RESPONSE_INFO {
     *     DWORD cbSize;
     *     WORD wResponseType;
     *     WORD wResponseFlags;
     *     FILETIME LastModifiedTime;
     *     DWORD dwMaxAge;
     *     LPCWSTR pwszETag;
     *     DWORD dwProxyId;
     * } *PCRYPTNET_URL_CACHE_RESPONSE_INFO
     * }
     */
    public static final AddressLayout PCRYPTNET_URL_CACHE_RESPONSE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RETRIEVE_AUX_INFO {
     *     DWORD cbSize;
     *     FILETIME *pLastSyncTime;
     *     DWORD dwMaxUrlRetrievalByteCount;
     *     PCRYPTNET_URL_CACHE_PRE_FETCH_INFO pPreFetchInfo;
     *     PCRYPTNET_URL_CACHE_FLUSH_INFO pFlushInfo;
     *     PCRYPTNET_URL_CACHE_RESPONSE_INFO *ppResponseInfo;
     *     LPWSTR pwszCacheFileNamePrefix;
     *     LPFILETIME pftCacheResync;
     *     BOOL fProxyCacheRetrieval;
     *     DWORD dwHttpStatusCode;
     *     LPWSTR *ppwszErrorResponseHeaders;
     *     PCRYPT_DATA_BLOB *ppErrorContentBlob;
     * } *PCRYPT_RETRIEVE_AUX_INFO
     * }
     */
    public static final AddressLayout PCRYPT_RETRIEVE_AUX_INFO = winapi.C_POINTER;

    private static class CryptRetrieveObjectByUrlA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptRetrieveObjectByUrlA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlA(LPCSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static FunctionDescriptor CryptRetrieveObjectByUrlA$descriptor() {
        return CryptRetrieveObjectByUrlA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlA(LPCSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static MethodHandle CryptRetrieveObjectByUrlA$handle() {
        return CryptRetrieveObjectByUrlA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlA(LPCSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static MemorySegment CryptRetrieveObjectByUrlA$address() {
        return CryptRetrieveObjectByUrlA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlA(LPCSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static int CryptRetrieveObjectByUrlA(MemorySegment pszUrl, MemorySegment pszObjectOid, int dwRetrievalFlags, int dwTimeout, MemorySegment ppvObject, MemorySegment hAsyncRetrieve, MemorySegment pCredentials, MemorySegment pvVerify, MemorySegment pAuxInfo) {
        var mh$ = CryptRetrieveObjectByUrlA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRetrieveObjectByUrlA", pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
            }
            return (int)mh$.invokeExact(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRetrieveObjectByUrlW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptRetrieveObjectByUrlW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlW(LPCWSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static FunctionDescriptor CryptRetrieveObjectByUrlW$descriptor() {
        return CryptRetrieveObjectByUrlW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlW(LPCWSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static MethodHandle CryptRetrieveObjectByUrlW$handle() {
        return CryptRetrieveObjectByUrlW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlW(LPCWSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static MemorySegment CryptRetrieveObjectByUrlW$address() {
        return CryptRetrieveObjectByUrlW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRetrieveObjectByUrlW(LPCWSTR pszUrl, LPCSTR pszObjectOid, DWORD dwRetrievalFlags, DWORD dwTimeout, LPVOID *ppvObject, HCRYPTASYNC hAsyncRetrieve, PCRYPT_CREDENTIALS pCredentials, LPVOID pvVerify, PCRYPT_RETRIEVE_AUX_INFO pAuxInfo)
     * }
     */
    public static int CryptRetrieveObjectByUrlW(MemorySegment pszUrl, MemorySegment pszObjectOid, int dwRetrievalFlags, int dwTimeout, MemorySegment ppvObject, MemorySegment hAsyncRetrieve, MemorySegment pCredentials, MemorySegment pvVerify, MemorySegment pAuxInfo) {
        var mh$ = CryptRetrieveObjectByUrlW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRetrieveObjectByUrlW", pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
            }
            return (int)mh$.invokeExact(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptInstallCancelRetrieval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptInstallCancelRetrieval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptInstallCancelRetrieval(PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, const void *pvArg, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptInstallCancelRetrieval$descriptor() {
        return CryptInstallCancelRetrieval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptInstallCancelRetrieval(PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, const void *pvArg, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptInstallCancelRetrieval$handle() {
        return CryptInstallCancelRetrieval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptInstallCancelRetrieval(PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, const void *pvArg, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CryptInstallCancelRetrieval$address() {
        return CryptInstallCancelRetrieval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptInstallCancelRetrieval(PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, const void *pvArg, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptInstallCancelRetrieval(MemorySegment pfnCancel, MemorySegment pvArg, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptInstallCancelRetrieval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInstallCancelRetrieval", pfnCancel, pvArg, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pfnCancel, pvArg, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUninstallCancelRetrieval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptUninstallCancelRetrieval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUninstallCancelRetrieval(DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptUninstallCancelRetrieval$descriptor() {
        return CryptUninstallCancelRetrieval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUninstallCancelRetrieval(DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptUninstallCancelRetrieval$handle() {
        return CryptUninstallCancelRetrieval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUninstallCancelRetrieval(DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MemorySegment CryptUninstallCancelRetrieval$address() {
        return CryptUninstallCancelRetrieval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUninstallCancelRetrieval(DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptUninstallCancelRetrieval(int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptUninstallCancelRetrieval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUninstallCancelRetrieval", dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptCancelAsyncRetrieval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptCancelAsyncRetrieval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCancelAsyncRetrieval(HCRYPTASYNC hAsyncRetrieval)
     * }
     */
    public static FunctionDescriptor CryptCancelAsyncRetrieval$descriptor() {
        return CryptCancelAsyncRetrieval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCancelAsyncRetrieval(HCRYPTASYNC hAsyncRetrieval)
     * }
     */
    public static MethodHandle CryptCancelAsyncRetrieval$handle() {
        return CryptCancelAsyncRetrieval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptCancelAsyncRetrieval(HCRYPTASYNC hAsyncRetrieval)
     * }
     */
    public static MemorySegment CryptCancelAsyncRetrieval$address() {
        return CryptCancelAsyncRetrieval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptCancelAsyncRetrieval(HCRYPTASYNC hAsyncRetrieval)
     * }
     */
    public static int CryptCancelAsyncRetrieval(MemorySegment hAsyncRetrieval) {
        var mh$ = CryptCancelAsyncRetrieval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCancelAsyncRetrieval", hAsyncRetrieval);
            }
            return (int)mh$.invokeExact(hAsyncRetrieval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ASYNC_RETRIEVAL_COMPLETION {
     *     PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC pfnCompletion;
     *     LPVOID pvCompletion;
     * } *PCRYPT_ASYNC_RETRIEVAL_COMPLETION
     * }
     */
    public static final AddressLayout PCRYPT_ASYNC_RETRIEVAL_COMPLETION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_URL_ARRAY {
     *     DWORD cUrl;
     *     LPWSTR *rgwszUrl;
     * } *PCRYPT_URL_ARRAY
     * }
     */
    public static final AddressLayout PCRYPT_URL_ARRAY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_URL_INFO {
     *     DWORD cbSize;
     *     DWORD dwSyncDeltaTime;
     *     DWORD cGroup;
     *     DWORD *rgcGroupEntry;
     * } *PCRYPT_URL_INFO
     * }
     */
    public static final AddressLayout PCRYPT_URL_INFO = winapi.C_POINTER;

    private static class CryptGetObjectUrl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetObjectUrl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetObjectUrl(LPCSTR pszUrlOid, LPVOID pvPara, DWORD dwFlags, PCRYPT_URL_ARRAY pUrlArray, DWORD *pcbUrlArray, PCRYPT_URL_INFO pUrlInfo, DWORD *pcbUrlInfo, LPVOID pvReserved)
     * }
     */
    public static FunctionDescriptor CryptGetObjectUrl$descriptor() {
        return CryptGetObjectUrl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetObjectUrl(LPCSTR pszUrlOid, LPVOID pvPara, DWORD dwFlags, PCRYPT_URL_ARRAY pUrlArray, DWORD *pcbUrlArray, PCRYPT_URL_INFO pUrlInfo, DWORD *pcbUrlInfo, LPVOID pvReserved)
     * }
     */
    public static MethodHandle CryptGetObjectUrl$handle() {
        return CryptGetObjectUrl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetObjectUrl(LPCSTR pszUrlOid, LPVOID pvPara, DWORD dwFlags, PCRYPT_URL_ARRAY pUrlArray, DWORD *pcbUrlArray, PCRYPT_URL_INFO pUrlInfo, DWORD *pcbUrlInfo, LPVOID pvReserved)
     * }
     */
    public static MemorySegment CryptGetObjectUrl$address() {
        return CryptGetObjectUrl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetObjectUrl(LPCSTR pszUrlOid, LPVOID pvPara, DWORD dwFlags, PCRYPT_URL_ARRAY pUrlArray, DWORD *pcbUrlArray, PCRYPT_URL_INFO pUrlInfo, DWORD *pcbUrlInfo, LPVOID pvReserved)
     * }
     */
    public static int CryptGetObjectUrl(MemorySegment pszUrlOid, MemorySegment pvPara, int dwFlags, MemorySegment pUrlArray, MemorySegment pcbUrlArray, MemorySegment pUrlInfo, MemorySegment pcbUrlInfo, MemorySegment pvReserved) {
        var mh$ = CryptGetObjectUrl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetObjectUrl", pszUrlOid, pvPara, dwFlags, pUrlArray, pcbUrlArray, pUrlInfo, pcbUrlInfo, pvReserved);
            }
            return (int)mh$.invokeExact(pszUrlOid, pvPara, dwFlags, pUrlArray, pcbUrlArray, pUrlInfo, pcbUrlInfo, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CRL_CONTEXT_PAIR {
     *     PCCERT_CONTEXT pCertContext;
     *     PCCRL_CONTEXT pCrlContext;
     * } *PCERT_CRL_CONTEXT_PAIR
     * }
     */
    public static final AddressLayout PCERT_CRL_CONTEXT_PAIR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_CRL_CONTEXT_PAIR *PCCERT_CRL_CONTEXT_PAIR
     * }
     */
    public static final AddressLayout PCCERT_CRL_CONTEXT_PAIR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO {
     *     DWORD cbSize;
     *     int iDeltaCrlIndicator;
     *     LPFILETIME pftCacheResync;
     *     LPFILETIME pLastSyncTime;
     *     LPFILETIME pMaxAgeTime;
     *     PCERT_REVOCATION_CHAIN_PARA pChainPara;
     *     PCRYPT_INTEGER_BLOB pDeltaCrlIndicator;
     * } *PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO
     * }
     */
    public static final AddressLayout PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = winapi.C_POINTER;

    private static class CryptGetTimeValidObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetTimeValidObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetTimeValidObject(LPCSTR pszTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, LPFILETIME pftValidFor, DWORD dwFlags, DWORD dwTimeout, LPVOID *ppvObject, PCRYPT_CREDENTIALS pCredentials, PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo)
     * }
     */
    public static FunctionDescriptor CryptGetTimeValidObject$descriptor() {
        return CryptGetTimeValidObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetTimeValidObject(LPCSTR pszTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, LPFILETIME pftValidFor, DWORD dwFlags, DWORD dwTimeout, LPVOID *ppvObject, PCRYPT_CREDENTIALS pCredentials, PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo)
     * }
     */
    public static MethodHandle CryptGetTimeValidObject$handle() {
        return CryptGetTimeValidObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetTimeValidObject(LPCSTR pszTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, LPFILETIME pftValidFor, DWORD dwFlags, DWORD dwTimeout, LPVOID *ppvObject, PCRYPT_CREDENTIALS pCredentials, PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo)
     * }
     */
    public static MemorySegment CryptGetTimeValidObject$address() {
        return CryptGetTimeValidObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetTimeValidObject(LPCSTR pszTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, LPFILETIME pftValidFor, DWORD dwFlags, DWORD dwTimeout, LPVOID *ppvObject, PCRYPT_CREDENTIALS pCredentials, PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo)
     * }
     */
    public static int CryptGetTimeValidObject(MemorySegment pszTimeValidOid, MemorySegment pvPara, MemorySegment pIssuer, MemorySegment pftValidFor, int dwFlags, int dwTimeout, MemorySegment ppvObject, MemorySegment pCredentials, MemorySegment pExtraInfo) {
        var mh$ = CryptGetTimeValidObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetTimeValidObject", pszTimeValidOid, pvPara, pIssuer, pftValidFor, dwFlags, dwTimeout, ppvObject, pCredentials, pExtraInfo);
            }
            return (int)mh$.invokeExact(pszTimeValidOid, pvPara, pIssuer, pftValidFor, dwFlags, dwTimeout, ppvObject, pCredentials, pExtraInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFlushTimeValidObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptFlushTimeValidObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFlushTimeValidObject(LPCSTR pszFlushTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static FunctionDescriptor CryptFlushTimeValidObject$descriptor() {
        return CryptFlushTimeValidObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFlushTimeValidObject(LPCSTR pszFlushTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MethodHandle CryptFlushTimeValidObject$handle() {
        return CryptFlushTimeValidObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptFlushTimeValidObject(LPCSTR pszFlushTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MemorySegment CryptFlushTimeValidObject$address() {
        return CryptFlushTimeValidObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptFlushTimeValidObject(LPCSTR pszFlushTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static int CryptFlushTimeValidObject(MemorySegment pszFlushTimeValidOid, MemorySegment pvPara, MemorySegment pIssuer, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptFlushTimeValidObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFlushTimeValidObject", pszFlushTimeValidOid, pvPara, pIssuer, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pszFlushTimeValidOid, pvPara, pIssuer, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateSelfSignCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCreateSelfSignCertificate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateSelfSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, PCERT_NAME_BLOB pSubjectIssuerBlob, DWORD dwFlags, PCRYPT_KEY_PROV_INFO pKeyProvInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, PSYSTEMTIME pStartTime, PSYSTEMTIME pEndTime, PCERT_EXTENSIONS pExtensions)
     * }
     */
    public static FunctionDescriptor CertCreateSelfSignCertificate$descriptor() {
        return CertCreateSelfSignCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateSelfSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, PCERT_NAME_BLOB pSubjectIssuerBlob, DWORD dwFlags, PCRYPT_KEY_PROV_INFO pKeyProvInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, PSYSTEMTIME pStartTime, PSYSTEMTIME pEndTime, PCERT_EXTENSIONS pExtensions)
     * }
     */
    public static MethodHandle CertCreateSelfSignCertificate$handle() {
        return CertCreateSelfSignCertificate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateSelfSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, PCERT_NAME_BLOB pSubjectIssuerBlob, DWORD dwFlags, PCRYPT_KEY_PROV_INFO pKeyProvInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, PSYSTEMTIME pStartTime, PSYSTEMTIME pEndTime, PCERT_EXTENSIONS pExtensions)
     * }
     */
    public static MemorySegment CertCreateSelfSignCertificate$address() {
        return CertCreateSelfSignCertificate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateSelfSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, PCERT_NAME_BLOB pSubjectIssuerBlob, DWORD dwFlags, PCRYPT_KEY_PROV_INFO pKeyProvInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, PSYSTEMTIME pStartTime, PSYSTEMTIME pEndTime, PCERT_EXTENSIONS pExtensions)
     * }
     */
    public static MemorySegment CertCreateSelfSignCertificate(long hCryptProvOrNCryptKey, MemorySegment pSubjectIssuerBlob, int dwFlags, MemorySegment pKeyProvInfo, MemorySegment pSignatureAlgorithm, MemorySegment pStartTime, MemorySegment pEndTime, MemorySegment pExtensions) {
        var mh$ = CertCreateSelfSignCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateSelfSignCertificate", hCryptProvOrNCryptKey, pSubjectIssuerBlob, dwFlags, pKeyProvInfo, pSignatureAlgorithm, pStartTime, pEndTime, pExtensions);
            }
            return (MemorySegment)mh$.invokeExact(hCryptProvOrNCryptKey, pSubjectIssuerBlob, dwFlags, pKeyProvInfo, pSignatureAlgorithm, pStartTime, pEndTime, pExtensions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetKeyIdentifierProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptGetKeyIdentifierProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CryptGetKeyIdentifierProperty$descriptor() {
        return CryptGetKeyIdentifierProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CryptGetKeyIdentifierProperty$handle() {
        return CryptGetKeyIdentifierProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvData, DWORD *pcbData)
     * }
     */
    public static MemorySegment CryptGetKeyIdentifierProperty$address() {
        return CryptGetKeyIdentifierProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptGetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CryptGetKeyIdentifierProperty(MemorySegment pKeyIdentifier, int dwPropId, int dwFlags, MemorySegment pwszComputerName, MemorySegment pvReserved, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CryptGetKeyIdentifierProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetKeyIdentifierProperty", pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetKeyIdentifierProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptSetKeyIdentifierProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, const void *pvData)
     * }
     */
    public static FunctionDescriptor CryptSetKeyIdentifierProperty$descriptor() {
        return CryptSetKeyIdentifierProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, const void *pvData)
     * }
     */
    public static MethodHandle CryptSetKeyIdentifierProperty$handle() {
        return CryptSetKeyIdentifierProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, const void *pvData)
     * }
     */
    public static MemorySegment CryptSetKeyIdentifierProperty$address() {
        return CryptSetKeyIdentifierProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptSetKeyIdentifierProperty(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, const void *pvData)
     * }
     */
    public static int CryptSetKeyIdentifierProperty(MemorySegment pKeyIdentifier, int dwPropId, int dwFlags, MemorySegment pwszComputerName, MemorySegment pvReserved, MemorySegment pvData) {
        var mh$ = CryptSetKeyIdentifierProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetKeyIdentifierProperty", pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData);
            }
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumKeyIdentifierProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptEnumKeyIdentifierProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumKeyIdentifierProperties(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvArg, PFN_CRYPT_ENUM_KEYID_PROP pfnEnum)
     * }
     */
    public static FunctionDescriptor CryptEnumKeyIdentifierProperties$descriptor() {
        return CryptEnumKeyIdentifierProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumKeyIdentifierProperties(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvArg, PFN_CRYPT_ENUM_KEYID_PROP pfnEnum)
     * }
     */
    public static MethodHandle CryptEnumKeyIdentifierProperties$handle() {
        return CryptEnumKeyIdentifierProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptEnumKeyIdentifierProperties(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvArg, PFN_CRYPT_ENUM_KEYID_PROP pfnEnum)
     * }
     */
    public static MemorySegment CryptEnumKeyIdentifierProperties$address() {
        return CryptEnumKeyIdentifierProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptEnumKeyIdentifierProperties(const CRYPT_HASH_BLOB *pKeyIdentifier, DWORD dwPropId, DWORD dwFlags, LPCWSTR pwszComputerName, void *pvReserved, void *pvArg, PFN_CRYPT_ENUM_KEYID_PROP pfnEnum)
     * }
     */
    public static int CryptEnumKeyIdentifierProperties(MemorySegment pKeyIdentifier, int dwPropId, int dwFlags, MemorySegment pwszComputerName, MemorySegment pvReserved, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CryptEnumKeyIdentifierProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumKeyIdentifierProperties", pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptCreateKeyIdentifierFromCSP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptCreateKeyIdentifierFromCSP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCreateKeyIdentifierFromCSP(DWORD dwCertEncodingType, LPCSTR pszPubKeyOID, const PUBLICKEYSTRUC *pPubKeyStruc, DWORD cbPubKeyStruc, DWORD dwFlags, void *pvReserved, BYTE *pbHash, DWORD *pcbHash)
     * }
     */
    public static FunctionDescriptor CryptCreateKeyIdentifierFromCSP$descriptor() {
        return CryptCreateKeyIdentifierFromCSP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCreateKeyIdentifierFromCSP(DWORD dwCertEncodingType, LPCSTR pszPubKeyOID, const PUBLICKEYSTRUC *pPubKeyStruc, DWORD cbPubKeyStruc, DWORD dwFlags, void *pvReserved, BYTE *pbHash, DWORD *pcbHash)
     * }
     */
    public static MethodHandle CryptCreateKeyIdentifierFromCSP$handle() {
        return CryptCreateKeyIdentifierFromCSP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptCreateKeyIdentifierFromCSP(DWORD dwCertEncodingType, LPCSTR pszPubKeyOID, const PUBLICKEYSTRUC *pPubKeyStruc, DWORD cbPubKeyStruc, DWORD dwFlags, void *pvReserved, BYTE *pbHash, DWORD *pcbHash)
     * }
     */
    public static MemorySegment CryptCreateKeyIdentifierFromCSP$address() {
        return CryptCreateKeyIdentifierFromCSP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptCreateKeyIdentifierFromCSP(DWORD dwCertEncodingType, LPCSTR pszPubKeyOID, const PUBLICKEYSTRUC *pPubKeyStruc, DWORD cbPubKeyStruc, DWORD dwFlags, void *pvReserved, BYTE *pbHash, DWORD *pcbHash)
     * }
     */
    public static int CryptCreateKeyIdentifierFromCSP(int dwCertEncodingType, MemorySegment pszPubKeyOID, MemorySegment pPubKeyStruc, int cbPubKeyStruc, int dwFlags, MemorySegment pvReserved, MemorySegment pbHash, MemorySegment pcbHash) {
        var mh$ = CryptCreateKeyIdentifierFromCSP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCreateKeyIdentifierFromCSP", dwCertEncodingType, pszPubKeyOID, pPubKeyStruc, cbPubKeyStruc, dwFlags, pvReserved, pbHash, pcbHash);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pszPubKeyOID, pPubKeyStruc, cbPubKeyStruc, dwFlags, pvReserved, pbHash, pcbHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef HANDLE HCERTCHAINENGINE
     * }
     */
    public static final AddressLayout HCERTCHAINENGINE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_ENGINE_CONFIG {
     *     DWORD cbSize;
     *     HCERTSTORE hRestrictedRoot;
     *     HCERTSTORE hRestrictedTrust;
     *     HCERTSTORE hRestrictedOther;
     *     DWORD cAdditionalStore;
     *     HCERTSTORE *rghAdditionalStore;
     *     DWORD dwFlags;
     *     DWORD dwUrlRetrievalTimeout;
     *     DWORD MaximumCachedCertificates;
     *     DWORD CycleDetectionModulus;
     *     HCERTSTORE hExclusiveRoot;
     *     HCERTSTORE hExclusiveTrustedPeople;
     *     DWORD dwExclusiveFlags;
     * } *PCERT_CHAIN_ENGINE_CONFIG
     * }
     */
    public static final AddressLayout PCERT_CHAIN_ENGINE_CONFIG = winapi.C_POINTER;

    private static class CertCreateCertificateChainEngine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCreateCertificateChainEngine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCreateCertificateChainEngine(PCERT_CHAIN_ENGINE_CONFIG pConfig, HCERTCHAINENGINE *phChainEngine)
     * }
     */
    public static FunctionDescriptor CertCreateCertificateChainEngine$descriptor() {
        return CertCreateCertificateChainEngine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCreateCertificateChainEngine(PCERT_CHAIN_ENGINE_CONFIG pConfig, HCERTCHAINENGINE *phChainEngine)
     * }
     */
    public static MethodHandle CertCreateCertificateChainEngine$handle() {
        return CertCreateCertificateChainEngine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertCreateCertificateChainEngine(PCERT_CHAIN_ENGINE_CONFIG pConfig, HCERTCHAINENGINE *phChainEngine)
     * }
     */
    public static MemorySegment CertCreateCertificateChainEngine$address() {
        return CertCreateCertificateChainEngine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertCreateCertificateChainEngine(PCERT_CHAIN_ENGINE_CONFIG pConfig, HCERTCHAINENGINE *phChainEngine)
     * }
     */
    public static int CertCreateCertificateChainEngine(MemorySegment pConfig, MemorySegment phChainEngine) {
        var mh$ = CertCreateCertificateChainEngine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCertificateChainEngine", pConfig, phChainEngine);
            }
            return (int)mh$.invokeExact(pConfig, phChainEngine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCertificateChainEngine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFreeCertificateChainEngine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static FunctionDescriptor CertFreeCertificateChainEngine$descriptor() {
        return CertFreeCertificateChainEngine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static MethodHandle CertFreeCertificateChainEngine$handle() {
        return CertFreeCertificateChainEngine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static MemorySegment CertFreeCertificateChainEngine$address() {
        return CertFreeCertificateChainEngine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertFreeCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static void CertFreeCertificateChainEngine(MemorySegment hChainEngine) {
        var mh$ = CertFreeCertificateChainEngine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCertificateChainEngine", hChainEngine);
            }
            mh$.invokeExact(hChainEngine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertResyncCertificateChainEngine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertResyncCertificateChainEngine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertResyncCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static FunctionDescriptor CertResyncCertificateChainEngine$descriptor() {
        return CertResyncCertificateChainEngine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertResyncCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static MethodHandle CertResyncCertificateChainEngine$handle() {
        return CertResyncCertificateChainEngine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertResyncCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static MemorySegment CertResyncCertificateChainEngine$address() {
        return CertResyncCertificateChainEngine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertResyncCertificateChainEngine(HCERTCHAINENGINE hChainEngine)
     * }
     */
    public static int CertResyncCertificateChainEngine(MemorySegment hChainEngine) {
        var mh$ = CertResyncCertificateChainEngine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertResyncCertificateChainEngine", hChainEngine);
            }
            return (int)mh$.invokeExact(hChainEngine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TRUST_STATUS {
     *     DWORD dwErrorStatus;
     *     DWORD dwInfoStatus;
     * } *PCERT_TRUST_STATUS
     * }
     */
    public static final AddressLayout PCERT_TRUST_STATUS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_INFO {
     *     DWORD cbSize;
     *     DWORD dwRevocationResult;
     *     LPCSTR pszRevocationOid;
     *     LPVOID pvOidSpecificInfo;
     *     BOOL fHasFreshnessTime;
     *     DWORD dwFreshnessTime;
     *     PCERT_REVOCATION_CRL_INFO pCrlInfo;
     * } *PCERT_REVOCATION_INFO
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TRUST_LIST_INFO {
     *     DWORD cbSize;
     *     PCTL_ENTRY pCtlEntry;
     *     PCCTL_CONTEXT pCtlContext;
     * } *PCERT_TRUST_LIST_INFO
     * }
     */
    public static final AddressLayout PCERT_TRUST_LIST_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_ELEMENT {
     *     DWORD cbSize;
     *     PCCERT_CONTEXT pCertContext;
     *     CERT_TRUST_STATUS TrustStatus;
     *     PCERT_REVOCATION_INFO pRevocationInfo;
     *     PCERT_ENHKEY_USAGE pIssuanceUsage;
     *     PCERT_ENHKEY_USAGE pApplicationUsage;
     *     LPCWSTR pwszExtendedErrorInfo;
     * } *PCERT_CHAIN_ELEMENT
     * }
     */
    public static final AddressLayout PCERT_CHAIN_ELEMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_CHAIN_ELEMENT *PCCERT_CHAIN_ELEMENT
     * }
     */
    public static final AddressLayout PCCERT_CHAIN_ELEMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SIMPLE_CHAIN {
     *     DWORD cbSize;
     *     CERT_TRUST_STATUS TrustStatus;
     *     DWORD cElement;
     *     PCERT_CHAIN_ELEMENT *rgpElement;
     *     PCERT_TRUST_LIST_INFO pTrustListInfo;
     *     BOOL fHasRevocationFreshnessTime;
     *     DWORD dwRevocationFreshnessTime;
     * } *PCERT_SIMPLE_CHAIN
     * }
     */
    public static final AddressLayout PCERT_SIMPLE_CHAIN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_SIMPLE_CHAIN *PCCERT_SIMPLE_CHAIN
     * }
     */
    public static final AddressLayout PCCERT_SIMPLE_CHAIN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_CONTEXT *PCERT_CHAIN_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_CHAIN_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_CHAIN_CONTEXT *PCCERT_CHAIN_CONTEXT
     * }
     */
    public static final AddressLayout PCCERT_CHAIN_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_USAGE_MATCH {
     *     DWORD dwType;
     *     CERT_ENHKEY_USAGE Usage;
     * } *PCERT_USAGE_MATCH
     * }
     */
    public static final AddressLayout PCERT_USAGE_MATCH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_USAGE_MATCH {
     *     DWORD dwType;
     *     CTL_USAGE Usage;
     * } *PCTL_USAGE_MATCH
     * }
     */
    public static final AddressLayout PCTL_USAGE_MATCH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_PARA {
     *     DWORD cbSize;
     *     CERT_USAGE_MATCH RequestedUsage;
     * } *PCERT_CHAIN_PARA
     * }
     */
    public static final AddressLayout PCERT_CHAIN_PARA = winapi.C_POINTER;

    private static class CertGetCertificateChain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetCertificateChain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateChain(HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT *ppChainContext)
     * }
     */
    public static FunctionDescriptor CertGetCertificateChain$descriptor() {
        return CertGetCertificateChain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateChain(HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT *ppChainContext)
     * }
     */
    public static MethodHandle CertGetCertificateChain$handle() {
        return CertGetCertificateChain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateChain(HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT *ppChainContext)
     * }
     */
    public static MemorySegment CertGetCertificateChain$address() {
        return CertGetCertificateChain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertGetCertificateChain(HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT *ppChainContext)
     * }
     */
    public static int CertGetCertificateChain(MemorySegment hChainEngine, MemorySegment pCertContext, MemorySegment pTime, MemorySegment hAdditionalStore, MemorySegment pChainPara, int dwFlags, MemorySegment pvReserved, MemorySegment ppChainContext) {
        var mh$ = CertGetCertificateChain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCertificateChain", hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, pvReserved, ppChainContext);
            }
            return (int)mh$.invokeExact(hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, pvReserved, ppChainContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCertificateChain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFreeCertificateChain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertFreeCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static FunctionDescriptor CertFreeCertificateChain$descriptor() {
        return CertFreeCertificateChain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertFreeCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MethodHandle CertFreeCertificateChain$handle() {
        return CertFreeCertificateChain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertFreeCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MemorySegment CertFreeCertificateChain$address() {
        return CertFreeCertificateChain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertFreeCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static void CertFreeCertificateChain(MemorySegment pChainContext) {
        var mh$ = CertFreeCertificateChain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCertificateChain", pChainContext);
            }
            mh$.invokeExact(pChainContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDuplicateCertificateChain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertDuplicateCertificateChain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertDuplicateCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCertificateChain$descriptor() {
        return CertDuplicateCertificateChain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertDuplicateCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MethodHandle CertDuplicateCertificateChain$handle() {
        return CertDuplicateCertificateChain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertDuplicateCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MemorySegment CertDuplicateCertificateChain$address() {
        return CertDuplicateCertificateChain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertDuplicateCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext)
     * }
     */
    public static MemorySegment CertDuplicateCertificateChain(MemorySegment pChainContext) {
        var mh$ = CertDuplicateCertificateChain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCertificateChain", pChainContext);
            }
            return (MemorySegment)mh$.invokeExact(pChainContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_REVOCATION_INFO {
     *     PCRL_ENTRY pCrlEntry;
     *     PCCRL_CONTEXT pCrlContext;
     *     PCCERT_CHAIN_CONTEXT pCrlIssuerChain;
     * } *PCRL_REVOCATION_INFO
     * }
     */
    public static final AddressLayout PCRL_REVOCATION_INFO = winapi.C_POINTER;

    private static class CertFindChainInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFindChainInStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertFindChainInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CHAIN_CONTEXT pPrevChainContext)
     * }
     */
    public static FunctionDescriptor CertFindChainInStore$descriptor() {
        return CertFindChainInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertFindChainInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CHAIN_CONTEXT pPrevChainContext)
     * }
     */
    public static MethodHandle CertFindChainInStore$handle() {
        return CertFindChainInStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertFindChainInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CHAIN_CONTEXT pPrevChainContext)
     * }
     */
    public static MemorySegment CertFindChainInStore$address() {
        return CertFindChainInStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_CHAIN_CONTEXT CertFindChainInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CHAIN_CONTEXT pPrevChainContext)
     * }
     */
    public static MemorySegment CertFindChainInStore(MemorySegment hCertStore, int dwCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevChainContext) {
        var mh$ = CertFindChainInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindChainInStore", hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevChainContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevChainContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_FIND_BY_ISSUER_PARA {
     *     DWORD cbSize;
     *     LPCSTR pszUsageIdentifier;
     *     DWORD dwKeySpec;
     *     DWORD dwAcquirePrivateKeyFlags;
     *     DWORD cIssuer;
     *     CERT_NAME_BLOB *rgIssuer;
     *     PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK pfnFindCallback;
     *     void *pvFindArg;
     * } *PCERT_CHAIN_FIND_ISSUER_PARA
     * }
     */
    public static final AddressLayout PCERT_CHAIN_FIND_ISSUER_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_FIND_BY_ISSUER_PARA {
     *     DWORD cbSize;
     *     LPCSTR pszUsageIdentifier;
     *     DWORD dwKeySpec;
     *     DWORD dwAcquirePrivateKeyFlags;
     *     DWORD cIssuer;
     *     CERT_NAME_BLOB *rgIssuer;
     *     PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK pfnFindCallback;
     *     void *pvFindArg;
     * } *PCERT_CHAIN_FIND_BY_ISSUER_PARA
     * }
     */
    public static final AddressLayout PCERT_CHAIN_FIND_BY_ISSUER_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     *     void *pvExtraPolicyPara;
     * } *PCERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PCERT_CHAIN_POLICY_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     DWORD dwError;
     *     LONG lChainIndex;
     *     LONG lElementIndex;
     *     void *pvExtraPolicyStatus;
     * } *PCERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PCERT_CHAIN_POLICY_STATUS = winapi.C_POINTER;

    private static class CertVerifyCertificateChainPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertVerifyCertificateChainPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyCertificateChainPolicy(LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus)
     * }
     */
    public static FunctionDescriptor CertVerifyCertificateChainPolicy$descriptor() {
        return CertVerifyCertificateChainPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyCertificateChainPolicy(LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus)
     * }
     */
    public static MethodHandle CertVerifyCertificateChainPolicy$handle() {
        return CertVerifyCertificateChainPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertVerifyCertificateChainPolicy(LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus)
     * }
     */
    public static MemorySegment CertVerifyCertificateChainPolicy$address() {
        return CertVerifyCertificateChainPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertVerifyCertificateChainPolicy(LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus)
     * }
     */
    public static int CertVerifyCertificateChainPolicy(MemorySegment pszPolicyOID, MemorySegment pChainContext, MemorySegment pPolicyPara, MemorySegment pPolicyStatus) {
        var mh$ = CertVerifyCertificateChainPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCertificateChainPolicy", pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus);
            }
            return (int)mh$.invokeExact(pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwRegPolicySettings;
     *     PCMSG_SIGNER_INFO pSignerInfo;
     * } *PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     BOOL fCommercial;
     * } *PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwRegPolicySettings;
     *     BOOL fCommercial;
     * } *PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _HTTPSPolicyCallbackData {
     *     union {
     *         DWORD cbStruct;
     *         DWORD cbSize;
     *     };
     *     DWORD dwAuthType;
     *     DWORD fdwChecks;
     *     WCHAR *pwszServerName;
     * } *PHTTPSPolicyCallbackData
     * }
     */
    public static final AddressLayout PHTTPSPolicyCallbackData = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _HTTPSPolicyCallbackData {
     *     union {
     *         DWORD cbStruct;
     *         DWORD cbSize;
     *     };
     *     DWORD dwAuthType;
     *     DWORD fdwChecks;
     *     WCHAR *pwszServerName;
     * } *PSSL_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PSSL_EXTRA_CERT_CHAIN_POLICY_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EV_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwRootProgramQualifierFlags;
     * } *PEV_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PEV_EXTRA_CERT_CHAIN_POLICY_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EV_EXTRA_CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     DWORD dwQualifiers;
     *     DWORD dwIssuanceUsageIndex;
     * } *PEV_EXTRA_CERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PEV_EXTRA_CERT_CHAIN_POLICY_STATUS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     DWORD dwErrorLevel;
     *     DWORD dwErrorCategory;
     *     DWORD dwReserved;
     *     WCHAR wszErrorText[256];
     * } *PSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwReserved;
     *     LPWSTR pwszServerName;
     *     LPSTR rgpszHpkpValue[2];
     * } *PSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA {
     *     DWORD cbSize;
     *     DWORD dwReserved;
     *     PCWSTR pwszServerName;
     * } *PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA
     * }
     */
    public static final AddressLayout PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     LONG lError;
     *     WCHAR wszErrorText[512];
     * } *PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CT_EXTRA_CERT_CHAIN_POLICY_STATUS {
     *     DWORD cbSize;
     *     LONG lErrorStatus;
     *     LONG lErrorSubStatus;
     *     DWORD cEntries;
     *     DWORD cValidated;
     * } *PCT_EXTRA_CERT_CHAIN_POLICY_STATUS
     * }
     */
    public static final AddressLayout PCT_EXTRA_CERT_CHAIN_POLICY_STATUS = winapi.C_POINTER;

    private static class CryptStringToBinaryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptStringToBinaryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryA(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CryptStringToBinaryA$descriptor() {
        return CryptStringToBinaryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryA(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CryptStringToBinaryA$handle() {
        return CryptStringToBinaryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryA(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CryptStringToBinaryA$address() {
        return CryptStringToBinaryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryA(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static int CryptStringToBinaryA(MemorySegment pszString, int cchString, int dwFlags, MemorySegment pbBinary, MemorySegment pcbBinary, MemorySegment pdwSkip, MemorySegment pdwFlags) {
        var mh$ = CryptStringToBinaryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptStringToBinaryA", pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
            }
            return (int)mh$.invokeExact(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptStringToBinaryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptStringToBinaryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryW(LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CryptStringToBinaryW$descriptor() {
        return CryptStringToBinaryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryW(LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CryptStringToBinaryW$handle() {
        return CryptStringToBinaryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryW(LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CryptStringToBinaryW$address() {
        return CryptStringToBinaryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptStringToBinaryW(LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags)
     * }
     */
    public static int CryptStringToBinaryW(MemorySegment pszString, int cchString, int dwFlags, MemorySegment pbBinary, MemorySegment pcbBinary, MemorySegment pdwSkip, MemorySegment pdwFlags) {
        var mh$ = CryptStringToBinaryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptStringToBinaryW", pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
            }
            return (int)mh$.invokeExact(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptBinaryToStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptBinaryToStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringA(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString)
     * }
     */
    public static FunctionDescriptor CryptBinaryToStringA$descriptor() {
        return CryptBinaryToStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringA(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString)
     * }
     */
    public static MethodHandle CryptBinaryToStringA$handle() {
        return CryptBinaryToStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringA(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString)
     * }
     */
    public static MemorySegment CryptBinaryToStringA$address() {
        return CryptBinaryToStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringA(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString)
     * }
     */
    public static int CryptBinaryToStringA(MemorySegment pbBinary, int cbBinary, int dwFlags, MemorySegment pszString, MemorySegment pcchString) {
        var mh$ = CryptBinaryToStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptBinaryToStringA", pbBinary, cbBinary, dwFlags, pszString, pcchString);
            }
            return (int)mh$.invokeExact(pbBinary, cbBinary, dwFlags, pszString, pcchString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptBinaryToStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptBinaryToStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringW(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD *pcchString)
     * }
     */
    public static FunctionDescriptor CryptBinaryToStringW$descriptor() {
        return CryptBinaryToStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringW(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD *pcchString)
     * }
     */
    public static MethodHandle CryptBinaryToStringW$handle() {
        return CryptBinaryToStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringW(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD *pcchString)
     * }
     */
    public static MemorySegment CryptBinaryToStringW$address() {
        return CryptBinaryToStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptBinaryToStringW(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD *pcchString)
     * }
     */
    public static int CryptBinaryToStringW(MemorySegment pbBinary, int cbBinary, int dwFlags, MemorySegment pszString, MemorySegment pcchString) {
        var mh$ = CryptBinaryToStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptBinaryToStringW", pbBinary, cbBinary, dwFlags, pszString, pcchString);
            }
            return (int)mh$.invokeExact(pbBinary, cbBinary, dwFlags, pszString, pcchString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PFXImportCertStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PFXImportCertStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PFXImportCertStore$descriptor() {
        return PFXImportCertStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MethodHandle PFXImportCertStore$handle() {
        return PFXImportCertStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXImportCertStore$address() {
        return PFXImportCertStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXImportCertStore(MemorySegment pPFX, MemorySegment szPassword, int dwFlags) {
        var mh$ = PFXImportCertStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXImportCertStore", pPFX, szPassword, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PFXIsPFXBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PFXIsPFXBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PFXIsPFXBlob(CRYPT_DATA_BLOB *pPFX)
     * }
     */
    public static FunctionDescriptor PFXIsPFXBlob$descriptor() {
        return PFXIsPFXBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PFXIsPFXBlob(CRYPT_DATA_BLOB *pPFX)
     * }
     */
    public static MethodHandle PFXIsPFXBlob$handle() {
        return PFXIsPFXBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PFXIsPFXBlob(CRYPT_DATA_BLOB *pPFX)
     * }
     */
    public static MemorySegment PFXIsPFXBlob$address() {
        return PFXIsPFXBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PFXIsPFXBlob(CRYPT_DATA_BLOB *pPFX)
     * }
     */
    public static int PFXIsPFXBlob(MemorySegment pPFX) {
        var mh$ = PFXIsPFXBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXIsPFXBlob", pPFX);
            }
            return (int)mh$.invokeExact(pPFX);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PFXVerifyPassword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PFXVerifyPassword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PFXVerifyPassword(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PFXVerifyPassword$descriptor() {
        return PFXVerifyPassword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PFXVerifyPassword(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MethodHandle PFXVerifyPassword$handle() {
        return PFXVerifyPassword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PFXVerifyPassword(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXVerifyPassword$address() {
        return PFXVerifyPassword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PFXVerifyPassword(CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static int PFXVerifyPassword(MemorySegment pPFX, MemorySegment szPassword, int dwFlags) {
        var mh$ = PFXVerifyPassword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXVerifyPassword", pPFX, szPassword, dwFlags);
            }
            return (int)mh$.invokeExact(pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PFXExportCertStoreEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PFXExportCertStoreEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStoreEx(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, void *pvPara, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PFXExportCertStoreEx$descriptor() {
        return PFXExportCertStoreEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStoreEx(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, void *pvPara, DWORD dwFlags)
     * }
     */
    public static MethodHandle PFXExportCertStoreEx$handle() {
        return PFXExportCertStoreEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStoreEx(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, void *pvPara, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXExportCertStoreEx$address() {
        return PFXExportCertStoreEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PFXExportCertStoreEx(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, void *pvPara, DWORD dwFlags)
     * }
     */
    public static int PFXExportCertStoreEx(MemorySegment hStore, MemorySegment pPFX, MemorySegment szPassword, MemorySegment pvPara, int dwFlags) {
        var mh$ = PFXExportCertStoreEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXExportCertStoreEx", hStore, pPFX, szPassword, pvPara, dwFlags);
            }
            return (int)mh$.invokeExact(hStore, pPFX, szPassword, pvPara, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PKCS12_PBES2_EXPORT_PARAMS {
     *     DWORD dwSize;
     *     PVOID hNcryptDescriptor;
     *     LPWSTR pwszPbes2Alg;
     * } *PPKCS12_PBES2_EXPORT_PARAMS
     * }
     */
    public static final AddressLayout PPKCS12_PBES2_EXPORT_PARAMS = winapi.C_POINTER;

    private static class PFXExportCertStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PFXExportCertStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PFXExportCertStore$descriptor() {
        return PFXExportCertStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MethodHandle PFXExportCertStore$handle() {
        return PFXExportCertStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static MemorySegment PFXExportCertStore$address() {
        return PFXExportCertStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB *pPFX, LPCWSTR szPassword, DWORD dwFlags)
     * }
     */
    public static int PFXExportCertStore(MemorySegment hStore, MemorySegment pPFX, MemorySegment szPassword, int dwFlags) {
        var mh$ = PFXExportCertStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PFXExportCertStore", hStore, pPFX, szPassword, dwFlags);
            }
            return (int)mh$.invokeExact(hStore, pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *HCERT_SERVER_OCSP_RESPONSE
     * }
     */
    public static final AddressLayout HCERT_SERVER_OCSP_RESPONSE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SERVER_OCSP_RESPONSE_CONTEXT *PCERT_SERVER_OCSP_RESPONSE_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_SERVER_OCSP_RESPONSE_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_SERVER_OCSP_RESPONSE_CONTEXT *PCCERT_SERVER_OCSP_RESPONSE_CONTEXT
     * }
     */
    public static final AddressLayout PCCERT_SERVER_OCSP_RESPONSE_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SERVER_OCSP_RESPONSE_OPEN_PARA {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     *     DWORD *pcbUsedSize;
     *     PWSTR pwszOcspDirectory;
     *     PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK pfnUpdateCallback;
     *     PVOID pvUpdateCallbackArg;
     * } *PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA
     * }
     */
    public static final AddressLayout PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA = winapi.C_POINTER;

    private static class CertOpenServerOcspResponse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertOpenServerOcspResponse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERT_SERVER_OCSP_RESPONSE CertOpenServerOcspResponse(PCCERT_CHAIN_CONTEXT pChainContext, DWORD dwFlags, PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara)
     * }
     */
    public static FunctionDescriptor CertOpenServerOcspResponse$descriptor() {
        return CertOpenServerOcspResponse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERT_SERVER_OCSP_RESPONSE CertOpenServerOcspResponse(PCCERT_CHAIN_CONTEXT pChainContext, DWORD dwFlags, PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara)
     * }
     */
    public static MethodHandle CertOpenServerOcspResponse$handle() {
        return CertOpenServerOcspResponse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCERT_SERVER_OCSP_RESPONSE CertOpenServerOcspResponse(PCCERT_CHAIN_CONTEXT pChainContext, DWORD dwFlags, PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara)
     * }
     */
    public static MemorySegment CertOpenServerOcspResponse$address() {
        return CertOpenServerOcspResponse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCERT_SERVER_OCSP_RESPONSE CertOpenServerOcspResponse(PCCERT_CHAIN_CONTEXT pChainContext, DWORD dwFlags, PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara)
     * }
     */
    public static MemorySegment CertOpenServerOcspResponse(MemorySegment pChainContext, int dwFlags, MemorySegment pOpenPara) {
        var mh$ = CertOpenServerOcspResponse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenServerOcspResponse", pChainContext, dwFlags, pOpenPara);
            }
            return (MemorySegment)mh$.invokeExact(pChainContext, dwFlags, pOpenPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddRefServerOcspResponse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddRefServerOcspResponse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse)
     * }
     */
    public static FunctionDescriptor CertAddRefServerOcspResponse$descriptor() {
        return CertAddRefServerOcspResponse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse)
     * }
     */
    public static MethodHandle CertAddRefServerOcspResponse$handle() {
        return CertAddRefServerOcspResponse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse)
     * }
     */
    public static MemorySegment CertAddRefServerOcspResponse$address() {
        return CertAddRefServerOcspResponse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse)
     * }
     */
    public static void CertAddRefServerOcspResponse(MemorySegment hServerOcspResponse) {
        var mh$ = CertAddRefServerOcspResponse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddRefServerOcspResponse", hServerOcspResponse);
            }
            mh$.invokeExact(hServerOcspResponse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCloseServerOcspResponse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertCloseServerOcspResponse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertCloseServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertCloseServerOcspResponse$descriptor() {
        return CertCloseServerOcspResponse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertCloseServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertCloseServerOcspResponse$handle() {
        return CertCloseServerOcspResponse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertCloseServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertCloseServerOcspResponse$address() {
        return CertCloseServerOcspResponse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertCloseServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags)
     * }
     */
    public static void CertCloseServerOcspResponse(MemorySegment hServerOcspResponse, int dwFlags) {
        var mh$ = CertCloseServerOcspResponse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCloseServerOcspResponse", hServerOcspResponse, dwFlags);
            }
            mh$.invokeExact(hServerOcspResponse, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetServerOcspResponseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertGetServerOcspResponseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_SERVER_OCSP_RESPONSE_CONTEXT CertGetServerOcspResponseContext(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static FunctionDescriptor CertGetServerOcspResponseContext$descriptor() {
        return CertGetServerOcspResponseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_SERVER_OCSP_RESPONSE_CONTEXT CertGetServerOcspResponseContext(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MethodHandle CertGetServerOcspResponseContext$handle() {
        return CertGetServerOcspResponseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PCCERT_SERVER_OCSP_RESPONSE_CONTEXT CertGetServerOcspResponseContext(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MemorySegment CertGetServerOcspResponseContext$address() {
        return CertGetServerOcspResponseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PCCERT_SERVER_OCSP_RESPONSE_CONTEXT CertGetServerOcspResponseContext(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MemorySegment CertGetServerOcspResponseContext(MemorySegment hServerOcspResponse, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CertGetServerOcspResponseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetServerOcspResponseContext", hServerOcspResponse, dwFlags, pvReserved);
            }
            return (MemorySegment)mh$.invokeExact(hServerOcspResponse, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddRefServerOcspResponseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertAddRefServerOcspResponseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static FunctionDescriptor CertAddRefServerOcspResponseContext$descriptor() {
        return CertAddRefServerOcspResponseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static MethodHandle CertAddRefServerOcspResponseContext$handle() {
        return CertAddRefServerOcspResponseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static MemorySegment CertAddRefServerOcspResponseContext$address() {
        return CertAddRefServerOcspResponseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertAddRefServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static void CertAddRefServerOcspResponseContext(MemorySegment pServerOcspResponseContext) {
        var mh$ = CertAddRefServerOcspResponseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddRefServerOcspResponseContext", pServerOcspResponseContext);
            }
            mh$.invokeExact(pServerOcspResponseContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeServerOcspResponseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFreeServerOcspResponseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertFreeServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static FunctionDescriptor CertFreeServerOcspResponseContext$descriptor() {
        return CertFreeServerOcspResponseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertFreeServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static MethodHandle CertFreeServerOcspResponseContext$handle() {
        return CertFreeServerOcspResponseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertFreeServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static MemorySegment CertFreeServerOcspResponseContext$address() {
        return CertFreeServerOcspResponseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertFreeServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext)
     * }
     */
    public static void CertFreeServerOcspResponseContext(MemorySegment pServerOcspResponseContext) {
        var mh$ = CertFreeServerOcspResponseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeServerOcspResponseContext", pServerOcspResponseContext);
            }
            mh$.invokeExact(pServerOcspResponseContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRetrieveLogoOrBiometricInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertRetrieveLogoOrBiometricInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRetrieveLogoOrBiometricInfo(PCCERT_CONTEXT pCertContext, LPCSTR lpszLogoOrBiometricType, DWORD dwRetrievalFlags, DWORD dwTimeout, DWORD dwFlags, void *pvReserved, BYTE **ppbData, DWORD *pcbData, LPWSTR *ppwszMimeType)
     * }
     */
    public static FunctionDescriptor CertRetrieveLogoOrBiometricInfo$descriptor() {
        return CertRetrieveLogoOrBiometricInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRetrieveLogoOrBiometricInfo(PCCERT_CONTEXT pCertContext, LPCSTR lpszLogoOrBiometricType, DWORD dwRetrievalFlags, DWORD dwTimeout, DWORD dwFlags, void *pvReserved, BYTE **ppbData, DWORD *pcbData, LPWSTR *ppwszMimeType)
     * }
     */
    public static MethodHandle CertRetrieveLogoOrBiometricInfo$handle() {
        return CertRetrieveLogoOrBiometricInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertRetrieveLogoOrBiometricInfo(PCCERT_CONTEXT pCertContext, LPCSTR lpszLogoOrBiometricType, DWORD dwRetrievalFlags, DWORD dwTimeout, DWORD dwFlags, void *pvReserved, BYTE **ppbData, DWORD *pcbData, LPWSTR *ppwszMimeType)
     * }
     */
    public static MemorySegment CertRetrieveLogoOrBiometricInfo$address() {
        return CertRetrieveLogoOrBiometricInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertRetrieveLogoOrBiometricInfo(PCCERT_CONTEXT pCertContext, LPCSTR lpszLogoOrBiometricType, DWORD dwRetrievalFlags, DWORD dwTimeout, DWORD dwFlags, void *pvReserved, BYTE **ppbData, DWORD *pcbData, LPWSTR *ppwszMimeType)
     * }
     */
    public static int CertRetrieveLogoOrBiometricInfo(MemorySegment pCertContext, MemorySegment lpszLogoOrBiometricType, int dwRetrievalFlags, int dwTimeout, int dwFlags, MemorySegment pvReserved, MemorySegment ppbData, MemorySegment pcbData, MemorySegment ppwszMimeType) {
        var mh$ = CertRetrieveLogoOrBiometricInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRetrieveLogoOrBiometricInfo", pCertContext, lpszLogoOrBiometricType, dwRetrievalFlags, dwTimeout, dwFlags, pvReserved, ppbData, pcbData, ppwszMimeType);
            }
            return (int)mh$.invokeExact(pCertContext, lpszLogoOrBiometricType, dwRetrievalFlags, dwTimeout, dwFlags, pvReserved, ppbData, pcbData, ppwszMimeType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SELECT_CHAIN_PARA {
     *     HCERTCHAINENGINE hChainEngine;
     *     PFILETIME pTime;
     *     HCERTSTORE hAdditionalStore;
     *     PCERT_CHAIN_PARA pChainPara;
     *     DWORD dwFlags;
     * } *PCERT_SELECT_CHAIN_PARA
     * }
     */
    public static final AddressLayout PCERT_SELECT_CHAIN_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_SELECT_CHAIN_PARA *PCCERT_SELECT_CHAIN_PARA
     * }
     */
    public static final AddressLayout PCCERT_SELECT_CHAIN_PARA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SELECT_CRITERIA {
     *     DWORD dwType;
     *     DWORD cPara;
     *     void **ppPara;
     * } *PCERT_SELECT_CRITERIA
     * }
     */
    public static final AddressLayout PCERT_SELECT_CRITERIA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_SELECT_CRITERIA *PCCERT_SELECT_CRITERIA
     * }
     */
    public static final AddressLayout PCCERT_SELECT_CRITERIA = winapi.C_POINTER;

    private static class CertSelectCertificateChains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertSelectCertificateChains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSelectCertificateChains(LPCGUID pSelectionContext, DWORD dwFlags, PCCERT_SELECT_CHAIN_PARA pChainParameters, DWORD cCriteria, PCCERT_SELECT_CRITERIA rgpCriteria, HCERTSTORE hStore, PDWORD pcSelection, PCCERT_CHAIN_CONTEXT **pprgpSelection)
     * }
     */
    public static FunctionDescriptor CertSelectCertificateChains$descriptor() {
        return CertSelectCertificateChains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSelectCertificateChains(LPCGUID pSelectionContext, DWORD dwFlags, PCCERT_SELECT_CHAIN_PARA pChainParameters, DWORD cCriteria, PCCERT_SELECT_CRITERIA rgpCriteria, HCERTSTORE hStore, PDWORD pcSelection, PCCERT_CHAIN_CONTEXT **pprgpSelection)
     * }
     */
    public static MethodHandle CertSelectCertificateChains$handle() {
        return CertSelectCertificateChains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertSelectCertificateChains(LPCGUID pSelectionContext, DWORD dwFlags, PCCERT_SELECT_CHAIN_PARA pChainParameters, DWORD cCriteria, PCCERT_SELECT_CRITERIA rgpCriteria, HCERTSTORE hStore, PDWORD pcSelection, PCCERT_CHAIN_CONTEXT **pprgpSelection)
     * }
     */
    public static MemorySegment CertSelectCertificateChains$address() {
        return CertSelectCertificateChains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertSelectCertificateChains(LPCGUID pSelectionContext, DWORD dwFlags, PCCERT_SELECT_CHAIN_PARA pChainParameters, DWORD cCriteria, PCCERT_SELECT_CRITERIA rgpCriteria, HCERTSTORE hStore, PDWORD pcSelection, PCCERT_CHAIN_CONTEXT **pprgpSelection)
     * }
     */
    public static int CertSelectCertificateChains(MemorySegment pSelectionContext, int dwFlags, MemorySegment pChainParameters, int cCriteria, MemorySegment rgpCriteria, MemorySegment hStore, MemorySegment pcSelection, MemorySegment pprgpSelection) {
        var mh$ = CertSelectCertificateChains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSelectCertificateChains", pSelectionContext, dwFlags, pChainParameters, cCriteria, rgpCriteria, hStore, pcSelection, pprgpSelection);
            }
            return (int)mh$.invokeExact(pSelectionContext, dwFlags, pChainParameters, cCriteria, rgpCriteria, hStore, pcSelection, pprgpSelection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCertificateChainList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertFreeCertificateChainList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainList(PCCERT_CHAIN_CONTEXT *prgpSelection)
     * }
     */
    public static FunctionDescriptor CertFreeCertificateChainList$descriptor() {
        return CertFreeCertificateChainList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainList(PCCERT_CHAIN_CONTEXT *prgpSelection)
     * }
     */
    public static MethodHandle CertFreeCertificateChainList$handle() {
        return CertFreeCertificateChainList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CertFreeCertificateChainList(PCCERT_CHAIN_CONTEXT *prgpSelection)
     * }
     */
    public static MemorySegment CertFreeCertificateChainList$address() {
        return CertFreeCertificateChainList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CertFreeCertificateChainList(PCCERT_CHAIN_CONTEXT *prgpSelection)
     * }
     */
    public static void CertFreeCertificateChainList(MemorySegment prgpSelection) {
        var mh$ = CertFreeCertificateChainList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCertificateChainList", prgpSelection);
            }
            mh$.invokeExact(prgpSelection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_REQUEST {
     *     DWORD dwVersion;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_DER_BLOB HashedMessage;
     *     LPSTR pszTSAPolicyId;
     *     CRYPT_INTEGER_BLOB Nonce;
     *     BOOL fCertReq;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRYPT_TIMESTAMP_REQUEST
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_REQUEST = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_RESPONSE {
     *     DWORD dwStatus;
     *     DWORD cFreeText;
     *     LPWSTR *rgFreeText;
     *     CRYPT_BIT_BLOB FailureInfo;
     *     CRYPT_DER_BLOB ContentInfo;
     * } *PCRYPT_TIMESTAMP_RESPONSE
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_RESPONSE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_ACCURACY {
     *     DWORD dwSeconds;
     *     DWORD dwMillis;
     *     DWORD dwMicros;
     * } *PCRYPT_TIMESTAMP_ACCURACY
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_ACCURACY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_INFO {
     *     DWORD dwVersion;
     *     LPSTR pszTSAPolicyId;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_DER_BLOB HashedMessage;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     *     FILETIME ftTime;
     *     PCRYPT_TIMESTAMP_ACCURACY pvAccuracy;
     *     BOOL fOrdering;
     *     CRYPT_DER_BLOB Nonce;
     *     CRYPT_DER_BLOB Tsa;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRYPT_TIMESTAMP_INFO
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_CONTEXT {
     *     DWORD cbEncoded;
     *     BYTE *pbEncoded;
     *     PCRYPT_TIMESTAMP_INFO pTimeStamp;
     * } *PCRYPT_TIMESTAMP_CONTEXT
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIMESTAMP_PARA {
     *     LPCSTR pszTSAPolicyId;
     *     BOOL fRequestCerts;
     *     CRYPT_INTEGER_BLOB Nonce;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRYPT_TIMESTAMP_PARA
     * }
     */
    public static final AddressLayout PCRYPT_TIMESTAMP_PARA = winapi.C_POINTER;

    private static class CryptRetrieveTimeStamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptRetrieveTimeStamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveTimeStamp(LPCWSTR wszUrl, DWORD dwRetrievalFlags, DWORD dwTimeout, LPCSTR pszHashId, const CRYPT_TIMESTAMP_PARA *pPara, const BYTE *pbData, DWORD cbData, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static FunctionDescriptor CryptRetrieveTimeStamp$descriptor() {
        return CryptRetrieveTimeStamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveTimeStamp(LPCWSTR wszUrl, DWORD dwRetrievalFlags, DWORD dwTimeout, LPCSTR pszHashId, const CRYPT_TIMESTAMP_PARA *pPara, const BYTE *pbData, DWORD cbData, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static MethodHandle CryptRetrieveTimeStamp$handle() {
        return CryptRetrieveTimeStamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptRetrieveTimeStamp(LPCWSTR wszUrl, DWORD dwRetrievalFlags, DWORD dwTimeout, LPCSTR pszHashId, const CRYPT_TIMESTAMP_PARA *pPara, const BYTE *pbData, DWORD cbData, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static MemorySegment CryptRetrieveTimeStamp$address() {
        return CryptRetrieveTimeStamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptRetrieveTimeStamp(LPCWSTR wszUrl, DWORD dwRetrievalFlags, DWORD dwTimeout, LPCSTR pszHashId, const CRYPT_TIMESTAMP_PARA *pPara, const BYTE *pbData, DWORD cbData, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static int CryptRetrieveTimeStamp(MemorySegment wszUrl, int dwRetrievalFlags, int dwTimeout, MemorySegment pszHashId, MemorySegment pPara, MemorySegment pbData, int cbData, MemorySegment ppTsContext, MemorySegment ppTsSigner, MemorySegment phStore) {
        var mh$ = CryptRetrieveTimeStamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRetrieveTimeStamp", wszUrl, dwRetrievalFlags, dwTimeout, pszHashId, pPara, pbData, cbData, ppTsContext, ppTsSigner, phStore);
            }
            return (int)mh$.invokeExact(wszUrl, dwRetrievalFlags, dwTimeout, pszHashId, pPara, pbData, cbData, ppTsContext, ppTsSigner, phStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyTimeStampSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptVerifyTimeStampSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyTimeStampSignature(const BYTE *pbTSContentInfo, DWORD cbTSContentInfo, const BYTE *pbData, DWORD cbData, HCERTSTORE hAdditionalStore, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static FunctionDescriptor CryptVerifyTimeStampSignature$descriptor() {
        return CryptVerifyTimeStampSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyTimeStampSignature(const BYTE *pbTSContentInfo, DWORD cbTSContentInfo, const BYTE *pbData, DWORD cbData, HCERTSTORE hAdditionalStore, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static MethodHandle CryptVerifyTimeStampSignature$handle() {
        return CryptVerifyTimeStampSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptVerifyTimeStampSignature(const BYTE *pbTSContentInfo, DWORD cbTSContentInfo, const BYTE *pbData, DWORD cbData, HCERTSTORE hAdditionalStore, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static MemorySegment CryptVerifyTimeStampSignature$address() {
        return CryptVerifyTimeStampSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyTimeStampSignature(const BYTE *pbTSContentInfo, DWORD cbTSContentInfo, const BYTE *pbData, DWORD cbData, HCERTSTORE hAdditionalStore, PCRYPT_TIMESTAMP_CONTEXT *ppTsContext, PCCERT_CONTEXT *ppTsSigner, HCERTSTORE *phStore)
     * }
     */
    public static int CryptVerifyTimeStampSignature(MemorySegment pbTSContentInfo, int cbTSContentInfo, MemorySegment pbData, int cbData, MemorySegment hAdditionalStore, MemorySegment ppTsContext, MemorySegment ppTsSigner, MemorySegment phStore) {
        var mh$ = CryptVerifyTimeStampSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyTimeStampSignature", pbTSContentInfo, cbTSContentInfo, pbData, cbData, hAdditionalStore, ppTsContext, ppTsSigner, phStore);
            }
            return (int)mh$.invokeExact(pbTSContentInfo, cbTSContentInfo, pbData, cbData, hAdditionalStore, ppTsContext, ppTsSigner, phStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE {
     *     DWORD cbSize;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET pfnGet;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE pfnRelease;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD pfnFreePassword;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE pfnFree;
     *     PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER pfnFreeIdentifier;
     * } *PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE
     * }
     */
    public static final AddressLayout PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = winapi.C_POINTER;

    private static class CertIsWeakHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CertIsWeakHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsWeakHash(DWORD dwHashUseType, LPCWSTR pwszCNGHashAlgid, DWORD dwChainFlags, PCCERT_CHAIN_CONTEXT pSignerChainContext, LPFILETIME pTimeStamp, LPCWSTR pwszFileName)
     * }
     */
    public static FunctionDescriptor CertIsWeakHash$descriptor() {
        return CertIsWeakHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsWeakHash(DWORD dwHashUseType, LPCWSTR pwszCNGHashAlgid, DWORD dwChainFlags, PCCERT_CHAIN_CONTEXT pSignerChainContext, LPFILETIME pTimeStamp, LPCWSTR pwszFileName)
     * }
     */
    public static MethodHandle CertIsWeakHash$handle() {
        return CertIsWeakHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CertIsWeakHash(DWORD dwHashUseType, LPCWSTR pwszCNGHashAlgid, DWORD dwChainFlags, PCCERT_CHAIN_CONTEXT pSignerChainContext, LPFILETIME pTimeStamp, LPCWSTR pwszFileName)
     * }
     */
    public static MemorySegment CertIsWeakHash$address() {
        return CertIsWeakHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CertIsWeakHash(DWORD dwHashUseType, LPCWSTR pwszCNGHashAlgid, DWORD dwChainFlags, PCCERT_CHAIN_CONTEXT pSignerChainContext, LPFILETIME pTimeStamp, LPCWSTR pwszFileName)
     * }
     */
    public static int CertIsWeakHash(int dwHashUseType, MemorySegment pwszCNGHashAlgid, int dwChainFlags, MemorySegment pSignerChainContext, MemorySegment pTimeStamp, MemorySegment pwszFileName) {
        var mh$ = CertIsWeakHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsWeakHash", dwHashUseType, pwszCNGHashAlgid, dwChainFlags, pSignerChainContext, pTimeStamp, pwszFileName);
            }
            return (int)mh$.invokeExact(dwHashUseType, pwszCNGHashAlgid, dwChainFlags, pSignerChainContext, pTimeStamp, pwszFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTPROTECT_PROMPTSTRUCT {
     *     DWORD cbSize;
     *     DWORD dwPromptFlags;
     *     HWND hwndApp;
     *     LPCWSTR szPrompt;
     * } *PCRYPTPROTECT_PROMPTSTRUCT
     * }
     */
    public static final AddressLayout PCRYPTPROTECT_PROMPTSTRUCT = winapi.C_POINTER;

    private static class CryptProtectData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptProtectData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptProtectData(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static FunctionDescriptor CryptProtectData$descriptor() {
        return CryptProtectData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptProtectData(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static MethodHandle CryptProtectData$handle() {
        return CryptProtectData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptProtectData(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static MemorySegment CryptProtectData$address() {
        return CryptProtectData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptProtectData(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static int CryptProtectData(MemorySegment pDataIn, MemorySegment szDataDescr, MemorySegment pOptionalEntropy, MemorySegment pvReserved, MemorySegment pPromptStruct, int dwFlags, MemorySegment pDataOut) {
        var mh$ = CryptProtectData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptProtectData", pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
            }
            return (int)mh$.invokeExact(pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnprotectData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptUnprotectData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectData(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static FunctionDescriptor CryptUnprotectData$descriptor() {
        return CryptUnprotectData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectData(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static MethodHandle CryptUnprotectData$handle() {
        return CryptUnprotectData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectData(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static MemorySegment CryptUnprotectData$address() {
        return CryptUnprotectData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnprotectData(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut)
     * }
     */
    public static int CryptUnprotectData(MemorySegment pDataIn, MemorySegment ppszDataDescr, MemorySegment pOptionalEntropy, MemorySegment pvReserved, MemorySegment pPromptStruct, int dwFlags, MemorySegment pDataOut) {
        var mh$ = CryptUnprotectData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnprotectData", pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
            }
            return (int)mh$.invokeExact(pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptProtectDataNoUI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptProtectDataNoUI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptProtectDataNoUI(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static FunctionDescriptor CryptProtectDataNoUI$descriptor() {
        return CryptProtectDataNoUI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptProtectDataNoUI(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static MethodHandle CryptProtectDataNoUI$handle() {
        return CryptProtectDataNoUI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptProtectDataNoUI(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static MemorySegment CryptProtectDataNoUI$address() {
        return CryptProtectDataNoUI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptProtectDataNoUI(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static int CryptProtectDataNoUI(MemorySegment pDataIn, MemorySegment szDataDescr, MemorySegment pOptionalEntropy, MemorySegment pvReserved, MemorySegment pPromptStruct, int dwFlags, MemorySegment pbOptionalPassword, int cbOptionalPassword, MemorySegment pDataOut) {
        var mh$ = CryptProtectDataNoUI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptProtectDataNoUI", pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
            }
            return (int)mh$.invokeExact(pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnprotectDataNoUI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptUnprotectDataNoUI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectDataNoUI(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static FunctionDescriptor CryptUnprotectDataNoUI$descriptor() {
        return CryptUnprotectDataNoUI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectDataNoUI(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static MethodHandle CryptUnprotectDataNoUI$handle() {
        return CryptUnprotectDataNoUI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectDataNoUI(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static MemorySegment CryptUnprotectDataNoUI$address() {
        return CryptUnprotectDataNoUI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnprotectDataNoUI(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, const BYTE *pbOptionalPassword, DWORD cbOptionalPassword, DATA_BLOB *pDataOut)
     * }
     */
    public static int CryptUnprotectDataNoUI(MemorySegment pDataIn, MemorySegment ppszDataDescr, MemorySegment pOptionalEntropy, MemorySegment pvReserved, MemorySegment pPromptStruct, int dwFlags, MemorySegment pbOptionalPassword, int cbOptionalPassword, MemorySegment pDataOut) {
        var mh$ = CryptUnprotectDataNoUI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnprotectDataNoUI", pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
            }
            return (int)mh$.invokeExact(pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUpdateProtectedState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptUpdateProtectedState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUpdateProtectedState(PSID pOldSid, LPCWSTR pwszOldPassword, DWORD dwFlags, DWORD *pdwSuccessCount, DWORD *pdwFailureCount)
     * }
     */
    public static FunctionDescriptor CryptUpdateProtectedState$descriptor() {
        return CryptUpdateProtectedState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUpdateProtectedState(PSID pOldSid, LPCWSTR pwszOldPassword, DWORD dwFlags, DWORD *pdwSuccessCount, DWORD *pdwFailureCount)
     * }
     */
    public static MethodHandle CryptUpdateProtectedState$handle() {
        return CryptUpdateProtectedState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUpdateProtectedState(PSID pOldSid, LPCWSTR pwszOldPassword, DWORD dwFlags, DWORD *pdwSuccessCount, DWORD *pdwFailureCount)
     * }
     */
    public static MemorySegment CryptUpdateProtectedState$address() {
        return CryptUpdateProtectedState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUpdateProtectedState(PSID pOldSid, LPCWSTR pwszOldPassword, DWORD dwFlags, DWORD *pdwSuccessCount, DWORD *pdwFailureCount)
     * }
     */
    public static int CryptUpdateProtectedState(MemorySegment pOldSid, MemorySegment pwszOldPassword, int dwFlags, MemorySegment pdwSuccessCount, MemorySegment pdwFailureCount) {
        var mh$ = CryptUpdateProtectedState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUpdateProtectedState", pOldSid, pwszOldPassword, dwFlags, pdwSuccessCount, pdwFailureCount);
            }
            return (int)mh$.invokeExact(pOldSid, pwszOldPassword, dwFlags, pdwSuccessCount, pdwFailureCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptProtectMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptProtectMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptProtectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptProtectMemory$descriptor() {
        return CryptProtectMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptProtectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptProtectMemory$handle() {
        return CryptProtectMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptProtectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptProtectMemory$address() {
        return CryptProtectMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptProtectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static int CryptProtectMemory(MemorySegment pDataIn, int cbDataIn, int dwFlags) {
        var mh$ = CryptProtectMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptProtectMemory", pDataIn, cbDataIn, dwFlags);
            }
            return (int)mh$.invokeExact(pDataIn, cbDataIn, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnprotectMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CryptUnprotectMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptUnprotectMemory$descriptor() {
        return CryptUnprotectMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptUnprotectMemory$handle() {
        return CryptUnprotectMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CryptUnprotectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptUnprotectMemory$address() {
        return CryptUnprotectMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CryptUnprotectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags)
     * }
     */
    public static int CryptUnprotectMemory(MemorySegment pDataIn, int cbDataIn, int dwFlags) {
        var mh$ = CryptUnprotectMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnprotectMemory", pDataIn, cbDataIn, dwFlags);
            }
            return (int)mh$.invokeExact(pDataIn, cbDataIn, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERTIFICATE_BLOB {
     *     DWORD dwCertEncodingType;
     *     DWORD cbData;
     *     PBYTE pbData;
     * } *PEFS_CERTIFICATE_BLOB
     * }
     */
    public static final AddressLayout PEFS_CERTIFICATE_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_HASH_BLOB {
     *     DWORD cbData;
     *     PBYTE pbData;
     * } *PEFS_HASH_BLOB
     * }
     */
    public static final AddressLayout PEFS_HASH_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_RPC_BLOB {
     *     DWORD cbData;
     *     PBYTE pbData;
     * } *PEFS_RPC_BLOB
     * }
     */
    public static final AddressLayout PEFS_RPC_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_PIN_BLOB {
     *     DWORD cbPadding;
     *     DWORD cbData;
     *     PBYTE pbData;
     * } *PEFS_PIN_BLOB
     * }
     */
    public static final AddressLayout PEFS_PIN_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_KEY_INFO {
     *     DWORD dwVersion;
     *     ULONG Entropy;
     *     ALG_ID Algorithm;
     *     ULONG KeyLength;
     * } *PEFS_KEY_INFO
     * }
     */
    public static final AddressLayout PEFS_KEY_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_COMPATIBILITY_INFO {
     *     DWORD EfsVersion;
     * } *PEFS_COMPATIBILITY_INFO
     * }
     */
    public static final AddressLayout PEFS_COMPATIBILITY_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_VERSION_INFO {
     *     DWORD EfsVersion;
     *     DWORD SubVersion;
     * } *PEFS_VERSION_INFO
     * }
     */
    public static final AddressLayout PEFS_VERSION_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_DECRYPTION_STATUS_INFO {
     *     DWORD dwDecryptionError;
     *     DWORD dwHashOffset;
     *     DWORD cbHash;
     * } *PEFS_DECRYPTION_STATUS_INFO
     * }
     */
    public static final AddressLayout PEFS_DECRYPTION_STATUS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EFS_ENCRYPTION_STATUS_INFO {
     *     BOOL bHasCurrentKey;
     *     DWORD dwEncryptionError;
     * } *PEFS_ENCRYPTION_STATUS_INFO
     * }
     */
    public static final AddressLayout PEFS_ENCRYPTION_STATUS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_CERTIFICATE {
     *     DWORD cbTotalLength;
     *     SID *pUserSid;
     *     PEFS_CERTIFICATE_BLOB pCertBlob;
     * } *PENCRYPTION_CERTIFICATE
     * }
     */
    public static final AddressLayout PENCRYPTION_CERTIFICATE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_CERTIFICATE_HASH {
     *     DWORD cbTotalLength;
     *     SID *pUserSid;
     *     PEFS_HASH_BLOB pHash;
     *     LPWSTR lpDisplayInformation;
     * } *PENCRYPTION_CERTIFICATE_HASH
     * }
     */
    public static final AddressLayout PENCRYPTION_CERTIFICATE_HASH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_CERTIFICATE_HASH_LIST {
     *     DWORD nCert_Hash;
     *     PENCRYPTION_CERTIFICATE_HASH *pUsers;
     * } *PENCRYPTION_CERTIFICATE_HASH_LIST
     * }
     */
    public static final AddressLayout PENCRYPTION_CERTIFICATE_HASH_LIST = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_CERTIFICATE_LIST {
     *     DWORD nUsers;
     *     PENCRYPTION_CERTIFICATE *pUsers;
     * } *PENCRYPTION_CERTIFICATE_LIST
     * }
     */
    public static final AddressLayout PENCRYPTION_CERTIFICATE_LIST = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTED_FILE_METADATA_SIGNATURE {
     *     DWORD dwEfsAccessType;
     *     PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded;
     *     PENCRYPTION_CERTIFICATE pEncryptionCertificate;
     *     PEFS_RPC_BLOB pEfsStreamSignature;
     * } *PENCRYPTED_FILE_METADATA_SIGNATURE
     * }
     */
    public static final AddressLayout PENCRYPTED_FILE_METADATA_SIGNATURE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_PROTECTOR {
     *     DWORD cbTotalLength;
     *     SID *pUserSid;
     *     LPWSTR lpProtectorDescriptor;
     * } *PENCRYPTION_PROTECTOR
     * }
     */
    public static final AddressLayout PENCRYPTION_PROTECTOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCRYPTION_PROTECTOR_LIST {
     *     DWORD nProtectors;
     *     PENCRYPTION_PROTECTOR *pProtectors;
     * } *PENCRYPTION_PROTECTOR_LIST
     * }
     */
    public static final AddressLayout PENCRYPTION_PROTECTOR_LIST = winapi.C_POINTER;

    private static class QueryUsersOnEncryptedFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueryUsersOnEncryptedFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryUsersOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pUsers)
     * }
     */
    public static FunctionDescriptor QueryUsersOnEncryptedFile$descriptor() {
        return QueryUsersOnEncryptedFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryUsersOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pUsers)
     * }
     */
    public static MethodHandle QueryUsersOnEncryptedFile$handle() {
        return QueryUsersOnEncryptedFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryUsersOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pUsers)
     * }
     */
    public static MemorySegment QueryUsersOnEncryptedFile$address() {
        return QueryUsersOnEncryptedFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryUsersOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pUsers)
     * }
     */
    public static int QueryUsersOnEncryptedFile(MemorySegment lpFileName, MemorySegment pUsers) {
        var mh$ = QueryUsersOnEncryptedFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUsersOnEncryptedFile", lpFileName, pUsers);
            }
            return (int)mh$.invokeExact(lpFileName, pUsers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryRecoveryAgentsOnEncryptedFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueryRecoveryAgentsOnEncryptedFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryRecoveryAgentsOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents)
     * }
     */
    public static FunctionDescriptor QueryRecoveryAgentsOnEncryptedFile$descriptor() {
        return QueryRecoveryAgentsOnEncryptedFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryRecoveryAgentsOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents)
     * }
     */
    public static MethodHandle QueryRecoveryAgentsOnEncryptedFile$handle() {
        return QueryRecoveryAgentsOnEncryptedFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryRecoveryAgentsOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents)
     * }
     */
    public static MemorySegment QueryRecoveryAgentsOnEncryptedFile$address() {
        return QueryRecoveryAgentsOnEncryptedFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryRecoveryAgentsOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents)
     * }
     */
    public static int QueryRecoveryAgentsOnEncryptedFile(MemorySegment lpFileName, MemorySegment pRecoveryAgents) {
        var mh$ = QueryRecoveryAgentsOnEncryptedFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryRecoveryAgentsOnEncryptedFile", lpFileName, pRecoveryAgents);
            }
            return (int)mh$.invokeExact(lpFileName, pRecoveryAgents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveUsersFromEncryptedFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveUsersFromEncryptedFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RemoveUsersFromEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes)
     * }
     */
    public static FunctionDescriptor RemoveUsersFromEncryptedFile$descriptor() {
        return RemoveUsersFromEncryptedFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RemoveUsersFromEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes)
     * }
     */
    public static MethodHandle RemoveUsersFromEncryptedFile$handle() {
        return RemoveUsersFromEncryptedFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RemoveUsersFromEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes)
     * }
     */
    public static MemorySegment RemoveUsersFromEncryptedFile$address() {
        return RemoveUsersFromEncryptedFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RemoveUsersFromEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes)
     * }
     */
    public static int RemoveUsersFromEncryptedFile(MemorySegment lpFileName, MemorySegment pHashes) {
        var mh$ = RemoveUsersFromEncryptedFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveUsersFromEncryptedFile", lpFileName, pHashes);
            }
            return (int)mh$.invokeExact(lpFileName, pHashes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddUsersToEncryptedFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddUsersToEncryptedFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD AddUsersToEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates)
     * }
     */
    public static FunctionDescriptor AddUsersToEncryptedFile$descriptor() {
        return AddUsersToEncryptedFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD AddUsersToEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates)
     * }
     */
    public static MethodHandle AddUsersToEncryptedFile$handle() {
        return AddUsersToEncryptedFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD AddUsersToEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates)
     * }
     */
    public static MemorySegment AddUsersToEncryptedFile$address() {
        return AddUsersToEncryptedFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD AddUsersToEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates)
     * }
     */
    public static int AddUsersToEncryptedFile(MemorySegment lpFileName, MemorySegment pEncryptionCertificates) {
        var mh$ = AddUsersToEncryptedFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddUsersToEncryptedFile", lpFileName, pEncryptionCertificates);
            }
            return (int)mh$.invokeExact(lpFileName, pEncryptionCertificates);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserFileEncryptionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetUserFileEncryptionKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKey(PENCRYPTION_CERTIFICATE pEncryptionCertificate)
     * }
     */
    public static FunctionDescriptor SetUserFileEncryptionKey$descriptor() {
        return SetUserFileEncryptionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKey(PENCRYPTION_CERTIFICATE pEncryptionCertificate)
     * }
     */
    public static MethodHandle SetUserFileEncryptionKey$handle() {
        return SetUserFileEncryptionKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKey(PENCRYPTION_CERTIFICATE pEncryptionCertificate)
     * }
     */
    public static MemorySegment SetUserFileEncryptionKey$address() {
        return SetUserFileEncryptionKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKey(PENCRYPTION_CERTIFICATE pEncryptionCertificate)
     * }
     */
    public static int SetUserFileEncryptionKey(MemorySegment pEncryptionCertificate) {
        var mh$ = SetUserFileEncryptionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserFileEncryptionKey", pEncryptionCertificate);
            }
            return (int)mh$.invokeExact(pEncryptionCertificate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserFileEncryptionKeyEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetUserFileEncryptionKeyEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKeyEx(PENCRYPTION_CERTIFICATE pEncryptionCertificate, DWORD dwCapabilities, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static FunctionDescriptor SetUserFileEncryptionKeyEx$descriptor() {
        return SetUserFileEncryptionKeyEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKeyEx(PENCRYPTION_CERTIFICATE pEncryptionCertificate, DWORD dwCapabilities, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MethodHandle SetUserFileEncryptionKeyEx$handle() {
        return SetUserFileEncryptionKeyEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKeyEx(PENCRYPTION_CERTIFICATE pEncryptionCertificate, DWORD dwCapabilities, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static MemorySegment SetUserFileEncryptionKeyEx$address() {
        return SetUserFileEncryptionKeyEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetUserFileEncryptionKeyEx(PENCRYPTION_CERTIFICATE pEncryptionCertificate, DWORD dwCapabilities, DWORD dwFlags, LPVOID pvReserved)
     * }
     */
    public static int SetUserFileEncryptionKeyEx(MemorySegment pEncryptionCertificate, int dwCapabilities, int dwFlags, MemorySegment pvReserved) {
        var mh$ = SetUserFileEncryptionKeyEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserFileEncryptionKeyEx", pEncryptionCertificate, dwCapabilities, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pEncryptionCertificate, dwCapabilities, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEncryptionCertificateHashList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FreeEncryptionCertificateHashList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeEncryptionCertificateHashList(PENCRYPTION_CERTIFICATE_HASH_LIST pUsers)
     * }
     */
    public static FunctionDescriptor FreeEncryptionCertificateHashList$descriptor() {
        return FreeEncryptionCertificateHashList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeEncryptionCertificateHashList(PENCRYPTION_CERTIFICATE_HASH_LIST pUsers)
     * }
     */
    public static MethodHandle FreeEncryptionCertificateHashList$handle() {
        return FreeEncryptionCertificateHashList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeEncryptionCertificateHashList(PENCRYPTION_CERTIFICATE_HASH_LIST pUsers)
     * }
     */
    public static MemorySegment FreeEncryptionCertificateHashList$address() {
        return FreeEncryptionCertificateHashList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeEncryptionCertificateHashList(PENCRYPTION_CERTIFICATE_HASH_LIST pUsers)
     * }
     */
    public static void FreeEncryptionCertificateHashList(MemorySegment pUsers) {
        var mh$ = FreeEncryptionCertificateHashList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEncryptionCertificateHashList", pUsers);
            }
            mh$.invokeExact(pUsers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncryptionDisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EncryptionDisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EncryptionDisable(LPCWSTR DirPath, BOOL Disable)
     * }
     */
    public static FunctionDescriptor EncryptionDisable$descriptor() {
        return EncryptionDisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EncryptionDisable(LPCWSTR DirPath, BOOL Disable)
     * }
     */
    public static MethodHandle EncryptionDisable$handle() {
        return EncryptionDisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EncryptionDisable(LPCWSTR DirPath, BOOL Disable)
     * }
     */
    public static MemorySegment EncryptionDisable$address() {
        return EncryptionDisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EncryptionDisable(LPCWSTR DirPath, BOOL Disable)
     * }
     */
    public static int EncryptionDisable(MemorySegment DirPath, int Disable) {
        var mh$ = EncryptionDisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncryptionDisable", DirPath, Disable);
            }
            return (int)mh$.invokeExact(DirPath, Disable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateEncryptionInfoFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DuplicateEncryptionInfoFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DuplicateEncryptionInfoFile(LPCWSTR SrcFileName, LPCWSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor DuplicateEncryptionInfoFile$descriptor() {
        return DuplicateEncryptionInfoFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DuplicateEncryptionInfoFile(LPCWSTR SrcFileName, LPCWSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle DuplicateEncryptionInfoFile$handle() {
        return DuplicateEncryptionInfoFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DuplicateEncryptionInfoFile(LPCWSTR SrcFileName, LPCWSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment DuplicateEncryptionInfoFile$address() {
        return DuplicateEncryptionInfoFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DuplicateEncryptionInfoFile(LPCWSTR SrcFileName, LPCWSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int DuplicateEncryptionInfoFile(MemorySegment SrcFileName, MemorySegment DstFileName, int dwCreationDistribution, int dwAttributes, MemorySegment lpSecurityAttributes) {
        var mh$ = DuplicateEncryptionInfoFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateEncryptionInfoFile", SrcFileName, DstFileName, dwCreationDistribution, dwAttributes, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(SrcFileName, DstFileName, dwCreationDistribution, dwAttributes, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEncryptedFileMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEncryptedFileMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetEncryptedFileMetadata(LPCWSTR lpFileName, PDWORD pcbMetadata, PBYTE *ppbMetadata)
     * }
     */
    public static FunctionDescriptor GetEncryptedFileMetadata$descriptor() {
        return GetEncryptedFileMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetEncryptedFileMetadata(LPCWSTR lpFileName, PDWORD pcbMetadata, PBYTE *ppbMetadata)
     * }
     */
    public static MethodHandle GetEncryptedFileMetadata$handle() {
        return GetEncryptedFileMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetEncryptedFileMetadata(LPCWSTR lpFileName, PDWORD pcbMetadata, PBYTE *ppbMetadata)
     * }
     */
    public static MemorySegment GetEncryptedFileMetadata$address() {
        return GetEncryptedFileMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetEncryptedFileMetadata(LPCWSTR lpFileName, PDWORD pcbMetadata, PBYTE *ppbMetadata)
     * }
     */
    public static int GetEncryptedFileMetadata(MemorySegment lpFileName, MemorySegment pcbMetadata, MemorySegment ppbMetadata) {
        var mh$ = GetEncryptedFileMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEncryptedFileMetadata", lpFileName, pcbMetadata, ppbMetadata);
            }
            return (int)mh$.invokeExact(lpFileName, pcbMetadata, ppbMetadata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEncryptedFileMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetEncryptedFileMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetEncryptedFileMetadata(LPCWSTR lpFileName, PBYTE pbOldMetadata, PBYTE pbNewMetadata, PENCRYPTION_CERTIFICATE_HASH pOwnerHash, DWORD dwOperation, PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded)
     * }
     */
    public static FunctionDescriptor SetEncryptedFileMetadata$descriptor() {
        return SetEncryptedFileMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetEncryptedFileMetadata(LPCWSTR lpFileName, PBYTE pbOldMetadata, PBYTE pbNewMetadata, PENCRYPTION_CERTIFICATE_HASH pOwnerHash, DWORD dwOperation, PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded)
     * }
     */
    public static MethodHandle SetEncryptedFileMetadata$handle() {
        return SetEncryptedFileMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetEncryptedFileMetadata(LPCWSTR lpFileName, PBYTE pbOldMetadata, PBYTE pbNewMetadata, PENCRYPTION_CERTIFICATE_HASH pOwnerHash, DWORD dwOperation, PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded)
     * }
     */
    public static MemorySegment SetEncryptedFileMetadata$address() {
        return SetEncryptedFileMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetEncryptedFileMetadata(LPCWSTR lpFileName, PBYTE pbOldMetadata, PBYTE pbNewMetadata, PENCRYPTION_CERTIFICATE_HASH pOwnerHash, DWORD dwOperation, PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded)
     * }
     */
    public static int SetEncryptedFileMetadata(MemorySegment lpFileName, MemorySegment pbOldMetadata, MemorySegment pbNewMetadata, MemorySegment pOwnerHash, int dwOperation, MemorySegment pCertificatesAdded) {
        var mh$ = SetEncryptedFileMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEncryptedFileMetadata", lpFileName, pbOldMetadata, pbNewMetadata, pOwnerHash, dwOperation, pCertificatesAdded);
            }
            return (int)mh$.invokeExact(lpFileName, pbOldMetadata, pbNewMetadata, pOwnerHash, dwOperation, pCertificatesAdded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEncryptedFileMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FreeEncryptedFileMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeEncryptedFileMetadata(PBYTE pbMetadata)
     * }
     */
    public static FunctionDescriptor FreeEncryptedFileMetadata$descriptor() {
        return FreeEncryptedFileMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeEncryptedFileMetadata(PBYTE pbMetadata)
     * }
     */
    public static MethodHandle FreeEncryptedFileMetadata$handle() {
        return FreeEncryptedFileMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeEncryptedFileMetadata(PBYTE pbMetadata)
     * }
     */
    public static MemorySegment FreeEncryptedFileMetadata$address() {
        return FreeEncryptedFileMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeEncryptedFileMetadata(PBYTE pbMetadata)
     * }
     */
    public static void FreeEncryptedFileMetadata(MemorySegment pbMetadata) {
        var mh$ = FreeEncryptedFileMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEncryptedFileMetadata", pbMetadata);
            }
            mh$.invokeExact(pbMetadata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     RPC_NS_HANDLE LookupContext;
     *     RPC_BINDING_HANDLE ProposedHandle;
     *     RPC_BINDING_VECTOR *Bindings;
     * } *PRPC_IMPORT_CONTEXT_P
     * }
     */
    public static final AddressLayout PRPC_IMPORT_CONTEXT_P = winapi.C_POINTER;

    private static class I_RpcNsGetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("I_RpcNsGetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsGetBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static FunctionDescriptor I_RpcNsGetBuffer$descriptor() {
        return I_RpcNsGetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsGetBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static MethodHandle I_RpcNsGetBuffer$handle() {
        return I_RpcNsGetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsGetBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static MemorySegment I_RpcNsGetBuffer$address() {
        return I_RpcNsGetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsGetBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static int I_RpcNsGetBuffer(MemorySegment Message) {
        var mh$ = I_RpcNsGetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcNsGetBuffer", Message);
            }
            return (int)mh$.invokeExact(Message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcNsSendReceive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("I_RpcNsSendReceive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsSendReceive(PRPC_MESSAGE Message, RPC_BINDING_HANDLE *Handle)
     * }
     */
    public static FunctionDescriptor I_RpcNsSendReceive$descriptor() {
        return I_RpcNsSendReceive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsSendReceive(PRPC_MESSAGE Message, RPC_BINDING_HANDLE *Handle)
     * }
     */
    public static MethodHandle I_RpcNsSendReceive$handle() {
        return I_RpcNsSendReceive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsSendReceive(PRPC_MESSAGE Message, RPC_BINDING_HANDLE *Handle)
     * }
     */
    public static MemorySegment I_RpcNsSendReceive$address() {
        return I_RpcNsSendReceive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_RpcNsSendReceive(PRPC_MESSAGE Message, RPC_BINDING_HANDLE *Handle)
     * }
     */
    public static int I_RpcNsSendReceive(MemorySegment Message, MemorySegment Handle) {
        var mh$ = I_RpcNsSendReceive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcNsSendReceive", Message, Handle);
            }
            return (int)mh$.invokeExact(Message, Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcNsRaiseException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("I_RpcNsRaiseException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void I_RpcNsRaiseException(PRPC_MESSAGE Message, RPC_STATUS Status)
     * }
     */
    public static FunctionDescriptor I_RpcNsRaiseException$descriptor() {
        return I_RpcNsRaiseException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void I_RpcNsRaiseException(PRPC_MESSAGE Message, RPC_STATUS Status)
     * }
     */
    public static MethodHandle I_RpcNsRaiseException$handle() {
        return I_RpcNsRaiseException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void I_RpcNsRaiseException(PRPC_MESSAGE Message, RPC_STATUS Status)
     * }
     */
    public static MemorySegment I_RpcNsRaiseException$address() {
        return I_RpcNsRaiseException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void I_RpcNsRaiseException(PRPC_MESSAGE Message, RPC_STATUS Status)
     * }
     */
    public static void I_RpcNsRaiseException(MemorySegment Message, int Status) {
        var mh$ = I_RpcNsRaiseException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcNsRaiseException", Message, Status);
            }
            mh$.invokeExact(Message, Status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcReBindBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("I_RpcReBindBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcReBindBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static FunctionDescriptor I_RpcReBindBuffer$descriptor() {
        return I_RpcReBindBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcReBindBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static MethodHandle I_RpcReBindBuffer$handle() {
        return I_RpcReBindBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcReBindBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static MemorySegment I_RpcReBindBuffer$address() {
        return I_RpcReBindBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_RpcReBindBuffer(PRPC_MESSAGE Message)
     * }
     */
    public static int I_RpcReBindBuffer(MemorySegment Message) {
        var mh$ = I_RpcReBindBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcReBindBuffer", Message);
            }
            return (int)mh$.invokeExact(Message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_NsServerBindSearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("I_NsServerBindSearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsServerBindSearch()
     * }
     */
    public static FunctionDescriptor I_NsServerBindSearch$descriptor() {
        return I_NsServerBindSearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsServerBindSearch()
     * }
     */
    public static MethodHandle I_NsServerBindSearch$handle() {
        return I_NsServerBindSearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsServerBindSearch()
     * }
     */
    public static MemorySegment I_NsServerBindSearch$address() {
        return I_NsServerBindSearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_NsServerBindSearch()
     * }
     */
    public static int I_NsServerBindSearch() {
        var mh$ = I_NsServerBindSearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_NsServerBindSearch");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_NsClientBindSearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("I_NsClientBindSearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsClientBindSearch()
     * }
     */
    public static FunctionDescriptor I_NsClientBindSearch$descriptor() {
        return I_NsClientBindSearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsClientBindSearch()
     * }
     */
    public static MethodHandle I_NsClientBindSearch$handle() {
        return I_NsClientBindSearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS I_NsClientBindSearch()
     * }
     */
    public static MemorySegment I_NsClientBindSearch$address() {
        return I_NsClientBindSearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS I_NsClientBindSearch()
     * }
     */
    public static int I_NsClientBindSearch() {
        var mh$ = I_NsClientBindSearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_NsClientBindSearch");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_NsClientBindDone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = winapi.findOrThrow("I_NsClientBindDone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void I_NsClientBindDone()
     * }
     */
    public static FunctionDescriptor I_NsClientBindDone$descriptor() {
        return I_NsClientBindDone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void I_NsClientBindDone()
     * }
     */
    public static MethodHandle I_NsClientBindDone$handle() {
        return I_NsClientBindDone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void I_NsClientBindDone()
     * }
     */
    public static MemorySegment I_NsClientBindDone$address() {
        return I_NsClientBindDone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void I_NsClientBindDone()
     * }
     */
    public static void I_NsClientBindDone() {
        var mh$ = I_NsClientBindDone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_NsClientBindDone");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char byte
     * }
     */
    public static final OfByte byte_ = winapi.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef byte cs_byte
     * }
     */
    public static final OfByte cs_byte = winapi.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char boolean
     * }
     */
    public static final OfByte boolean_ = winapi.C_CHAR;

    private static class MIDL_user_allocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("MIDL_user_allocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *MIDL_user_allocate(size_t size)
     * }
     */
    public static FunctionDescriptor MIDL_user_allocate$descriptor() {
        return MIDL_user_allocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *MIDL_user_allocate(size_t size)
     * }
     */
    public static MethodHandle MIDL_user_allocate$handle() {
        return MIDL_user_allocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *MIDL_user_allocate(size_t size)
     * }
     */
    public static MemorySegment MIDL_user_allocate$address() {
        return MIDL_user_allocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *MIDL_user_allocate(size_t size)
     * }
     */
    public static MemorySegment MIDL_user_allocate(long size) {
        var mh$ = MIDL_user_allocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MIDL_user_allocate", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MIDL_user_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("MIDL_user_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MIDL_user_free(void *)
     * }
     */
    public static FunctionDescriptor MIDL_user_free$descriptor() {
        return MIDL_user_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MIDL_user_free(void *)
     * }
     */
    public static MethodHandle MIDL_user_free$handle() {
        return MIDL_user_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void MIDL_user_free(void *)
     * }
     */
    public static MemorySegment MIDL_user_free$address() {
        return MIDL_user_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void MIDL_user_free(void *)
     * }
     */
    public static void MIDL_user_free(MemorySegment x0) {
        var mh$ = MIDL_user_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MIDL_user_free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcDefaultAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("I_RpcDefaultAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *I_RpcDefaultAllocate(handle_t bh, size_t size, void *(*RealAlloc)(size_t))
     * }
     */
    public static FunctionDescriptor I_RpcDefaultAllocate$descriptor() {
        return I_RpcDefaultAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *I_RpcDefaultAllocate(handle_t bh, size_t size, void *(*RealAlloc)(size_t))
     * }
     */
    public static MethodHandle I_RpcDefaultAllocate$handle() {
        return I_RpcDefaultAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *I_RpcDefaultAllocate(handle_t bh, size_t size, void *(*RealAlloc)(size_t))
     * }
     */
    public static MemorySegment I_RpcDefaultAllocate$address() {
        return I_RpcDefaultAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *I_RpcDefaultAllocate(handle_t bh, size_t size, void *(*RealAlloc)(size_t))
     * }
     */
    public static MemorySegment I_RpcDefaultAllocate(MemorySegment bh, long size, MemorySegment RealAlloc) {
        var mh$ = I_RpcDefaultAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcDefaultAllocate", bh, size, RealAlloc);
            }
            return (MemorySegment)mh$.invokeExact(bh, size, RealAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcDefaultFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("I_RpcDefaultFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void I_RpcDefaultFree(handle_t bh, void *, void (*RealFree)(void *))
     * }
     */
    public static FunctionDescriptor I_RpcDefaultFree$descriptor() {
        return I_RpcDefaultFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void I_RpcDefaultFree(handle_t bh, void *, void (*RealFree)(void *))
     * }
     */
    public static MethodHandle I_RpcDefaultFree$handle() {
        return I_RpcDefaultFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void I_RpcDefaultFree(handle_t bh, void *, void (*RealFree)(void *))
     * }
     */
    public static MemorySegment I_RpcDefaultFree$address() {
        return I_RpcDefaultFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void I_RpcDefaultFree(handle_t bh, void *, void (*RealFree)(void *))
     * }
     */
    public static void I_RpcDefaultFree(MemorySegment bh, MemorySegment x1, MemorySegment RealFree) {
        var mh$ = I_RpcDefaultFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcDefaultFree", bh, x1, RealFree);
            }
            mh$.invokeExact(bh, x1, RealFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *NDR_CCONTEXT
     * }
     */
    public static final AddressLayout NDR_CCONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NDR_SCONTEXT {
     *     void *pad[2];
     *     void *userContext;
     * } *NDR_SCONTEXT
     * }
     */
    public static final AddressLayout NDR_SCONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCONTEXT_QUEUE {
     *     unsigned long NumberOfObjects;
     *     NDR_SCONTEXT *ArrayOfObjects;
     * } *PSCONTEXT_QUEUE
     * }
     */
    public static final AddressLayout PSCONTEXT_QUEUE = winapi.C_POINTER;

    private static class NDRCContextBinding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRCContextBinding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_BINDING_HANDLE NDRCContextBinding(NDR_CCONTEXT CContext)
     * }
     */
    public static FunctionDescriptor NDRCContextBinding$descriptor() {
        return NDRCContextBinding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_BINDING_HANDLE NDRCContextBinding(NDR_CCONTEXT CContext)
     * }
     */
    public static MethodHandle NDRCContextBinding$handle() {
        return NDRCContextBinding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_BINDING_HANDLE NDRCContextBinding(NDR_CCONTEXT CContext)
     * }
     */
    public static MemorySegment NDRCContextBinding$address() {
        return NDRCContextBinding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_BINDING_HANDLE NDRCContextBinding(NDR_CCONTEXT CContext)
     * }
     */
    public static MemorySegment NDRCContextBinding(MemorySegment CContext) {
        var mh$ = NDRCContextBinding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRCContextBinding", CContext);
            }
            return (MemorySegment)mh$.invokeExact(CContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRCContextMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRCContextMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRCContextMarshall(NDR_CCONTEXT CContext, void *pBuff)
     * }
     */
    public static FunctionDescriptor NDRCContextMarshall$descriptor() {
        return NDRCContextMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRCContextMarshall(NDR_CCONTEXT CContext, void *pBuff)
     * }
     */
    public static MethodHandle NDRCContextMarshall$handle() {
        return NDRCContextMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRCContextMarshall(NDR_CCONTEXT CContext, void *pBuff)
     * }
     */
    public static MemorySegment NDRCContextMarshall$address() {
        return NDRCContextMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRCContextMarshall(NDR_CCONTEXT CContext, void *pBuff)
     * }
     */
    public static void NDRCContextMarshall(MemorySegment CContext, MemorySegment pBuff) {
        var mh$ = NDRCContextMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRCContextMarshall", CContext, pBuff);
            }
            mh$.invokeExact(CContext, pBuff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRCContextUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRCContextUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static FunctionDescriptor NDRCContextUnmarshall$descriptor() {
        return NDRCContextUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MethodHandle NDRCContextUnmarshall$handle() {
        return NDRCContextUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRCContextUnmarshall$address() {
        return NDRCContextUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRCContextUnmarshall(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static void NDRCContextUnmarshall(MemorySegment pCContext, MemorySegment hBinding, MemorySegment pBuff, int DataRepresentation) {
        var mh$ = NDRCContextUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRCContextUnmarshall", pCContext, hBinding, pBuff, DataRepresentation);
            }
            mh$.invokeExact(pCContext, hBinding, pBuff, DataRepresentation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRCContextUnmarshall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRCContextUnmarshall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall2(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static FunctionDescriptor NDRCContextUnmarshall2$descriptor() {
        return NDRCContextUnmarshall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall2(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MethodHandle NDRCContextUnmarshall2$handle() {
        return NDRCContextUnmarshall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRCContextUnmarshall2(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRCContextUnmarshall2$address() {
        return NDRCContextUnmarshall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRCContextUnmarshall2(NDR_CCONTEXT *pCContext, RPC_BINDING_HANDLE hBinding, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static void NDRCContextUnmarshall2(MemorySegment pCContext, MemorySegment hBinding, MemorySegment pBuff, int DataRepresentation) {
        var mh$ = NDRCContextUnmarshall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRCContextUnmarshall2", pCContext, hBinding, pBuff, DataRepresentation);
            }
            mh$.invokeExact(pCContext, hBinding, pBuff, DataRepresentation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRSContextMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRSContextMarshall(NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static FunctionDescriptor NDRSContextMarshall$descriptor() {
        return NDRSContextMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRSContextMarshall(NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static MethodHandle NDRSContextMarshall$handle() {
        return NDRSContextMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRSContextMarshall(NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static MemorySegment NDRSContextMarshall$address() {
        return NDRSContextMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRSContextMarshall(NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static void NDRSContextMarshall(MemorySegment CContext, MemorySegment pBuff, MemorySegment userRunDownIn) {
        var mh$ = NDRSContextMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextMarshall", CContext, pBuff, userRunDownIn);
            }
            mh$.invokeExact(CContext, pBuff, userRunDownIn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRSContextUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall(void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static FunctionDescriptor NDRSContextUnmarshall$descriptor() {
        return NDRSContextUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall(void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MethodHandle NDRSContextUnmarshall$handle() {
        return NDRSContextUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall(void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRSContextUnmarshall$address() {
        return NDRSContextUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall(void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRSContextUnmarshall(MemorySegment pBuff, int DataRepresentation) {
        var mh$ = NDRSContextUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextUnmarshall", pBuff, DataRepresentation);
            }
            return (MemorySegment)mh$.invokeExact(pBuff, DataRepresentation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextMarshallEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRSContextMarshallEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRSContextMarshallEx(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static FunctionDescriptor NDRSContextMarshallEx$descriptor() {
        return NDRSContextMarshallEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRSContextMarshallEx(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static MethodHandle NDRSContextMarshallEx$handle() {
        return NDRSContextMarshallEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRSContextMarshallEx(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static MemorySegment NDRSContextMarshallEx$address() {
        return NDRSContextMarshallEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRSContextMarshallEx(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn)
     * }
     */
    public static void NDRSContextMarshallEx(MemorySegment BindingHandle, MemorySegment CContext, MemorySegment pBuff, MemorySegment userRunDownIn) {
        var mh$ = NDRSContextMarshallEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextMarshallEx", BindingHandle, CContext, pBuff, userRunDownIn);
            }
            mh$.invokeExact(BindingHandle, CContext, pBuff, userRunDownIn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextMarshall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRSContextMarshall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NDRSContextMarshall2(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static FunctionDescriptor NDRSContextMarshall2$descriptor() {
        return NDRSContextMarshall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NDRSContextMarshall2(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MethodHandle NDRSContextMarshall2$handle() {
        return NDRSContextMarshall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NDRSContextMarshall2(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MemorySegment NDRSContextMarshall2$address() {
        return NDRSContextMarshall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NDRSContextMarshall2(RPC_BINDING_HANDLE BindingHandle, NDR_SCONTEXT CContext, void *pBuff, NDR_RUNDOWN userRunDownIn, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static void NDRSContextMarshall2(MemorySegment BindingHandle, MemorySegment CContext, MemorySegment pBuff, MemorySegment userRunDownIn, MemorySegment CtxGuard, int Flags) {
        var mh$ = NDRSContextMarshall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextMarshall2", BindingHandle, CContext, pBuff, userRunDownIn, CtxGuard, Flags);
            }
            mh$.invokeExact(BindingHandle, CContext, pBuff, userRunDownIn, CtxGuard, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextUnmarshallEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRSContextUnmarshallEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshallEx(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static FunctionDescriptor NDRSContextUnmarshallEx$descriptor() {
        return NDRSContextUnmarshallEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshallEx(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MethodHandle NDRSContextUnmarshallEx$handle() {
        return NDRSContextUnmarshallEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshallEx(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRSContextUnmarshallEx$address() {
        return NDRSContextUnmarshallEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshallEx(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation)
     * }
     */
    public static MemorySegment NDRSContextUnmarshallEx(MemorySegment BindingHandle, MemorySegment pBuff, int DataRepresentation) {
        var mh$ = NDRSContextUnmarshallEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextUnmarshallEx", BindingHandle, pBuff, DataRepresentation);
            }
            return (MemorySegment)mh$.invokeExact(BindingHandle, pBuff, DataRepresentation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NDRSContextUnmarshall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NDRSContextUnmarshall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall2(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static FunctionDescriptor NDRSContextUnmarshall2$descriptor() {
        return NDRSContextUnmarshall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall2(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MethodHandle NDRSContextUnmarshall2$handle() {
        return NDRSContextUnmarshall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall2(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MemorySegment NDRSContextUnmarshall2$address() {
        return NDRSContextUnmarshall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NDR_SCONTEXT NDRSContextUnmarshall2(RPC_BINDING_HANDLE BindingHandle, void *pBuff, unsigned long DataRepresentation, void *CtxGuard, unsigned long Flags)
     * }
     */
    public static MemorySegment NDRSContextUnmarshall2(MemorySegment BindingHandle, MemorySegment pBuff, int DataRepresentation, MemorySegment CtxGuard, int Flags) {
        var mh$ = NDRSContextUnmarshall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NDRSContextUnmarshall2", BindingHandle, pBuff, DataRepresentation, CtxGuard, Flags);
            }
            return (MemorySegment)mh$.invokeExact(BindingHandle, pBuff, DataRepresentation, CtxGuard, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsDestroyClientContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSsDestroyClientContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcSsDestroyClientContext(void **ContextHandle)
     * }
     */
    public static FunctionDescriptor RpcSsDestroyClientContext$descriptor() {
        return RpcSsDestroyClientContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcSsDestroyClientContext(void **ContextHandle)
     * }
     */
    public static MethodHandle RpcSsDestroyClientContext$handle() {
        return RpcSsDestroyClientContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcSsDestroyClientContext(void **ContextHandle)
     * }
     */
    public static MemorySegment RpcSsDestroyClientContext$address() {
        return RpcSsDestroyClientContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcSsDestroyClientContext(void **ContextHandle)
     * }
     */
    public static void RpcSsDestroyClientContext(MemorySegment ContextHandle) {
        var mh$ = RpcSsDestroyClientContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsDestroyClientContext", ContextHandle);
            }
            mh$.invokeExact(ContextHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long error_status_t
     * }
     */
    public static final OfInt error_status_t = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char *RPC_BUFPTR
     * }
     */
    public static final AddressLayout RPC_BUFPTR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long RPC_LENGTH
     * }
     */
    public static final OfInt RPC_LENGTH = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef const unsigned char *PFORMAT_STRING
     * }
     */
    public static final AddressLayout PFORMAT_STRING = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     long Dimension;
     *     unsigned long *BufferConformanceMark;
     *     unsigned long *BufferVarianceMark;
     *     unsigned long *MaxCountArray;
     *     unsigned long *OffsetArray;
     *     unsigned long *ActualCountArray;
     * } *PARRAY_INFO
     * }
     */
    public static final AddressLayout PARRAY_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NDR_ASYNC_MESSAGE *PNDR_ASYNC_MESSAGE
     * }
     */
    public static final AddressLayout PNDR_ASYNC_MESSAGE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NDR_CORRELATION_INFO *PNDR_CORRELATION_INFO
     * }
     */
    public static final AddressLayout PNDR_CORRELATION_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MIDL_SYNTAX_INFO *PMIDL_SYNTAX_INFO
     * }
     */
    public static final AddressLayout PMIDL_SYNTAX_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MIDL_STUB_MESSAGE {
     *     PRPC_MESSAGE RpcMsg;
     *     unsigned char *Buffer;
     *     unsigned char *BufferStart;
     *     unsigned char *BufferEnd;
     *     unsigned char *BufferMark;
     *     unsigned long BufferLength;
     *     unsigned long MemorySize;
     *     unsigned char *Memory;
     *     unsigned char IsClient;
     *     unsigned char Pad;
     *     unsigned short uFlags2;
     *     int ReuseBuffer;
     *     struct NDR_ALLOC_ALL_NODES_CONTEXT *pAllocAllNodesContext;
     *     struct NDR_POINTER_QUEUE_STATE *pPointerQueueState;
     *     int IgnoreEmbeddedPointers;
     *     unsigned char *PointerBufferMark;
     *     unsigned char CorrDespIncrement;
     *     unsigned char uFlags;
     *     unsigned short UniquePtrCount;
     *     ULONG_PTR MaxCount;
     *     unsigned long Offset;
     *     unsigned long ActualCount;
     *     void *(*pfnAllocate)(size_t) __attribute__((stdcall));
     *     void (*pfnFree)(void *) __attribute__((stdcall));
     *     unsigned char *StackTop;
     *     unsigned char *pPresentedType;
     *     unsigned char *pTransmitType;
     *     handle_t SavedHandle;
     *     const struct _MIDL_STUB_DESC *StubDesc;
     *     struct _FULL_PTR_XLAT_TABLES *FullPtrXlatTables;
     *     unsigned long FullPtrRefId;
     *     unsigned long PointerLength;
     *     int fInDontFree : 1;
     *     int fDontCallFreeInst : 1;
     *     int fUnused1 : 1;
     *     int fHasReturn : 1;
     *     int fHasExtensions : 1;
     *     int fHasNewCorrDesc : 1;
     *     int fIsIn : 1;
     *     int fIsOut : 1;
     *     int fIsOicf : 1;
     *     int fBufferValid : 1;
     *     int fHasMemoryValidateCallback : 1;
     *     int fInFree : 1;
     *     int fNeedMCCP : 1;
     *     int fUnused2 : 3;
     *     int fUnused3 : 16;
     *     unsigned long dwDestContext;
     *     void *pvDestContext;
     *     NDR_SCONTEXT *SavedContextHandles;
     *     long ParamNumber;
     *     struct IRpcChannelBuffer *pRpcChannelBuffer;
     *     PARRAY_INFO pArrayInfo;
     *     unsigned long *SizePtrCountArray;
     *     unsigned long *SizePtrOffsetArray;
     *     unsigned long *SizePtrLengthArray;
     *     void *pArgQueue;
     *     unsigned long dwStubPhase;
     *     void *LowStackMark;
     *     PNDR_ASYNC_MESSAGE pAsyncMsg;
     *     PNDR_CORRELATION_INFO pCorrInfo;
     *     unsigned char *pCorrMemory;
     *     void *pMemoryList;
     *     INT_PTR pCSInfo;
     *     unsigned char *ConformanceMark;
     *     unsigned char *VarianceMark;
     *     INT_PTR Unused;
     *     struct _NDR_PROC_CONTEXT *pContext;
     *     void *ContextHandleHash;
     *     void *pUserMarshalList;
     *     unsigned char *pFullPtrFormat;
     *     INT_PTR Reserved51_4;
     *     INT_PTR Reserved51_5;
     * } *PMIDL_STUB_MESSAGE
     * }
     */
    public static final AddressLayout PMIDL_STUB_MESSAGE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GENERIC_BINDING_ROUTINE_PAIR {
     *     GENERIC_BINDING_ROUTINE pfnBind;
     *     GENERIC_UNBIND_ROUTINE pfnUnbind;
     * } *PGENERIC_BINDING_ROUTINE_PAIR
     * }
     */
    public static final AddressLayout PGENERIC_BINDING_ROUTINE_PAIR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct __GENERIC_BINDING_INFO {
     *     void *pObj;
     *     unsigned int Size;
     *     GENERIC_BINDING_ROUTINE pfnBind;
     *     GENERIC_UNBIND_ROUTINE pfnUnbind;
     * } *PGENERIC_BINDING_INFO
     * }
     */
    public static final AddressLayout PGENERIC_BINDING_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _XMIT_ROUTINE_QUINTUPLE {
     *     XMIT_HELPER_ROUTINE pfnTranslateToXmit;
     *     XMIT_HELPER_ROUTINE pfnTranslateFromXmit;
     *     XMIT_HELPER_ROUTINE pfnFreeXmit;
     *     XMIT_HELPER_ROUTINE pfnFreeInst;
     * } *PXMIT_ROUTINE_QUINTUPLE
     * }
     */
    public static final AddressLayout PXMIT_ROUTINE_QUINTUPLE = winapi.C_POINTER;
    private static final int USER_MARSHAL_CB_BUFFER_SIZE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _USER_MARSHAL_CB_TYPE.USER_MARSHAL_CB_BUFFER_SIZE = 0
     * }
     */
    public static int USER_MARSHAL_CB_BUFFER_SIZE() {
        return USER_MARSHAL_CB_BUFFER_SIZE;
    }
    private static final int USER_MARSHAL_CB_MARSHALL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _USER_MARSHAL_CB_TYPE.USER_MARSHAL_CB_MARSHALL = 1
     * }
     */
    public static int USER_MARSHAL_CB_MARSHALL() {
        return USER_MARSHAL_CB_MARSHALL;
    }
    private static final int USER_MARSHAL_CB_UNMARSHALL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _USER_MARSHAL_CB_TYPE.USER_MARSHAL_CB_UNMARSHALL = 2
     * }
     */
    public static int USER_MARSHAL_CB_UNMARSHALL() {
        return USER_MARSHAL_CB_UNMARSHALL;
    }
    private static final int USER_MARSHAL_CB_FREE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _USER_MARSHAL_CB_TYPE.USER_MARSHAL_CB_FREE = 3
     * }
     */
    public static int USER_MARSHAL_CB_FREE() {
        return USER_MARSHAL_CB_FREE;
    }
    private static final int IDL_CS_NO_CONVERT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _IDL_CS_CONVERT.IDL_CS_NO_CONVERT = 0
     * }
     */
    public static int IDL_CS_NO_CONVERT() {
        return IDL_CS_NO_CONVERT;
    }
    private static final int IDL_CS_IN_PLACE_CONVERT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _IDL_CS_CONVERT.IDL_CS_IN_PLACE_CONVERT = 1
     * }
     */
    public static int IDL_CS_IN_PLACE_CONVERT() {
        return IDL_CS_IN_PLACE_CONVERT;
    }
    private static final int IDL_CS_NEW_BUFFER_CONVERT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _IDL_CS_CONVERT.IDL_CS_NEW_BUFFER_CONVERT = 2
     * }
     */
    public static int IDL_CS_NEW_BUFFER_CONVERT() {
        return IDL_CS_NEW_BUFFER_CONVERT;
    }

    private static class RpcCsGetTags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcCsGetTags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcCsGetTags(RPC_BINDING_HANDLE hBinding, int fServerSide, unsigned long *pulSendingTag, unsigned long *pulDesiredReceivingTag, unsigned long *pulReceivingTag, error_status_t *pStatus)
     * }
     */
    public static FunctionDescriptor RpcCsGetTags$descriptor() {
        return RpcCsGetTags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcCsGetTags(RPC_BINDING_HANDLE hBinding, int fServerSide, unsigned long *pulSendingTag, unsigned long *pulDesiredReceivingTag, unsigned long *pulReceivingTag, error_status_t *pStatus)
     * }
     */
    public static MethodHandle RpcCsGetTags$handle() {
        return RpcCsGetTags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcCsGetTags(RPC_BINDING_HANDLE hBinding, int fServerSide, unsigned long *pulSendingTag, unsigned long *pulDesiredReceivingTag, unsigned long *pulReceivingTag, error_status_t *pStatus)
     * }
     */
    public static MemorySegment RpcCsGetTags$address() {
        return RpcCsGetTags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcCsGetTags(RPC_BINDING_HANDLE hBinding, int fServerSide, unsigned long *pulSendingTag, unsigned long *pulDesiredReceivingTag, unsigned long *pulReceivingTag, error_status_t *pStatus)
     * }
     */
    public static void RpcCsGetTags(MemorySegment hBinding, int fServerSide, MemorySegment pulSendingTag, MemorySegment pulDesiredReceivingTag, MemorySegment pulReceivingTag, MemorySegment pStatus) {
        var mh$ = RpcCsGetTags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcCsGetTags", hBinding, fServerSide, pulSendingTag, pulDesiredReceivingTag, pulReceivingTag, pStatus);
            }
            mh$.invokeExact(hBinding, fServerSide, pulSendingTag, pulDesiredReceivingTag, pulReceivingTag, pStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef const MIDL_STUB_DESC *PMIDL_STUB_DESC
     * }
     */
    public static final AddressLayout PMIDL_STUB_DESC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *PMIDL_XMIT_TYPE
     * }
     */
    public static final AddressLayout PMIDL_XMIT_TYPE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MIDL_METHOD_PROPERTY {
     *     unsigned long Id;
     *     ULONG_PTR Value;
     * } *PMIDL_METHOD_PROPERTY
     * }
     */
    public static final AddressLayout PMIDL_METHOD_PROPERTY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MIDL_METHOD_PROPERTY_MAP {
     *     unsigned long Count;
     *     const MIDL_METHOD_PROPERTY *Properties;
     * } *PMIDL_METHOD_PROPERTY_MAP
     * }
     */
    public static final AddressLayout PMIDL_METHOD_PROPERTY_MAP = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MIDL_SERVER_INFO_ {
     *     PMIDL_STUB_DESC pStubDesc;
     *     const SERVER_ROUTINE *DispatchTable;
     *     PFORMAT_STRING ProcString;
     *     const unsigned short *FmtStringOffset;
     *     const STUB_THUNK *ThunkTable;
     *     PRPC_SYNTAX_IDENTIFIER pTransferSyntax;
     *     ULONG_PTR nCount;
     *     PMIDL_SYNTAX_INFO pSyntaxInfo;
     * } *PMIDL_SERVER_INFO
     * }
     */
    public static final AddressLayout PMIDL_SERVER_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef MIDL_STUBLESS_PROXY_INFO *PMIDL_STUBLESS_PROXY_INFO
     * }
     */
    public static final AddressLayout PMIDL_STUBLESS_PROXY_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short *PARAM_OFFSETTABLE
     * }
     */
    public static final AddressLayout PARAM_OFFSETTABLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short *PPARAM_OFFSETTABLE
     * }
     */
    public static final AddressLayout PPARAM_OFFSETTABLE = winapi.C_POINTER;
    private static final int XLAT_SERVER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XLAT_SERVER = 1
     * }
     */
    public static int XLAT_SERVER() {
        return XLAT_SERVER;
    }
    private static final int XLAT_CLIENT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XLAT_CLIENT = 2
     * }
     */
    public static int XLAT_CLIENT() {
        return XLAT_CLIENT;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FULL_PTR_XLAT_TABLES {
     *     void *RefIdToPointer;
     *     void *PointerToRefId;
     *     unsigned long NextRefId;
     *     XLAT_SIDE XlatSide;
     * } *PFULL_PTR_XLAT_TABLES
     * }
     */
    public static final AddressLayout PFULL_PTR_XLAT_TABLES = winapi.C_POINTER;
    private static final int SYSTEM_HANDLE_FILE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_FILE = 0
     * }
     */
    public static int SYSTEM_HANDLE_FILE() {
        return SYSTEM_HANDLE_FILE;
    }
    private static final int SYSTEM_HANDLE_SEMAPHORE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_SEMAPHORE = 1
     * }
     */
    public static int SYSTEM_HANDLE_SEMAPHORE() {
        return SYSTEM_HANDLE_SEMAPHORE;
    }
    private static final int SYSTEM_HANDLE_EVENT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_EVENT = 2
     * }
     */
    public static int SYSTEM_HANDLE_EVENT() {
        return SYSTEM_HANDLE_EVENT;
    }
    private static final int SYSTEM_HANDLE_MUTEX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_MUTEX = 3
     * }
     */
    public static int SYSTEM_HANDLE_MUTEX() {
        return SYSTEM_HANDLE_MUTEX;
    }
    private static final int SYSTEM_HANDLE_PROCESS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_PROCESS = 4
     * }
     */
    public static int SYSTEM_HANDLE_PROCESS() {
        return SYSTEM_HANDLE_PROCESS;
    }
    private static final int SYSTEM_HANDLE_TOKEN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_TOKEN = 5
     * }
     */
    public static int SYSTEM_HANDLE_TOKEN() {
        return SYSTEM_HANDLE_TOKEN;
    }
    private static final int SYSTEM_HANDLE_SECTION = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_SECTION = 6
     * }
     */
    public static int SYSTEM_HANDLE_SECTION() {
        return SYSTEM_HANDLE_SECTION;
    }
    private static final int SYSTEM_HANDLE_REG_KEY = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_REG_KEY = 7
     * }
     */
    public static int SYSTEM_HANDLE_REG_KEY() {
        return SYSTEM_HANDLE_REG_KEY;
    }
    private static final int SYSTEM_HANDLE_THREAD = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_THREAD = 8
     * }
     */
    public static int SYSTEM_HANDLE_THREAD() {
        return SYSTEM_HANDLE_THREAD;
    }
    private static final int SYSTEM_HANDLE_COMPOSITION_OBJECT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_COMPOSITION_OBJECT = 9
     * }
     */
    public static int SYSTEM_HANDLE_COMPOSITION_OBJECT() {
        return SYSTEM_HANDLE_COMPOSITION_OBJECT;
    }
    private static final int SYSTEM_HANDLE_SOCKET = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_SOCKET = 10
     * }
     */
    public static int SYSTEM_HANDLE_SOCKET() {
        return SYSTEM_HANDLE_SOCKET;
    }
    private static final int SYSTEM_HANDLE_JOB = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_JOB = 11
     * }
     */
    public static int SYSTEM_HANDLE_JOB() {
        return SYSTEM_HANDLE_JOB;
    }
    private static final int SYSTEM_HANDLE_PIPE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_PIPE = 12
     * }
     */
    public static int SYSTEM_HANDLE_PIPE() {
        return SYSTEM_HANDLE_PIPE;
    }
    private static final int SYSTEM_HANDLE_MAX = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_MAX = 12
     * }
     */
    public static int SYSTEM_HANDLE_MAX() {
        return SYSTEM_HANDLE_MAX;
    }
    private static final int SYSTEM_HANDLE_INVALID = (int)255L;
    /**
     * {@snippet lang=c :
     * enum _system_handle_t.SYSTEM_HANDLE_INVALID = 255
     * }
     */
    public static int SYSTEM_HANDLE_INVALID() {
        return SYSTEM_HANDLE_INVALID;
    }
    private static final int MidlInterceptionInfoVersionOne = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MidlInterceptionInfoVersionOne = 1
     * }
     */
    public static int MidlInterceptionInfoVersionOne() {
        return MidlInterceptionInfoVersionOne;
    }
    private static final int MidlWinrtTypeSerializationInfoVersionOne = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MidlWinrtTypeSerializationInfoVersionOne = 1
     * }
     */
    public static int MidlWinrtTypeSerializationInfoVersionOne() {
        return MidlWinrtTypeSerializationInfoVersionOne;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _MIDL_INTERCEPTION_INFO {
     *     unsigned long Version;
     *     PFORMAT_STRING ProcString;
     *     const unsigned short *ProcFormatOffsetTable;
     *     unsigned long ProcCount;
     *     PFORMAT_STRING TypeString;
     * } *PMIDL_INTERCEPTION_INFO
     * }
     */
    public static final AddressLayout PMIDL_INTERCEPTION_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MIDL_WINRT_TYPE_SERIALIZATION_INFO {
     *     unsigned long Version;
     *     PFORMAT_STRING TypeFormatString;
     *     unsigned short FormatStringSize;
     *     unsigned short TypeOffset;
     *     PMIDL_STUB_DESC StubDesc;
     * } *PMIDL_WINRT_TYPE_SERIALIZATION_INFO
     * }
     */
    public static final AddressLayout PMIDL_WINRT_TYPE_SERIALIZATION_INFO = winapi.C_POINTER;

    private static class NdrClientGetSupportedSyntaxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrClientGetSupportedSyntaxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS NdrClientGetSupportedSyntaxes(RPC_CLIENT_INTERFACE *pInf, unsigned long *pCount, MIDL_SYNTAX_INFO **pArr)
     * }
     */
    public static FunctionDescriptor NdrClientGetSupportedSyntaxes$descriptor() {
        return NdrClientGetSupportedSyntaxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS NdrClientGetSupportedSyntaxes(RPC_CLIENT_INTERFACE *pInf, unsigned long *pCount, MIDL_SYNTAX_INFO **pArr)
     * }
     */
    public static MethodHandle NdrClientGetSupportedSyntaxes$handle() {
        return NdrClientGetSupportedSyntaxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS NdrClientGetSupportedSyntaxes(RPC_CLIENT_INTERFACE *pInf, unsigned long *pCount, MIDL_SYNTAX_INFO **pArr)
     * }
     */
    public static MemorySegment NdrClientGetSupportedSyntaxes$address() {
        return NdrClientGetSupportedSyntaxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS NdrClientGetSupportedSyntaxes(RPC_CLIENT_INTERFACE *pInf, unsigned long *pCount, MIDL_SYNTAX_INFO **pArr)
     * }
     */
    public static int NdrClientGetSupportedSyntaxes(MemorySegment pInf, MemorySegment pCount, MemorySegment pArr) {
        var mh$ = NdrClientGetSupportedSyntaxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrClientGetSupportedSyntaxes", pInf, pCount, pArr);
            }
            return (int)mh$.invokeExact(pInf, pCount, pArr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerGetSupportedSyntaxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerGetSupportedSyntaxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS NdrServerGetSupportedSyntaxes(RPC_SERVER_INTERFACE *pInf, unsigned long *pCount, MIDL_SYNTAX_INFO **pArr, unsigned long *pPreferSyntaxIndex)
     * }
     */
    public static FunctionDescriptor NdrServerGetSupportedSyntaxes$descriptor() {
        return NdrServerGetSupportedSyntaxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS NdrServerGetSupportedSyntaxes(RPC_SERVER_INTERFACE *pInf, unsigned long *pCount, MIDL_SYNTAX_INFO **pArr, unsigned long *pPreferSyntaxIndex)
     * }
     */
    public static MethodHandle NdrServerGetSupportedSyntaxes$handle() {
        return NdrServerGetSupportedSyntaxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS NdrServerGetSupportedSyntaxes(RPC_SERVER_INTERFACE *pInf, unsigned long *pCount, MIDL_SYNTAX_INFO **pArr, unsigned long *pPreferSyntaxIndex)
     * }
     */
    public static MemorySegment NdrServerGetSupportedSyntaxes$address() {
        return NdrServerGetSupportedSyntaxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS NdrServerGetSupportedSyntaxes(RPC_SERVER_INTERFACE *pInf, unsigned long *pCount, MIDL_SYNTAX_INFO **pArr, unsigned long *pPreferSyntaxIndex)
     * }
     */
    public static int NdrServerGetSupportedSyntaxes(MemorySegment pInf, MemorySegment pCount, MemorySegment pArr, MemorySegment pPreferSyntaxIndex) {
        var mh$ = NdrServerGetSupportedSyntaxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerGetSupportedSyntaxes", pInf, pCount, pArr, pPreferSyntaxIndex);
            }
            return (int)mh$.invokeExact(pInf, pCount, pArr, pPreferSyntaxIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrSimpleTypeMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrSimpleTypeMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrSimpleTypeMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, unsigned char FormatChar)
     * }
     */
    public static FunctionDescriptor NdrSimpleTypeMarshall$descriptor() {
        return NdrSimpleTypeMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrSimpleTypeMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, unsigned char FormatChar)
     * }
     */
    public static MethodHandle NdrSimpleTypeMarshall$handle() {
        return NdrSimpleTypeMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrSimpleTypeMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, unsigned char FormatChar)
     * }
     */
    public static MemorySegment NdrSimpleTypeMarshall$address() {
        return NdrSimpleTypeMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrSimpleTypeMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, unsigned char FormatChar)
     * }
     */
    public static void NdrSimpleTypeMarshall(MemorySegment pStubMsg, MemorySegment pMemory, byte FormatChar) {
        var mh$ = NdrSimpleTypeMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrSimpleTypeMarshall", pStubMsg, pMemory, FormatChar);
            }
            mh$.invokeExact(pStubMsg, pMemory, FormatChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrPointerMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrPointerMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrPointerMarshall$descriptor() {
        return NdrPointerMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrPointerMarshall$handle() {
        return NdrPointerMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrPointerMarshall$address() {
        return NdrPointerMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrPointerMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrPointerMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrPointerMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCsArrayMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCsArrayMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrCsArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrCsArrayMarshall$descriptor() {
        return NdrCsArrayMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrCsArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrCsArrayMarshall$handle() {
        return NdrCsArrayMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrCsArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrCsArrayMarshall$address() {
        return NdrCsArrayMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrCsArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrCsArrayMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrCsArrayMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCsArrayMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCsTagMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCsTagMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrCsTagMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrCsTagMarshall$descriptor() {
        return NdrCsTagMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrCsTagMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrCsTagMarshall$handle() {
        return NdrCsTagMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrCsTagMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrCsTagMarshall$address() {
        return NdrCsTagMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrCsTagMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrCsTagMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrCsTagMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCsTagMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrSimpleStructMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrSimpleStructMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrSimpleStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrSimpleStructMarshall$descriptor() {
        return NdrSimpleStructMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrSimpleStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrSimpleStructMarshall$handle() {
        return NdrSimpleStructMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrSimpleStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrSimpleStructMarshall$address() {
        return NdrSimpleStructMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrSimpleStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrSimpleStructMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrSimpleStructMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrSimpleStructMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantStructMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantStructMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantStructMarshall$descriptor() {
        return NdrConformantStructMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantStructMarshall$handle() {
        return NdrConformantStructMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantStructMarshall$address() {
        return NdrConformantStructMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantStructMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantStructMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantStructMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingStructMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingStructMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingStructMarshall$descriptor() {
        return NdrConformantVaryingStructMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantVaryingStructMarshall$handle() {
        return NdrConformantVaryingStructMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingStructMarshall$address() {
        return NdrConformantVaryingStructMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingStructMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantVaryingStructMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingStructMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexStructMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexStructMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrComplexStructMarshall$descriptor() {
        return NdrComplexStructMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrComplexStructMarshall$handle() {
        return NdrComplexStructMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexStructMarshall$address() {
        return NdrComplexStructMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrComplexStructMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexStructMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrComplexStructMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexStructMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrFixedArrayMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrFixedArrayMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrFixedArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrFixedArrayMarshall$descriptor() {
        return NdrFixedArrayMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrFixedArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrFixedArrayMarshall$handle() {
        return NdrFixedArrayMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrFixedArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrFixedArrayMarshall$address() {
        return NdrFixedArrayMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrFixedArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrFixedArrayMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrFixedArrayMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrFixedArrayMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantArrayMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantArrayMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantArrayMarshall$descriptor() {
        return NdrConformantArrayMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantArrayMarshall$handle() {
        return NdrConformantArrayMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantArrayMarshall$address() {
        return NdrConformantArrayMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantArrayMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantArrayMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantArrayMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingArrayMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingArrayMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingArrayMarshall$descriptor() {
        return NdrConformantVaryingArrayMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantVaryingArrayMarshall$handle() {
        return NdrConformantVaryingArrayMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingArrayMarshall$address() {
        return NdrConformantVaryingArrayMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingArrayMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantVaryingArrayMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingArrayMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrVaryingArrayMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrVaryingArrayMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrVaryingArrayMarshall$descriptor() {
        return NdrVaryingArrayMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrVaryingArrayMarshall$handle() {
        return NdrVaryingArrayMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrVaryingArrayMarshall$address() {
        return NdrVaryingArrayMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrVaryingArrayMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrVaryingArrayMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrVaryingArrayMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexArrayMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexArrayMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrComplexArrayMarshall$descriptor() {
        return NdrComplexArrayMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrComplexArrayMarshall$handle() {
        return NdrComplexArrayMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexArrayMarshall$address() {
        return NdrComplexArrayMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrComplexArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexArrayMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrComplexArrayMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexArrayMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNonConformantStringMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNonConformantStringMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrNonConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrNonConformantStringMarshall$descriptor() {
        return NdrNonConformantStringMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrNonConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrNonConformantStringMarshall$handle() {
        return NdrNonConformantStringMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrNonConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrNonConformantStringMarshall$address() {
        return NdrNonConformantStringMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrNonConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrNonConformantStringMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrNonConformantStringMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNonConformantStringMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantStringMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantStringMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantStringMarshall$descriptor() {
        return NdrConformantStringMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantStringMarshall$handle() {
        return NdrConformantStringMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantStringMarshall$address() {
        return NdrConformantStringMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantStringMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantStringMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantStringMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrEncapsulatedUnionMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrEncapsulatedUnionMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrEncapsulatedUnionMarshall$descriptor() {
        return NdrEncapsulatedUnionMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrEncapsulatedUnionMarshall$handle() {
        return NdrEncapsulatedUnionMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrEncapsulatedUnionMarshall$address() {
        return NdrEncapsulatedUnionMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrEncapsulatedUnionMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrEncapsulatedUnionMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrEncapsulatedUnionMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNonEncapsulatedUnionMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNonEncapsulatedUnionMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrNonEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrNonEncapsulatedUnionMarshall$descriptor() {
        return NdrNonEncapsulatedUnionMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrNonEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrNonEncapsulatedUnionMarshall$handle() {
        return NdrNonEncapsulatedUnionMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrNonEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrNonEncapsulatedUnionMarshall$address() {
        return NdrNonEncapsulatedUnionMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrNonEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrNonEncapsulatedUnionMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrNonEncapsulatedUnionMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNonEncapsulatedUnionMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrByteCountPointerMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrByteCountPointerMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrByteCountPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrByteCountPointerMarshall$descriptor() {
        return NdrByteCountPointerMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrByteCountPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrByteCountPointerMarshall$handle() {
        return NdrByteCountPointerMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrByteCountPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrByteCountPointerMarshall$address() {
        return NdrByteCountPointerMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrByteCountPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrByteCountPointerMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrByteCountPointerMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrByteCountPointerMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrXmitOrRepAsMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrXmitOrRepAsMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrXmitOrRepAsMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrXmitOrRepAsMarshall$descriptor() {
        return NdrXmitOrRepAsMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrXmitOrRepAsMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrXmitOrRepAsMarshall$handle() {
        return NdrXmitOrRepAsMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrXmitOrRepAsMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrXmitOrRepAsMarshall$address() {
        return NdrXmitOrRepAsMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrXmitOrRepAsMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrXmitOrRepAsMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrXmitOrRepAsMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrXmitOrRepAsMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrUserMarshalMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrUserMarshalMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrUserMarshalMarshall$descriptor() {
        return NdrUserMarshalMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrUserMarshalMarshall$handle() {
        return NdrUserMarshalMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrUserMarshalMarshall$address() {
        return NdrUserMarshalMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrUserMarshalMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrUserMarshalMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrUserMarshalMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrInterfacePointerMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrInterfacePointerMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrInterfacePointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrInterfacePointerMarshall$descriptor() {
        return NdrInterfacePointerMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrInterfacePointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrInterfacePointerMarshall$handle() {
        return NdrInterfacePointerMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrInterfacePointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrInterfacePointerMarshall$address() {
        return NdrInterfacePointerMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrInterfacePointerMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrInterfacePointerMarshall(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrInterfacePointerMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrInterfacePointerMarshall", pStubMsg, pMemory, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrClientContextMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrClientContextMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrClientContextMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_CCONTEXT ContextHandle, int fCheck)
     * }
     */
    public static FunctionDescriptor NdrClientContextMarshall$descriptor() {
        return NdrClientContextMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrClientContextMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_CCONTEXT ContextHandle, int fCheck)
     * }
     */
    public static MethodHandle NdrClientContextMarshall$handle() {
        return NdrClientContextMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrClientContextMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_CCONTEXT ContextHandle, int fCheck)
     * }
     */
    public static MemorySegment NdrClientContextMarshall$address() {
        return NdrClientContextMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrClientContextMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_CCONTEXT ContextHandle, int fCheck)
     * }
     */
    public static void NdrClientContextMarshall(MemorySegment pStubMsg, MemorySegment ContextHandle, int fCheck) {
        var mh$ = NdrClientContextMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrClientContextMarshall", pStubMsg, ContextHandle, fCheck);
            }
            mh$.invokeExact(pStubMsg, ContextHandle, fCheck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerContextMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerContextMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerContextMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_SCONTEXT ContextHandle, NDR_RUNDOWN RundownRoutine)
     * }
     */
    public static FunctionDescriptor NdrServerContextMarshall$descriptor() {
        return NdrServerContextMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerContextMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_SCONTEXT ContextHandle, NDR_RUNDOWN RundownRoutine)
     * }
     */
    public static MethodHandle NdrServerContextMarshall$handle() {
        return NdrServerContextMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerContextMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_SCONTEXT ContextHandle, NDR_RUNDOWN RundownRoutine)
     * }
     */
    public static MemorySegment NdrServerContextMarshall$address() {
        return NdrServerContextMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerContextMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_SCONTEXT ContextHandle, NDR_RUNDOWN RundownRoutine)
     * }
     */
    public static void NdrServerContextMarshall(MemorySegment pStubMsg, MemorySegment ContextHandle, MemorySegment RundownRoutine) {
        var mh$ = NdrServerContextMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerContextMarshall", pStubMsg, ContextHandle, RundownRoutine);
            }
            mh$.invokeExact(pStubMsg, ContextHandle, RundownRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerContextNewMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerContextNewMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerContextNewMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_SCONTEXT ContextHandle, NDR_RUNDOWN RundownRoutine, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrServerContextNewMarshall$descriptor() {
        return NdrServerContextNewMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerContextNewMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_SCONTEXT ContextHandle, NDR_RUNDOWN RundownRoutine, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrServerContextNewMarshall$handle() {
        return NdrServerContextNewMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerContextNewMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_SCONTEXT ContextHandle, NDR_RUNDOWN RundownRoutine, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrServerContextNewMarshall$address() {
        return NdrServerContextNewMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerContextNewMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_SCONTEXT ContextHandle, NDR_RUNDOWN RundownRoutine, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrServerContextNewMarshall(MemorySegment pStubMsg, MemorySegment ContextHandle, MemorySegment RundownRoutine, MemorySegment pFormat) {
        var mh$ = NdrServerContextNewMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerContextNewMarshall", pStubMsg, ContextHandle, RundownRoutine, pFormat);
            }
            mh$.invokeExact(pStubMsg, ContextHandle, RundownRoutine, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrSimpleTypeUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrSimpleTypeUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrSimpleTypeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, unsigned char FormatChar)
     * }
     */
    public static FunctionDescriptor NdrSimpleTypeUnmarshall$descriptor() {
        return NdrSimpleTypeUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrSimpleTypeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, unsigned char FormatChar)
     * }
     */
    public static MethodHandle NdrSimpleTypeUnmarshall$handle() {
        return NdrSimpleTypeUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrSimpleTypeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, unsigned char FormatChar)
     * }
     */
    public static MemorySegment NdrSimpleTypeUnmarshall$address() {
        return NdrSimpleTypeUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrSimpleTypeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, unsigned char FormatChar)
     * }
     */
    public static void NdrSimpleTypeUnmarshall(MemorySegment pStubMsg, MemorySegment pMemory, byte FormatChar) {
        var mh$ = NdrSimpleTypeUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrSimpleTypeUnmarshall", pStubMsg, pMemory, FormatChar);
            }
            mh$.invokeExact(pStubMsg, pMemory, FormatChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCsArrayUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCsArrayUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrCsArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrCsArrayUnmarshall$descriptor() {
        return NdrCsArrayUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrCsArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrCsArrayUnmarshall$handle() {
        return NdrCsArrayUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrCsArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrCsArrayUnmarshall$address() {
        return NdrCsArrayUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrCsArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrCsArrayUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrCsArrayUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCsArrayUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCsTagUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCsTagUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrCsTagUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrCsTagUnmarshall$descriptor() {
        return NdrCsTagUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrCsTagUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrCsTagUnmarshall$handle() {
        return NdrCsTagUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrCsTagUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrCsTagUnmarshall$address() {
        return NdrCsTagUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrCsTagUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrCsTagUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrCsTagUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCsTagUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrRangeUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrRangeUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrRangeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrRangeUnmarshall$descriptor() {
        return NdrRangeUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrRangeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrRangeUnmarshall$handle() {
        return NdrRangeUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrRangeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrRangeUnmarshall$address() {
        return NdrRangeUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrRangeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrRangeUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrRangeUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrRangeUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCorrelationInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCorrelationInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrCorrelationInitialize(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory, unsigned long CacheSize, unsigned long flags)
     * }
     */
    public static FunctionDescriptor NdrCorrelationInitialize$descriptor() {
        return NdrCorrelationInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrCorrelationInitialize(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory, unsigned long CacheSize, unsigned long flags)
     * }
     */
    public static MethodHandle NdrCorrelationInitialize$handle() {
        return NdrCorrelationInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrCorrelationInitialize(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory, unsigned long CacheSize, unsigned long flags)
     * }
     */
    public static MemorySegment NdrCorrelationInitialize$address() {
        return NdrCorrelationInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrCorrelationInitialize(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory, unsigned long CacheSize, unsigned long flags)
     * }
     */
    public static void NdrCorrelationInitialize(MemorySegment pStubMsg, MemorySegment pMemory, int CacheSize, int flags) {
        var mh$ = NdrCorrelationInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCorrelationInitialize", pStubMsg, pMemory, CacheSize, flags);
            }
            mh$.invokeExact(pStubMsg, pMemory, CacheSize, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCorrelationPass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCorrelationPass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrCorrelationPass(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static FunctionDescriptor NdrCorrelationPass$descriptor() {
        return NdrCorrelationPass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrCorrelationPass(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MethodHandle NdrCorrelationPass$handle() {
        return NdrCorrelationPass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrCorrelationPass(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MemorySegment NdrCorrelationPass$address() {
        return NdrCorrelationPass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrCorrelationPass(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static void NdrCorrelationPass(MemorySegment pStubMsg) {
        var mh$ = NdrCorrelationPass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCorrelationPass", pStubMsg);
            }
            mh$.invokeExact(pStubMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCorrelationFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCorrelationFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrCorrelationFree(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static FunctionDescriptor NdrCorrelationFree$descriptor() {
        return NdrCorrelationFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrCorrelationFree(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MethodHandle NdrCorrelationFree$handle() {
        return NdrCorrelationFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrCorrelationFree(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MemorySegment NdrCorrelationFree$address() {
        return NdrCorrelationFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrCorrelationFree(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static void NdrCorrelationFree(MemorySegment pStubMsg) {
        var mh$ = NdrCorrelationFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCorrelationFree", pStubMsg);
            }
            mh$.invokeExact(pStubMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrPointerUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrPointerUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrPointerUnmarshall$descriptor() {
        return NdrPointerUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrPointerUnmarshall$handle() {
        return NdrPointerUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrPointerUnmarshall$address() {
        return NdrPointerUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrPointerUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrPointerUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrPointerUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrSimpleStructUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrSimpleStructUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrSimpleStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrSimpleStructUnmarshall$descriptor() {
        return NdrSimpleStructUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrSimpleStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrSimpleStructUnmarshall$handle() {
        return NdrSimpleStructUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrSimpleStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrSimpleStructUnmarshall$address() {
        return NdrSimpleStructUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrSimpleStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrSimpleStructUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrSimpleStructUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrSimpleStructUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantStructUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantStructUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrConformantStructUnmarshall$descriptor() {
        return NdrConformantStructUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrConformantStructUnmarshall$handle() {
        return NdrConformantStructUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantStructUnmarshall$address() {
        return NdrConformantStructUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantStructUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrConformantStructUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantStructUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingStructUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingStructUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingStructUnmarshall$descriptor() {
        return NdrConformantVaryingStructUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrConformantVaryingStructUnmarshall$handle() {
        return NdrConformantVaryingStructUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantVaryingStructUnmarshall$address() {
        return NdrConformantVaryingStructUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantVaryingStructUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrConformantVaryingStructUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingStructUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexStructUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexStructUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrComplexStructUnmarshall$descriptor() {
        return NdrComplexStructUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrComplexStructUnmarshall$handle() {
        return NdrComplexStructUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrComplexStructUnmarshall$address() {
        return NdrComplexStructUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrComplexStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrComplexStructUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrComplexStructUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexStructUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrFixedArrayUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrFixedArrayUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrFixedArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrFixedArrayUnmarshall$descriptor() {
        return NdrFixedArrayUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrFixedArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrFixedArrayUnmarshall$handle() {
        return NdrFixedArrayUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrFixedArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrFixedArrayUnmarshall$address() {
        return NdrFixedArrayUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrFixedArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrFixedArrayUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrFixedArrayUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrFixedArrayUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantArrayUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantArrayUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrConformantArrayUnmarshall$descriptor() {
        return NdrConformantArrayUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrConformantArrayUnmarshall$handle() {
        return NdrConformantArrayUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantArrayUnmarshall$address() {
        return NdrConformantArrayUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantArrayUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrConformantArrayUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantArrayUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingArrayUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingArrayUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingArrayUnmarshall$descriptor() {
        return NdrConformantVaryingArrayUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrConformantVaryingArrayUnmarshall$handle() {
        return NdrConformantVaryingArrayUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantVaryingArrayUnmarshall$address() {
        return NdrConformantVaryingArrayUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantVaryingArrayUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrConformantVaryingArrayUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingArrayUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrVaryingArrayUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrVaryingArrayUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrVaryingArrayUnmarshall$descriptor() {
        return NdrVaryingArrayUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrVaryingArrayUnmarshall$handle() {
        return NdrVaryingArrayUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrVaryingArrayUnmarshall$address() {
        return NdrVaryingArrayUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrVaryingArrayUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrVaryingArrayUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrVaryingArrayUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexArrayUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexArrayUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrComplexArrayUnmarshall$descriptor() {
        return NdrComplexArrayUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrComplexArrayUnmarshall$handle() {
        return NdrComplexArrayUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrComplexArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrComplexArrayUnmarshall$address() {
        return NdrComplexArrayUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrComplexArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrComplexArrayUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrComplexArrayUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexArrayUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNonConformantStringUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNonConformantStringUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrNonConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrNonConformantStringUnmarshall$descriptor() {
        return NdrNonConformantStringUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrNonConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrNonConformantStringUnmarshall$handle() {
        return NdrNonConformantStringUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrNonConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrNonConformantStringUnmarshall$address() {
        return NdrNonConformantStringUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrNonConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrNonConformantStringUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrNonConformantStringUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNonConformantStringUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantStringUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantStringUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrConformantStringUnmarshall$descriptor() {
        return NdrConformantStringUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrConformantStringUnmarshall$handle() {
        return NdrConformantStringUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantStringUnmarshall$address() {
        return NdrConformantStringUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrConformantStringUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrConformantStringUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantStringUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrEncapsulatedUnionUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrEncapsulatedUnionUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrEncapsulatedUnionUnmarshall$descriptor() {
        return NdrEncapsulatedUnionUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrEncapsulatedUnionUnmarshall$handle() {
        return NdrEncapsulatedUnionUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrEncapsulatedUnionUnmarshall$address() {
        return NdrEncapsulatedUnionUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrEncapsulatedUnionUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrEncapsulatedUnionUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrEncapsulatedUnionUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNonEncapsulatedUnionUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNonEncapsulatedUnionUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrNonEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrNonEncapsulatedUnionUnmarshall$descriptor() {
        return NdrNonEncapsulatedUnionUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrNonEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrNonEncapsulatedUnionUnmarshall$handle() {
        return NdrNonEncapsulatedUnionUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrNonEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrNonEncapsulatedUnionUnmarshall$address() {
        return NdrNonEncapsulatedUnionUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrNonEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrNonEncapsulatedUnionUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrNonEncapsulatedUnionUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNonEncapsulatedUnionUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrByteCountPointerUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrByteCountPointerUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrByteCountPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrByteCountPointerUnmarshall$descriptor() {
        return NdrByteCountPointerUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrByteCountPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrByteCountPointerUnmarshall$handle() {
        return NdrByteCountPointerUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrByteCountPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrByteCountPointerUnmarshall$address() {
        return NdrByteCountPointerUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrByteCountPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrByteCountPointerUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrByteCountPointerUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrByteCountPointerUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrXmitOrRepAsUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrXmitOrRepAsUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrXmitOrRepAsUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrXmitOrRepAsUnmarshall$descriptor() {
        return NdrXmitOrRepAsUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrXmitOrRepAsUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrXmitOrRepAsUnmarshall$handle() {
        return NdrXmitOrRepAsUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrXmitOrRepAsUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrXmitOrRepAsUnmarshall$address() {
        return NdrXmitOrRepAsUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrXmitOrRepAsUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrXmitOrRepAsUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrXmitOrRepAsUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrXmitOrRepAsUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrUserMarshalUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrUserMarshalUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrUserMarshalUnmarshall$descriptor() {
        return NdrUserMarshalUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrUserMarshalUnmarshall$handle() {
        return NdrUserMarshalUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrUserMarshalUnmarshall$address() {
        return NdrUserMarshalUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrUserMarshalUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrUserMarshalUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrUserMarshalUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrInterfacePointerUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrInterfacePointerUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrInterfacePointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static FunctionDescriptor NdrInterfacePointerUnmarshall$descriptor() {
        return NdrInterfacePointerUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrInterfacePointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MethodHandle NdrInterfacePointerUnmarshall$handle() {
        return NdrInterfacePointerUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrInterfacePointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrInterfacePointerUnmarshall$address() {
        return NdrInterfacePointerUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrInterfacePointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char **ppMemory, PFORMAT_STRING pFormat, unsigned char fMustAlloc)
     * }
     */
    public static MemorySegment NdrInterfacePointerUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat, byte fMustAlloc) {
        var mh$ = NdrInterfacePointerUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrInterfacePointerUnmarshall", pStubMsg, ppMemory, pFormat, fMustAlloc);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, ppMemory, pFormat, fMustAlloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrClientContextUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrClientContextUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrClientContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_CCONTEXT *pContextHandle, RPC_BINDING_HANDLE BindHandle)
     * }
     */
    public static FunctionDescriptor NdrClientContextUnmarshall$descriptor() {
        return NdrClientContextUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrClientContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_CCONTEXT *pContextHandle, RPC_BINDING_HANDLE BindHandle)
     * }
     */
    public static MethodHandle NdrClientContextUnmarshall$handle() {
        return NdrClientContextUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrClientContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_CCONTEXT *pContextHandle, RPC_BINDING_HANDLE BindHandle)
     * }
     */
    public static MemorySegment NdrClientContextUnmarshall$address() {
        return NdrClientContextUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrClientContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_CCONTEXT *pContextHandle, RPC_BINDING_HANDLE BindHandle)
     * }
     */
    public static void NdrClientContextUnmarshall(MemorySegment pStubMsg, MemorySegment pContextHandle, MemorySegment BindHandle) {
        var mh$ = NdrClientContextUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrClientContextUnmarshall", pStubMsg, pContextHandle, BindHandle);
            }
            mh$.invokeExact(pStubMsg, pContextHandle, BindHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerContextUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerContextUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrServerContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static FunctionDescriptor NdrServerContextUnmarshall$descriptor() {
        return NdrServerContextUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrServerContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MethodHandle NdrServerContextUnmarshall$handle() {
        return NdrServerContextUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrServerContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MemorySegment NdrServerContextUnmarshall$address() {
        return NdrServerContextUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrServerContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MemorySegment NdrServerContextUnmarshall(MemorySegment pStubMsg) {
        var mh$ = NdrServerContextUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerContextUnmarshall", pStubMsg);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrContextHandleInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrContextHandleInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrContextHandleInitialize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrContextHandleInitialize$descriptor() {
        return NdrContextHandleInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrContextHandleInitialize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrContextHandleInitialize$handle() {
        return NdrContextHandleInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrContextHandleInitialize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrContextHandleInitialize$address() {
        return NdrContextHandleInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrContextHandleInitialize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrContextHandleInitialize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrContextHandleInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrContextHandleInitialize", pStubMsg, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerContextNewUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerContextNewUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrServerContextNewUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrServerContextNewUnmarshall$descriptor() {
        return NdrServerContextNewUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrServerContextNewUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrServerContextNewUnmarshall$handle() {
        return NdrServerContextNewUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrServerContextNewUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrServerContextNewUnmarshall$address() {
        return NdrServerContextNewUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NDR_SCONTEXT NdrServerContextNewUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrServerContextNewUnmarshall(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrServerContextNewUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerContextNewUnmarshall", pStubMsg, pFormat);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrPointerBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrPointerBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrPointerBufferSize$descriptor() {
        return NdrPointerBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrPointerBufferSize$handle() {
        return NdrPointerBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrPointerBufferSize$address() {
        return NdrPointerBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrPointerBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrPointerBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrPointerBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCsArrayBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCsArrayBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrCsArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrCsArrayBufferSize$descriptor() {
        return NdrCsArrayBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrCsArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrCsArrayBufferSize$handle() {
        return NdrCsArrayBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrCsArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrCsArrayBufferSize$address() {
        return NdrCsArrayBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrCsArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrCsArrayBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrCsArrayBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCsArrayBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCsTagBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCsTagBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrCsTagBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrCsTagBufferSize$descriptor() {
        return NdrCsTagBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrCsTagBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrCsTagBufferSize$handle() {
        return NdrCsTagBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrCsTagBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrCsTagBufferSize$address() {
        return NdrCsTagBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrCsTagBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrCsTagBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrCsTagBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCsTagBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrSimpleStructBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrSimpleStructBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrSimpleStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrSimpleStructBufferSize$descriptor() {
        return NdrSimpleStructBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrSimpleStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrSimpleStructBufferSize$handle() {
        return NdrSimpleStructBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrSimpleStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrSimpleStructBufferSize$address() {
        return NdrSimpleStructBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrSimpleStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrSimpleStructBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrSimpleStructBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrSimpleStructBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantStructBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantStructBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConformantStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantStructBufferSize$descriptor() {
        return NdrConformantStructBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConformantStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantStructBufferSize$handle() {
        return NdrConformantStructBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConformantStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantStructBufferSize$address() {
        return NdrConformantStructBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConformantStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConformantStructBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantStructBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantStructBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingStructBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingStructBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConformantVaryingStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingStructBufferSize$descriptor() {
        return NdrConformantVaryingStructBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConformantVaryingStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantVaryingStructBufferSize$handle() {
        return NdrConformantVaryingStructBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConformantVaryingStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingStructBufferSize$address() {
        return NdrConformantVaryingStructBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConformantVaryingStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConformantVaryingStructBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantVaryingStructBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingStructBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexStructBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexStructBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrComplexStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrComplexStructBufferSize$descriptor() {
        return NdrComplexStructBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrComplexStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrComplexStructBufferSize$handle() {
        return NdrComplexStructBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrComplexStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexStructBufferSize$address() {
        return NdrComplexStructBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrComplexStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrComplexStructBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrComplexStructBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexStructBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrFixedArrayBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrFixedArrayBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrFixedArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrFixedArrayBufferSize$descriptor() {
        return NdrFixedArrayBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrFixedArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrFixedArrayBufferSize$handle() {
        return NdrFixedArrayBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrFixedArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrFixedArrayBufferSize$address() {
        return NdrFixedArrayBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrFixedArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrFixedArrayBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrFixedArrayBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrFixedArrayBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantArrayBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantArrayBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConformantArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantArrayBufferSize$descriptor() {
        return NdrConformantArrayBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConformantArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantArrayBufferSize$handle() {
        return NdrConformantArrayBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConformantArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantArrayBufferSize$address() {
        return NdrConformantArrayBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConformantArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConformantArrayBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantArrayBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantArrayBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingArrayBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingArrayBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConformantVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingArrayBufferSize$descriptor() {
        return NdrConformantVaryingArrayBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConformantVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantVaryingArrayBufferSize$handle() {
        return NdrConformantVaryingArrayBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConformantVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingArrayBufferSize$address() {
        return NdrConformantVaryingArrayBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConformantVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConformantVaryingArrayBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantVaryingArrayBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingArrayBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrVaryingArrayBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrVaryingArrayBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrVaryingArrayBufferSize$descriptor() {
        return NdrVaryingArrayBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrVaryingArrayBufferSize$handle() {
        return NdrVaryingArrayBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrVaryingArrayBufferSize$address() {
        return NdrVaryingArrayBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrVaryingArrayBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrVaryingArrayBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrVaryingArrayBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexArrayBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexArrayBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrComplexArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrComplexArrayBufferSize$descriptor() {
        return NdrComplexArrayBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrComplexArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrComplexArrayBufferSize$handle() {
        return NdrComplexArrayBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrComplexArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexArrayBufferSize$address() {
        return NdrComplexArrayBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrComplexArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrComplexArrayBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrComplexArrayBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexArrayBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantStringBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantStringBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantStringBufferSize$descriptor() {
        return NdrConformantStringBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantStringBufferSize$handle() {
        return NdrConformantStringBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantStringBufferSize$address() {
        return NdrConformantStringBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConformantStringBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantStringBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantStringBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNonConformantStringBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNonConformantStringBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrNonConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrNonConformantStringBufferSize$descriptor() {
        return NdrNonConformantStringBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrNonConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrNonConformantStringBufferSize$handle() {
        return NdrNonConformantStringBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrNonConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrNonConformantStringBufferSize$address() {
        return NdrNonConformantStringBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrNonConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrNonConformantStringBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrNonConformantStringBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNonConformantStringBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrEncapsulatedUnionBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrEncapsulatedUnionBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrEncapsulatedUnionBufferSize$descriptor() {
        return NdrEncapsulatedUnionBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrEncapsulatedUnionBufferSize$handle() {
        return NdrEncapsulatedUnionBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrEncapsulatedUnionBufferSize$address() {
        return NdrEncapsulatedUnionBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrEncapsulatedUnionBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrEncapsulatedUnionBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrEncapsulatedUnionBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNonEncapsulatedUnionBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNonEncapsulatedUnionBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrNonEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrNonEncapsulatedUnionBufferSize$descriptor() {
        return NdrNonEncapsulatedUnionBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrNonEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrNonEncapsulatedUnionBufferSize$handle() {
        return NdrNonEncapsulatedUnionBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrNonEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrNonEncapsulatedUnionBufferSize$address() {
        return NdrNonEncapsulatedUnionBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrNonEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrNonEncapsulatedUnionBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrNonEncapsulatedUnionBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNonEncapsulatedUnionBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrByteCountPointerBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrByteCountPointerBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrByteCountPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrByteCountPointerBufferSize$descriptor() {
        return NdrByteCountPointerBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrByteCountPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrByteCountPointerBufferSize$handle() {
        return NdrByteCountPointerBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrByteCountPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrByteCountPointerBufferSize$address() {
        return NdrByteCountPointerBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrByteCountPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrByteCountPointerBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrByteCountPointerBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrByteCountPointerBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrXmitOrRepAsBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrXmitOrRepAsBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrXmitOrRepAsBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrXmitOrRepAsBufferSize$descriptor() {
        return NdrXmitOrRepAsBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrXmitOrRepAsBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrXmitOrRepAsBufferSize$handle() {
        return NdrXmitOrRepAsBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrXmitOrRepAsBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrXmitOrRepAsBufferSize$address() {
        return NdrXmitOrRepAsBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrXmitOrRepAsBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrXmitOrRepAsBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrXmitOrRepAsBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrXmitOrRepAsBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrUserMarshalBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrUserMarshalBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrUserMarshalBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrUserMarshalBufferSize$descriptor() {
        return NdrUserMarshalBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrUserMarshalBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrUserMarshalBufferSize$handle() {
        return NdrUserMarshalBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrUserMarshalBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrUserMarshalBufferSize$address() {
        return NdrUserMarshalBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrUserMarshalBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrUserMarshalBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrUserMarshalBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrUserMarshalBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrInterfacePointerBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrInterfacePointerBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrInterfacePointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrInterfacePointerBufferSize$descriptor() {
        return NdrInterfacePointerBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrInterfacePointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrInterfacePointerBufferSize$handle() {
        return NdrInterfacePointerBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrInterfacePointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrInterfacePointerBufferSize$address() {
        return NdrInterfacePointerBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrInterfacePointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrInterfacePointerBufferSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrInterfacePointerBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrInterfacePointerBufferSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrContextHandleSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrContextHandleSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrContextHandleSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrContextHandleSize$descriptor() {
        return NdrContextHandleSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrContextHandleSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrContextHandleSize$handle() {
        return NdrContextHandleSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrContextHandleSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrContextHandleSize$address() {
        return NdrContextHandleSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrContextHandleSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrContextHandleSize(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrContextHandleSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrContextHandleSize", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrPointerMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrPointerMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrPointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrPointerMemorySize$descriptor() {
        return NdrPointerMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrPointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrPointerMemorySize$handle() {
        return NdrPointerMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrPointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrPointerMemorySize$address() {
        return NdrPointerMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrPointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrPointerMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrPointerMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrPointerMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrContextHandleMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrContextHandleMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrContextHandleMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrContextHandleMemorySize$descriptor() {
        return NdrContextHandleMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrContextHandleMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrContextHandleMemorySize$handle() {
        return NdrContextHandleMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrContextHandleMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrContextHandleMemorySize$address() {
        return NdrContextHandleMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrContextHandleMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrContextHandleMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrContextHandleMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrContextHandleMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCsArrayMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCsArrayMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrCsArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrCsArrayMemorySize$descriptor() {
        return NdrCsArrayMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrCsArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrCsArrayMemorySize$handle() {
        return NdrCsArrayMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrCsArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrCsArrayMemorySize$address() {
        return NdrCsArrayMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrCsArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrCsArrayMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrCsArrayMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCsArrayMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCsTagMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCsTagMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrCsTagMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrCsTagMemorySize$descriptor() {
        return NdrCsTagMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrCsTagMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrCsTagMemorySize$handle() {
        return NdrCsTagMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrCsTagMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrCsTagMemorySize$address() {
        return NdrCsTagMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrCsTagMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrCsTagMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrCsTagMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCsTagMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrSimpleStructMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrSimpleStructMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrSimpleStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrSimpleStructMemorySize$descriptor() {
        return NdrSimpleStructMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrSimpleStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrSimpleStructMemorySize$handle() {
        return NdrSimpleStructMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrSimpleStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrSimpleStructMemorySize$address() {
        return NdrSimpleStructMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrSimpleStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrSimpleStructMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrSimpleStructMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrSimpleStructMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantStructMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantStructMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrConformantStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantStructMemorySize$descriptor() {
        return NdrConformantStructMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrConformantStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantStructMemorySize$handle() {
        return NdrConformantStructMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrConformantStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantStructMemorySize$address() {
        return NdrConformantStructMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrConformantStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrConformantStructMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrConformantStructMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantStructMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingStructMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingStructMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrConformantVaryingStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingStructMemorySize$descriptor() {
        return NdrConformantVaryingStructMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrConformantVaryingStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantVaryingStructMemorySize$handle() {
        return NdrConformantVaryingStructMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrConformantVaryingStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingStructMemorySize$address() {
        return NdrConformantVaryingStructMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrConformantVaryingStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrConformantVaryingStructMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrConformantVaryingStructMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingStructMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexStructMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexStructMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrComplexStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrComplexStructMemorySize$descriptor() {
        return NdrComplexStructMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrComplexStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrComplexStructMemorySize$handle() {
        return NdrComplexStructMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrComplexStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexStructMemorySize$address() {
        return NdrComplexStructMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrComplexStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrComplexStructMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrComplexStructMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexStructMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrFixedArrayMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrFixedArrayMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrFixedArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrFixedArrayMemorySize$descriptor() {
        return NdrFixedArrayMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrFixedArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrFixedArrayMemorySize$handle() {
        return NdrFixedArrayMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrFixedArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrFixedArrayMemorySize$address() {
        return NdrFixedArrayMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrFixedArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrFixedArrayMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrFixedArrayMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrFixedArrayMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantArrayMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantArrayMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrConformantArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantArrayMemorySize$descriptor() {
        return NdrConformantArrayMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrConformantArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantArrayMemorySize$handle() {
        return NdrConformantArrayMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrConformantArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantArrayMemorySize$address() {
        return NdrConformantArrayMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrConformantArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrConformantArrayMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrConformantArrayMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantArrayMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingArrayMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingArrayMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrConformantVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingArrayMemorySize$descriptor() {
        return NdrConformantVaryingArrayMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrConformantVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantVaryingArrayMemorySize$handle() {
        return NdrConformantVaryingArrayMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrConformantVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingArrayMemorySize$address() {
        return NdrConformantVaryingArrayMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrConformantVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrConformantVaryingArrayMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrConformantVaryingArrayMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingArrayMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrVaryingArrayMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrVaryingArrayMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrVaryingArrayMemorySize$descriptor() {
        return NdrVaryingArrayMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrVaryingArrayMemorySize$handle() {
        return NdrVaryingArrayMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrVaryingArrayMemorySize$address() {
        return NdrVaryingArrayMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrVaryingArrayMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrVaryingArrayMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrVaryingArrayMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexArrayMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexArrayMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrComplexArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrComplexArrayMemorySize$descriptor() {
        return NdrComplexArrayMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrComplexArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrComplexArrayMemorySize$handle() {
        return NdrComplexArrayMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrComplexArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexArrayMemorySize$address() {
        return NdrComplexArrayMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrComplexArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrComplexArrayMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrComplexArrayMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexArrayMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantStringMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantStringMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantStringMemorySize$descriptor() {
        return NdrConformantStringMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantStringMemorySize$handle() {
        return NdrConformantStringMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantStringMemorySize$address() {
        return NdrConformantStringMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrConformantStringMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrConformantStringMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantStringMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNonConformantStringMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNonConformantStringMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrNonConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrNonConformantStringMemorySize$descriptor() {
        return NdrNonConformantStringMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrNonConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrNonConformantStringMemorySize$handle() {
        return NdrNonConformantStringMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrNonConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrNonConformantStringMemorySize$address() {
        return NdrNonConformantStringMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrNonConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrNonConformantStringMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrNonConformantStringMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNonConformantStringMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrEncapsulatedUnionMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrEncapsulatedUnionMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrEncapsulatedUnionMemorySize$descriptor() {
        return NdrEncapsulatedUnionMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrEncapsulatedUnionMemorySize$handle() {
        return NdrEncapsulatedUnionMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrEncapsulatedUnionMemorySize$address() {
        return NdrEncapsulatedUnionMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrEncapsulatedUnionMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrEncapsulatedUnionMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrEncapsulatedUnionMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNonEncapsulatedUnionMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNonEncapsulatedUnionMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrNonEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrNonEncapsulatedUnionMemorySize$descriptor() {
        return NdrNonEncapsulatedUnionMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrNonEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrNonEncapsulatedUnionMemorySize$handle() {
        return NdrNonEncapsulatedUnionMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrNonEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrNonEncapsulatedUnionMemorySize$address() {
        return NdrNonEncapsulatedUnionMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrNonEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrNonEncapsulatedUnionMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrNonEncapsulatedUnionMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNonEncapsulatedUnionMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrXmitOrRepAsMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrXmitOrRepAsMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrXmitOrRepAsMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrXmitOrRepAsMemorySize$descriptor() {
        return NdrXmitOrRepAsMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrXmitOrRepAsMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrXmitOrRepAsMemorySize$handle() {
        return NdrXmitOrRepAsMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrXmitOrRepAsMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrXmitOrRepAsMemorySize$address() {
        return NdrXmitOrRepAsMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrXmitOrRepAsMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrXmitOrRepAsMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrXmitOrRepAsMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrXmitOrRepAsMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrUserMarshalMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrUserMarshalMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrUserMarshalMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrUserMarshalMemorySize$descriptor() {
        return NdrUserMarshalMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrUserMarshalMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrUserMarshalMemorySize$handle() {
        return NdrUserMarshalMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrUserMarshalMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrUserMarshalMemorySize$address() {
        return NdrUserMarshalMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrUserMarshalMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrUserMarshalMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrUserMarshalMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrUserMarshalMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrInterfacePointerMemorySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrInterfacePointerMemorySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long NdrInterfacePointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrInterfacePointerMemorySize$descriptor() {
        return NdrInterfacePointerMemorySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long NdrInterfacePointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrInterfacePointerMemorySize$handle() {
        return NdrInterfacePointerMemorySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long NdrInterfacePointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrInterfacePointerMemorySize$address() {
        return NdrInterfacePointerMemorySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long NdrInterfacePointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static int NdrInterfacePointerMemorySize(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrInterfacePointerMemorySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrInterfacePointerMemorySize", pStubMsg, pFormat);
            }
            return (int)mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrPointerFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrPointerFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrPointerFree$descriptor() {
        return NdrPointerFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrPointerFree$handle() {
        return NdrPointerFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrPointerFree$address() {
        return NdrPointerFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrPointerFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrPointerFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrPointerFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCsArrayFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCsArrayFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrCsArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrCsArrayFree$descriptor() {
        return NdrCsArrayFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrCsArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrCsArrayFree$handle() {
        return NdrCsArrayFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrCsArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrCsArrayFree$address() {
        return NdrCsArrayFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrCsArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrCsArrayFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrCsArrayFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCsArrayFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrSimpleStructFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrSimpleStructFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrSimpleStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrSimpleStructFree$descriptor() {
        return NdrSimpleStructFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrSimpleStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrSimpleStructFree$handle() {
        return NdrSimpleStructFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrSimpleStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrSimpleStructFree$address() {
        return NdrSimpleStructFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrSimpleStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrSimpleStructFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrSimpleStructFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrSimpleStructFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantStructFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantStructFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConformantStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantStructFree$descriptor() {
        return NdrConformantStructFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConformantStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantStructFree$handle() {
        return NdrConformantStructFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConformantStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantStructFree$address() {
        return NdrConformantStructFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConformantStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConformantStructFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantStructFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantStructFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingStructFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingStructFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConformantVaryingStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingStructFree$descriptor() {
        return NdrConformantVaryingStructFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConformantVaryingStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantVaryingStructFree$handle() {
        return NdrConformantVaryingStructFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConformantVaryingStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingStructFree$address() {
        return NdrConformantVaryingStructFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConformantVaryingStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConformantVaryingStructFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantVaryingStructFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingStructFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexStructFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexStructFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrComplexStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrComplexStructFree$descriptor() {
        return NdrComplexStructFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrComplexStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrComplexStructFree$handle() {
        return NdrComplexStructFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrComplexStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexStructFree$address() {
        return NdrComplexStructFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrComplexStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrComplexStructFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrComplexStructFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexStructFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrFixedArrayFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrFixedArrayFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrFixedArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrFixedArrayFree$descriptor() {
        return NdrFixedArrayFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrFixedArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrFixedArrayFree$handle() {
        return NdrFixedArrayFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrFixedArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrFixedArrayFree$address() {
        return NdrFixedArrayFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrFixedArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrFixedArrayFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrFixedArrayFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrFixedArrayFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantArrayFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantArrayFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConformantArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantArrayFree$descriptor() {
        return NdrConformantArrayFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConformantArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantArrayFree$handle() {
        return NdrConformantArrayFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConformantArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantArrayFree$address() {
        return NdrConformantArrayFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConformantArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConformantArrayFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantArrayFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantArrayFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConformantVaryingArrayFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConformantVaryingArrayFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConformantVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConformantVaryingArrayFree$descriptor() {
        return NdrConformantVaryingArrayFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConformantVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConformantVaryingArrayFree$handle() {
        return NdrConformantVaryingArrayFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConformantVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConformantVaryingArrayFree$address() {
        return NdrConformantVaryingArrayFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConformantVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConformantVaryingArrayFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrConformantVaryingArrayFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConformantVaryingArrayFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrVaryingArrayFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrVaryingArrayFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrVaryingArrayFree$descriptor() {
        return NdrVaryingArrayFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrVaryingArrayFree$handle() {
        return NdrVaryingArrayFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrVaryingArrayFree$address() {
        return NdrVaryingArrayFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrVaryingArrayFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrVaryingArrayFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrVaryingArrayFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrComplexArrayFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrComplexArrayFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrComplexArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrComplexArrayFree$descriptor() {
        return NdrComplexArrayFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrComplexArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrComplexArrayFree$handle() {
        return NdrComplexArrayFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrComplexArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrComplexArrayFree$address() {
        return NdrComplexArrayFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrComplexArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrComplexArrayFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrComplexArrayFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrComplexArrayFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrEncapsulatedUnionFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrEncapsulatedUnionFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrEncapsulatedUnionFree$descriptor() {
        return NdrEncapsulatedUnionFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrEncapsulatedUnionFree$handle() {
        return NdrEncapsulatedUnionFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrEncapsulatedUnionFree$address() {
        return NdrEncapsulatedUnionFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrEncapsulatedUnionFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrEncapsulatedUnionFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrEncapsulatedUnionFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNonEncapsulatedUnionFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNonEncapsulatedUnionFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrNonEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrNonEncapsulatedUnionFree$descriptor() {
        return NdrNonEncapsulatedUnionFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrNonEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrNonEncapsulatedUnionFree$handle() {
        return NdrNonEncapsulatedUnionFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrNonEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrNonEncapsulatedUnionFree$address() {
        return NdrNonEncapsulatedUnionFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrNonEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrNonEncapsulatedUnionFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrNonEncapsulatedUnionFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNonEncapsulatedUnionFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrByteCountPointerFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrByteCountPointerFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrByteCountPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrByteCountPointerFree$descriptor() {
        return NdrByteCountPointerFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrByteCountPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrByteCountPointerFree$handle() {
        return NdrByteCountPointerFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrByteCountPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrByteCountPointerFree$address() {
        return NdrByteCountPointerFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrByteCountPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrByteCountPointerFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrByteCountPointerFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrByteCountPointerFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrXmitOrRepAsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrXmitOrRepAsFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrXmitOrRepAsFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrXmitOrRepAsFree$descriptor() {
        return NdrXmitOrRepAsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrXmitOrRepAsFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrXmitOrRepAsFree$handle() {
        return NdrXmitOrRepAsFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrXmitOrRepAsFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrXmitOrRepAsFree$address() {
        return NdrXmitOrRepAsFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrXmitOrRepAsFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrXmitOrRepAsFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrXmitOrRepAsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrXmitOrRepAsFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrUserMarshalFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrUserMarshalFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrUserMarshalFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrUserMarshalFree$descriptor() {
        return NdrUserMarshalFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrUserMarshalFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrUserMarshalFree$handle() {
        return NdrUserMarshalFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrUserMarshalFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrUserMarshalFree$address() {
        return NdrUserMarshalFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrUserMarshalFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrUserMarshalFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrUserMarshalFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrUserMarshalFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrInterfacePointerFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrInterfacePointerFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrInterfacePointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrInterfacePointerFree$descriptor() {
        return NdrInterfacePointerFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrInterfacePointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrInterfacePointerFree$handle() {
        return NdrInterfacePointerFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrInterfacePointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrInterfacePointerFree$address() {
        return NdrInterfacePointerFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrInterfacePointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrInterfacePointerFree(MemorySegment pStubMsg, MemorySegment pMemory, MemorySegment pFormat) {
        var mh$ = NdrInterfacePointerFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrInterfacePointerFree", pStubMsg, pMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, pMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConvert2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConvert2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConvert2(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, long NumberParams)
     * }
     */
    public static FunctionDescriptor NdrConvert2$descriptor() {
        return NdrConvert2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConvert2(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, long NumberParams)
     * }
     */
    public static MethodHandle NdrConvert2$handle() {
        return NdrConvert2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConvert2(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, long NumberParams)
     * }
     */
    public static MemorySegment NdrConvert2$address() {
        return NdrConvert2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConvert2(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, long NumberParams)
     * }
     */
    public static void NdrConvert2(MemorySegment pStubMsg, MemorySegment pFormat, int NumberParams) {
        var mh$ = NdrConvert2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConvert2", pStubMsg, pFormat, NumberParams);
            }
            mh$.invokeExact(pStubMsg, pFormat, NumberParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrConvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrConvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrConvert(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrConvert$descriptor() {
        return NdrConvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrConvert(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrConvert$handle() {
        return NdrConvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrConvert(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrConvert$address() {
        return NdrConvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrConvert(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrConvert(MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrConvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrConvert", pStubMsg, pFormat);
            }
            mh$.invokeExact(pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrUserMarshalSimpleTypeConvert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrUserMarshalSimpleTypeConvert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalSimpleTypeConvert(unsigned long *pFlags, unsigned char *pBuffer, unsigned char FormatChar)
     * }
     */
    public static FunctionDescriptor NdrUserMarshalSimpleTypeConvert$descriptor() {
        return NdrUserMarshalSimpleTypeConvert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalSimpleTypeConvert(unsigned long *pFlags, unsigned char *pBuffer, unsigned char FormatChar)
     * }
     */
    public static MethodHandle NdrUserMarshalSimpleTypeConvert$handle() {
        return NdrUserMarshalSimpleTypeConvert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalSimpleTypeConvert(unsigned long *pFlags, unsigned char *pBuffer, unsigned char FormatChar)
     * }
     */
    public static MemorySegment NdrUserMarshalSimpleTypeConvert$address() {
        return NdrUserMarshalSimpleTypeConvert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrUserMarshalSimpleTypeConvert(unsigned long *pFlags, unsigned char *pBuffer, unsigned char FormatChar)
     * }
     */
    public static MemorySegment NdrUserMarshalSimpleTypeConvert(MemorySegment pFlags, MemorySegment pBuffer, byte FormatChar) {
        var mh$ = NdrUserMarshalSimpleTypeConvert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrUserMarshalSimpleTypeConvert", pFlags, pBuffer, FormatChar);
            }
            return (MemorySegment)mh$.invokeExact(pFlags, pBuffer, FormatChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrClientInitializeNew {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrClientInitializeNew");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrClientInitializeNew(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned int ProcNum)
     * }
     */
    public static FunctionDescriptor NdrClientInitializeNew$descriptor() {
        return NdrClientInitializeNew.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrClientInitializeNew(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned int ProcNum)
     * }
     */
    public static MethodHandle NdrClientInitializeNew$handle() {
        return NdrClientInitializeNew.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrClientInitializeNew(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned int ProcNum)
     * }
     */
    public static MemorySegment NdrClientInitializeNew$address() {
        return NdrClientInitializeNew.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrClientInitializeNew(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned int ProcNum)
     * }
     */
    public static void NdrClientInitializeNew(MemorySegment pRpcMsg, MemorySegment pStubMsg, MemorySegment pStubDescriptor, int ProcNum) {
        var mh$ = NdrClientInitializeNew.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrClientInitializeNew", pRpcMsg, pStubMsg, pStubDescriptor, ProcNum);
            }
            mh$.invokeExact(pRpcMsg, pStubMsg, pStubDescriptor, ProcNum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerInitializeNew {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerInitializeNew");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrServerInitializeNew(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor)
     * }
     */
    public static FunctionDescriptor NdrServerInitializeNew$descriptor() {
        return NdrServerInitializeNew.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrServerInitializeNew(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor)
     * }
     */
    public static MethodHandle NdrServerInitializeNew$handle() {
        return NdrServerInitializeNew.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrServerInitializeNew(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor)
     * }
     */
    public static MemorySegment NdrServerInitializeNew$address() {
        return NdrServerInitializeNew.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrServerInitializeNew(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor)
     * }
     */
    public static MemorySegment NdrServerInitializeNew(MemorySegment pRpcMsg, MemorySegment pStubMsg, MemorySegment pStubDescriptor) {
        var mh$ = NdrServerInitializeNew.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerInitializeNew", pRpcMsg, pStubMsg, pStubDescriptor);
            }
            return (MemorySegment)mh$.invokeExact(pRpcMsg, pStubMsg, pStubDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerInitializePartial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerInitializePartial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerInitializePartial(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned long RequestedBufferSize)
     * }
     */
    public static FunctionDescriptor NdrServerInitializePartial$descriptor() {
        return NdrServerInitializePartial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerInitializePartial(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned long RequestedBufferSize)
     * }
     */
    public static MethodHandle NdrServerInitializePartial$handle() {
        return NdrServerInitializePartial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerInitializePartial(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned long RequestedBufferSize)
     * }
     */
    public static MemorySegment NdrServerInitializePartial$address() {
        return NdrServerInitializePartial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerInitializePartial(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned long RequestedBufferSize)
     * }
     */
    public static void NdrServerInitializePartial(MemorySegment pRpcMsg, MemorySegment pStubMsg, MemorySegment pStubDescriptor, int RequestedBufferSize) {
        var mh$ = NdrServerInitializePartial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerInitializePartial", pRpcMsg, pStubMsg, pStubDescriptor, RequestedBufferSize);
            }
            mh$.invokeExact(pRpcMsg, pStubMsg, pStubDescriptor, RequestedBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrClientInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrClientInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrClientInitialize(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned int ProcNum)
     * }
     */
    public static FunctionDescriptor NdrClientInitialize$descriptor() {
        return NdrClientInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrClientInitialize(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned int ProcNum)
     * }
     */
    public static MethodHandle NdrClientInitialize$handle() {
        return NdrClientInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrClientInitialize(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned int ProcNum)
     * }
     */
    public static MemorySegment NdrClientInitialize$address() {
        return NdrClientInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrClientInitialize(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, unsigned int ProcNum)
     * }
     */
    public static void NdrClientInitialize(MemorySegment pRpcMsg, MemorySegment pStubMsg, MemorySegment pStubDescriptor, int ProcNum) {
        var mh$ = NdrClientInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrClientInitialize", pRpcMsg, pStubMsg, pStubDescriptor, ProcNum);
            }
            mh$.invokeExact(pRpcMsg, pStubMsg, pStubDescriptor, ProcNum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrServerInitialize(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor)
     * }
     */
    public static FunctionDescriptor NdrServerInitialize$descriptor() {
        return NdrServerInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrServerInitialize(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor)
     * }
     */
    public static MethodHandle NdrServerInitialize$handle() {
        return NdrServerInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrServerInitialize(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor)
     * }
     */
    public static MemorySegment NdrServerInitialize$address() {
        return NdrServerInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrServerInitialize(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor)
     * }
     */
    public static MemorySegment NdrServerInitialize(MemorySegment pRpcMsg, MemorySegment pStubMsg, MemorySegment pStubDescriptor) {
        var mh$ = NdrServerInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerInitialize", pRpcMsg, pStubMsg, pStubDescriptor);
            }
            return (MemorySegment)mh$.invokeExact(pRpcMsg, pStubMsg, pStubDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerInitializeUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerInitializeUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrServerInitializeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor NdrServerInitializeUnmarshall$descriptor() {
        return NdrServerInitializeUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrServerInitializeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle NdrServerInitializeUnmarshall$handle() {
        return NdrServerInitializeUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrServerInitializeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment NdrServerInitializeUnmarshall$address() {
        return NdrServerInitializeUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrServerInitializeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment NdrServerInitializeUnmarshall(MemorySegment pStubMsg, MemorySegment pStubDescriptor, MemorySegment pRpcMsg) {
        var mh$ = NdrServerInitializeUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerInitializeUnmarshall", pStubMsg, pStubDescriptor, pRpcMsg);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pStubDescriptor, pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerInitializeMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerInitializeMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerInitializeMarshall(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static FunctionDescriptor NdrServerInitializeMarshall$descriptor() {
        return NdrServerInitializeMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerInitializeMarshall(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MethodHandle NdrServerInitializeMarshall$handle() {
        return NdrServerInitializeMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerInitializeMarshall(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MemorySegment NdrServerInitializeMarshall$address() {
        return NdrServerInitializeMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerInitializeMarshall(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static void NdrServerInitializeMarshall(MemorySegment pRpcMsg, MemorySegment pStubMsg) {
        var mh$ = NdrServerInitializeMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerInitializeMarshall", pRpcMsg, pStubMsg);
            }
            mh$.invokeExact(pRpcMsg, pStubMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrGetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrGetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrGetBuffer(PMIDL_STUB_MESSAGE pStubMsg, unsigned long BufferLength, RPC_BINDING_HANDLE Handle)
     * }
     */
    public static FunctionDescriptor NdrGetBuffer$descriptor() {
        return NdrGetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrGetBuffer(PMIDL_STUB_MESSAGE pStubMsg, unsigned long BufferLength, RPC_BINDING_HANDLE Handle)
     * }
     */
    public static MethodHandle NdrGetBuffer$handle() {
        return NdrGetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrGetBuffer(PMIDL_STUB_MESSAGE pStubMsg, unsigned long BufferLength, RPC_BINDING_HANDLE Handle)
     * }
     */
    public static MemorySegment NdrGetBuffer$address() {
        return NdrGetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrGetBuffer(PMIDL_STUB_MESSAGE pStubMsg, unsigned long BufferLength, RPC_BINDING_HANDLE Handle)
     * }
     */
    public static MemorySegment NdrGetBuffer(MemorySegment pStubMsg, int BufferLength, MemorySegment Handle) {
        var mh$ = NdrGetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrGetBuffer", pStubMsg, BufferLength, Handle);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, BufferLength, Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNsGetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNsGetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrNsGetBuffer(PMIDL_STUB_MESSAGE pStubMsg, unsigned long BufferLength, RPC_BINDING_HANDLE Handle)
     * }
     */
    public static FunctionDescriptor NdrNsGetBuffer$descriptor() {
        return NdrNsGetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrNsGetBuffer(PMIDL_STUB_MESSAGE pStubMsg, unsigned long BufferLength, RPC_BINDING_HANDLE Handle)
     * }
     */
    public static MethodHandle NdrNsGetBuffer$handle() {
        return NdrNsGetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrNsGetBuffer(PMIDL_STUB_MESSAGE pStubMsg, unsigned long BufferLength, RPC_BINDING_HANDLE Handle)
     * }
     */
    public static MemorySegment NdrNsGetBuffer$address() {
        return NdrNsGetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrNsGetBuffer(PMIDL_STUB_MESSAGE pStubMsg, unsigned long BufferLength, RPC_BINDING_HANDLE Handle)
     * }
     */
    public static MemorySegment NdrNsGetBuffer(MemorySegment pStubMsg, int BufferLength, MemorySegment Handle) {
        var mh$ = NdrNsGetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNsGetBuffer", pStubMsg, BufferLength, Handle);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, BufferLength, Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrSendReceive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrSendReceive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrSendReceive(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pBufferEnd)
     * }
     */
    public static FunctionDescriptor NdrSendReceive$descriptor() {
        return NdrSendReceive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrSendReceive(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pBufferEnd)
     * }
     */
    public static MethodHandle NdrSendReceive$handle() {
        return NdrSendReceive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrSendReceive(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pBufferEnd)
     * }
     */
    public static MemorySegment NdrSendReceive$address() {
        return NdrSendReceive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrSendReceive(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pBufferEnd)
     * }
     */
    public static MemorySegment NdrSendReceive(MemorySegment pStubMsg, MemorySegment pBufferEnd) {
        var mh$ = NdrSendReceive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrSendReceive", pStubMsg, pBufferEnd);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pBufferEnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrNsSendReceive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrNsSendReceive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char *NdrNsSendReceive(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pBufferEnd, RPC_BINDING_HANDLE *pAutoHandle)
     * }
     */
    public static FunctionDescriptor NdrNsSendReceive$descriptor() {
        return NdrNsSendReceive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char *NdrNsSendReceive(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pBufferEnd, RPC_BINDING_HANDLE *pAutoHandle)
     * }
     */
    public static MethodHandle NdrNsSendReceive$handle() {
        return NdrNsSendReceive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char *NdrNsSendReceive(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pBufferEnd, RPC_BINDING_HANDLE *pAutoHandle)
     * }
     */
    public static MemorySegment NdrNsSendReceive$address() {
        return NdrNsSendReceive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char *NdrNsSendReceive(PMIDL_STUB_MESSAGE pStubMsg, unsigned char *pBufferEnd, RPC_BINDING_HANDLE *pAutoHandle)
     * }
     */
    public static MemorySegment NdrNsSendReceive(MemorySegment pStubMsg, MemorySegment pBufferEnd, MemorySegment pAutoHandle) {
        var mh$ = NdrNsSendReceive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrNsSendReceive", pStubMsg, pBufferEnd, pAutoHandle);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, pBufferEnd, pAutoHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrFreeBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrFreeBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrFreeBuffer(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static FunctionDescriptor NdrFreeBuffer$descriptor() {
        return NdrFreeBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrFreeBuffer(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MethodHandle NdrFreeBuffer$handle() {
        return NdrFreeBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrFreeBuffer(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static MemorySegment NdrFreeBuffer$address() {
        return NdrFreeBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrFreeBuffer(PMIDL_STUB_MESSAGE pStubMsg)
     * }
     */
    public static void NdrFreeBuffer(MemorySegment pStubMsg) {
        var mh$ = NdrFreeBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrFreeBuffer", pStubMsg);
            }
            mh$.invokeExact(pStubMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrGetDcomProtocolVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrGetDcomProtocolVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT NdrGetDcomProtocolVersion(PMIDL_STUB_MESSAGE pStubMsg, RPC_VERSION *pVersion)
     * }
     */
    public static FunctionDescriptor NdrGetDcomProtocolVersion$descriptor() {
        return NdrGetDcomProtocolVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT NdrGetDcomProtocolVersion(PMIDL_STUB_MESSAGE pStubMsg, RPC_VERSION *pVersion)
     * }
     */
    public static MethodHandle NdrGetDcomProtocolVersion$handle() {
        return NdrGetDcomProtocolVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT NdrGetDcomProtocolVersion(PMIDL_STUB_MESSAGE pStubMsg, RPC_VERSION *pVersion)
     * }
     */
    public static MemorySegment NdrGetDcomProtocolVersion$address() {
        return NdrGetDcomProtocolVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT NdrGetDcomProtocolVersion(PMIDL_STUB_MESSAGE pStubMsg, RPC_VERSION *pVersion)
     * }
     */
    public static int NdrGetDcomProtocolVersion(MemorySegment pStubMsg, MemorySegment pVersion) {
        var mh$ = NdrGetDcomProtocolVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrGetDcomProtocolVersion", pStubMsg, pVersion);
            }
            return (int)mh$.invokeExact(pStubMsg, pVersion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * CLIENT_CALL_RETURN NdrClientCall2(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...)
     * }
     */
    public static class NdrClientCall2 {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                _CLIENT_CALL_RETURN.layout(),
                winapi.C_POINTER,
                winapi.C_POINTER
            );
        private static final MemorySegment ADDR = winapi.findOrThrow("NdrClientCall2");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private NdrClientCall2(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * CLIENT_CALL_RETURN NdrClientCall2(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...)
         * }
         */
        public static NdrClientCall2 makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new NdrClientCall2(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, MemorySegment pStubDescriptor, MemorySegment pFormat, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("NdrClientCall2", allocator, pStubDescriptor, pFormat, x2);
                }
                return (MemorySegment) spreader.invokeExact(allocator, pStubDescriptor, pFormat, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * CLIENT_CALL_RETURN NdrClientCall(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...)
     * }
     */
    public static class NdrClientCall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                _CLIENT_CALL_RETURN.layout(),
                winapi.C_POINTER,
                winapi.C_POINTER
            );
        private static final MemorySegment ADDR = winapi.findOrThrow("NdrClientCall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private NdrClientCall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * CLIENT_CALL_RETURN NdrClientCall(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...)
         * }
         */
        public static NdrClientCall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new NdrClientCall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, MemorySegment pStubDescriptor, MemorySegment pFormat, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("NdrClientCall", allocator, pStubDescriptor, pFormat, x2);
                }
                return (MemorySegment) spreader.invokeExact(allocator, pStubDescriptor, pFormat, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * CLIENT_CALL_RETURN NdrAsyncClientCall(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...)
     * }
     */
    public static class NdrAsyncClientCall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                _CLIENT_CALL_RETURN.layout(),
                winapi.C_POINTER,
                winapi.C_POINTER
            );
        private static final MemorySegment ADDR = winapi.findOrThrow("NdrAsyncClientCall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private NdrAsyncClientCall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * CLIENT_CALL_RETURN NdrAsyncClientCall(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...)
         * }
         */
        public static NdrAsyncClientCall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new NdrAsyncClientCall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, MemorySegment pStubDescriptor, MemorySegment pFormat, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("NdrAsyncClientCall", allocator, pStubDescriptor, pFormat, x2);
                }
                return (MemorySegment) spreader.invokeExact(allocator, pStubDescriptor, pFormat, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * CLIENT_CALL_RETURN NdrDcomAsyncClientCall(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...)
     * }
     */
    public static class NdrDcomAsyncClientCall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                _CLIENT_CALL_RETURN.layout(),
                winapi.C_POINTER,
                winapi.C_POINTER
            );
        private static final MemorySegment ADDR = winapi.findOrThrow("NdrDcomAsyncClientCall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private NdrDcomAsyncClientCall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * CLIENT_CALL_RETURN NdrDcomAsyncClientCall(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...)
         * }
         */
        public static NdrDcomAsyncClientCall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new NdrDcomAsyncClientCall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, MemorySegment pStubDescriptor, MemorySegment pFormat, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("NdrDcomAsyncClientCall", allocator, pStubDescriptor, pFormat, x2);
                }
                return (MemorySegment) spreader.invokeExact(allocator, pStubDescriptor, pFormat, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    private static final int STUB_UNMARSHAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.STUB_UNMARSHAL = 0
     * }
     */
    public static int STUB_UNMARSHAL() {
        return STUB_UNMARSHAL;
    }
    private static final int STUB_CALL_SERVER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.STUB_CALL_SERVER = 1
     * }
     */
    public static int STUB_CALL_SERVER() {
        return STUB_CALL_SERVER;
    }
    private static final int STUB_MARSHAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.STUB_MARSHAL = 2
     * }
     */
    public static int STUB_MARSHAL() {
        return STUB_MARSHAL;
    }
    private static final int STUB_CALL_SERVER_NO_HRESULT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.STUB_CALL_SERVER_NO_HRESULT = 3
     * }
     */
    public static int STUB_CALL_SERVER_NO_HRESULT() {
        return STUB_CALL_SERVER_NO_HRESULT;
    }
    private static final int PROXY_CALCSIZE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROXY_CALCSIZE = 0
     * }
     */
    public static int PROXY_CALCSIZE() {
        return PROXY_CALCSIZE;
    }
    private static final int PROXY_GETBUFFER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROXY_GETBUFFER = 1
     * }
     */
    public static int PROXY_GETBUFFER() {
        return PROXY_GETBUFFER;
    }
    private static final int PROXY_MARSHAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROXY_MARSHAL = 2
     * }
     */
    public static int PROXY_MARSHAL() {
        return PROXY_MARSHAL;
    }
    private static final int PROXY_SENDRECEIVE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROXY_SENDRECEIVE = 3
     * }
     */
    public static int PROXY_SENDRECEIVE() {
        return PROXY_SENDRECEIVE;
    }
    private static final int PROXY_UNMARSHAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROXY_UNMARSHAL = 4
     * }
     */
    public static int PROXY_UNMARSHAL() {
        return PROXY_UNMARSHAL;
    }

    private static class NdrAsyncServerCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrAsyncServerCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrAsyncServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor NdrAsyncServerCall$descriptor() {
        return NdrAsyncServerCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrAsyncServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle NdrAsyncServerCall$handle() {
        return NdrAsyncServerCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrAsyncServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment NdrAsyncServerCall$address() {
        return NdrAsyncServerCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrAsyncServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static void NdrAsyncServerCall(MemorySegment pRpcMsg) {
        var mh$ = NdrAsyncServerCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrAsyncServerCall", pRpcMsg);
            }
            mh$.invokeExact(pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrAsyncStubCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrAsyncStubCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long NdrAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static FunctionDescriptor NdrAsyncStubCall$descriptor() {
        return NdrAsyncStubCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long NdrAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MethodHandle NdrAsyncStubCall$handle() {
        return NdrAsyncStubCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long NdrAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MemorySegment NdrAsyncStubCall$address() {
        return NdrAsyncStubCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long NdrAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static int NdrAsyncStubCall(MemorySegment pThis, MemorySegment pChannel, MemorySegment pRpcMsg, MemorySegment pdwStubPhase) {
        var mh$ = NdrAsyncStubCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrAsyncStubCall", pThis, pChannel, pRpcMsg, pdwStubPhase);
            }
            return (int)mh$.invokeExact(pThis, pChannel, pRpcMsg, pdwStubPhase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrDcomAsyncStubCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrDcomAsyncStubCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long NdrDcomAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static FunctionDescriptor NdrDcomAsyncStubCall$descriptor() {
        return NdrDcomAsyncStubCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long NdrDcomAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MethodHandle NdrDcomAsyncStubCall$handle() {
        return NdrDcomAsyncStubCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long NdrDcomAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MemorySegment NdrDcomAsyncStubCall$address() {
        return NdrDcomAsyncStubCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long NdrDcomAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static int NdrDcomAsyncStubCall(MemorySegment pThis, MemorySegment pChannel, MemorySegment pRpcMsg, MemorySegment pdwStubPhase) {
        var mh$ = NdrDcomAsyncStubCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrDcomAsyncStubCall", pThis, pChannel, pRpcMsg, pdwStubPhase);
            }
            return (int)mh$.invokeExact(pThis, pChannel, pRpcMsg, pdwStubPhase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrStubCall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrStubCall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long NdrStubCall2(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static FunctionDescriptor NdrStubCall2$descriptor() {
        return NdrStubCall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long NdrStubCall2(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MethodHandle NdrStubCall2$handle() {
        return NdrStubCall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long NdrStubCall2(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MemorySegment NdrStubCall2$address() {
        return NdrStubCall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long NdrStubCall2(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static int NdrStubCall2(MemorySegment pThis, MemorySegment pChannel, MemorySegment pRpcMsg, MemorySegment pdwStubPhase) {
        var mh$ = NdrStubCall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrStubCall2", pThis, pChannel, pRpcMsg, pdwStubPhase);
            }
            return (int)mh$.invokeExact(pThis, pChannel, pRpcMsg, pdwStubPhase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerCall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerCall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerCall2(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor NdrServerCall2$descriptor() {
        return NdrServerCall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerCall2(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle NdrServerCall2$handle() {
        return NdrServerCall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerCall2(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment NdrServerCall2$address() {
        return NdrServerCall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerCall2(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static void NdrServerCall2(MemorySegment pRpcMsg) {
        var mh$ = NdrServerCall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerCall2", pRpcMsg);
            }
            mh$.invokeExact(pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrStubCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrStubCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long NdrStubCall(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static FunctionDescriptor NdrStubCall$descriptor() {
        return NdrStubCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long NdrStubCall(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MethodHandle NdrStubCall$handle() {
        return NdrStubCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long NdrStubCall(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MemorySegment NdrStubCall$address() {
        return NdrStubCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long NdrStubCall(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static int NdrStubCall(MemorySegment pThis, MemorySegment pChannel, MemorySegment pRpcMsg, MemorySegment pdwStubPhase) {
        var mh$ = NdrStubCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrStubCall", pThis, pChannel, pRpcMsg, pdwStubPhase);
            }
            return (int)mh$.invokeExact(pThis, pChannel, pRpcMsg, pdwStubPhase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor NdrServerCall$descriptor() {
        return NdrServerCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle NdrServerCall$handle() {
        return NdrServerCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment NdrServerCall$address() {
        return NdrServerCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static void NdrServerCall(MemorySegment pRpcMsg) {
        var mh$ = NdrServerCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerCall", pRpcMsg);
            }
            mh$.invokeExact(pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NdrServerUnmarshall(void *pChannel, PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, void *pParamList)
     * }
     */
    public static FunctionDescriptor NdrServerUnmarshall$descriptor() {
        return NdrServerUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NdrServerUnmarshall(void *pChannel, PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, void *pParamList)
     * }
     */
    public static MethodHandle NdrServerUnmarshall$handle() {
        return NdrServerUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NdrServerUnmarshall(void *pChannel, PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, void *pParamList)
     * }
     */
    public static MemorySegment NdrServerUnmarshall$address() {
        return NdrServerUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NdrServerUnmarshall(void *pChannel, PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, void *pParamList)
     * }
     */
    public static int NdrServerUnmarshall(MemorySegment pChannel, MemorySegment pRpcMsg, MemorySegment pStubMsg, MemorySegment pStubDescriptor, MemorySegment pFormat, MemorySegment pParamList) {
        var mh$ = NdrServerUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerUnmarshall", pChannel, pRpcMsg, pStubMsg, pStubDescriptor, pFormat, pParamList);
            }
            return (int)mh$.invokeExact(pChannel, pRpcMsg, pStubMsg, pStubDescriptor, pFormat, pParamList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerMarshall(void *pThis, void *pChannel, PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrServerMarshall$descriptor() {
        return NdrServerMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerMarshall(void *pThis, void *pChannel, PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrServerMarshall$handle() {
        return NdrServerMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerMarshall(void *pThis, void *pChannel, PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrServerMarshall$address() {
        return NdrServerMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerMarshall(void *pThis, void *pChannel, PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrServerMarshall(MemorySegment pThis, MemorySegment pChannel, MemorySegment pStubMsg, MemorySegment pFormat) {
        var mh$ = NdrServerMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerMarshall", pThis, pChannel, pStubMsg, pFormat);
            }
            mh$.invokeExact(pThis, pChannel, pStubMsg, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrMapCommAndFaultStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrMapCommAndFaultStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS NdrMapCommAndFaultStatus(PMIDL_STUB_MESSAGE pStubMsg, unsigned long *pCommStatus, unsigned long *pFaultStatus, RPC_STATUS Status)
     * }
     */
    public static FunctionDescriptor NdrMapCommAndFaultStatus$descriptor() {
        return NdrMapCommAndFaultStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS NdrMapCommAndFaultStatus(PMIDL_STUB_MESSAGE pStubMsg, unsigned long *pCommStatus, unsigned long *pFaultStatus, RPC_STATUS Status)
     * }
     */
    public static MethodHandle NdrMapCommAndFaultStatus$handle() {
        return NdrMapCommAndFaultStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS NdrMapCommAndFaultStatus(PMIDL_STUB_MESSAGE pStubMsg, unsigned long *pCommStatus, unsigned long *pFaultStatus, RPC_STATUS Status)
     * }
     */
    public static MemorySegment NdrMapCommAndFaultStatus$address() {
        return NdrMapCommAndFaultStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS NdrMapCommAndFaultStatus(PMIDL_STUB_MESSAGE pStubMsg, unsigned long *pCommStatus, unsigned long *pFaultStatus, RPC_STATUS Status)
     * }
     */
    public static int NdrMapCommAndFaultStatus(MemorySegment pStubMsg, MemorySegment pCommStatus, MemorySegment pFaultStatus, int Status) {
        var mh$ = NdrMapCommAndFaultStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrMapCommAndFaultStatus", pStubMsg, pCommStatus, pFaultStatus, Status);
            }
            return (int)mh$.invokeExact(pStubMsg, pCommStatus, pFaultStatus, Status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *RPC_SS_THREAD_HANDLE
     * }
     */
    public static final AddressLayout RPC_SS_THREAD_HANDLE = winapi.C_POINTER;

    private static class RpcSsAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSsAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *RpcSsAllocate(size_t Size)
     * }
     */
    public static FunctionDescriptor RpcSsAllocate$descriptor() {
        return RpcSsAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *RpcSsAllocate(size_t Size)
     * }
     */
    public static MethodHandle RpcSsAllocate$handle() {
        return RpcSsAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *RpcSsAllocate(size_t Size)
     * }
     */
    public static MemorySegment RpcSsAllocate$address() {
        return RpcSsAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *RpcSsAllocate(size_t Size)
     * }
     */
    public static MemorySegment RpcSsAllocate(long Size) {
        var mh$ = RpcSsAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsAllocate", Size);
            }
            return (MemorySegment)mh$.invokeExact(Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsDisableAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSsDisableAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcSsDisableAllocate()
     * }
     */
    public static FunctionDescriptor RpcSsDisableAllocate$descriptor() {
        return RpcSsDisableAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcSsDisableAllocate()
     * }
     */
    public static MethodHandle RpcSsDisableAllocate$handle() {
        return RpcSsDisableAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcSsDisableAllocate()
     * }
     */
    public static MemorySegment RpcSsDisableAllocate$address() {
        return RpcSsDisableAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcSsDisableAllocate()
     * }
     */
    public static void RpcSsDisableAllocate() {
        var mh$ = RpcSsDisableAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsDisableAllocate");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsEnableAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSsEnableAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcSsEnableAllocate()
     * }
     */
    public static FunctionDescriptor RpcSsEnableAllocate$descriptor() {
        return RpcSsEnableAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcSsEnableAllocate()
     * }
     */
    public static MethodHandle RpcSsEnableAllocate$handle() {
        return RpcSsEnableAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcSsEnableAllocate()
     * }
     */
    public static MemorySegment RpcSsEnableAllocate$address() {
        return RpcSsEnableAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcSsEnableAllocate()
     * }
     */
    public static void RpcSsEnableAllocate() {
        var mh$ = RpcSsEnableAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsEnableAllocate");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSsFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcSsFree(void *NodeToFree)
     * }
     */
    public static FunctionDescriptor RpcSsFree$descriptor() {
        return RpcSsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcSsFree(void *NodeToFree)
     * }
     */
    public static MethodHandle RpcSsFree$handle() {
        return RpcSsFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcSsFree(void *NodeToFree)
     * }
     */
    public static MemorySegment RpcSsFree$address() {
        return RpcSsFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcSsFree(void *NodeToFree)
     * }
     */
    public static void RpcSsFree(MemorySegment NodeToFree) {
        var mh$ = RpcSsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsFree", NodeToFree);
            }
            mh$.invokeExact(NodeToFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsGetThreadHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSsGetThreadHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_SS_THREAD_HANDLE RpcSsGetThreadHandle()
     * }
     */
    public static FunctionDescriptor RpcSsGetThreadHandle$descriptor() {
        return RpcSsGetThreadHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_SS_THREAD_HANDLE RpcSsGetThreadHandle()
     * }
     */
    public static MethodHandle RpcSsGetThreadHandle$handle() {
        return RpcSsGetThreadHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_SS_THREAD_HANDLE RpcSsGetThreadHandle()
     * }
     */
    public static MemorySegment RpcSsGetThreadHandle$address() {
        return RpcSsGetThreadHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_SS_THREAD_HANDLE RpcSsGetThreadHandle()
     * }
     */
    public static MemorySegment RpcSsGetThreadHandle() {
        var mh$ = RpcSsGetThreadHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsGetThreadHandle");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsSetClientAllocFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSsSetClientAllocFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcSsSetClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree)
     * }
     */
    public static FunctionDescriptor RpcSsSetClientAllocFree$descriptor() {
        return RpcSsSetClientAllocFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcSsSetClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree)
     * }
     */
    public static MethodHandle RpcSsSetClientAllocFree$handle() {
        return RpcSsSetClientAllocFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcSsSetClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree)
     * }
     */
    public static MemorySegment RpcSsSetClientAllocFree$address() {
        return RpcSsSetClientAllocFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcSsSetClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree)
     * }
     */
    public static void RpcSsSetClientAllocFree(MemorySegment ClientAlloc, MemorySegment ClientFree) {
        var mh$ = RpcSsSetClientAllocFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsSetClientAllocFree", ClientAlloc, ClientFree);
            }
            mh$.invokeExact(ClientAlloc, ClientFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsSetThreadHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSsSetThreadHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcSsSetThreadHandle(RPC_SS_THREAD_HANDLE Id)
     * }
     */
    public static FunctionDescriptor RpcSsSetThreadHandle$descriptor() {
        return RpcSsSetThreadHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcSsSetThreadHandle(RPC_SS_THREAD_HANDLE Id)
     * }
     */
    public static MethodHandle RpcSsSetThreadHandle$handle() {
        return RpcSsSetThreadHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcSsSetThreadHandle(RPC_SS_THREAD_HANDLE Id)
     * }
     */
    public static MemorySegment RpcSsSetThreadHandle$address() {
        return RpcSsSetThreadHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcSsSetThreadHandle(RPC_SS_THREAD_HANDLE Id)
     * }
     */
    public static void RpcSsSetThreadHandle(MemorySegment Id) {
        var mh$ = RpcSsSetThreadHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsSetThreadHandle", Id);
            }
            mh$.invokeExact(Id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsSwapClientAllocFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSsSwapClientAllocFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcSsSwapClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree, RPC_CLIENT_ALLOC **OldClientAlloc, RPC_CLIENT_FREE **OldClientFree)
     * }
     */
    public static FunctionDescriptor RpcSsSwapClientAllocFree$descriptor() {
        return RpcSsSwapClientAllocFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcSsSwapClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree, RPC_CLIENT_ALLOC **OldClientAlloc, RPC_CLIENT_FREE **OldClientFree)
     * }
     */
    public static MethodHandle RpcSsSwapClientAllocFree$handle() {
        return RpcSsSwapClientAllocFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcSsSwapClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree, RPC_CLIENT_ALLOC **OldClientAlloc, RPC_CLIENT_FREE **OldClientFree)
     * }
     */
    public static MemorySegment RpcSsSwapClientAllocFree$address() {
        return RpcSsSwapClientAllocFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcSsSwapClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree, RPC_CLIENT_ALLOC **OldClientAlloc, RPC_CLIENT_FREE **OldClientFree)
     * }
     */
    public static void RpcSsSwapClientAllocFree(MemorySegment ClientAlloc, MemorySegment ClientFree, MemorySegment OldClientAlloc, MemorySegment OldClientFree) {
        var mh$ = RpcSsSwapClientAllocFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsSwapClientAllocFree", ClientAlloc, ClientFree, OldClientAlloc, OldClientFree);
            }
            mh$.invokeExact(ClientAlloc, ClientFree, OldClientAlloc, OldClientFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *RpcSmAllocate(size_t Size, RPC_STATUS *pStatus)
     * }
     */
    public static FunctionDescriptor RpcSmAllocate$descriptor() {
        return RpcSmAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *RpcSmAllocate(size_t Size, RPC_STATUS *pStatus)
     * }
     */
    public static MethodHandle RpcSmAllocate$handle() {
        return RpcSmAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *RpcSmAllocate(size_t Size, RPC_STATUS *pStatus)
     * }
     */
    public static MemorySegment RpcSmAllocate$address() {
        return RpcSmAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *RpcSmAllocate(size_t Size, RPC_STATUS *pStatus)
     * }
     */
    public static MemorySegment RpcSmAllocate(long Size, MemorySegment pStatus) {
        var mh$ = RpcSmAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmAllocate", Size, pStatus);
            }
            return (MemorySegment)mh$.invokeExact(Size, pStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmClientFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmClientFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmClientFree(void *pNodeToFree)
     * }
     */
    public static FunctionDescriptor RpcSmClientFree$descriptor() {
        return RpcSmClientFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmClientFree(void *pNodeToFree)
     * }
     */
    public static MethodHandle RpcSmClientFree$handle() {
        return RpcSmClientFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmClientFree(void *pNodeToFree)
     * }
     */
    public static MemorySegment RpcSmClientFree$address() {
        return RpcSmClientFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSmClientFree(void *pNodeToFree)
     * }
     */
    public static int RpcSmClientFree(MemorySegment pNodeToFree) {
        var mh$ = RpcSmClientFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmClientFree", pNodeToFree);
            }
            return (int)mh$.invokeExact(pNodeToFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmDestroyClientContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmDestroyClientContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmDestroyClientContext(void **ContextHandle)
     * }
     */
    public static FunctionDescriptor RpcSmDestroyClientContext$descriptor() {
        return RpcSmDestroyClientContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmDestroyClientContext(void **ContextHandle)
     * }
     */
    public static MethodHandle RpcSmDestroyClientContext$handle() {
        return RpcSmDestroyClientContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmDestroyClientContext(void **ContextHandle)
     * }
     */
    public static MemorySegment RpcSmDestroyClientContext$address() {
        return RpcSmDestroyClientContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSmDestroyClientContext(void **ContextHandle)
     * }
     */
    public static int RpcSmDestroyClientContext(MemorySegment ContextHandle) {
        var mh$ = RpcSmDestroyClientContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmDestroyClientContext", ContextHandle);
            }
            return (int)mh$.invokeExact(ContextHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmDisableAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmDisableAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmDisableAllocate()
     * }
     */
    public static FunctionDescriptor RpcSmDisableAllocate$descriptor() {
        return RpcSmDisableAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmDisableAllocate()
     * }
     */
    public static MethodHandle RpcSmDisableAllocate$handle() {
        return RpcSmDisableAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmDisableAllocate()
     * }
     */
    public static MemorySegment RpcSmDisableAllocate$address() {
        return RpcSmDisableAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSmDisableAllocate()
     * }
     */
    public static int RpcSmDisableAllocate() {
        var mh$ = RpcSmDisableAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmDisableAllocate");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmEnableAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmEnableAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmEnableAllocate()
     * }
     */
    public static FunctionDescriptor RpcSmEnableAllocate$descriptor() {
        return RpcSmEnableAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmEnableAllocate()
     * }
     */
    public static MethodHandle RpcSmEnableAllocate$handle() {
        return RpcSmEnableAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmEnableAllocate()
     * }
     */
    public static MemorySegment RpcSmEnableAllocate$address() {
        return RpcSmEnableAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSmEnableAllocate()
     * }
     */
    public static int RpcSmEnableAllocate() {
        var mh$ = RpcSmEnableAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmEnableAllocate");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmFree(void *NodeToFree)
     * }
     */
    public static FunctionDescriptor RpcSmFree$descriptor() {
        return RpcSmFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmFree(void *NodeToFree)
     * }
     */
    public static MethodHandle RpcSmFree$handle() {
        return RpcSmFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmFree(void *NodeToFree)
     * }
     */
    public static MemorySegment RpcSmFree$address() {
        return RpcSmFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSmFree(void *NodeToFree)
     * }
     */
    public static int RpcSmFree(MemorySegment NodeToFree) {
        var mh$ = RpcSmFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmFree", NodeToFree);
            }
            return (int)mh$.invokeExact(NodeToFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmGetThreadHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmGetThreadHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_SS_THREAD_HANDLE RpcSmGetThreadHandle(RPC_STATUS *pStatus)
     * }
     */
    public static FunctionDescriptor RpcSmGetThreadHandle$descriptor() {
        return RpcSmGetThreadHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_SS_THREAD_HANDLE RpcSmGetThreadHandle(RPC_STATUS *pStatus)
     * }
     */
    public static MethodHandle RpcSmGetThreadHandle$handle() {
        return RpcSmGetThreadHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_SS_THREAD_HANDLE RpcSmGetThreadHandle(RPC_STATUS *pStatus)
     * }
     */
    public static MemorySegment RpcSmGetThreadHandle$address() {
        return RpcSmGetThreadHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_SS_THREAD_HANDLE RpcSmGetThreadHandle(RPC_STATUS *pStatus)
     * }
     */
    public static MemorySegment RpcSmGetThreadHandle(MemorySegment pStatus) {
        var mh$ = RpcSmGetThreadHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmGetThreadHandle", pStatus);
            }
            return (MemorySegment)mh$.invokeExact(pStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmSetClientAllocFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmSetClientAllocFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSetClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree)
     * }
     */
    public static FunctionDescriptor RpcSmSetClientAllocFree$descriptor() {
        return RpcSmSetClientAllocFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSetClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree)
     * }
     */
    public static MethodHandle RpcSmSetClientAllocFree$handle() {
        return RpcSmSetClientAllocFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSetClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree)
     * }
     */
    public static MemorySegment RpcSmSetClientAllocFree$address() {
        return RpcSmSetClientAllocFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSetClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree)
     * }
     */
    public static int RpcSmSetClientAllocFree(MemorySegment ClientAlloc, MemorySegment ClientFree) {
        var mh$ = RpcSmSetClientAllocFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmSetClientAllocFree", ClientAlloc, ClientFree);
            }
            return (int)mh$.invokeExact(ClientAlloc, ClientFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmSetThreadHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmSetThreadHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSetThreadHandle(RPC_SS_THREAD_HANDLE Id)
     * }
     */
    public static FunctionDescriptor RpcSmSetThreadHandle$descriptor() {
        return RpcSmSetThreadHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSetThreadHandle(RPC_SS_THREAD_HANDLE Id)
     * }
     */
    public static MethodHandle RpcSmSetThreadHandle$handle() {
        return RpcSmSetThreadHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSetThreadHandle(RPC_SS_THREAD_HANDLE Id)
     * }
     */
    public static MemorySegment RpcSmSetThreadHandle$address() {
        return RpcSmSetThreadHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSetThreadHandle(RPC_SS_THREAD_HANDLE Id)
     * }
     */
    public static int RpcSmSetThreadHandle(MemorySegment Id) {
        var mh$ = RpcSmSetThreadHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmSetThreadHandle", Id);
            }
            return (int)mh$.invokeExact(Id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSmSwapClientAllocFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcSmSwapClientAllocFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSwapClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree, RPC_CLIENT_ALLOC **OldClientAlloc, RPC_CLIENT_FREE **OldClientFree)
     * }
     */
    public static FunctionDescriptor RpcSmSwapClientAllocFree$descriptor() {
        return RpcSmSwapClientAllocFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSwapClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree, RPC_CLIENT_ALLOC **OldClientAlloc, RPC_CLIENT_FREE **OldClientFree)
     * }
     */
    public static MethodHandle RpcSmSwapClientAllocFree$handle() {
        return RpcSmSwapClientAllocFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSwapClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree, RPC_CLIENT_ALLOC **OldClientAlloc, RPC_CLIENT_FREE **OldClientFree)
     * }
     */
    public static MemorySegment RpcSmSwapClientAllocFree$address() {
        return RpcSmSwapClientAllocFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSmSwapClientAllocFree(RPC_CLIENT_ALLOC *ClientAlloc, RPC_CLIENT_FREE *ClientFree, RPC_CLIENT_ALLOC **OldClientAlloc, RPC_CLIENT_FREE **OldClientFree)
     * }
     */
    public static int RpcSmSwapClientAllocFree(MemorySegment ClientAlloc, MemorySegment ClientFree, MemorySegment OldClientAlloc, MemorySegment OldClientFree) {
        var mh$ = RpcSmSwapClientAllocFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSmSwapClientAllocFree", ClientAlloc, ClientFree, OldClientAlloc, OldClientFree);
            }
            return (int)mh$.invokeExact(ClientAlloc, ClientFree, OldClientAlloc, OldClientFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrRpcSsEnableAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrRpcSsEnableAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrRpcSsEnableAllocate(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static FunctionDescriptor NdrRpcSsEnableAllocate$descriptor() {
        return NdrRpcSsEnableAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrRpcSsEnableAllocate(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static MethodHandle NdrRpcSsEnableAllocate$handle() {
        return NdrRpcSsEnableAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrRpcSsEnableAllocate(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static MemorySegment NdrRpcSsEnableAllocate$address() {
        return NdrRpcSsEnableAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrRpcSsEnableAllocate(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static void NdrRpcSsEnableAllocate(MemorySegment pMessage) {
        var mh$ = NdrRpcSsEnableAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrRpcSsEnableAllocate", pMessage);
            }
            mh$.invokeExact(pMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrRpcSsDisableAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrRpcSsDisableAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrRpcSsDisableAllocate(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static FunctionDescriptor NdrRpcSsDisableAllocate$descriptor() {
        return NdrRpcSsDisableAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrRpcSsDisableAllocate(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static MethodHandle NdrRpcSsDisableAllocate$handle() {
        return NdrRpcSsDisableAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrRpcSsDisableAllocate(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static MemorySegment NdrRpcSsDisableAllocate$address() {
        return NdrRpcSsDisableAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrRpcSsDisableAllocate(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static void NdrRpcSsDisableAllocate(MemorySegment pMessage) {
        var mh$ = NdrRpcSsDisableAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrRpcSsDisableAllocate", pMessage);
            }
            mh$.invokeExact(pMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrRpcSmSetClientToOsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrRpcSmSetClientToOsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrRpcSmSetClientToOsf(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static FunctionDescriptor NdrRpcSmSetClientToOsf$descriptor() {
        return NdrRpcSmSetClientToOsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrRpcSmSetClientToOsf(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static MethodHandle NdrRpcSmSetClientToOsf$handle() {
        return NdrRpcSmSetClientToOsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrRpcSmSetClientToOsf(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static MemorySegment NdrRpcSmSetClientToOsf$address() {
        return NdrRpcSmSetClientToOsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrRpcSmSetClientToOsf(PMIDL_STUB_MESSAGE pMessage)
     * }
     */
    public static void NdrRpcSmSetClientToOsf(MemorySegment pMessage) {
        var mh$ = NdrRpcSmSetClientToOsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrRpcSmSetClientToOsf", pMessage);
            }
            mh$.invokeExact(pMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrRpcSmClientAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrRpcSmClientAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *NdrRpcSmClientAllocate(size_t Size)
     * }
     */
    public static FunctionDescriptor NdrRpcSmClientAllocate$descriptor() {
        return NdrRpcSmClientAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *NdrRpcSmClientAllocate(size_t Size)
     * }
     */
    public static MethodHandle NdrRpcSmClientAllocate$handle() {
        return NdrRpcSmClientAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *NdrRpcSmClientAllocate(size_t Size)
     * }
     */
    public static MemorySegment NdrRpcSmClientAllocate$address() {
        return NdrRpcSmClientAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *NdrRpcSmClientAllocate(size_t Size)
     * }
     */
    public static MemorySegment NdrRpcSmClientAllocate(long Size) {
        var mh$ = NdrRpcSmClientAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrRpcSmClientAllocate", Size);
            }
            return (MemorySegment)mh$.invokeExact(Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrRpcSmClientFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrRpcSmClientFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrRpcSmClientFree(void *NodeToFree)
     * }
     */
    public static FunctionDescriptor NdrRpcSmClientFree$descriptor() {
        return NdrRpcSmClientFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrRpcSmClientFree(void *NodeToFree)
     * }
     */
    public static MethodHandle NdrRpcSmClientFree$handle() {
        return NdrRpcSmClientFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrRpcSmClientFree(void *NodeToFree)
     * }
     */
    public static MemorySegment NdrRpcSmClientFree$address() {
        return NdrRpcSmClientFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrRpcSmClientFree(void *NodeToFree)
     * }
     */
    public static void NdrRpcSmClientFree(MemorySegment NodeToFree) {
        var mh$ = NdrRpcSmClientFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrRpcSmClientFree", NodeToFree);
            }
            mh$.invokeExact(NodeToFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrRpcSsDefaultAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrRpcSsDefaultAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *NdrRpcSsDefaultAllocate(size_t Size)
     * }
     */
    public static FunctionDescriptor NdrRpcSsDefaultAllocate$descriptor() {
        return NdrRpcSsDefaultAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *NdrRpcSsDefaultAllocate(size_t Size)
     * }
     */
    public static MethodHandle NdrRpcSsDefaultAllocate$handle() {
        return NdrRpcSsDefaultAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *NdrRpcSsDefaultAllocate(size_t Size)
     * }
     */
    public static MemorySegment NdrRpcSsDefaultAllocate$address() {
        return NdrRpcSsDefaultAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *NdrRpcSsDefaultAllocate(size_t Size)
     * }
     */
    public static MemorySegment NdrRpcSsDefaultAllocate(long Size) {
        var mh$ = NdrRpcSsDefaultAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrRpcSsDefaultAllocate", Size);
            }
            return (MemorySegment)mh$.invokeExact(Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrRpcSsDefaultFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrRpcSsDefaultFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrRpcSsDefaultFree(void *NodeToFree)
     * }
     */
    public static FunctionDescriptor NdrRpcSsDefaultFree$descriptor() {
        return NdrRpcSsDefaultFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrRpcSsDefaultFree(void *NodeToFree)
     * }
     */
    public static MethodHandle NdrRpcSsDefaultFree$handle() {
        return NdrRpcSsDefaultFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrRpcSsDefaultFree(void *NodeToFree)
     * }
     */
    public static MemorySegment NdrRpcSsDefaultFree$address() {
        return NdrRpcSsDefaultFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrRpcSsDefaultFree(void *NodeToFree)
     * }
     */
    public static void NdrRpcSsDefaultFree(MemorySegment NodeToFree) {
        var mh$ = NdrRpcSsDefaultFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrRpcSsDefaultFree", NodeToFree);
            }
            mh$.invokeExact(NodeToFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrFullPointerXlatInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrFullPointerXlatInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PFULL_PTR_XLAT_TABLES NdrFullPointerXlatInit(unsigned long NumberOfPointers, XLAT_SIDE XlatSide)
     * }
     */
    public static FunctionDescriptor NdrFullPointerXlatInit$descriptor() {
        return NdrFullPointerXlatInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PFULL_PTR_XLAT_TABLES NdrFullPointerXlatInit(unsigned long NumberOfPointers, XLAT_SIDE XlatSide)
     * }
     */
    public static MethodHandle NdrFullPointerXlatInit$handle() {
        return NdrFullPointerXlatInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PFULL_PTR_XLAT_TABLES NdrFullPointerXlatInit(unsigned long NumberOfPointers, XLAT_SIDE XlatSide)
     * }
     */
    public static MemorySegment NdrFullPointerXlatInit$address() {
        return NdrFullPointerXlatInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PFULL_PTR_XLAT_TABLES NdrFullPointerXlatInit(unsigned long NumberOfPointers, XLAT_SIDE XlatSide)
     * }
     */
    public static MemorySegment NdrFullPointerXlatInit(int NumberOfPointers, int XlatSide) {
        var mh$ = NdrFullPointerXlatInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrFullPointerXlatInit", NumberOfPointers, XlatSide);
            }
            return (MemorySegment)mh$.invokeExact(NumberOfPointers, XlatSide);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrFullPointerXlatFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrFullPointerXlatFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrFullPointerXlatFree(PFULL_PTR_XLAT_TABLES pXlatTables)
     * }
     */
    public static FunctionDescriptor NdrFullPointerXlatFree$descriptor() {
        return NdrFullPointerXlatFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrFullPointerXlatFree(PFULL_PTR_XLAT_TABLES pXlatTables)
     * }
     */
    public static MethodHandle NdrFullPointerXlatFree$handle() {
        return NdrFullPointerXlatFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrFullPointerXlatFree(PFULL_PTR_XLAT_TABLES pXlatTables)
     * }
     */
    public static MemorySegment NdrFullPointerXlatFree$address() {
        return NdrFullPointerXlatFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrFullPointerXlatFree(PFULL_PTR_XLAT_TABLES pXlatTables)
     * }
     */
    public static void NdrFullPointerXlatFree(MemorySegment pXlatTables) {
        var mh$ = NdrFullPointerXlatFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrFullPointerXlatFree", pXlatTables);
            }
            mh$.invokeExact(pXlatTables);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *NdrAllocate(PMIDL_STUB_MESSAGE pStubMsg, size_t Len)
     * }
     */
    public static FunctionDescriptor NdrAllocate$descriptor() {
        return NdrAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *NdrAllocate(PMIDL_STUB_MESSAGE pStubMsg, size_t Len)
     * }
     */
    public static MethodHandle NdrAllocate$handle() {
        return NdrAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *NdrAllocate(PMIDL_STUB_MESSAGE pStubMsg, size_t Len)
     * }
     */
    public static MemorySegment NdrAllocate$address() {
        return NdrAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *NdrAllocate(PMIDL_STUB_MESSAGE pStubMsg, size_t Len)
     * }
     */
    public static MemorySegment NdrAllocate(MemorySegment pStubMsg, long Len) {
        var mh$ = NdrAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrAllocate", pStubMsg, Len);
            }
            return (MemorySegment)mh$.invokeExact(pStubMsg, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrClearOutParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrClearOutParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrClearOutParameters(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, void *ArgAddr)
     * }
     */
    public static FunctionDescriptor NdrClearOutParameters$descriptor() {
        return NdrClearOutParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrClearOutParameters(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, void *ArgAddr)
     * }
     */
    public static MethodHandle NdrClearOutParameters$handle() {
        return NdrClearOutParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrClearOutParameters(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, void *ArgAddr)
     * }
     */
    public static MemorySegment NdrClearOutParameters$address() {
        return NdrClearOutParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrClearOutParameters(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, void *ArgAddr)
     * }
     */
    public static void NdrClearOutParameters(MemorySegment pStubMsg, MemorySegment pFormat, MemorySegment ArgAddr) {
        var mh$ = NdrClearOutParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrClearOutParameters", pStubMsg, pFormat, ArgAddr);
            }
            mh$.invokeExact(pStubMsg, pFormat, ArgAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrOleAllocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrOleAllocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *NdrOleAllocate(size_t Size)
     * }
     */
    public static FunctionDescriptor NdrOleAllocate$descriptor() {
        return NdrOleAllocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *NdrOleAllocate(size_t Size)
     * }
     */
    public static MethodHandle NdrOleAllocate$handle() {
        return NdrOleAllocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *NdrOleAllocate(size_t Size)
     * }
     */
    public static MemorySegment NdrOleAllocate$address() {
        return NdrOleAllocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *NdrOleAllocate(size_t Size)
     * }
     */
    public static MemorySegment NdrOleAllocate(long Size) {
        var mh$ = NdrOleAllocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrOleAllocate", Size);
            }
            return (MemorySegment)mh$.invokeExact(Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrOleFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrOleFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrOleFree(void *NodeToFree)
     * }
     */
    public static FunctionDescriptor NdrOleFree$descriptor() {
        return NdrOleFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrOleFree(void *NodeToFree)
     * }
     */
    public static MethodHandle NdrOleFree$handle() {
        return NdrOleFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrOleFree(void *NodeToFree)
     * }
     */
    public static MemorySegment NdrOleFree$address() {
        return NdrOleFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrOleFree(void *NodeToFree)
     * }
     */
    public static void NdrOleFree(MemorySegment NodeToFree) {
        var mh$ = NdrOleFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrOleFree", NodeToFree);
            }
            mh$.invokeExact(NodeToFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrGetUserMarshalInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrGetUserMarshalInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS NdrGetUserMarshalInfo(unsigned long *pFlags, unsigned long InformationLevel, NDR_USER_MARSHAL_INFO *pMarshalInfo)
     * }
     */
    public static FunctionDescriptor NdrGetUserMarshalInfo$descriptor() {
        return NdrGetUserMarshalInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS NdrGetUserMarshalInfo(unsigned long *pFlags, unsigned long InformationLevel, NDR_USER_MARSHAL_INFO *pMarshalInfo)
     * }
     */
    public static MethodHandle NdrGetUserMarshalInfo$handle() {
        return NdrGetUserMarshalInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS NdrGetUserMarshalInfo(unsigned long *pFlags, unsigned long InformationLevel, NDR_USER_MARSHAL_INFO *pMarshalInfo)
     * }
     */
    public static MemorySegment NdrGetUserMarshalInfo$address() {
        return NdrGetUserMarshalInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS NdrGetUserMarshalInfo(unsigned long *pFlags, unsigned long InformationLevel, NDR_USER_MARSHAL_INFO *pMarshalInfo)
     * }
     */
    public static int NdrGetUserMarshalInfo(MemorySegment pFlags, int InformationLevel, MemorySegment pMarshalInfo) {
        var mh$ = NdrGetUserMarshalInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrGetUserMarshalInfo", pFlags, InformationLevel, pMarshalInfo);
            }
            return (int)mh$.invokeExact(pFlags, InformationLevel, pMarshalInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrCreateServerInterfaceFromStub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrCreateServerInterfaceFromStub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS NdrCreateServerInterfaceFromStub(struct IRpcStubBuffer *pStub, RPC_SERVER_INTERFACE *pServerIf)
     * }
     */
    public static FunctionDescriptor NdrCreateServerInterfaceFromStub$descriptor() {
        return NdrCreateServerInterfaceFromStub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS NdrCreateServerInterfaceFromStub(struct IRpcStubBuffer *pStub, RPC_SERVER_INTERFACE *pServerIf)
     * }
     */
    public static MethodHandle NdrCreateServerInterfaceFromStub$handle() {
        return NdrCreateServerInterfaceFromStub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * RPC_STATUS NdrCreateServerInterfaceFromStub(struct IRpcStubBuffer *pStub, RPC_SERVER_INTERFACE *pServerIf)
     * }
     */
    public static MemorySegment NdrCreateServerInterfaceFromStub$address() {
        return NdrCreateServerInterfaceFromStub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * RPC_STATUS NdrCreateServerInterfaceFromStub(struct IRpcStubBuffer *pStub, RPC_SERVER_INTERFACE *pServerIf)
     * }
     */
    public static int NdrCreateServerInterfaceFromStub(MemorySegment pStub, MemorySegment pServerIf) {
        var mh$ = NdrCreateServerInterfaceFromStub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrCreateServerInterfaceFromStub", pStub, pServerIf);
            }
            return (int)mh$.invokeExact(pStub, pServerIf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * CLIENT_CALL_RETURN NdrClientCall3(MIDL_STUBLESS_PROXY_INFO *pProxyInfo, unsigned long nProcNum, void *pReturnValue, ...)
     * }
     */
    public static class NdrClientCall3 {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                _CLIENT_CALL_RETURN.layout(),
                winapi.C_POINTER,
                winapi.C_LONG,
                winapi.C_POINTER
            );
        private static final MemorySegment ADDR = winapi.findOrThrow("NdrClientCall3");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private NdrClientCall3(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * CLIENT_CALL_RETURN NdrClientCall3(MIDL_STUBLESS_PROXY_INFO *pProxyInfo, unsigned long nProcNum, void *pReturnValue, ...)
         * }
         */
        public static NdrClientCall3 makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new NdrClientCall3(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, MemorySegment pProxyInfo, int nProcNum, MemorySegment pReturnValue, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("NdrClientCall3", allocator, pProxyInfo, nProcNum, pReturnValue, x3);
                }
                return (MemorySegment) spreader.invokeExact(allocator, pProxyInfo, nProcNum, pReturnValue, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * CLIENT_CALL_RETURN Ndr64AsyncClientCall(MIDL_STUBLESS_PROXY_INFO *pProxyInfo, unsigned long nProcNum, void *pReturnValue, ...)
     * }
     */
    public static class Ndr64AsyncClientCall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                _CLIENT_CALL_RETURN.layout(),
                winapi.C_POINTER,
                winapi.C_LONG,
                winapi.C_POINTER
            );
        private static final MemorySegment ADDR = winapi.findOrThrow("Ndr64AsyncClientCall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private Ndr64AsyncClientCall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * CLIENT_CALL_RETURN Ndr64AsyncClientCall(MIDL_STUBLESS_PROXY_INFO *pProxyInfo, unsigned long nProcNum, void *pReturnValue, ...)
         * }
         */
        public static Ndr64AsyncClientCall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new Ndr64AsyncClientCall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, MemorySegment pProxyInfo, int nProcNum, MemorySegment pReturnValue, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("Ndr64AsyncClientCall", allocator, pProxyInfo, nProcNum, pReturnValue, x3);
                }
                return (MemorySegment) spreader.invokeExact(allocator, pProxyInfo, nProcNum, pReturnValue, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * CLIENT_CALL_RETURN Ndr64DcomAsyncClientCall(MIDL_STUBLESS_PROXY_INFO *pProxyInfo, unsigned long nProcNum, void *pReturnValue, ...)
     * }
     */
    public static class Ndr64DcomAsyncClientCall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                _CLIENT_CALL_RETURN.layout(),
                winapi.C_POINTER,
                winapi.C_LONG,
                winapi.C_POINTER
            );
        private static final MemorySegment ADDR = winapi.findOrThrow("Ndr64DcomAsyncClientCall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private Ndr64DcomAsyncClientCall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * CLIENT_CALL_RETURN Ndr64DcomAsyncClientCall(MIDL_STUBLESS_PROXY_INFO *pProxyInfo, unsigned long nProcNum, void *pReturnValue, ...)
         * }
         */
        public static Ndr64DcomAsyncClientCall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new Ndr64DcomAsyncClientCall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(SegmentAllocator allocator, MemorySegment pProxyInfo, int nProcNum, MemorySegment pReturnValue, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("Ndr64DcomAsyncClientCall", allocator, pProxyInfo, nProcNum, pReturnValue, x3);
                }
                return (MemorySegment) spreader.invokeExact(allocator, pProxyInfo, nProcNum, pReturnValue, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class Ndr64AsyncServerCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Ndr64AsyncServerCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Ndr64AsyncServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor Ndr64AsyncServerCall$descriptor() {
        return Ndr64AsyncServerCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Ndr64AsyncServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle Ndr64AsyncServerCall$handle() {
        return Ndr64AsyncServerCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Ndr64AsyncServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment Ndr64AsyncServerCall$address() {
        return Ndr64AsyncServerCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Ndr64AsyncServerCall(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static void Ndr64AsyncServerCall(MemorySegment pRpcMsg) {
        var mh$ = Ndr64AsyncServerCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ndr64AsyncServerCall", pRpcMsg);
            }
            mh$.invokeExact(pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ndr64AsyncServerCall64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Ndr64AsyncServerCall64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Ndr64AsyncServerCall64(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor Ndr64AsyncServerCall64$descriptor() {
        return Ndr64AsyncServerCall64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Ndr64AsyncServerCall64(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle Ndr64AsyncServerCall64$handle() {
        return Ndr64AsyncServerCall64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Ndr64AsyncServerCall64(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment Ndr64AsyncServerCall64$address() {
        return Ndr64AsyncServerCall64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Ndr64AsyncServerCall64(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static void Ndr64AsyncServerCall64(MemorySegment pRpcMsg) {
        var mh$ = Ndr64AsyncServerCall64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ndr64AsyncServerCall64", pRpcMsg);
            }
            mh$.invokeExact(pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ndr64AsyncServerCallAll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Ndr64AsyncServerCallAll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Ndr64AsyncServerCallAll(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor Ndr64AsyncServerCallAll$descriptor() {
        return Ndr64AsyncServerCallAll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Ndr64AsyncServerCallAll(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle Ndr64AsyncServerCallAll$handle() {
        return Ndr64AsyncServerCallAll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Ndr64AsyncServerCallAll(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment Ndr64AsyncServerCallAll$address() {
        return Ndr64AsyncServerCallAll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Ndr64AsyncServerCallAll(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static void Ndr64AsyncServerCallAll(MemorySegment pRpcMsg) {
        var mh$ = Ndr64AsyncServerCallAll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ndr64AsyncServerCallAll", pRpcMsg);
            }
            mh$.invokeExact(pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ndr64AsyncStubCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Ndr64AsyncStubCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long Ndr64AsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static FunctionDescriptor Ndr64AsyncStubCall$descriptor() {
        return Ndr64AsyncStubCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long Ndr64AsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MethodHandle Ndr64AsyncStubCall$handle() {
        return Ndr64AsyncStubCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long Ndr64AsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MemorySegment Ndr64AsyncStubCall$address() {
        return Ndr64AsyncStubCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long Ndr64AsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static int Ndr64AsyncStubCall(MemorySegment pThis, MemorySegment pChannel, MemorySegment pRpcMsg, MemorySegment pdwStubPhase) {
        var mh$ = Ndr64AsyncStubCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ndr64AsyncStubCall", pThis, pChannel, pRpcMsg, pdwStubPhase);
            }
            return (int)mh$.invokeExact(pThis, pChannel, pRpcMsg, pdwStubPhase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ndr64DcomAsyncStubCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Ndr64DcomAsyncStubCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long Ndr64DcomAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static FunctionDescriptor Ndr64DcomAsyncStubCall$descriptor() {
        return Ndr64DcomAsyncStubCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long Ndr64DcomAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MethodHandle Ndr64DcomAsyncStubCall$handle() {
        return Ndr64DcomAsyncStubCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long Ndr64DcomAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MemorySegment Ndr64DcomAsyncStubCall$address() {
        return Ndr64DcomAsyncStubCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long Ndr64DcomAsyncStubCall(struct IRpcStubBuffer *pThis, struct IRpcChannelBuffer *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static int Ndr64DcomAsyncStubCall(MemorySegment pThis, MemorySegment pChannel, MemorySegment pRpcMsg, MemorySegment pdwStubPhase) {
        var mh$ = Ndr64DcomAsyncStubCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ndr64DcomAsyncStubCall", pThis, pChannel, pRpcMsg, pdwStubPhase);
            }
            return (int)mh$.invokeExact(pThis, pChannel, pRpcMsg, pdwStubPhase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrStubCall3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrStubCall3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long NdrStubCall3(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static FunctionDescriptor NdrStubCall3$descriptor() {
        return NdrStubCall3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long NdrStubCall3(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MethodHandle NdrStubCall3$handle() {
        return NdrStubCall3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long NdrStubCall3(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static MemorySegment NdrStubCall3$address() {
        return NdrStubCall3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long NdrStubCall3(void *pThis, void *pChannel, PRPC_MESSAGE pRpcMsg, unsigned long *pdwStubPhase)
     * }
     */
    public static int NdrStubCall3(MemorySegment pThis, MemorySegment pChannel, MemorySegment pRpcMsg, MemorySegment pdwStubPhase) {
        var mh$ = NdrStubCall3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrStubCall3", pThis, pChannel, pRpcMsg, pdwStubPhase);
            }
            return (int)mh$.invokeExact(pThis, pChannel, pRpcMsg, pdwStubPhase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerCallAll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerCallAll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerCallAll(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor NdrServerCallAll$descriptor() {
        return NdrServerCallAll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerCallAll(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle NdrServerCallAll$handle() {
        return NdrServerCallAll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerCallAll(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment NdrServerCallAll$address() {
        return NdrServerCallAll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerCallAll(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static void NdrServerCallAll(MemorySegment pRpcMsg) {
        var mh$ = NdrServerCallAll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerCallAll", pRpcMsg);
            }
            mh$.invokeExact(pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerCallNdr64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerCallNdr64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerCallNdr64(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor NdrServerCallNdr64$descriptor() {
        return NdrServerCallNdr64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerCallNdr64(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle NdrServerCallNdr64$handle() {
        return NdrServerCallNdr64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerCallNdr64(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment NdrServerCallNdr64$address() {
        return NdrServerCallNdr64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerCallNdr64(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static void NdrServerCallNdr64(MemorySegment pRpcMsg) {
        var mh$ = NdrServerCallNdr64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerCallNdr64", pRpcMsg);
            }
            mh$.invokeExact(pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrServerCall3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrServerCall3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrServerCall3(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static FunctionDescriptor NdrServerCall3$descriptor() {
        return NdrServerCall3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrServerCall3(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MethodHandle NdrServerCall3$handle() {
        return NdrServerCall3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrServerCall3(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static MemorySegment NdrServerCall3$address() {
        return NdrServerCall3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrServerCall3(PRPC_MESSAGE pRpcMsg)
     * }
     */
    public static void NdrServerCall3(MemorySegment pRpcMsg) {
        var mh$ = NdrServerCall3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrServerCall3", pRpcMsg);
            }
            mh$.invokeExact(pRpcMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrPartialIgnoreClientMarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrPartialIgnoreClientMarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreClientMarshall(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory)
     * }
     */
    public static FunctionDescriptor NdrPartialIgnoreClientMarshall$descriptor() {
        return NdrPartialIgnoreClientMarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreClientMarshall(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory)
     * }
     */
    public static MethodHandle NdrPartialIgnoreClientMarshall$handle() {
        return NdrPartialIgnoreClientMarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreClientMarshall(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory)
     * }
     */
    public static MemorySegment NdrPartialIgnoreClientMarshall$address() {
        return NdrPartialIgnoreClientMarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrPartialIgnoreClientMarshall(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory)
     * }
     */
    public static void NdrPartialIgnoreClientMarshall(MemorySegment pStubMsg, MemorySegment pMemory) {
        var mh$ = NdrPartialIgnoreClientMarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrPartialIgnoreClientMarshall", pStubMsg, pMemory);
            }
            mh$.invokeExact(pStubMsg, pMemory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrPartialIgnoreServerUnmarshall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrPartialIgnoreServerUnmarshall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreServerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, void **ppMemory)
     * }
     */
    public static FunctionDescriptor NdrPartialIgnoreServerUnmarshall$descriptor() {
        return NdrPartialIgnoreServerUnmarshall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreServerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, void **ppMemory)
     * }
     */
    public static MethodHandle NdrPartialIgnoreServerUnmarshall$handle() {
        return NdrPartialIgnoreServerUnmarshall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreServerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, void **ppMemory)
     * }
     */
    public static MemorySegment NdrPartialIgnoreServerUnmarshall$address() {
        return NdrPartialIgnoreServerUnmarshall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrPartialIgnoreServerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, void **ppMemory)
     * }
     */
    public static void NdrPartialIgnoreServerUnmarshall(MemorySegment pStubMsg, MemorySegment ppMemory) {
        var mh$ = NdrPartialIgnoreServerUnmarshall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrPartialIgnoreServerUnmarshall", pStubMsg, ppMemory);
            }
            mh$.invokeExact(pStubMsg, ppMemory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrPartialIgnoreClientBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrPartialIgnoreClientBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreClientBufferSize(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory)
     * }
     */
    public static FunctionDescriptor NdrPartialIgnoreClientBufferSize$descriptor() {
        return NdrPartialIgnoreClientBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreClientBufferSize(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory)
     * }
     */
    public static MethodHandle NdrPartialIgnoreClientBufferSize$handle() {
        return NdrPartialIgnoreClientBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreClientBufferSize(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory)
     * }
     */
    public static MemorySegment NdrPartialIgnoreClientBufferSize$address() {
        return NdrPartialIgnoreClientBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrPartialIgnoreClientBufferSize(PMIDL_STUB_MESSAGE pStubMsg, void *pMemory)
     * }
     */
    public static void NdrPartialIgnoreClientBufferSize(MemorySegment pStubMsg, MemorySegment pMemory) {
        var mh$ = NdrPartialIgnoreClientBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrPartialIgnoreClientBufferSize", pStubMsg, pMemory);
            }
            mh$.invokeExact(pStubMsg, pMemory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NdrPartialIgnoreServerInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NdrPartialIgnoreServerInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreServerInitialize(PMIDL_STUB_MESSAGE pStubMsg, void **ppMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static FunctionDescriptor NdrPartialIgnoreServerInitialize$descriptor() {
        return NdrPartialIgnoreServerInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreServerInitialize(PMIDL_STUB_MESSAGE pStubMsg, void **ppMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MethodHandle NdrPartialIgnoreServerInitialize$handle() {
        return NdrPartialIgnoreServerInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NdrPartialIgnoreServerInitialize(PMIDL_STUB_MESSAGE pStubMsg, void **ppMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static MemorySegment NdrPartialIgnoreServerInitialize$address() {
        return NdrPartialIgnoreServerInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NdrPartialIgnoreServerInitialize(PMIDL_STUB_MESSAGE pStubMsg, void **ppMemory, PFORMAT_STRING pFormat)
     * }
     */
    public static void NdrPartialIgnoreServerInitialize(MemorySegment pStubMsg, MemorySegment ppMemory, MemorySegment pFormat) {
        var mh$ = NdrPartialIgnoreServerInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NdrPartialIgnoreServerInitialize", pStubMsg, ppMemory, pFormat);
            }
            mh$.invokeExact(pStubMsg, ppMemory, pFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcUserFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RpcUserFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcUserFree(handle_t AsyncHandle, void *pBuffer)
     * }
     */
    public static FunctionDescriptor RpcUserFree$descriptor() {
        return RpcUserFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcUserFree(handle_t AsyncHandle, void *pBuffer)
     * }
     */
    public static MethodHandle RpcUserFree$handle() {
        return RpcUserFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RpcUserFree(handle_t AsyncHandle, void *pBuffer)
     * }
     */
    public static MemorySegment RpcUserFree$address() {
        return RpcUserFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RpcUserFree(handle_t AsyncHandle, void *pBuffer)
     * }
     */
    public static void RpcUserFree(MemorySegment AsyncHandle, MemorySegment pBuffer) {
        var mh$ = RpcUserFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcUserFree", AsyncHandle, pBuffer);
            }
            mh$.invokeExact(AsyncHandle, pBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("__MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec
     * }
     */
    public static AddressLayout __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec$layout() {
        return __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec$segment() {
        return __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec() {
        return __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec$constants.SEGMENT.get(__MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec
     * }
     */
    public static void __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec(MemorySegment varValue) {
        __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec$constants.SEGMENT.set(__MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec$constants.LAYOUT, 0L, varValue);
    }

    private static class __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("__MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec
     * }
     */
    public static AddressLayout __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec$layout() {
        return __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec$segment() {
        return __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec() {
        return __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec$constants.SEGMENT.get(__MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec
     * }
     */
    public static void __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec(MemorySegment varValue) {
        __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec$constants.SEGMENT.set(__MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef WCHAR OLECHAR
     * }
     */
    public static final OfShort OLECHAR = winapi.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef OLECHAR *LPOLESTR
     * }
     */
    public static final AddressLayout LPOLESTR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const OLECHAR *LPCOLESTR
     * }
     */
    public static final AddressLayout LPCOLESTR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef double DOUBLE
     * }
     */
    public static final OfDouble DOUBLE = winapi.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef LONG SCODE
     * }
     */
    public static final OfInt SCODE = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef SCODE *PSCODE
     * }
     */
    public static final AddressLayout PSCODE = winapi.C_POINTER;
    private static final int MEMCTX_TASK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagMEMCTX.MEMCTX_TASK = 1
     * }
     */
    public static int MEMCTX_TASK() {
        return MEMCTX_TASK;
    }
    private static final int MEMCTX_SHARED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagMEMCTX.MEMCTX_SHARED = 2
     * }
     */
    public static int MEMCTX_SHARED() {
        return MEMCTX_SHARED;
    }
    private static final int MEMCTX_MACSYSTEM = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagMEMCTX.MEMCTX_MACSYSTEM = 3
     * }
     */
    public static int MEMCTX_MACSYSTEM() {
        return MEMCTX_MACSYSTEM;
    }
    private static final int MEMCTX_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum tagMEMCTX.MEMCTX_UNKNOWN = -1
     * }
     */
    public static int MEMCTX_UNKNOWN() {
        return MEMCTX_UNKNOWN;
    }
    private static final int MEMCTX_SAME = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum tagMEMCTX.MEMCTX_SAME = -2
     * }
     */
    public static int MEMCTX_SAME() {
        return MEMCTX_SAME;
    }
    private static final int CLSCTX_INPROC_SERVER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_INPROC_SERVER = 1
     * }
     */
    public static int CLSCTX_INPROC_SERVER() {
        return CLSCTX_INPROC_SERVER;
    }
    private static final int CLSCTX_INPROC_HANDLER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_INPROC_HANDLER = 2
     * }
     */
    public static int CLSCTX_INPROC_HANDLER() {
        return CLSCTX_INPROC_HANDLER;
    }
    private static final int CLSCTX_LOCAL_SERVER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_LOCAL_SERVER = 4
     * }
     */
    public static int CLSCTX_LOCAL_SERVER() {
        return CLSCTX_LOCAL_SERVER;
    }
    private static final int CLSCTX_INPROC_SERVER16 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_INPROC_SERVER16 = 8
     * }
     */
    public static int CLSCTX_INPROC_SERVER16() {
        return CLSCTX_INPROC_SERVER16;
    }
    private static final int CLSCTX_REMOTE_SERVER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_REMOTE_SERVER = 16
     * }
     */
    public static int CLSCTX_REMOTE_SERVER() {
        return CLSCTX_REMOTE_SERVER;
    }
    private static final int CLSCTX_INPROC_HANDLER16 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_INPROC_HANDLER16 = 32
     * }
     */
    public static int CLSCTX_INPROC_HANDLER16() {
        return CLSCTX_INPROC_HANDLER16;
    }
    private static final int CLSCTX_RESERVED1 = (int)64L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_RESERVED1 = 64
     * }
     */
    public static int CLSCTX_RESERVED1() {
        return CLSCTX_RESERVED1;
    }
    private static final int CLSCTX_RESERVED2 = (int)128L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_RESERVED2 = 128
     * }
     */
    public static int CLSCTX_RESERVED2() {
        return CLSCTX_RESERVED2;
    }
    private static final int CLSCTX_RESERVED3 = (int)256L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_RESERVED3 = 256
     * }
     */
    public static int CLSCTX_RESERVED3() {
        return CLSCTX_RESERVED3;
    }
    private static final int CLSCTX_RESERVED4 = (int)512L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_RESERVED4 = 512
     * }
     */
    public static int CLSCTX_RESERVED4() {
        return CLSCTX_RESERVED4;
    }
    private static final int CLSCTX_NO_CODE_DOWNLOAD = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_NO_CODE_DOWNLOAD = 1024
     * }
     */
    public static int CLSCTX_NO_CODE_DOWNLOAD() {
        return CLSCTX_NO_CODE_DOWNLOAD;
    }
    private static final int CLSCTX_RESERVED5 = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_RESERVED5 = 2048
     * }
     */
    public static int CLSCTX_RESERVED5() {
        return CLSCTX_RESERVED5;
    }
    private static final int CLSCTX_NO_CUSTOM_MARSHAL = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_NO_CUSTOM_MARSHAL = 4096
     * }
     */
    public static int CLSCTX_NO_CUSTOM_MARSHAL() {
        return CLSCTX_NO_CUSTOM_MARSHAL;
    }
    private static final int CLSCTX_ENABLE_CODE_DOWNLOAD = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_ENABLE_CODE_DOWNLOAD = 8192
     * }
     */
    public static int CLSCTX_ENABLE_CODE_DOWNLOAD() {
        return CLSCTX_ENABLE_CODE_DOWNLOAD;
    }
    private static final int CLSCTX_NO_FAILURE_LOG = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_NO_FAILURE_LOG = 16384
     * }
     */
    public static int CLSCTX_NO_FAILURE_LOG() {
        return CLSCTX_NO_FAILURE_LOG;
    }
    private static final int CLSCTX_DISABLE_AAA = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_DISABLE_AAA = 32768
     * }
     */
    public static int CLSCTX_DISABLE_AAA() {
        return CLSCTX_DISABLE_AAA;
    }
    private static final int CLSCTX_ENABLE_AAA = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_ENABLE_AAA = 65536
     * }
     */
    public static int CLSCTX_ENABLE_AAA() {
        return CLSCTX_ENABLE_AAA;
    }
    private static final int CLSCTX_FROM_DEFAULT_CONTEXT = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_FROM_DEFAULT_CONTEXT = 131072
     * }
     */
    public static int CLSCTX_FROM_DEFAULT_CONTEXT() {
        return CLSCTX_FROM_DEFAULT_CONTEXT;
    }
    private static final int CLSCTX_ACTIVATE_X86_SERVER = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_ACTIVATE_X86_SERVER = 262144
     * }
     */
    public static int CLSCTX_ACTIVATE_X86_SERVER() {
        return CLSCTX_ACTIVATE_X86_SERVER;
    }
    private static final int CLSCTX_ACTIVATE_32_BIT_SERVER = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_ACTIVATE_32_BIT_SERVER = 262144
     * }
     */
    public static int CLSCTX_ACTIVATE_32_BIT_SERVER() {
        return CLSCTX_ACTIVATE_32_BIT_SERVER;
    }
    private static final int CLSCTX_ACTIVATE_64_BIT_SERVER = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_ACTIVATE_64_BIT_SERVER = 524288
     * }
     */
    public static int CLSCTX_ACTIVATE_64_BIT_SERVER() {
        return CLSCTX_ACTIVATE_64_BIT_SERVER;
    }
    private static final int CLSCTX_ENABLE_CLOAKING = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_ENABLE_CLOAKING = 1048576
     * }
     */
    public static int CLSCTX_ENABLE_CLOAKING() {
        return CLSCTX_ENABLE_CLOAKING;
    }
    private static final int CLSCTX_APPCONTAINER = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_APPCONTAINER = 4194304
     * }
     */
    public static int CLSCTX_APPCONTAINER() {
        return CLSCTX_APPCONTAINER;
    }
    private static final int CLSCTX_ACTIVATE_AAA_AS_IU = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_ACTIVATE_AAA_AS_IU = 8388608
     * }
     */
    public static int CLSCTX_ACTIVATE_AAA_AS_IU() {
        return CLSCTX_ACTIVATE_AAA_AS_IU;
    }
    private static final int CLSCTX_RESERVED6 = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_RESERVED6 = 16777216
     * }
     */
    public static int CLSCTX_RESERVED6() {
        return CLSCTX_RESERVED6;
    }
    private static final int CLSCTX_ACTIVATE_ARM32_SERVER = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_ACTIVATE_ARM32_SERVER = 33554432
     * }
     */
    public static int CLSCTX_ACTIVATE_ARM32_SERVER() {
        return CLSCTX_ACTIVATE_ARM32_SERVER;
    }
    private static final int CLSCTX_ALLOW_LOWER_TRUST_REGISTRATION = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_ALLOW_LOWER_TRUST_REGISTRATION = 67108864
     * }
     */
    public static int CLSCTX_ALLOW_LOWER_TRUST_REGISTRATION() {
        return CLSCTX_ALLOW_LOWER_TRUST_REGISTRATION;
    }
    private static final int CLSCTX_PS_DLL = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * enum tagCLSCTX.CLSCTX_PS_DLL = -2147483648
     * }
     */
    public static int CLSCTX_PS_DLL() {
        return CLSCTX_PS_DLL;
    }
    private static final int MSHLFLAGS_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagMSHLFLAGS.MSHLFLAGS_NORMAL = 0
     * }
     */
    public static int MSHLFLAGS_NORMAL() {
        return MSHLFLAGS_NORMAL;
    }
    private static final int MSHLFLAGS_TABLESTRONG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagMSHLFLAGS.MSHLFLAGS_TABLESTRONG = 1
     * }
     */
    public static int MSHLFLAGS_TABLESTRONG() {
        return MSHLFLAGS_TABLESTRONG;
    }
    private static final int MSHLFLAGS_TABLEWEAK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagMSHLFLAGS.MSHLFLAGS_TABLEWEAK = 2
     * }
     */
    public static int MSHLFLAGS_TABLEWEAK() {
        return MSHLFLAGS_TABLEWEAK;
    }
    private static final int MSHLFLAGS_NOPING = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagMSHLFLAGS.MSHLFLAGS_NOPING = 4
     * }
     */
    public static int MSHLFLAGS_NOPING() {
        return MSHLFLAGS_NOPING;
    }
    private static final int MSHLFLAGS_RESERVED1 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagMSHLFLAGS.MSHLFLAGS_RESERVED1 = 8
     * }
     */
    public static int MSHLFLAGS_RESERVED1() {
        return MSHLFLAGS_RESERVED1;
    }
    private static final int MSHLFLAGS_RESERVED2 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum tagMSHLFLAGS.MSHLFLAGS_RESERVED2 = 16
     * }
     */
    public static int MSHLFLAGS_RESERVED2() {
        return MSHLFLAGS_RESERVED2;
    }
    private static final int MSHLFLAGS_RESERVED3 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum tagMSHLFLAGS.MSHLFLAGS_RESERVED3 = 32
     * }
     */
    public static int MSHLFLAGS_RESERVED3() {
        return MSHLFLAGS_RESERVED3;
    }
    private static final int MSHLFLAGS_RESERVED4 = (int)64L;
    /**
     * {@snippet lang=c :
     * enum tagMSHLFLAGS.MSHLFLAGS_RESERVED4 = 64
     * }
     */
    public static int MSHLFLAGS_RESERVED4() {
        return MSHLFLAGS_RESERVED4;
    }
    private static final int MSHCTX_LOCAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagMSHCTX.MSHCTX_LOCAL = 0
     * }
     */
    public static int MSHCTX_LOCAL() {
        return MSHCTX_LOCAL;
    }
    private static final int MSHCTX_NOSHAREDMEM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagMSHCTX.MSHCTX_NOSHAREDMEM = 1
     * }
     */
    public static int MSHCTX_NOSHAREDMEM() {
        return MSHCTX_NOSHAREDMEM;
    }
    private static final int MSHCTX_DIFFERENTMACHINE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagMSHCTX.MSHCTX_DIFFERENTMACHINE = 2
     * }
     */
    public static int MSHCTX_DIFFERENTMACHINE() {
        return MSHCTX_DIFFERENTMACHINE;
    }
    private static final int MSHCTX_INPROC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagMSHCTX.MSHCTX_INPROC = 3
     * }
     */
    public static int MSHCTX_INPROC() {
        return MSHCTX_INPROC;
    }
    private static final int MSHCTX_CROSSCTX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagMSHCTX.MSHCTX_CROSSCTX = 4
     * }
     */
    public static int MSHCTX_CROSSCTX() {
        return MSHCTX_CROSSCTX;
    }
    private static final int MSHCTX_CONTAINER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagMSHCTX.MSHCTX_CONTAINER = 5
     * }
     */
    public static int MSHCTX_CONTAINER() {
        return MSHCTX_CONTAINER;
    }
    /**
     * {@snippet lang=c :
     * typedef BYTE_BLOB *UP_BYTE_BLOB
     * }
     */
    public static final AddressLayout UP_BYTE_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WORD_BLOB *UP_WORD_BLOB
     * }
     */
    public static final AddressLayout UP_WORD_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD_BLOB *UP_DWORD_BLOB
     * }
     */
    public static final AddressLayout UP_DWORD_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef FLAGGED_BYTE_BLOB *UP_FLAGGED_BYTE_BLOB
     * }
     */
    public static final AddressLayout UP_FLAGGED_BYTE_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef FLAGGED_WORD_BLOB *UP_FLAGGED_WORD_BLOB
     * }
     */
    public static final AddressLayout UP_FLAGGED_WORD_BLOB = winapi.C_POINTER;

    private static class IWinTypesBase_v0_1_c_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("IWinTypesBase_v0_1_c_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypesBase_v0_1_c_ifspec
     * }
     */
    public static AddressLayout IWinTypesBase_v0_1_c_ifspec$layout() {
        return IWinTypesBase_v0_1_c_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypesBase_v0_1_c_ifspec
     * }
     */
    public static MemorySegment IWinTypesBase_v0_1_c_ifspec$segment() {
        return IWinTypesBase_v0_1_c_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypesBase_v0_1_c_ifspec
     * }
     */
    public static MemorySegment IWinTypesBase_v0_1_c_ifspec() {
        return IWinTypesBase_v0_1_c_ifspec$constants.SEGMENT.get(IWinTypesBase_v0_1_c_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypesBase_v0_1_c_ifspec
     * }
     */
    public static void IWinTypesBase_v0_1_c_ifspec(MemorySegment varValue) {
        IWinTypesBase_v0_1_c_ifspec$constants.SEGMENT.set(IWinTypesBase_v0_1_c_ifspec$constants.LAYOUT, 0L, varValue);
    }

    private static class IWinTypesBase_v0_1_s_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("IWinTypesBase_v0_1_s_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypesBase_v0_1_s_ifspec
     * }
     */
    public static AddressLayout IWinTypesBase_v0_1_s_ifspec$layout() {
        return IWinTypesBase_v0_1_s_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypesBase_v0_1_s_ifspec
     * }
     */
    public static MemorySegment IWinTypesBase_v0_1_s_ifspec$segment() {
        return IWinTypesBase_v0_1_s_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypesBase_v0_1_s_ifspec
     * }
     */
    public static MemorySegment IWinTypesBase_v0_1_s_ifspec() {
        return IWinTypesBase_v0_1_s_ifspec$constants.SEGMENT.get(IWinTypesBase_v0_1_s_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypesBase_v0_1_s_ifspec
     * }
     */
    public static void IWinTypesBase_v0_1_s_ifspec(MemorySegment varValue) {
        IWinTypesBase_v0_1_s_ifspec$constants.SEGMENT.set(IWinTypesBase_v0_1_s_ifspec$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagBLOB {
     *     ULONG cbSize;
     *     BYTE *pBlobData;
     * } *LPBLOB
     * }
     */
    public static final AddressLayout LPBLOB = winapi.C_POINTER;

    private static class __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("__MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec
     * }
     */
    public static AddressLayout __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec$layout() {
        return __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec$segment() {
        return __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec() {
        return __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec$constants.SEGMENT.get(__MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec
     * }
     */
    public static void __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec(MemorySegment varValue) {
        __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec$constants.SEGMENT.set(__MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec$constants.LAYOUT, 0L, varValue);
    }

    private static class __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("__MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec
     * }
     */
    public static AddressLayout __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec$layout() {
        return __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec$segment() {
        return __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec() {
        return __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec$constants.SEGMENT.get(__MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec
     * }
     */
    public static void __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec(MemorySegment varValue) {
        __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec$constants.SEGMENT.set(__MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec$constants.LAYOUT, 0L, varValue);
    }

    private static class __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("__MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec
     * }
     */
    public static AddressLayout __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec$layout() {
        return __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec$segment() {
        return __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec() {
        return __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec$constants.SEGMENT.get(__MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec
     * }
     */
    public static void __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec(MemorySegment varValue) {
        __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec$constants.SEGMENT.set(__MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec$constants.LAYOUT, 0L, varValue);
    }

    private static class __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("__MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec
     * }
     */
    public static AddressLayout __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec$layout() {
        return __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec$segment() {
        return __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec() {
        return __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec$constants.SEGMENT.get(__MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec
     * }
     */
    public static void __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec(MemorySegment varValue) {
        __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec$constants.SEGMENT.set(__MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec$constants.LAYOUT, 0L, varValue);
    }
    private static final int DVASPECT_CONTENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagDVASPECT.DVASPECT_CONTENT = 1
     * }
     */
    public static int DVASPECT_CONTENT() {
        return DVASPECT_CONTENT;
    }
    private static final int DVASPECT_THUMBNAIL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagDVASPECT.DVASPECT_THUMBNAIL = 2
     * }
     */
    public static int DVASPECT_THUMBNAIL() {
        return DVASPECT_THUMBNAIL;
    }
    private static final int DVASPECT_ICON = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagDVASPECT.DVASPECT_ICON = 4
     * }
     */
    public static int DVASPECT_ICON() {
        return DVASPECT_ICON;
    }
    private static final int DVASPECT_DOCPRINT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagDVASPECT.DVASPECT_DOCPRINT = 8
     * }
     */
    public static int DVASPECT_DOCPRINT() {
        return DVASPECT_DOCPRINT;
    }
    private static final int STGC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagSTGC.STGC_DEFAULT = 0
     * }
     */
    public static int STGC_DEFAULT() {
        return STGC_DEFAULT;
    }
    private static final int STGC_OVERWRITE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagSTGC.STGC_OVERWRITE = 1
     * }
     */
    public static int STGC_OVERWRITE() {
        return STGC_OVERWRITE;
    }
    private static final int STGC_ONLYIFCURRENT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagSTGC.STGC_ONLYIFCURRENT = 2
     * }
     */
    public static int STGC_ONLYIFCURRENT() {
        return STGC_ONLYIFCURRENT;
    }
    private static final int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagSTGC.STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
     * }
     */
    public static int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE() {
        return STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE;
    }
    private static final int STGC_CONSOLIDATE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagSTGC.STGC_CONSOLIDATE = 8
     * }
     */
    public static int STGC_CONSOLIDATE() {
        return STGC_CONSOLIDATE;
    }
    private static final int STGMOVE_MOVE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagSTGMOVE.STGMOVE_MOVE = 0
     * }
     */
    public static int STGMOVE_MOVE() {
        return STGMOVE_MOVE;
    }
    private static final int STGMOVE_COPY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagSTGMOVE.STGMOVE_COPY = 1
     * }
     */
    public static int STGMOVE_COPY() {
        return STGMOVE_COPY;
    }
    private static final int STGMOVE_SHALLOWCOPY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagSTGMOVE.STGMOVE_SHALLOWCOPY = 2
     * }
     */
    public static int STGMOVE_SHALLOWCOPY() {
        return STGMOVE_SHALLOWCOPY;
    }
    private static final int STATFLAG_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagSTATFLAG.STATFLAG_DEFAULT = 0
     * }
     */
    public static int STATFLAG_DEFAULT() {
        return STATFLAG_DEFAULT;
    }
    private static final int STATFLAG_NONAME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagSTATFLAG.STATFLAG_NONAME = 1
     * }
     */
    public static int STATFLAG_NONAME() {
        return STATFLAG_NONAME;
    }
    private static final int STATFLAG_NOOPEN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagSTATFLAG.STATFLAG_NOOPEN = 2
     * }
     */
    public static int STATFLAG_NOOPEN() {
        return STATFLAG_NOOPEN;
    }
    /**
     * {@snippet lang=c :
     * typedef void *HCONTEXT
     * }
     */
    public static final AddressLayout HCONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef userCLIPFORMAT *wireCLIPFORMAT
     * }
     */
    public static final AddressLayout wireCLIPFORMAT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WORD CLIPFORMAT
     * }
     */
    public static final OfShort CLIPFORMAT = winapi.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef userHGLOBAL *wireHGLOBAL
     * }
     */
    public static final AddressLayout wireHGLOBAL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RemotableHandle *wireHWND
     * }
     */
    public static final AddressLayout wireHWND = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RemotableHandle *wireHMENU
     * }
     */
    public static final AddressLayout wireHMENU = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RemotableHandle *wireHACCEL
     * }
     */
    public static final AddressLayout wireHACCEL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RemotableHandle *wireHBRUSH
     * }
     */
    public static final AddressLayout wireHBRUSH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RemotableHandle *wireHFONT
     * }
     */
    public static final AddressLayout wireHFONT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RemotableHandle *wireHDC
     * }
     */
    public static final AddressLayout wireHDC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RemotableHandle *wireHICON
     * }
     */
    public static final AddressLayout wireHICON = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RemotableHandle *wireHRGN
     * }
     */
    public static final AddressLayout wireHRGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RemotableHandle *wireHMONITOR
     * }
     */
    public static final AddressLayout wireHMONITOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef userHBITMAP *wireHBITMAP
     * }
     */
    public static final AddressLayout wireHBITMAP = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef userHPALETTE *wireHPALETTE
     * }
     */
    public static final AddressLayout wireHPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef userHENHMETAFILE *wireHENHMETAFILE
     * }
     */
    public static final AddressLayout wireHENHMETAFILE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef userHMETAFILE *wireHMETAFILE
     * }
     */
    public static final AddressLayout wireHMETAFILE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef userHMETAFILEPICT *wireHMETAFILEPICT
     * }
     */
    public static final AddressLayout wireHMETAFILEPICT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HMETAFILEPICT
     * }
     */
    public static final AddressLayout HMETAFILEPICT = winapi.C_POINTER;

    private static class IWinTypes_v0_1_c_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("IWinTypes_v0_1_c_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec
     * }
     */
    public static AddressLayout IWinTypes_v0_1_c_ifspec$layout() {
        return IWinTypes_v0_1_c_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec
     * }
     */
    public static MemorySegment IWinTypes_v0_1_c_ifspec$segment() {
        return IWinTypes_v0_1_c_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec
     * }
     */
    public static MemorySegment IWinTypes_v0_1_c_ifspec() {
        return IWinTypes_v0_1_c_ifspec$constants.SEGMENT.get(IWinTypes_v0_1_c_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec
     * }
     */
    public static void IWinTypes_v0_1_c_ifspec(MemorySegment varValue) {
        IWinTypes_v0_1_c_ifspec$constants.SEGMENT.set(IWinTypes_v0_1_c_ifspec$constants.LAYOUT, 0L, varValue);
    }

    private static class IWinTypes_v0_1_s_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("IWinTypes_v0_1_s_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec
     * }
     */
    public static AddressLayout IWinTypes_v0_1_s_ifspec$layout() {
        return IWinTypes_v0_1_s_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec
     * }
     */
    public static MemorySegment IWinTypes_v0_1_s_ifspec$segment() {
        return IWinTypes_v0_1_s_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec
     * }
     */
    public static MemorySegment IWinTypes_v0_1_s_ifspec() {
        return IWinTypes_v0_1_s_ifspec$constants.SEGMENT.get(IWinTypes_v0_1_s_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec
     * }
     */
    public static void IWinTypes_v0_1_s_ifspec(MemorySegment varValue) {
        IWinTypes_v0_1_s_ifspec$constants.SEGMENT.set(IWinTypes_v0_1_s_ifspec$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef double DATE
     * }
     */
    public static final OfDouble DATE = winapi.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef CY *LPCY
     * }
     */
    public static final AddressLayout LPCY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DECIMAL *LPDECIMAL
     * }
     */
    public static final AddressLayout LPDECIMAL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef FLAGGED_WORD_BLOB *wireBSTR
     * }
     */
    public static final AddressLayout wireBSTR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef OLECHAR *BSTR
     * }
     */
    public static final AddressLayout BSTR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BSTR *LPBSTR
     * }
     */
    public static final AddressLayout LPBSTR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef short VARIANT_BOOL
     * }
     */
    public static final OfShort VARIANT_BOOL = winapi.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct tagBSTRBLOB {
     *     ULONG cbSize;
     *     BYTE *pData;
     * } *LPBSTRBLOB
     * }
     */
    public static final AddressLayout LPBSTRBLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short VARTYPE
     * }
     */
    public static final OfShort VARTYPE = winapi.C_SHORT;
    private static final int VT_EMPTY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_EMPTY = 0
     * }
     */
    public static int VT_EMPTY() {
        return VT_EMPTY;
    }
    private static final int VT_NULL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_NULL = 1
     * }
     */
    public static int VT_NULL() {
        return VT_NULL;
    }
    private static final int VT_I2 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_I2 = 2
     * }
     */
    public static int VT_I2() {
        return VT_I2;
    }
    private static final int VT_I4 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_I4 = 3
     * }
     */
    public static int VT_I4() {
        return VT_I4;
    }
    private static final int VT_R4 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_R4 = 4
     * }
     */
    public static int VT_R4() {
        return VT_R4;
    }
    private static final int VT_R8 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_R8 = 5
     * }
     */
    public static int VT_R8() {
        return VT_R8;
    }
    private static final int VT_CY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_CY = 6
     * }
     */
    public static int VT_CY() {
        return VT_CY;
    }
    private static final int VT_DATE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_DATE = 7
     * }
     */
    public static int VT_DATE() {
        return VT_DATE;
    }
    private static final int VT_BSTR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_BSTR = 8
     * }
     */
    public static int VT_BSTR() {
        return VT_BSTR;
    }
    private static final int VT_DISPATCH = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_DISPATCH = 9
     * }
     */
    public static int VT_DISPATCH() {
        return VT_DISPATCH;
    }
    private static final int VT_ERROR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_ERROR = 10
     * }
     */
    public static int VT_ERROR() {
        return VT_ERROR;
    }
    private static final int VT_BOOL = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_BOOL = 11
     * }
     */
    public static int VT_BOOL() {
        return VT_BOOL;
    }
    private static final int VT_VARIANT = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_VARIANT = 12
     * }
     */
    public static int VT_VARIANT() {
        return VT_VARIANT;
    }
    private static final int VT_UNKNOWN = (int)13L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_UNKNOWN = 13
     * }
     */
    public static int VT_UNKNOWN() {
        return VT_UNKNOWN;
    }
    private static final int VT_DECIMAL = (int)14L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_DECIMAL = 14
     * }
     */
    public static int VT_DECIMAL() {
        return VT_DECIMAL;
    }
    private static final int VT_I1 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_I1 = 16
     * }
     */
    public static int VT_I1() {
        return VT_I1;
    }
    private static final int VT_UI1 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_UI1 = 17
     * }
     */
    public static int VT_UI1() {
        return VT_UI1;
    }
    private static final int VT_UI2 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_UI2 = 18
     * }
     */
    public static int VT_UI2() {
        return VT_UI2;
    }
    private static final int VT_UI4 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_UI4 = 19
     * }
     */
    public static int VT_UI4() {
        return VT_UI4;
    }
    private static final int VT_I8 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_I8 = 20
     * }
     */
    public static int VT_I8() {
        return VT_I8;
    }
    private static final int VT_UI8 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_UI8 = 21
     * }
     */
    public static int VT_UI8() {
        return VT_UI8;
    }
    private static final int VT_INT = (int)22L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_INT = 22
     * }
     */
    public static int VT_INT() {
        return VT_INT;
    }
    private static final int VT_UINT = (int)23L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_UINT = 23
     * }
     */
    public static int VT_UINT() {
        return VT_UINT;
    }
    private static final int VT_VOID = (int)24L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_VOID = 24
     * }
     */
    public static int VT_VOID() {
        return VT_VOID;
    }
    private static final int VT_HRESULT = (int)25L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_HRESULT = 25
     * }
     */
    public static int VT_HRESULT() {
        return VT_HRESULT;
    }
    private static final int VT_PTR = (int)26L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_PTR = 26
     * }
     */
    public static int VT_PTR() {
        return VT_PTR;
    }
    private static final int VT_SAFEARRAY = (int)27L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_SAFEARRAY = 27
     * }
     */
    public static int VT_SAFEARRAY() {
        return VT_SAFEARRAY;
    }
    private static final int VT_CARRAY = (int)28L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_CARRAY = 28
     * }
     */
    public static int VT_CARRAY() {
        return VT_CARRAY;
    }
    private static final int VT_USERDEFINED = (int)29L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_USERDEFINED = 29
     * }
     */
    public static int VT_USERDEFINED() {
        return VT_USERDEFINED;
    }
    private static final int VT_LPSTR = (int)30L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_LPSTR = 30
     * }
     */
    public static int VT_LPSTR() {
        return VT_LPSTR;
    }
    private static final int VT_LPWSTR = (int)31L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_LPWSTR = 31
     * }
     */
    public static int VT_LPWSTR() {
        return VT_LPWSTR;
    }
    private static final int VT_RECORD = (int)36L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_RECORD = 36
     * }
     */
    public static int VT_RECORD() {
        return VT_RECORD;
    }
    private static final int VT_INT_PTR = (int)37L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_INT_PTR = 37
     * }
     */
    public static int VT_INT_PTR() {
        return VT_INT_PTR;
    }
    private static final int VT_UINT_PTR = (int)38L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_UINT_PTR = 38
     * }
     */
    public static int VT_UINT_PTR() {
        return VT_UINT_PTR;
    }
    private static final int VT_FILETIME = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_FILETIME = 64
     * }
     */
    public static int VT_FILETIME() {
        return VT_FILETIME;
    }
    private static final int VT_BLOB = (int)65L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_BLOB = 65
     * }
     */
    public static int VT_BLOB() {
        return VT_BLOB;
    }
    private static final int VT_STREAM = (int)66L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_STREAM = 66
     * }
     */
    public static int VT_STREAM() {
        return VT_STREAM;
    }
    private static final int VT_STORAGE = (int)67L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_STORAGE = 67
     * }
     */
    public static int VT_STORAGE() {
        return VT_STORAGE;
    }
    private static final int VT_STREAMED_OBJECT = (int)68L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_STREAMED_OBJECT = 68
     * }
     */
    public static int VT_STREAMED_OBJECT() {
        return VT_STREAMED_OBJECT;
    }
    private static final int VT_STORED_OBJECT = (int)69L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_STORED_OBJECT = 69
     * }
     */
    public static int VT_STORED_OBJECT() {
        return VT_STORED_OBJECT;
    }
    private static final int VT_BLOB_OBJECT = (int)70L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_BLOB_OBJECT = 70
     * }
     */
    public static int VT_BLOB_OBJECT() {
        return VT_BLOB_OBJECT;
    }
    private static final int VT_CF = (int)71L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_CF = 71
     * }
     */
    public static int VT_CF() {
        return VT_CF;
    }
    private static final int VT_CLSID = (int)72L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_CLSID = 72
     * }
     */
    public static int VT_CLSID() {
        return VT_CLSID;
    }
    private static final int VT_VERSIONED_STREAM = (int)73L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_VERSIONED_STREAM = 73
     * }
     */
    public static int VT_VERSIONED_STREAM() {
        return VT_VERSIONED_STREAM;
    }
    private static final int VT_BSTR_BLOB = (int)4095L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_BSTR_BLOB = 4095
     * }
     */
    public static int VT_BSTR_BLOB() {
        return VT_BSTR_BLOB;
    }
    private static final int VT_VECTOR = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_VECTOR = 4096
     * }
     */
    public static int VT_VECTOR() {
        return VT_VECTOR;
    }
    private static final int VT_ARRAY = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_ARRAY = 8192
     * }
     */
    public static int VT_ARRAY() {
        return VT_ARRAY;
    }
    private static final int VT_BYREF = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_BYREF = 16384
     * }
     */
    public static int VT_BYREF() {
        return VT_BYREF;
    }
    private static final int VT_RESERVED = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_RESERVED = 32768
     * }
     */
    public static int VT_RESERVED() {
        return VT_RESERVED;
    }
    private static final int VT_ILLEGAL = (int)65535L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_ILLEGAL = 65535
     * }
     */
    public static int VT_ILLEGAL() {
        return VT_ILLEGAL;
    }
    private static final int VT_ILLEGALMASKED = (int)4095L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_ILLEGALMASKED = 4095
     * }
     */
    public static int VT_ILLEGALMASKED() {
        return VT_ILLEGALMASKED;
    }
    private static final int VT_TYPEMASK = (int)4095L;
    /**
     * {@snippet lang=c :
     * enum VARENUM.VT_TYPEMASK = 4095
     * }
     */
    public static int VT_TYPEMASK() {
        return VT_TYPEMASK;
    }
    /**
     * {@snippet lang=c :
     * typedef ULONG PROPID
     * }
     */
    public static final OfInt PROPID = winapi.C_LONG;
    private static final int TYSPEC_CLSID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagTYSPEC.TYSPEC_CLSID = 0
     * }
     */
    public static int TYSPEC_CLSID() {
        return TYSPEC_CLSID;
    }
    private static final int TYSPEC_FILEEXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagTYSPEC.TYSPEC_FILEEXT = 1
     * }
     */
    public static int TYSPEC_FILEEXT() {
        return TYSPEC_FILEEXT;
    }
    private static final int TYSPEC_MIMETYPE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagTYSPEC.TYSPEC_MIMETYPE = 2
     * }
     */
    public static int TYSPEC_MIMETYPE() {
        return TYSPEC_MIMETYPE;
    }
    private static final int TYSPEC_FILENAME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagTYSPEC.TYSPEC_FILENAME = 3
     * }
     */
    public static int TYSPEC_FILENAME() {
        return TYSPEC_FILENAME;
    }
    private static final int TYSPEC_PROGID = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagTYSPEC.TYSPEC_PROGID = 4
     * }
     */
    public static int TYSPEC_PROGID() {
        return TYSPEC_PROGID;
    }
    private static final int TYSPEC_PACKAGENAME = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagTYSPEC.TYSPEC_PACKAGENAME = 5
     * }
     */
    public static int TYSPEC_PACKAGENAME() {
        return TYSPEC_PACKAGENAME;
    }
    private static final int TYSPEC_OBJECTID = (int)6L;
    /**
     * {@snippet lang=c :
     * enum tagTYSPEC.TYSPEC_OBJECTID = 6
     * }
     */
    public static int TYSPEC_OBJECTID() {
        return TYSPEC_OBJECTID;
    }

    private static class __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("__MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec
     * }
     */
    public static AddressLayout __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec$layout() {
        return __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec$segment() {
        return __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec() {
        return __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec$constants.SEGMENT.get(__MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec
     * }
     */
    public static void __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec(MemorySegment varValue) {
        __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec$constants.SEGMENT.set(__MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec$constants.LAYOUT, 0L, varValue);
    }

    private static class __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec$constants {
        public static final AddressLayout LAYOUT = winapi.C_POINTER;
        public static final MemorySegment SEGMENT = winapi.findOrThrow("__MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec
     * }
     */
    public static AddressLayout __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec$layout() {
        return __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec$segment() {
        return __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec
     * }
     */
    public static MemorySegment __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec() {
        return __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec$constants.SEGMENT.get(__MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec
     * }
     */
    public static void __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec(MemorySegment varValue) {
        __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec$constants.SEGMENT.set(__MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec$constants.LAYOUT, 0L, varValue);
    }

    private static class GUID_DEVINTERFACE_DISK$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_DISK").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_DISK
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_DISK$layout() {
        return GUID_DEVINTERFACE_DISK$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_DISK
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_DISK() {
        return GUID_DEVINTERFACE_DISK$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_DISK
     * }
     */
    public static void GUID_DEVINTERFACE_DISK(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_DISK$constants.SEGMENT, 0L, GUID_DEVINTERFACE_DISK$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_CDROM$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_CDROM").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_CDROM
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_CDROM$layout() {
        return GUID_DEVINTERFACE_CDROM$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_CDROM
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_CDROM() {
        return GUID_DEVINTERFACE_CDROM$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_CDROM
     * }
     */
    public static void GUID_DEVINTERFACE_CDROM(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_CDROM$constants.SEGMENT, 0L, GUID_DEVINTERFACE_CDROM$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_PARTITION$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_PARTITION").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_PARTITION
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_PARTITION$layout() {
        return GUID_DEVINTERFACE_PARTITION$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_PARTITION
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_PARTITION() {
        return GUID_DEVINTERFACE_PARTITION$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_PARTITION
     * }
     */
    public static void GUID_DEVINTERFACE_PARTITION(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_PARTITION$constants.SEGMENT, 0L, GUID_DEVINTERFACE_PARTITION$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_TAPE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_TAPE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_TAPE
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_TAPE$layout() {
        return GUID_DEVINTERFACE_TAPE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_TAPE
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_TAPE() {
        return GUID_DEVINTERFACE_TAPE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_TAPE
     * }
     */
    public static void GUID_DEVINTERFACE_TAPE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_TAPE$constants.SEGMENT, 0L, GUID_DEVINTERFACE_TAPE$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_WRITEONCEDISK$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_WRITEONCEDISK").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_WRITEONCEDISK
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_WRITEONCEDISK$layout() {
        return GUID_DEVINTERFACE_WRITEONCEDISK$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_WRITEONCEDISK
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_WRITEONCEDISK() {
        return GUID_DEVINTERFACE_WRITEONCEDISK$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_WRITEONCEDISK
     * }
     */
    public static void GUID_DEVINTERFACE_WRITEONCEDISK(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_WRITEONCEDISK$constants.SEGMENT, 0L, GUID_DEVINTERFACE_WRITEONCEDISK$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_VOLUME$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_VOLUME").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_VOLUME
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_VOLUME$layout() {
        return GUID_DEVINTERFACE_VOLUME$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_VOLUME
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_VOLUME() {
        return GUID_DEVINTERFACE_VOLUME$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_VOLUME
     * }
     */
    public static void GUID_DEVINTERFACE_VOLUME(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_VOLUME$constants.SEGMENT, 0L, GUID_DEVINTERFACE_VOLUME$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_MEDIUMCHANGER$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_MEDIUMCHANGER").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_MEDIUMCHANGER
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_MEDIUMCHANGER$layout() {
        return GUID_DEVINTERFACE_MEDIUMCHANGER$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_MEDIUMCHANGER
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_MEDIUMCHANGER() {
        return GUID_DEVINTERFACE_MEDIUMCHANGER$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_MEDIUMCHANGER
     * }
     */
    public static void GUID_DEVINTERFACE_MEDIUMCHANGER(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_MEDIUMCHANGER$constants.SEGMENT, 0L, GUID_DEVINTERFACE_MEDIUMCHANGER$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_FLOPPY$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_FLOPPY").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_FLOPPY
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_FLOPPY$layout() {
        return GUID_DEVINTERFACE_FLOPPY$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_FLOPPY
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_FLOPPY() {
        return GUID_DEVINTERFACE_FLOPPY$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_FLOPPY
     * }
     */
    public static void GUID_DEVINTERFACE_FLOPPY(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_FLOPPY$constants.SEGMENT, 0L, GUID_DEVINTERFACE_FLOPPY$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_CDCHANGER$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_CDCHANGER").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_CDCHANGER
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_CDCHANGER$layout() {
        return GUID_DEVINTERFACE_CDCHANGER$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_CDCHANGER
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_CDCHANGER() {
        return GUID_DEVINTERFACE_CDCHANGER$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_CDCHANGER
     * }
     */
    public static void GUID_DEVINTERFACE_CDCHANGER(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_CDCHANGER$constants.SEGMENT, 0L, GUID_DEVINTERFACE_CDCHANGER$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_STORAGEPORT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_STORAGEPORT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_STORAGEPORT
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_STORAGEPORT$layout() {
        return GUID_DEVINTERFACE_STORAGEPORT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_STORAGEPORT
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_STORAGEPORT() {
        return GUID_DEVINTERFACE_STORAGEPORT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_STORAGEPORT
     * }
     */
    public static void GUID_DEVINTERFACE_STORAGEPORT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_STORAGEPORT$constants.SEGMENT, 0L, GUID_DEVINTERFACE_STORAGEPORT$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_VMLUN$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_VMLUN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_VMLUN
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_VMLUN$layout() {
        return GUID_DEVINTERFACE_VMLUN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_VMLUN
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_VMLUN() {
        return GUID_DEVINTERFACE_VMLUN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_VMLUN
     * }
     */
    public static void GUID_DEVINTERFACE_VMLUN(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_VMLUN$constants.SEGMENT, 0L, GUID_DEVINTERFACE_VMLUN$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_SES$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_SES").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SES
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_SES$layout() {
        return GUID_DEVINTERFACE_SES$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SES
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_SES() {
        return GUID_DEVINTERFACE_SES$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SES
     * }
     */
    public static void GUID_DEVINTERFACE_SES(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_SES$constants.SEGMENT, 0L, GUID_DEVINTERFACE_SES$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_ZNSDISK$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_ZNSDISK").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_ZNSDISK
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_ZNSDISK$layout() {
        return GUID_DEVINTERFACE_ZNSDISK$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_ZNSDISK
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_ZNSDISK() {
        return GUID_DEVINTERFACE_ZNSDISK$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_ZNSDISK
     * }
     */
    public static void GUID_DEVINTERFACE_ZNSDISK(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_ZNSDISK$constants.SEGMENT, 0L, GUID_DEVINTERFACE_ZNSDISK$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_HIDDEN_DISK$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_HIDDEN_DISK").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_HIDDEN_DISK
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_HIDDEN_DISK$layout() {
        return GUID_DEVINTERFACE_HIDDEN_DISK$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_HIDDEN_DISK
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_HIDDEN_DISK() {
        return GUID_DEVINTERFACE_HIDDEN_DISK$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_HIDDEN_DISK
     * }
     */
    public static void GUID_DEVINTERFACE_HIDDEN_DISK(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_HIDDEN_DISK$constants.SEGMENT, 0L, GUID_DEVINTERFACE_HIDDEN_DISK$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_SERVICE_VOLUME$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_SERVICE_VOLUME").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SERVICE_VOLUME
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_SERVICE_VOLUME$layout() {
        return GUID_DEVINTERFACE_SERVICE_VOLUME$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SERVICE_VOLUME
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_SERVICE_VOLUME() {
        return GUID_DEVINTERFACE_SERVICE_VOLUME$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SERVICE_VOLUME
     * }
     */
    public static void GUID_DEVINTERFACE_SERVICE_VOLUME(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_SERVICE_VOLUME$constants.SEGMENT, 0L, GUID_DEVINTERFACE_SERVICE_VOLUME$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_HIDDEN_VOLUME$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_HIDDEN_VOLUME").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_HIDDEN_VOLUME
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_HIDDEN_VOLUME$layout() {
        return GUID_DEVINTERFACE_HIDDEN_VOLUME$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_HIDDEN_VOLUME
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_HIDDEN_VOLUME() {
        return GUID_DEVINTERFACE_HIDDEN_VOLUME$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_HIDDEN_VOLUME
     * }
     */
    public static void GUID_DEVINTERFACE_HIDDEN_VOLUME(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_HIDDEN_VOLUME$constants.SEGMENT, 0L, GUID_DEVINTERFACE_HIDDEN_VOLUME$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB$layout() {
        return GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB() {
        return GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB
     * }
     */
    public static void GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB$constants.SEGMENT, 0L, GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE$layout() {
        return GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE() {
        return GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE
     * }
     */
    public static void GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE$constants.SEGMENT, 0L, GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE$constants.LAYOUT.byteSize());
    }

    private static class GUID_SCM_PD_HEALTH_NOTIFICATION$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_SCM_PD_HEALTH_NOTIFICATION").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SCM_PD_HEALTH_NOTIFICATION
     * }
     */
    public static GroupLayout GUID_SCM_PD_HEALTH_NOTIFICATION$layout() {
        return GUID_SCM_PD_HEALTH_NOTIFICATION$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SCM_PD_HEALTH_NOTIFICATION
     * }
     */
    public static MemorySegment GUID_SCM_PD_HEALTH_NOTIFICATION() {
        return GUID_SCM_PD_HEALTH_NOTIFICATION$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SCM_PD_HEALTH_NOTIFICATION
     * }
     */
    public static void GUID_SCM_PD_HEALTH_NOTIFICATION(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_SCM_PD_HEALTH_NOTIFICATION$constants.SEGMENT, 0L, GUID_SCM_PD_HEALTH_NOTIFICATION$constants.LAYOUT.byteSize());
    }

    private static class GUID_SCM_PD_PASSTHROUGH_INVDIMM$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_SCM_PD_PASSTHROUGH_INVDIMM").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SCM_PD_PASSTHROUGH_INVDIMM
     * }
     */
    public static GroupLayout GUID_SCM_PD_PASSTHROUGH_INVDIMM$layout() {
        return GUID_SCM_PD_PASSTHROUGH_INVDIMM$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SCM_PD_PASSTHROUGH_INVDIMM
     * }
     */
    public static MemorySegment GUID_SCM_PD_PASSTHROUGH_INVDIMM() {
        return GUID_SCM_PD_PASSTHROUGH_INVDIMM$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SCM_PD_PASSTHROUGH_INVDIMM
     * }
     */
    public static void GUID_SCM_PD_PASSTHROUGH_INVDIMM(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_SCM_PD_PASSTHROUGH_INVDIMM$constants.SEGMENT, 0L, GUID_SCM_PD_PASSTHROUGH_INVDIMM$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_COMPORT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_COMPORT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_COMPORT
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_COMPORT$layout() {
        return GUID_DEVINTERFACE_COMPORT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_COMPORT
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_COMPORT() {
        return GUID_DEVINTERFACE_COMPORT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_COMPORT
     * }
     */
    public static void GUID_DEVINTERFACE_COMPORT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_COMPORT$constants.SEGMENT, 0L, GUID_DEVINTERFACE_COMPORT$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR
     * }
     */
    public static GroupLayout GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR$layout() {
        return GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR
     * }
     */
    public static MemorySegment GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR() {
        return GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR
     * }
     */
    public static void GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR$constants.SEGMENT, 0L, GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR$constants.LAYOUT.byteSize());
    }
}

