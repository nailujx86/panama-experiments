// Generated by jextract

package net.nailuj.win;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class winapi_25 extends winapi_26 {

    winapi_25() {
        // Should not be called directly
    }
    private static final int PlatformRoleMobile = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _POWER_PLATFORM_ROLE.PlatformRoleMobile = 2
     * }
     */
    public static int PlatformRoleMobile() {
        return PlatformRoleMobile;
    }
    private static final int PlatformRoleWorkstation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _POWER_PLATFORM_ROLE.PlatformRoleWorkstation = 3
     * }
     */
    public static int PlatformRoleWorkstation() {
        return PlatformRoleWorkstation;
    }
    private static final int PlatformRoleEnterpriseServer = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _POWER_PLATFORM_ROLE.PlatformRoleEnterpriseServer = 4
     * }
     */
    public static int PlatformRoleEnterpriseServer() {
        return PlatformRoleEnterpriseServer;
    }
    private static final int PlatformRoleSOHOServer = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _POWER_PLATFORM_ROLE.PlatformRoleSOHOServer = 5
     * }
     */
    public static int PlatformRoleSOHOServer() {
        return PlatformRoleSOHOServer;
    }
    private static final int PlatformRoleAppliancePC = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _POWER_PLATFORM_ROLE.PlatformRoleAppliancePC = 6
     * }
     */
    public static int PlatformRoleAppliancePC() {
        return PlatformRoleAppliancePC;
    }
    private static final int PlatformRolePerformanceServer = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _POWER_PLATFORM_ROLE.PlatformRolePerformanceServer = 7
     * }
     */
    public static int PlatformRolePerformanceServer() {
        return PlatformRolePerformanceServer;
    }
    private static final int PlatformRoleSlate = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _POWER_PLATFORM_ROLE.PlatformRoleSlate = 8
     * }
     */
    public static int PlatformRoleSlate() {
        return PlatformRoleSlate;
    }
    private static final int PlatformRoleMaximum = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _POWER_PLATFORM_ROLE.PlatformRoleMaximum = 9
     * }
     */
    public static int PlatformRoleMaximum() {
        return PlatformRoleMaximum;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _POWER_PLATFORM_ROLE {
     *     PlatformRoleUnspecified = 0,
     *     PlatformRoleDesktop,
     *     PlatformRoleMobile,
     *     PlatformRoleWorkstation,
     *     PlatformRoleEnterpriseServer,
     *     PlatformRoleSOHOServer,
     *     PlatformRoleAppliancePC,
     *     PlatformRolePerformanceServer,
     *     PlatformRoleSlate,
     *     PlatformRoleMaximum
     * } *PPOWER_PLATFORM_ROLE
     * }
     */
    public static final AddressLayout PPOWER_PLATFORM_ROLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _POWER_PLATFORM_INFORMATION {
     *     BOOLEAN AoAc;
     * } *PPOWER_PLATFORM_INFORMATION
     * }
     */
    public static final AddressLayout PPOWER_PLATFORM_INFORMATION = winapi.C_POINTER;
    private static final int ALTITUDE_GROUP_POLICY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum POWER_SETTING_ALTITUDE.ALTITUDE_GROUP_POLICY = 0
     * }
     */
    public static int ALTITUDE_GROUP_POLICY() {
        return ALTITUDE_GROUP_POLICY;
    }
    private static final int ALTITUDE_USER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum POWER_SETTING_ALTITUDE.ALTITUDE_USER = 1
     * }
     */
    public static int ALTITUDE_USER() {
        return ALTITUDE_USER;
    }
    private static final int ALTITUDE_RUNTIME_OVERRIDE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum POWER_SETTING_ALTITUDE.ALTITUDE_RUNTIME_OVERRIDE = 2
     * }
     */
    public static int ALTITUDE_RUNTIME_OVERRIDE() {
        return ALTITUDE_RUNTIME_OVERRIDE;
    }
    private static final int ALTITUDE_PROVISIONING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum POWER_SETTING_ALTITUDE.ALTITUDE_PROVISIONING = 3
     * }
     */
    public static int ALTITUDE_PROVISIONING() {
        return ALTITUDE_PROVISIONING;
    }
    private static final int ALTITUDE_OEM_CUSTOMIZATION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum POWER_SETTING_ALTITUDE.ALTITUDE_OEM_CUSTOMIZATION = 4
     * }
     */
    public static int ALTITUDE_OEM_CUSTOMIZATION() {
        return ALTITUDE_OEM_CUSTOMIZATION;
    }
    private static final int ALTITUDE_INTERNAL_OVERRIDE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum POWER_SETTING_ALTITUDE.ALTITUDE_INTERNAL_OVERRIDE = 5
     * }
     */
    public static int ALTITUDE_INTERNAL_OVERRIDE() {
        return ALTITUDE_INTERNAL_OVERRIDE;
    }
    private static final int ALTITUDE_OS_DEFAULT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum POWER_SETTING_ALTITUDE.ALTITUDE_OS_DEFAULT = 6
     * }
     */
    public static int ALTITUDE_OS_DEFAULT() {
        return ALTITUDE_OS_DEFAULT;
    }
    /**
     * {@snippet lang=c :
     * typedef enum POWER_SETTING_ALTITUDE {
     *     ALTITUDE_GROUP_POLICY,
     *     ALTITUDE_USER,
     *     ALTITUDE_RUNTIME_OVERRIDE,
     *     ALTITUDE_PROVISIONING,
     *     ALTITUDE_OEM_CUSTOMIZATION,
     *     ALTITUDE_INTERNAL_OVERRIDE,
     *     ALTITUDE_OS_DEFAULT
     * } *PPOWER_SETTING_ALTITUDE
     * }
     */
    public static final AddressLayout PPOWER_SETTING_ALTITUDE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD Granularity;
     *     DWORD Capacity;
     * } *PBATTERY_REPORTING_SCALE
     * }
     */
    public static final AddressLayout PBATTERY_REPORTING_SCALE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD Frequency;
     *     DWORD Flags;
     *     DWORD PercentFrequency;
     * } *PPPM_WMI_LEGACY_PERFSTATE
     * }
     */
    public static final AddressLayout PPPM_WMI_LEGACY_PERFSTATE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD Latency;
     *     DWORD Power;
     *     DWORD TimeCheck;
     *     BYTE PromotePercent;
     *     BYTE DemotePercent;
     *     BYTE StateType;
     *     BYTE Reserved;
     *     DWORD StateFlags;
     *     DWORD Context;
     *     DWORD IdleHandler;
     *     DWORD Reserved1;
     * } *PPPM_WMI_IDLE_STATE
     * }
     */
    public static final AddressLayout PPPM_WMI_IDLE_STATE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD Type;
     *     DWORD Count;
     *     DWORD TargetState;
     *     DWORD OldState;
     *     DWORD64 TargetProcessors;
     *     PPM_WMI_IDLE_STATE State[1];
     * } *PPPM_WMI_IDLE_STATES
     * }
     */
    public static final AddressLayout PPPM_WMI_IDLE_STATES = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD Type;
     *     DWORD Count;
     *     DWORD TargetState;
     *     DWORD OldState;
     *     PVOID TargetProcessors;
     *     PPM_WMI_IDLE_STATE State[1];
     * } *PPPM_WMI_IDLE_STATES_EX
     * }
     */
    public static final AddressLayout PPPM_WMI_IDLE_STATES_EX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD Frequency;
     *     DWORD Power;
     *     BYTE PercentFrequency;
     *     BYTE IncreaseLevel;
     *     BYTE DecreaseLevel;
     *     BYTE Type;
     *     DWORD IncreaseTime;
     *     DWORD DecreaseTime;
     *     DWORD64 Control;
     *     DWORD64 Status;
     *     DWORD HitCount;
     *     DWORD Reserved1;
     *     DWORD64 Reserved2;
     *     DWORD64 Reserved3;
     * } *PPPM_WMI_PERF_STATE
     * }
     */
    public static final AddressLayout PPPM_WMI_PERF_STATE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD Count;
     *     DWORD MaxFrequency;
     *     DWORD CurrentState;
     *     DWORD MaxPerfState;
     *     DWORD MinPerfState;
     *     DWORD LowestPerfState;
     *     DWORD ThermalConstraint;
     *     BYTE BusyAdjThreshold;
     *     BYTE PolicyType;
     *     BYTE Type;
     *     BYTE Reserved;
     *     DWORD TimerInterval;
     *     DWORD64 TargetProcessors;
     *     DWORD PStateHandler;
     *     DWORD PStateContext;
     *     DWORD TStateHandler;
     *     DWORD TStateContext;
     *     DWORD FeedbackHandler;
     *     DWORD Reserved1;
     *     DWORD64 Reserved2;
     *     PPM_WMI_PERF_STATE State[1];
     * } *PPPM_WMI_PERF_STATES
     * }
     */
    public static final AddressLayout PPPM_WMI_PERF_STATES = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD Count;
     *     DWORD MaxFrequency;
     *     DWORD CurrentState;
     *     DWORD MaxPerfState;
     *     DWORD MinPerfState;
     *     DWORD LowestPerfState;
     *     DWORD ThermalConstraint;
     *     BYTE BusyAdjThreshold;
     *     BYTE PolicyType;
     *     BYTE Type;
     *     BYTE Reserved;
     *     DWORD TimerInterval;
     *     PVOID TargetProcessors;
     *     DWORD PStateHandler;
     *     DWORD PStateContext;
     *     DWORD TStateHandler;
     *     DWORD TStateContext;
     *     DWORD FeedbackHandler;
     *     DWORD Reserved1;
     *     DWORD64 Reserved2;
     *     PPM_WMI_PERF_STATE State[1];
     * } *PPPM_WMI_PERF_STATES_EX
     * }
     */
    public static final AddressLayout PPPM_WMI_PERF_STATES_EX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD IdleTransitions;
     *     DWORD FailedTransitions;
     *     DWORD InvalidBucketIndex;
     *     DWORD64 TotalTime;
     *     DWORD IdleTimeBuckets[6];
     * } *PPPM_IDLE_STATE_ACCOUNTING
     * }
     */
    public static final AddressLayout PPPM_IDLE_STATE_ACCOUNTING = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD StateCount;
     *     DWORD TotalTransitions;
     *     DWORD ResetCount;
     *     DWORD64 StartTime;
     *     PPM_IDLE_STATE_ACCOUNTING State[1];
     * } *PPPM_IDLE_ACCOUNTING
     * }
     */
    public static final AddressLayout PPPM_IDLE_ACCOUNTING = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD64 TotalTimeUs;
     *     DWORD MinTimeUs;
     *     DWORD MaxTimeUs;
     *     DWORD Count;
     * } *PPPM_IDLE_STATE_BUCKET_EX
     * }
     */
    public static final AddressLayout PPPM_IDLE_STATE_BUCKET_EX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD64 TotalTime;
     *     DWORD IdleTransitions;
     *     DWORD FailedTransitions;
     *     DWORD InvalidBucketIndex;
     *     DWORD MinTimeUs;
     *     DWORD MaxTimeUs;
     *     DWORD CancelledTransitions;
     *     PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
     * } *PPPM_IDLE_STATE_ACCOUNTING_EX
     * }
     */
    public static final AddressLayout PPPM_IDLE_STATE_ACCOUNTING_EX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD StateCount;
     *     DWORD TotalTransitions;
     *     DWORD ResetCount;
     *     DWORD AbortCount;
     *     DWORD64 StartTime;
     *     PPM_IDLE_STATE_ACCOUNTING_EX State[1];
     * } *PPPM_IDLE_ACCOUNTING_EX
     * }
     */
    public static final AddressLayout PPPM_IDLE_ACCOUNTING_EX = winapi.C_POINTER;

    private static class PPM_PERFSTATE_CHANGE_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_PERFSTATE_CHANGE_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFSTATE_CHANGE_GUID
     * }
     */
    public static GroupLayout PPM_PERFSTATE_CHANGE_GUID$layout() {
        return PPM_PERFSTATE_CHANGE_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFSTATE_CHANGE_GUID
     * }
     */
    public static MemorySegment PPM_PERFSTATE_CHANGE_GUID() {
        return PPM_PERFSTATE_CHANGE_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFSTATE_CHANGE_GUID
     * }
     */
    public static void PPM_PERFSTATE_CHANGE_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_PERFSTATE_CHANGE_GUID$constants.SEGMENT, 0L, PPM_PERFSTATE_CHANGE_GUID$constants.LAYOUT.byteSize());
    }

    private static class PPM_PERFSTATE_DOMAIN_CHANGE_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_PERFSTATE_DOMAIN_CHANGE_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID
     * }
     */
    public static GroupLayout PPM_PERFSTATE_DOMAIN_CHANGE_GUID$layout() {
        return PPM_PERFSTATE_DOMAIN_CHANGE_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID
     * }
     */
    public static MemorySegment PPM_PERFSTATE_DOMAIN_CHANGE_GUID() {
        return PPM_PERFSTATE_DOMAIN_CHANGE_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID
     * }
     */
    public static void PPM_PERFSTATE_DOMAIN_CHANGE_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_PERFSTATE_DOMAIN_CHANGE_GUID$constants.SEGMENT, 0L, PPM_PERFSTATE_DOMAIN_CHANGE_GUID$constants.LAYOUT.byteSize());
    }

    private static class PPM_IDLESTATE_CHANGE_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_IDLESTATE_CHANGE_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLESTATE_CHANGE_GUID
     * }
     */
    public static GroupLayout PPM_IDLESTATE_CHANGE_GUID$layout() {
        return PPM_IDLESTATE_CHANGE_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLESTATE_CHANGE_GUID
     * }
     */
    public static MemorySegment PPM_IDLESTATE_CHANGE_GUID() {
        return PPM_IDLESTATE_CHANGE_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLESTATE_CHANGE_GUID
     * }
     */
    public static void PPM_IDLESTATE_CHANGE_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_IDLESTATE_CHANGE_GUID$constants.SEGMENT, 0L, PPM_IDLESTATE_CHANGE_GUID$constants.LAYOUT.byteSize());
    }

    private static class PPM_PERFSTATES_DATA_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_PERFSTATES_DATA_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFSTATES_DATA_GUID
     * }
     */
    public static GroupLayout PPM_PERFSTATES_DATA_GUID$layout() {
        return PPM_PERFSTATES_DATA_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFSTATES_DATA_GUID
     * }
     */
    public static MemorySegment PPM_PERFSTATES_DATA_GUID() {
        return PPM_PERFSTATES_DATA_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFSTATES_DATA_GUID
     * }
     */
    public static void PPM_PERFSTATES_DATA_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_PERFSTATES_DATA_GUID$constants.SEGMENT, 0L, PPM_PERFSTATES_DATA_GUID$constants.LAYOUT.byteSize());
    }

    private static class PPM_IDLESTATES_DATA_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_IDLESTATES_DATA_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLESTATES_DATA_GUID
     * }
     */
    public static GroupLayout PPM_IDLESTATES_DATA_GUID$layout() {
        return PPM_IDLESTATES_DATA_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLESTATES_DATA_GUID
     * }
     */
    public static MemorySegment PPM_IDLESTATES_DATA_GUID() {
        return PPM_IDLESTATES_DATA_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLESTATES_DATA_GUID
     * }
     */
    public static void PPM_IDLESTATES_DATA_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_IDLESTATES_DATA_GUID$constants.SEGMENT, 0L, PPM_IDLESTATES_DATA_GUID$constants.LAYOUT.byteSize());
    }

    private static class PPM_IDLE_ACCOUNTING_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_IDLE_ACCOUNTING_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLE_ACCOUNTING_GUID
     * }
     */
    public static GroupLayout PPM_IDLE_ACCOUNTING_GUID$layout() {
        return PPM_IDLE_ACCOUNTING_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLE_ACCOUNTING_GUID
     * }
     */
    public static MemorySegment PPM_IDLE_ACCOUNTING_GUID() {
        return PPM_IDLE_ACCOUNTING_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLE_ACCOUNTING_GUID
     * }
     */
    public static void PPM_IDLE_ACCOUNTING_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_IDLE_ACCOUNTING_GUID$constants.SEGMENT, 0L, PPM_IDLE_ACCOUNTING_GUID$constants.LAYOUT.byteSize());
    }

    private static class PPM_IDLE_ACCOUNTING_EX_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_IDLE_ACCOUNTING_EX_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLE_ACCOUNTING_EX_GUID
     * }
     */
    public static GroupLayout PPM_IDLE_ACCOUNTING_EX_GUID$layout() {
        return PPM_IDLE_ACCOUNTING_EX_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLE_ACCOUNTING_EX_GUID
     * }
     */
    public static MemorySegment PPM_IDLE_ACCOUNTING_EX_GUID() {
        return PPM_IDLE_ACCOUNTING_EX_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_IDLE_ACCOUNTING_EX_GUID
     * }
     */
    public static void PPM_IDLE_ACCOUNTING_EX_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_IDLE_ACCOUNTING_EX_GUID$constants.SEGMENT, 0L, PPM_IDLE_ACCOUNTING_EX_GUID$constants.LAYOUT.byteSize());
    }

    private static class PPM_THERMALCONSTRAINT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_THERMALCONSTRAINT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_THERMALCONSTRAINT_GUID
     * }
     */
    public static GroupLayout PPM_THERMALCONSTRAINT_GUID$layout() {
        return PPM_THERMALCONSTRAINT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_THERMALCONSTRAINT_GUID
     * }
     */
    public static MemorySegment PPM_THERMALCONSTRAINT_GUID() {
        return PPM_THERMALCONSTRAINT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_THERMALCONSTRAINT_GUID
     * }
     */
    public static void PPM_THERMALCONSTRAINT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_THERMALCONSTRAINT_GUID$constants.SEGMENT, 0L, PPM_THERMALCONSTRAINT_GUID$constants.LAYOUT.byteSize());
    }

    private static class PPM_PERFMON_PERFSTATE_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_PERFMON_PERFSTATE_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFMON_PERFSTATE_GUID
     * }
     */
    public static GroupLayout PPM_PERFMON_PERFSTATE_GUID$layout() {
        return PPM_PERFMON_PERFSTATE_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFMON_PERFSTATE_GUID
     * }
     */
    public static MemorySegment PPM_PERFMON_PERFSTATE_GUID() {
        return PPM_PERFMON_PERFSTATE_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_PERFMON_PERFSTATE_GUID
     * }
     */
    public static void PPM_PERFMON_PERFSTATE_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_PERFMON_PERFSTATE_GUID$constants.SEGMENT, 0L, PPM_PERFMON_PERFSTATE_GUID$constants.LAYOUT.byteSize());
    }

    private static class PPM_THERMAL_POLICY_CHANGE_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = winapi.findOrThrow("PPM_THERMAL_POLICY_CHANGE_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_THERMAL_POLICY_CHANGE_GUID
     * }
     */
    public static GroupLayout PPM_THERMAL_POLICY_CHANGE_GUID$layout() {
        return PPM_THERMAL_POLICY_CHANGE_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_THERMAL_POLICY_CHANGE_GUID
     * }
     */
    public static MemorySegment PPM_THERMAL_POLICY_CHANGE_GUID() {
        return PPM_THERMAL_POLICY_CHANGE_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID PPM_THERMAL_POLICY_CHANGE_GUID
     * }
     */
    public static void PPM_THERMAL_POLICY_CHANGE_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PPM_THERMAL_POLICY_CHANGE_GUID$constants.SEGMENT, 0L, PPM_THERMAL_POLICY_CHANGE_GUID$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD State;
     *     DWORD Status;
     *     DWORD Latency;
     *     DWORD Speed;
     *     DWORD Processor;
     * } *PPPM_PERFSTATE_EVENT
     * }
     */
    public static final AddressLayout PPPM_PERFSTATE_EVENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD State;
     *     DWORD Latency;
     *     DWORD Speed;
     *     DWORD64 Processors;
     * } *PPPM_PERFSTATE_DOMAIN_EVENT
     * }
     */
    public static final AddressLayout PPPM_PERFSTATE_DOMAIN_EVENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD NewState;
     *     DWORD OldState;
     *     DWORD64 Processors;
     * } *PPPM_IDLESTATE_EVENT
     * }
     */
    public static final AddressLayout PPPM_IDLESTATE_EVENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD ThermalConstraint;
     *     DWORD64 Processors;
     * } *PPPM_THERMALCHANGE_EVENT
     * }
     */
    public static final AddressLayout PPPM_THERMALCHANGE_EVENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     BYTE Mode;
     *     DWORD64 Processors;
     * } *PPPM_THERMAL_POLICY_EVENT
     * }
     */
    public static final AddressLayout PPPM_THERMAL_POLICY_EVENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     POWER_ACTION Action;
     *     DWORD Flags;
     *     DWORD EventCode;
     * } *PPOWER_ACTION_POLICY
     * }
     */
    public static final AddressLayout PPOWER_ACTION_POLICY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     BOOLEAN Enable;
     *     BYTE Spare[3];
     *     DWORD BatteryLevel;
     *     POWER_ACTION_POLICY PowerPolicy;
     *     SYSTEM_POWER_STATE MinSystemState;
     * } *PSYSTEM_POWER_LEVEL
     * }
     */
    public static final AddressLayout PSYSTEM_POWER_LEVEL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_POWER_POLICY {
     *     DWORD Revision;
     *     POWER_ACTION_POLICY PowerButton;
     *     POWER_ACTION_POLICY SleepButton;
     *     POWER_ACTION_POLICY LidClose;
     *     SYSTEM_POWER_STATE LidOpenWake;
     *     DWORD Reserved;
     *     POWER_ACTION_POLICY Idle;
     *     DWORD IdleTimeout;
     *     BYTE IdleSensitivity;
     *     BYTE DynamicThrottle;
     *     BYTE Spare2[2];
     *     SYSTEM_POWER_STATE MinSleep;
     *     SYSTEM_POWER_STATE MaxSleep;
     *     SYSTEM_POWER_STATE ReducedLatencySleep;
     *     DWORD WinLogonFlags;
     *     DWORD Spare3;
     *     DWORD DozeS4Timeout;
     *     DWORD BroadcastCapacityResolution;
     *     SYSTEM_POWER_LEVEL DischargePolicy[4];
     *     DWORD VideoTimeout;
     *     BOOLEAN VideoDimDisplay;
     *     DWORD VideoReserved[3];
     *     DWORD SpindownTimeout;
     *     BOOLEAN OptimizeForPower;
     *     BYTE FanThrottleTolerance;
     *     BYTE ForcedThrottle;
     *     BYTE MinThrottle;
     *     POWER_ACTION_POLICY OverThrottled;
     * } *PSYSTEM_POWER_POLICY
     * }
     */
    public static final AddressLayout PSYSTEM_POWER_POLICY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD TimeCheck;
     *     BYTE DemotePercent;
     *     BYTE PromotePercent;
     *     BYTE Spare[2];
     * } *PPROCESSOR_IDLESTATE_INFO
     * }
     */
    public static final AddressLayout PPROCESSOR_IDLESTATE_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     WORD Revision;
     *     union {
     *         WORD AsWORD;
     *         struct {
     *             WORD AllowScaling : 1;
     *             WORD Disabled : 1;
     *             WORD Reserved : 14;
     *         };
     *     } Flags;
     *     DWORD PolicyCount;
     *     PROCESSOR_IDLESTATE_INFO Policy[3];
     * } *PPROCESSOR_IDLESTATE_POLICY
     * }
     */
    public static final AddressLayout PPROCESSOR_IDLESTATE_POLICY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESSOR_POWER_POLICY_INFO {
     *     DWORD TimeCheck;
     *     DWORD DemoteLimit;
     *     DWORD PromoteLimit;
     *     BYTE DemotePercent;
     *     BYTE PromotePercent;
     *     BYTE Spare[2];
     *     DWORD AllowDemotion : 1;
     *     DWORD AllowPromotion : 1;
     *     DWORD Reserved : 30;
     * } *PPROCESSOR_POWER_POLICY_INFO
     * }
     */
    public static final AddressLayout PPROCESSOR_POWER_POLICY_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESSOR_POWER_POLICY {
     *     DWORD Revision;
     *     BYTE DynamicThrottle;
     *     BYTE Spare[3];
     *     DWORD DisableCStates : 1;
     *     DWORD Reserved : 31;
     *     DWORD PolicyCount;
     *     PROCESSOR_POWER_POLICY_INFO Policy[3];
     * } *PPROCESSOR_POWER_POLICY
     * }
     */
    public static final AddressLayout PPROCESSOR_POWER_POLICY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD Revision;
     *     BYTE MaxThrottle;
     *     BYTE MinThrottle;
     *     BYTE BusyAdjThreshold;
     *     union {
     *         BYTE Spare;
     *         union {
     *             BYTE AsBYTE;
     *             struct {
     *                 BYTE NoDomainAccounting : 1;
     *                 BYTE IncreasePolicy : 2;
     *                 BYTE DecreasePolicy : 2;
     *                 BYTE Reserved : 3;
     *             };
     *         } Flags;
     *     };
     *     DWORD TimeCheck;
     *     DWORD IncreaseTime;
     *     DWORD DecreaseTime;
     *     DWORD IncreasePercent;
     *     DWORD DecreasePercent;
     * } *PPROCESSOR_PERFSTATE_POLICY
     * }
     */
    public static final AddressLayout PPROCESSOR_PERFSTATE_POLICY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ADMINISTRATOR_POWER_POLICY {
     *     SYSTEM_POWER_STATE MinSleep;
     *     SYSTEM_POWER_STATE MaxSleep;
     *     DWORD MinVideoTimeout;
     *     DWORD MaxVideoTimeout;
     *     DWORD MinSpindownTimeout;
     *     DWORD MaxSpindownTimeout;
     * } *PADMINISTRATOR_POWER_POLICY
     * }
     */
    public static final AddressLayout PADMINISTRATOR_POWER_POLICY = winapi.C_POINTER;
    private static final int HiberFileBucket1GB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _HIBERFILE_BUCKET_SIZE.HiberFileBucket1GB = 0
     * }
     */
    public static int HiberFileBucket1GB() {
        return HiberFileBucket1GB;
    }
    private static final int HiberFileBucket2GB = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _HIBERFILE_BUCKET_SIZE.HiberFileBucket2GB = 1
     * }
     */
    public static int HiberFileBucket2GB() {
        return HiberFileBucket2GB;
    }
    private static final int HiberFileBucket4GB = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _HIBERFILE_BUCKET_SIZE.HiberFileBucket4GB = 2
     * }
     */
    public static int HiberFileBucket4GB() {
        return HiberFileBucket4GB;
    }
    private static final int HiberFileBucket8GB = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _HIBERFILE_BUCKET_SIZE.HiberFileBucket8GB = 3
     * }
     */
    public static int HiberFileBucket8GB() {
        return HiberFileBucket8GB;
    }
    private static final int HiberFileBucket16GB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _HIBERFILE_BUCKET_SIZE.HiberFileBucket16GB = 4
     * }
     */
    public static int HiberFileBucket16GB() {
        return HiberFileBucket16GB;
    }
    private static final int HiberFileBucket32GB = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _HIBERFILE_BUCKET_SIZE.HiberFileBucket32GB = 5
     * }
     */
    public static int HiberFileBucket32GB() {
        return HiberFileBucket32GB;
    }
    private static final int HiberFileBucketUnlimited = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _HIBERFILE_BUCKET_SIZE.HiberFileBucketUnlimited = 6
     * }
     */
    public static int HiberFileBucketUnlimited() {
        return HiberFileBucketUnlimited;
    }
    private static final int HiberFileBucketMax = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _HIBERFILE_BUCKET_SIZE.HiberFileBucketMax = 7
     * }
     */
    public static int HiberFileBucketMax() {
        return HiberFileBucketMax;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _HIBERFILE_BUCKET_SIZE {
     *     HiberFileBucket1GB = 0,
     *     HiberFileBucket2GB,
     *     HiberFileBucket4GB,
     *     HiberFileBucket8GB,
     *     HiberFileBucket16GB,
     *     HiberFileBucket32GB,
     *     HiberFileBucketUnlimited,
     *     HiberFileBucketMax
     * } *PHIBERFILE_BUCKET_SIZE
     * }
     */
    public static final AddressLayout PHIBERFILE_BUCKET_SIZE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _HIBERFILE_BUCKET {
     *     DWORD64 MaxPhysicalMemory;
     *     DWORD PhysicalMemoryPercent[3];
     * } *PHIBERFILE_BUCKET
     * }
     */
    public static final AddressLayout PHIBERFILE_BUCKET = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     BOOLEAN PowerButtonPresent;
     *     BOOLEAN SleepButtonPresent;
     *     BOOLEAN LidPresent;
     *     BOOLEAN SystemS1;
     *     BOOLEAN SystemS2;
     *     BOOLEAN SystemS3;
     *     BOOLEAN SystemS4;
     *     BOOLEAN SystemS5;
     *     BOOLEAN HiberFilePresent;
     *     BOOLEAN FullWake;
     *     BOOLEAN VideoDimPresent;
     *     BOOLEAN ApmPresent;
     *     BOOLEAN UpsPresent;
     *     BOOLEAN ThermalControl;
     *     BOOLEAN ProcessorThrottle;
     *     BYTE ProcessorMinThrottle;
     *     BYTE ProcessorMaxThrottle;
     *     BOOLEAN FastSystemS4;
     *     BOOLEAN Hiberboot;
     *     BOOLEAN WakeAlarmPresent;
     *     BOOLEAN AoAc;
     *     BOOLEAN DiskSpinDown;
     *     BYTE HiberFileType;
     *     BOOLEAN AoAcConnectivitySupported;
     *     BYTE spare3[6];
     *     BOOLEAN SystemBatteriesPresent;
     *     BOOLEAN BatteriesAreShortTerm;
     *     BATTERY_REPORTING_SCALE BatteryScale[3];
     *     SYSTEM_POWER_STATE AcOnLineWake;
     *     SYSTEM_POWER_STATE SoftLidWake;
     *     SYSTEM_POWER_STATE RtcWake;
     *     SYSTEM_POWER_STATE MinDeviceWakeState;
     *     SYSTEM_POWER_STATE DefaultLowLatencyWake;
     * } *PSYSTEM_POWER_CAPABILITIES
     * }
     */
    public static final AddressLayout PSYSTEM_POWER_CAPABILITIES = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     BOOLEAN AcOnLine;
     *     BOOLEAN BatteryPresent;
     *     BOOLEAN Charging;
     *     BOOLEAN Discharging;
     *     BOOLEAN Spare1[3];
     *     BYTE Tag;
     *     DWORD MaxCapacity;
     *     DWORD RemainingCapacity;
     *     DWORD Rate;
     *     DWORD EstimatedTime;
     *     DWORD DefaultAlert1;
     *     DWORD DefaultAlert2;
     * } *PSYSTEM_BATTERY_STATE
     * }
     */
    public static final AddressLayout PSYSTEM_BATTERY_STATE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_POWER_SOURCE_STATE {
     *     SYSTEM_BATTERY_STATE BatteryState;
     *     DWORD InstantaneousPeakPower;
     *     DWORD InstantaneousPeakPeriod;
     *     DWORD SustainablePeakPower;
     *     DWORD SustainablePeakPeriod;
     *     DWORD PeakPower;
     *     DWORD MaxOutputPower;
     *     DWORD MaxInputPower;
     *     LONG BatteryRateInCurrent;
     *     DWORD BatteryVoltage;
     * } *PSYSTEM_POWER_SOURCE_STATE
     * }
     */
    public static final AddressLayout PSYSTEM_POWER_SOURCE_STATE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DOS_HEADER {
     *     WORD e_magic;
     *     WORD e_cblp;
     *     WORD e_cp;
     *     WORD e_crlc;
     *     WORD e_cparhdr;
     *     WORD e_minalloc;
     *     WORD e_maxalloc;
     *     WORD e_ss;
     *     WORD e_sp;
     *     WORD e_csum;
     *     WORD e_ip;
     *     WORD e_cs;
     *     WORD e_lfarlc;
     *     WORD e_ovno;
     *     WORD e_res[4];
     *     WORD e_oemid;
     *     WORD e_oeminfo;
     *     WORD e_res2[10];
     *     LONG e_lfanew;
     * } *PIMAGE_DOS_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_DOS_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_OS2_HEADER {
     *     WORD ne_magic;
     *     CHAR ne_ver;
     *     CHAR ne_rev;
     *     WORD ne_enttab;
     *     WORD ne_cbenttab;
     *     LONG ne_crc;
     *     WORD ne_flags;
     *     WORD ne_autodata;
     *     WORD ne_heap;
     *     WORD ne_stack;
     *     LONG ne_csip;
     *     LONG ne_sssp;
     *     WORD ne_cseg;
     *     WORD ne_cmod;
     *     WORD ne_cbnrestab;
     *     WORD ne_segtab;
     *     WORD ne_rsrctab;
     *     WORD ne_restab;
     *     WORD ne_modtab;
     *     WORD ne_imptab;
     *     LONG ne_nrestab;
     *     WORD ne_cmovent;
     *     WORD ne_align;
     *     WORD ne_cres;
     *     BYTE ne_exetyp;
     *     BYTE ne_flagsothers;
     *     WORD ne_pretthunks;
     *     WORD ne_psegrefbytes;
     *     WORD ne_swaparea;
     *     WORD ne_expver;
     * } *PIMAGE_OS2_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_OS2_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_VXD_HEADER {
     *     WORD e32_magic;
     *     BYTE e32_border;
     *     BYTE e32_worder;
     *     DWORD e32_level;
     *     WORD e32_cpu;
     *     WORD e32_os;
     *     DWORD e32_ver;
     *     DWORD e32_mflags;
     *     DWORD e32_mpages;
     *     DWORD e32_startobj;
     *     DWORD e32_eip;
     *     DWORD e32_stackobj;
     *     DWORD e32_esp;
     *     DWORD e32_pagesize;
     *     DWORD e32_lastpagesize;
     *     DWORD e32_fixupsize;
     *     DWORD e32_fixupsum;
     *     DWORD e32_ldrsize;
     *     DWORD e32_ldrsum;
     *     DWORD e32_objtab;
     *     DWORD e32_objcnt;
     *     DWORD e32_objmap;
     *     DWORD e32_itermap;
     *     DWORD e32_rsrctab;
     *     DWORD e32_rsrccnt;
     *     DWORD e32_restab;
     *     DWORD e32_enttab;
     *     DWORD e32_dirtab;
     *     DWORD e32_dircnt;
     *     DWORD e32_fpagetab;
     *     DWORD e32_frectab;
     *     DWORD e32_impmod;
     *     DWORD e32_impmodcnt;
     *     DWORD e32_impproc;
     *     DWORD e32_pagesum;
     *     DWORD e32_datapage;
     *     DWORD e32_preload;
     *     DWORD e32_nrestab;
     *     DWORD e32_cbnrestab;
     *     DWORD e32_nressum;
     *     DWORD e32_autodata;
     *     DWORD e32_debuginfo;
     *     DWORD e32_debuglen;
     *     DWORD e32_instpreload;
     *     DWORD e32_instdemand;
     *     DWORD e32_heapsize;
     *     BYTE e32_res3[12];
     *     DWORD e32_winresoff;
     *     DWORD e32_winreslen;
     *     WORD e32_devid;
     *     WORD e32_ddkver;
     * } *PIMAGE_VXD_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_VXD_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_FILE_HEADER {
     *     WORD Machine;
     *     WORD NumberOfSections;
     *     DWORD TimeDateStamp;
     *     DWORD PointerToSymbolTable;
     *     DWORD NumberOfSymbols;
     *     WORD SizeOfOptionalHeader;
     *     WORD Characteristics;
     * } *PIMAGE_FILE_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_FILE_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DATA_DIRECTORY {
     *     DWORD VirtualAddress;
     *     DWORD Size;
     * } *PIMAGE_DATA_DIRECTORY
     * }
     */
    public static final AddressLayout PIMAGE_DATA_DIRECTORY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_OPTIONAL_HEADER {
     *     WORD Magic;
     *     BYTE MajorLinkerVersion;
     *     BYTE MinorLinkerVersion;
     *     DWORD SizeOfCode;
     *     DWORD SizeOfInitializedData;
     *     DWORD SizeOfUninitializedData;
     *     DWORD AddressOfEntryPoint;
     *     DWORD BaseOfCode;
     *     DWORD BaseOfData;
     *     DWORD ImageBase;
     *     DWORD SectionAlignment;
     *     DWORD FileAlignment;
     *     WORD MajorOperatingSystemVersion;
     *     WORD MinorOperatingSystemVersion;
     *     WORD MajorImageVersion;
     *     WORD MinorImageVersion;
     *     WORD MajorSubsystemVersion;
     *     WORD MinorSubsystemVersion;
     *     DWORD Win32VersionValue;
     *     DWORD SizeOfImage;
     *     DWORD SizeOfHeaders;
     *     DWORD CheckSum;
     *     WORD Subsystem;
     *     WORD DllCharacteristics;
     *     DWORD SizeOfStackReserve;
     *     DWORD SizeOfStackCommit;
     *     DWORD SizeOfHeapReserve;
     *     DWORD SizeOfHeapCommit;
     *     DWORD LoaderFlags;
     *     DWORD NumberOfRvaAndSizes;
     *     IMAGE_DATA_DIRECTORY DataDirectory[16];
     * } *PIMAGE_OPTIONAL_HEADER32
     * }
     */
    public static final AddressLayout PIMAGE_OPTIONAL_HEADER32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
     *     WORD Magic;
     *     BYTE MajorLinkerVersion;
     *     BYTE MinorLinkerVersion;
     *     DWORD SizeOfCode;
     *     DWORD SizeOfInitializedData;
     *     DWORD SizeOfUninitializedData;
     *     DWORD AddressOfEntryPoint;
     *     DWORD BaseOfCode;
     *     DWORD BaseOfData;
     *     DWORD BaseOfBss;
     *     DWORD GprMask;
     *     DWORD CprMask[4];
     *     DWORD GpValue;
     * } *PIMAGE_ROM_OPTIONAL_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_ROM_OPTIONAL_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_OPTIONAL_HEADER64 {
     *     WORD Magic;
     *     BYTE MajorLinkerVersion;
     *     BYTE MinorLinkerVersion;
     *     DWORD SizeOfCode;
     *     DWORD SizeOfInitializedData;
     *     DWORD SizeOfUninitializedData;
     *     DWORD AddressOfEntryPoint;
     *     DWORD BaseOfCode;
     *     ULONGLONG ImageBase;
     *     DWORD SectionAlignment;
     *     DWORD FileAlignment;
     *     WORD MajorOperatingSystemVersion;
     *     WORD MinorOperatingSystemVersion;
     *     WORD MajorImageVersion;
     *     WORD MinorImageVersion;
     *     WORD MajorSubsystemVersion;
     *     WORD MinorSubsystemVersion;
     *     DWORD Win32VersionValue;
     *     DWORD SizeOfImage;
     *     DWORD SizeOfHeaders;
     *     DWORD CheckSum;
     *     WORD Subsystem;
     *     WORD DllCharacteristics;
     *     ULONGLONG SizeOfStackReserve;
     *     ULONGLONG SizeOfStackCommit;
     *     ULONGLONG SizeOfHeapReserve;
     *     ULONGLONG SizeOfHeapCommit;
     *     DWORD LoaderFlags;
     *     DWORD NumberOfRvaAndSizes;
     *     IMAGE_DATA_DIRECTORY DataDirectory[16];
     * } *PIMAGE_OPTIONAL_HEADER64
     * }
     */
    public static final AddressLayout PIMAGE_OPTIONAL_HEADER64 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMAGE_OPTIONAL_HEADER64 PIMAGE_OPTIONAL_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_OPTIONAL_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_NT_HEADERS64 {
     *     DWORD Signature;
     *     IMAGE_FILE_HEADER FileHeader;
     *     IMAGE_OPTIONAL_HEADER64 OptionalHeader;
     * } *PIMAGE_NT_HEADERS64
     * }
     */
    public static final AddressLayout PIMAGE_NT_HEADERS64 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_NT_HEADERS {
     *     DWORD Signature;
     *     IMAGE_FILE_HEADER FileHeader;
     *     IMAGE_OPTIONAL_HEADER32 OptionalHeader;
     * } *PIMAGE_NT_HEADERS32
     * }
     */
    public static final AddressLayout PIMAGE_NT_HEADERS32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ROM_HEADERS {
     *     IMAGE_FILE_HEADER FileHeader;
     *     IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
     * } *PIMAGE_ROM_HEADERS
     * }
     */
    public static final AddressLayout PIMAGE_ROM_HEADERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS
     * }
     */
    public static final AddressLayout PIMAGE_NT_HEADERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_SECTION_HEADER {
     *     BYTE Name[8];
     *     union {
     *         DWORD PhysicalAddress;
     *         DWORD VirtualSize;
     *     } Misc;
     *     DWORD VirtualAddress;
     *     DWORD SizeOfRawData;
     *     DWORD PointerToRawData;
     *     DWORD PointerToRelocations;
     *     DWORD PointerToLinenumbers;
     *     WORD NumberOfRelocations;
     *     WORD NumberOfLinenumbers;
     *     DWORD Characteristics;
     * } *PIMAGE_SECTION_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_SECTION_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_SYMBOL *PIMAGE_SYMBOL
     * }
     */
    public static final AddressLayout PIMAGE_SYMBOL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_SYMBOL_EX *PIMAGE_SYMBOL_EX
     * }
     */
    public static final AddressLayout PIMAGE_SYMBOL_EX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_AUX_SYMBOL_TOKEN_DEF *PIMAGE_AUX_SYMBOL_TOKEN_DEF
     * }
     */
    public static final AddressLayout PIMAGE_AUX_SYMBOL_TOKEN_DEF = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_AUX_SYMBOL *PIMAGE_AUX_SYMBOL
     * }
     */
    public static final AddressLayout PIMAGE_AUX_SYMBOL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_AUX_SYMBOL_EX *PIMAGE_AUX_SYMBOL_EX
     * }
     */
    public static final AddressLayout PIMAGE_AUX_SYMBOL_EX = winapi.C_POINTER;
    private static final int IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = (int)1L;
    /**
     * {@snippet lang=c :
     * enum IMAGE_AUX_SYMBOL_TYPE.IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1
     * }
     */
    public static int IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF() {
        return IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF;
    }
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_RELOCATION *PIMAGE_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_LINENUMBER *PIMAGE_LINENUMBER
     * }
     */
    public static final AddressLayout PIMAGE_LINENUMBER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_BASE_RELOCATION *PIMAGE_BASE_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_BASE_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
     *     BYTE Name[16];
     *     BYTE Date[12];
     *     BYTE UserID[6];
     *     BYTE GroupID[6];
     *     BYTE Mode[8];
     *     BYTE Size[10];
     *     BYTE EndHeader[2];
     * } *PIMAGE_ARCHIVE_MEMBER_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_ARCHIVE_MEMBER_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_EXPORT_DIRECTORY {
     *     DWORD Characteristics;
     *     DWORD TimeDateStamp;
     *     WORD MajorVersion;
     *     WORD MinorVersion;
     *     DWORD Name;
     *     DWORD Base;
     *     DWORD NumberOfFunctions;
     *     DWORD NumberOfNames;
     *     DWORD AddressOfFunctions;
     *     DWORD AddressOfNames;
     *     DWORD AddressOfNameOrdinals;
     * } *PIMAGE_EXPORT_DIRECTORY
     * }
     */
    public static final AddressLayout PIMAGE_EXPORT_DIRECTORY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_IMPORT_BY_NAME {
     *     WORD Hint;
     *     CHAR Name[1];
     * } *PIMAGE_IMPORT_BY_NAME
     * }
     */
    public static final AddressLayout PIMAGE_IMPORT_BY_NAME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IMAGE_THUNK_DATA64 *PIMAGE_THUNK_DATA64
     * }
     */
    public static final AddressLayout PIMAGE_THUNK_DATA64 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IMAGE_THUNK_DATA32 *PIMAGE_THUNK_DATA32
     * }
     */
    public static final AddressLayout PIMAGE_THUNK_DATA32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IMAGE_TLS_DIRECTORY64 *PIMAGE_TLS_DIRECTORY64
     * }
     */
    public static final AddressLayout PIMAGE_TLS_DIRECTORY64 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IMAGE_TLS_DIRECTORY32 *PIMAGE_TLS_DIRECTORY32
     * }
     */
    public static final AddressLayout PIMAGE_TLS_DIRECTORY32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMAGE_THUNK_DATA64 PIMAGE_THUNK_DATA
     * }
     */
    public static final AddressLayout PIMAGE_THUNK_DATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY
     * }
     */
    public static final AddressLayout PIMAGE_TLS_DIRECTORY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_IMPORT_DESCRIPTOR *PIMAGE_IMPORT_DESCRIPTOR
     * }
     */
    public static final AddressLayout PIMAGE_IMPORT_DESCRIPTOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
     *     DWORD TimeDateStamp;
     *     WORD OffsetModuleName;
     *     WORD NumberOfModuleForwarderRefs;
     * } *PIMAGE_BOUND_IMPORT_DESCRIPTOR
     * }
     */
    public static final AddressLayout PIMAGE_BOUND_IMPORT_DESCRIPTOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_BOUND_FORWARDER_REF {
     *     DWORD TimeDateStamp;
     *     WORD OffsetModuleName;
     *     WORD Reserved;
     * } *PIMAGE_BOUND_FORWARDER_REF
     * }
     */
    public static final AddressLayout PIMAGE_BOUND_FORWARDER_REF = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
     *     union {
     *         DWORD AllAttributes;
     *         struct {
     *             DWORD RvaBased : 1;
     *             DWORD ReservedAttributes : 31;
     *         };
     *     } Attributes;
     *     DWORD DllNameRVA;
     *     DWORD ModuleHandleRVA;
     *     DWORD ImportAddressTableRVA;
     *     DWORD ImportNameTableRVA;
     *     DWORD BoundImportAddressTableRVA;
     *     DWORD UnloadInformationTableRVA;
     *     DWORD TimeDateStamp;
     * } *PIMAGE_DELAYLOAD_DESCRIPTOR
     * }
     */
    public static final AddressLayout PIMAGE_DELAYLOAD_DESCRIPTOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const IMAGE_DELAYLOAD_DESCRIPTOR *PCIMAGE_DELAYLOAD_DESCRIPTOR
     * }
     */
    public static final AddressLayout PCIMAGE_DELAYLOAD_DESCRIPTOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_RESOURCE_DIRECTORY {
     *     DWORD Characteristics;
     *     DWORD TimeDateStamp;
     *     WORD MajorVersion;
     *     WORD MinorVersion;
     *     WORD NumberOfNamedEntries;
     *     WORD NumberOfIdEntries;
     * } *PIMAGE_RESOURCE_DIRECTORY
     * }
     */
    public static final AddressLayout PIMAGE_RESOURCE_DIRECTORY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
     *     union {
     *         struct {
     *             DWORD NameOffset : 31;
     *             DWORD NameIsString : 1;
     *         };
     *         DWORD Name;
     *         WORD Id;
     *     };
     *     union {
     *         DWORD OffsetToData;
     *         struct {
     *             DWORD OffsetToDirectory : 31;
     *             DWORD DataIsDirectory : 1;
     *         };
     *     };
     * } *PIMAGE_RESOURCE_DIRECTORY_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_RESOURCE_DIRECTORY_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
     *     WORD Length;
     *     CHAR NameString[1];
     * } *PIMAGE_RESOURCE_DIRECTORY_STRING
     * }
     */
    public static final AddressLayout PIMAGE_RESOURCE_DIRECTORY_STRING = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
     *     WORD Length;
     *     WCHAR NameString[1];
     * } *PIMAGE_RESOURCE_DIR_STRING_U
     * }
     */
    public static final AddressLayout PIMAGE_RESOURCE_DIR_STRING_U = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
     *     DWORD OffsetToData;
     *     DWORD Size;
     *     DWORD CodePage;
     *     DWORD Reserved;
     * } *PIMAGE_RESOURCE_DATA_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_RESOURCE_DATA_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
     *     WORD Flags;
     *     WORD Catalog;
     *     DWORD CatalogOffset;
     *     DWORD Reserved;
     * } *PIMAGE_LOAD_CONFIG_CODE_INTEGRITY
     * }
     */
    public static final AddressLayout PIMAGE_LOAD_CONFIG_CODE_INTEGRITY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DYNAMIC_RELOCATION_TABLE {
     *     DWORD Version;
     *     DWORD Size;
     * } *PIMAGE_DYNAMIC_RELOCATION_TABLE
     * }
     */
    public static final AddressLayout PIMAGE_DYNAMIC_RELOCATION_TABLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DYNAMIC_RELOCATION32 {
     *     DWORD Symbol;
     *     DWORD BaseRelocSize;
     * } *PIMAGE_DYNAMIC_RELOCATION32
     * }
     */
    public static final AddressLayout PIMAGE_DYNAMIC_RELOCATION32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DYNAMIC_RELOCATION64 {
     *     ULONGLONG Symbol;
     *     DWORD BaseRelocSize;
     * } *PIMAGE_DYNAMIC_RELOCATION64
     * }
     */
    public static final AddressLayout PIMAGE_DYNAMIC_RELOCATION64 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DYNAMIC_RELOCATION32_V2 {
     *     DWORD HeaderSize;
     *     DWORD FixupInfoSize;
     *     DWORD Symbol;
     *     DWORD SymbolGroup;
     *     DWORD Flags;
     * } *PIMAGE_DYNAMIC_RELOCATION32_V2
     * }
     */
    public static final AddressLayout PIMAGE_DYNAMIC_RELOCATION32_V2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DYNAMIC_RELOCATION64_V2 {
     *     DWORD HeaderSize;
     *     DWORD FixupInfoSize;
     *     ULONGLONG Symbol;
     *     DWORD SymbolGroup;
     *     DWORD Flags;
     * } *PIMAGE_DYNAMIC_RELOCATION64_V2
     * }
     */
    public static final AddressLayout PIMAGE_DYNAMIC_RELOCATION64_V2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMAGE_DYNAMIC_RELOCATION64 PIMAGE_DYNAMIC_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_DYNAMIC_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMAGE_DYNAMIC_RELOCATION64_V2 PIMAGE_DYNAMIC_RELOCATION_V2
     * }
     */
    public static final AddressLayout PIMAGE_DYNAMIC_RELOCATION_V2 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER *PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER *PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION *PIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_IMPORT_CONTROL_TRANSFER_ARM64_RELOCATION *PIMAGE_IMPORT_CONTROL_TRANSFER_ARM64_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_IMPORT_CONTROL_TRANSFER_ARM64_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION *PIMAGE_IMPORT_CONTROL_TRANSFER_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_IMPORT_CONTROL_TRANSFER_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION *PIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION *PIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned IMAGE_FUNCTION_OVERRIDE_HEADER *PIMAGE_FUNCTION_OVERRIDE_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_FUNCTION_OVERRIDE_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION *PIMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IMAGE_BDD_INFO *PIMAGE_BDD_INFO
     * }
     */
    public static final AddressLayout PIMAGE_BDD_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IMAGE_BDD_DYNAMIC_RELOCATION *PIMAGE_BDD_DYNAMIC_RELOCATION
     * }
     */
    public static final AddressLayout PIMAGE_BDD_DYNAMIC_RELOCATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
     *     DWORD Size;
     *     DWORD TimeDateStamp;
     *     WORD MajorVersion;
     *     WORD MinorVersion;
     *     DWORD GlobalFlagsClear;
     *     DWORD GlobalFlagsSet;
     *     DWORD CriticalSectionDefaultTimeout;
     *     DWORD DeCommitFreeBlockThreshold;
     *     DWORD DeCommitTotalFreeThreshold;
     *     DWORD LockPrefixTable;
     *     DWORD MaximumAllocationSize;
     *     DWORD VirtualMemoryThreshold;
     *     DWORD ProcessHeapFlags;
     *     DWORD ProcessAffinityMask;
     *     WORD CSDVersion;
     *     WORD DependentLoadFlags;
     *     DWORD EditList;
     *     DWORD SecurityCookie;
     *     DWORD SEHandlerTable;
     *     DWORD SEHandlerCount;
     *     DWORD GuardCFCheckFunctionPointer;
     *     DWORD GuardCFDispatchFunctionPointer;
     *     DWORD GuardCFFunctionTable;
     *     DWORD GuardCFFunctionCount;
     *     DWORD GuardFlags;
     *     IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
     *     DWORD GuardAddressTakenIatEntryTable;
     *     DWORD GuardAddressTakenIatEntryCount;
     *     DWORD GuardLongJumpTargetTable;
     *     DWORD GuardLongJumpTargetCount;
     *     DWORD DynamicValueRelocTable;
     *     DWORD CHPEMetadataPointer;
     *     DWORD GuardRFFailureRoutine;
     *     DWORD GuardRFFailureRoutineFunctionPointer;
     *     DWORD DynamicValueRelocTableOffset;
     *     WORD DynamicValueRelocTableSection;
     *     WORD Reserved2;
     *     DWORD GuardRFVerifyStackPointerFunctionPointer;
     *     DWORD HotPatchTableOffset;
     *     DWORD Reserved3;
     *     DWORD EnclaveConfigurationPointer;
     *     DWORD VolatileMetadataPointer;
     *     DWORD GuardEHContinuationTable;
     *     DWORD GuardEHContinuationCount;
     *     DWORD GuardXFGCheckFunctionPointer;
     *     DWORD GuardXFGDispatchFunctionPointer;
     *     DWORD GuardXFGTableDispatchFunctionPointer;
     *     DWORD CastGuardOsDeterminedFailureMode;
     *     DWORD GuardMemcpyFunctionPointer;
     * } *PIMAGE_LOAD_CONFIG_DIRECTORY32
     * }
     */
    public static final AddressLayout PIMAGE_LOAD_CONFIG_DIRECTORY32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
     *     DWORD Size;
     *     DWORD TimeDateStamp;
     *     WORD MajorVersion;
     *     WORD MinorVersion;
     *     DWORD GlobalFlagsClear;
     *     DWORD GlobalFlagsSet;
     *     DWORD CriticalSectionDefaultTimeout;
     *     ULONGLONG DeCommitFreeBlockThreshold;
     *     ULONGLONG DeCommitTotalFreeThreshold;
     *     ULONGLONG LockPrefixTable;
     *     ULONGLONG MaximumAllocationSize;
     *     ULONGLONG VirtualMemoryThreshold;
     *     ULONGLONG ProcessAffinityMask;
     *     DWORD ProcessHeapFlags;
     *     WORD CSDVersion;
     *     WORD DependentLoadFlags;
     *     ULONGLONG EditList;
     *     ULONGLONG SecurityCookie;
     *     ULONGLONG SEHandlerTable;
     *     ULONGLONG SEHandlerCount;
     *     ULONGLONG GuardCFCheckFunctionPointer;
     *     ULONGLONG GuardCFDispatchFunctionPointer;
     *     ULONGLONG GuardCFFunctionTable;
     *     ULONGLONG GuardCFFunctionCount;
     *     DWORD GuardFlags;
     *     IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
     *     ULONGLONG GuardAddressTakenIatEntryTable;
     *     ULONGLONG GuardAddressTakenIatEntryCount;
     *     ULONGLONG GuardLongJumpTargetTable;
     *     ULONGLONG GuardLongJumpTargetCount;
     *     ULONGLONG DynamicValueRelocTable;
     *     ULONGLONG CHPEMetadataPointer;
     *     ULONGLONG GuardRFFailureRoutine;
     *     ULONGLONG GuardRFFailureRoutineFunctionPointer;
     *     DWORD DynamicValueRelocTableOffset;
     *     WORD DynamicValueRelocTableSection;
     *     WORD Reserved2;
     *     ULONGLONG GuardRFVerifyStackPointerFunctionPointer;
     *     DWORD HotPatchTableOffset;
     *     DWORD Reserved3;
     *     ULONGLONG EnclaveConfigurationPointer;
     *     ULONGLONG VolatileMetadataPointer;
     *     ULONGLONG GuardEHContinuationTable;
     *     ULONGLONG GuardEHContinuationCount;
     *     ULONGLONG GuardXFGCheckFunctionPointer;
     *     ULONGLONG GuardXFGDispatchFunctionPointer;
     *     ULONGLONG GuardXFGTableDispatchFunctionPointer;
     *     ULONGLONG CastGuardOsDeterminedFailureMode;
     *     ULONGLONG GuardMemcpyFunctionPointer;
     * } *PIMAGE_LOAD_CONFIG_DIRECTORY64
     * }
     */
    public static final AddressLayout PIMAGE_LOAD_CONFIG_DIRECTORY64 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMAGE_LOAD_CONFIG_DIRECTORY64 PIMAGE_LOAD_CONFIG_DIRECTORY
     * }
     */
    public static final AddressLayout PIMAGE_LOAD_CONFIG_DIRECTORY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_HOT_PATCH_INFO {
     *     DWORD Version;
     *     DWORD Size;
     *     DWORD SequenceNumber;
     *     DWORD BaseImageList;
     *     DWORD BaseImageCount;
     *     DWORD BufferOffset;
     *     DWORD ExtraPatchSize;
     *     DWORD MinSequenceNumber;
     *     DWORD Flags;
     * } *PIMAGE_HOT_PATCH_INFO
     * }
     */
    public static final AddressLayout PIMAGE_HOT_PATCH_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_HOT_PATCH_BASE {
     *     DWORD SequenceNumber;
     *     DWORD Flags;
     *     DWORD OriginalTimeDateStamp;
     *     DWORD OriginalCheckSum;
     *     DWORD CodeIntegrityInfo;
     *     DWORD CodeIntegritySize;
     *     DWORD PatchTable;
     *     DWORD BufferOffset;
     * } *PIMAGE_HOT_PATCH_BASE
     * }
     */
    public static final AddressLayout PIMAGE_HOT_PATCH_BASE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_HOT_PATCH_MACHINE {
     *     struct {
     *         DWORD _x86 : 1;
     *         DWORD Amd64 : 1;
     *         DWORD Arm64 : 1;
     *         DWORD Amd64EC : 1;
     *     };
     * } *PIMAGE_HOT_PATCH_MACHINE
     * }
     */
    public static final AddressLayout PIMAGE_HOT_PATCH_MACHINE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_HOT_PATCH_HASHES {
     *     BYTE SHA256[32];
     *     BYTE SHA1[20];
     * } *PIMAGE_HOT_PATCH_HASHES
     * }
     */
    public static final AddressLayout PIMAGE_HOT_PATCH_HASHES = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
     *     DWORD FuncStart;
     *     DWORD PrologLen : 8;
     *     DWORD FuncLen : 22;
     *     DWORD ThirtyTwoBit : 1;
     *     DWORD ExceptionFlag : 1;
     * } *PIMAGE_CE_RUNTIME_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_CE_RUNTIME_FUNCTION_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
     *     DWORD BeginAddress;
     *     union {
     *         DWORD UnwindData;
     *         struct {
     *             DWORD Flag : 2;
     *             DWORD FunctionLength : 11;
     *             DWORD Ret : 2;
     *             DWORD H : 1;
     *             DWORD Reg : 3;
     *             DWORD R : 1;
     *             DWORD L : 1;
     *             DWORD C : 1;
     *             DWORD StackAdjust : 10;
     *         };
     *     };
     * } *PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY = winapi.C_POINTER;
    private static final int PdataRefToFullXdata = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ARM64_FNPDATA_FLAGS.PdataRefToFullXdata = 0
     * }
     */
    public static int PdataRefToFullXdata() {
        return PdataRefToFullXdata;
    }
    private static final int PdataPackedUnwindFunction = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ARM64_FNPDATA_FLAGS.PdataPackedUnwindFunction = 1
     * }
     */
    public static int PdataPackedUnwindFunction() {
        return PdataPackedUnwindFunction;
    }
    private static final int PdataPackedUnwindFragment = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ARM64_FNPDATA_FLAGS.PdataPackedUnwindFragment = 2
     * }
     */
    public static int PdataPackedUnwindFragment() {
        return PdataPackedUnwindFragment;
    }
    private static final int PdataCrUnchained = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ARM64_FNPDATA_CR.PdataCrUnchained = 0
     * }
     */
    public static int PdataCrUnchained() {
        return PdataCrUnchained;
    }
    private static final int PdataCrUnchainedSavedLr = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ARM64_FNPDATA_CR.PdataCrUnchainedSavedLr = 1
     * }
     */
    public static int PdataCrUnchainedSavedLr() {
        return PdataCrUnchainedSavedLr;
    }
    private static final int PdataCrChainedWithPac = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ARM64_FNPDATA_CR.PdataCrChainedWithPac = 2
     * }
     */
    public static int PdataCrChainedWithPac() {
        return PdataCrChainedWithPac;
    }
    private static final int PdataCrChained = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ARM64_FNPDATA_CR.PdataCrChained = 3
     * }
     */
    public static int PdataCrChained() {
        return PdataCrChained;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
     *     DWORD BeginAddress;
     *     union {
     *         DWORD UnwindData;
     *         struct {
     *             DWORD Flag : 2;
     *             DWORD FunctionLength : 11;
     *             DWORD RegF : 3;
     *             DWORD RegI : 4;
     *             DWORD H : 1;
     *             DWORD CR : 2;
     *             DWORD FrameSize : 9;
     *         };
     *     };
     * } *PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
     *     ULONGLONG BeginAddress;
     *     ULONGLONG EndAddress;
     *     ULONGLONG ExceptionHandler;
     *     ULONGLONG HandlerData;
     *     ULONGLONG PrologEndAddress;
     * } *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
     *     DWORD BeginAddress;
     *     DWORD EndAddress;
     *     DWORD ExceptionHandler;
     *     DWORD HandlerData;
     *     DWORD PrologEndAddress;
     * } *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
     *     DWORD BeginAddress;
     *     DWORD EndAddress;
     *     union {
     *         DWORD UnwindInfoAddress;
     *         DWORD UnwindData;
     *     };
     * } *_PIMAGE_RUNTIME_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout _PIMAGE_RUNTIME_FUNCTION_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_AMD64_RUNTIME_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_AMD64_RUNTIME_FUNCTION_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_RUNTIME_FUNCTION_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ENCLAVE_CONFIG32 {
     *     DWORD Size;
     *     DWORD MinimumRequiredConfigSize;
     *     DWORD PolicyFlags;
     *     DWORD NumberOfImports;
     *     DWORD ImportList;
     *     DWORD ImportEntrySize;
     *     BYTE FamilyID[16];
     *     BYTE ImageID[16];
     *     DWORD ImageVersion;
     *     DWORD SecurityVersion;
     *     DWORD EnclaveSize;
     *     DWORD NumberOfThreads;
     *     DWORD EnclaveFlags;
     * } *PIMAGE_ENCLAVE_CONFIG32
     * }
     */
    public static final AddressLayout PIMAGE_ENCLAVE_CONFIG32 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ENCLAVE_CONFIG64 {
     *     DWORD Size;
     *     DWORD MinimumRequiredConfigSize;
     *     DWORD PolicyFlags;
     *     DWORD NumberOfImports;
     *     DWORD ImportList;
     *     DWORD ImportEntrySize;
     *     BYTE FamilyID[16];
     *     BYTE ImageID[16];
     *     DWORD ImageVersion;
     *     DWORD SecurityVersion;
     *     ULONGLONG EnclaveSize;
     *     DWORD NumberOfThreads;
     *     DWORD EnclaveFlags;
     * } *PIMAGE_ENCLAVE_CONFIG64
     * }
     */
    public static final AddressLayout PIMAGE_ENCLAVE_CONFIG64 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMAGE_ENCLAVE_CONFIG64 PIMAGE_ENCLAVE_CONFIG
     * }
     */
    public static final AddressLayout PIMAGE_ENCLAVE_CONFIG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_ENCLAVE_IMPORT {
     *     DWORD MatchType;
     *     DWORD MinimumSecurityVersion;
     *     BYTE UniqueOrAuthorID[32];
     *     BYTE FamilyID[16];
     *     BYTE ImageID[16];
     *     DWORD ImportName;
     *     DWORD Reserved;
     * } *PIMAGE_ENCLAVE_IMPORT
     * }
     */
    public static final AddressLayout PIMAGE_ENCLAVE_IMPORT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DEBUG_DIRECTORY {
     *     DWORD Characteristics;
     *     DWORD TimeDateStamp;
     *     WORD MajorVersion;
     *     WORD MinorVersion;
     *     DWORD Type;
     *     DWORD SizeOfData;
     *     DWORD AddressOfRawData;
     *     DWORD PointerToRawData;
     * } *PIMAGE_DEBUG_DIRECTORY
     * }
     */
    public static final AddressLayout PIMAGE_DEBUG_DIRECTORY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
     *     DWORD NumberOfSymbols;
     *     DWORD LvaToFirstSymbol;
     *     DWORD NumberOfLinenumbers;
     *     DWORD LvaToFirstLinenumber;
     *     DWORD RvaToFirstByteOfCode;
     *     DWORD RvaToLastByteOfCode;
     *     DWORD RvaToFirstByteOfData;
     *     DWORD RvaToLastByteOfData;
     * } *PIMAGE_COFF_SYMBOLS_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_COFF_SYMBOLS_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FPO_DATA {
     *     DWORD ulOffStart;
     *     DWORD cbProcSize;
     *     DWORD cdwLocals;
     *     WORD cdwParams;
     *     WORD cbProlog : 8;
     *     WORD cbRegs : 3;
     *     WORD fHasSEH : 1;
     *     WORD fUseBP : 1;
     *     WORD reserved : 1;
     *     WORD cbFrame : 2;
     * } *PFPO_DATA
     * }
     */
    public static final AddressLayout PFPO_DATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_DEBUG_MISC {
     *     DWORD DataType;
     *     DWORD Length;
     *     BOOLEAN Unicode;
     *     BYTE Reserved[3];
     *     BYTE Data[1];
     * } *PIMAGE_DEBUG_MISC
     * }
     */
    public static final AddressLayout PIMAGE_DEBUG_MISC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_FUNCTION_ENTRY {
     *     DWORD StartingAddress;
     *     DWORD EndingAddress;
     *     DWORD EndOfPrologue;
     * } *PIMAGE_FUNCTION_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_FUNCTION_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_FUNCTION_ENTRY64 {
     *     ULONGLONG StartingAddress;
     *     ULONGLONG EndingAddress;
     *     union {
     *         ULONGLONG EndOfPrologue;
     *         ULONGLONG UnwindInfoAddress;
     *     };
     * } *PIMAGE_FUNCTION_ENTRY64
     * }
     */
    public static final AddressLayout PIMAGE_FUNCTION_ENTRY64 = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
     *     WORD Signature;
     *     WORD Flags;
     *     WORD Machine;
     *     WORD Characteristics;
     *     DWORD TimeDateStamp;
     *     DWORD CheckSum;
     *     DWORD ImageBase;
     *     DWORD SizeOfImage;
     *     DWORD NumberOfSections;
     *     DWORD ExportedNamesSize;
     *     DWORD DebugDirectorySize;
     *     DWORD SectionAlignment;
     *     DWORD Reserved[2];
     * } *PIMAGE_SEPARATE_DEBUG_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_SEPARATE_DEBUG_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NON_PAGED_DEBUG_INFO {
     *     WORD Signature;
     *     WORD Flags;
     *     DWORD Size;
     *     WORD Machine;
     *     WORD Characteristics;
     *     DWORD TimeDateStamp;
     *     DWORD CheckSum;
     *     DWORD SizeOfImage;
     *     ULONGLONG ImageBase;
     * } *PNON_PAGED_DEBUG_INFO
     * }
     */
    public static final AddressLayout PNON_PAGED_DEBUG_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ImageArchitectureHeader {
     *     unsigned int AmaskValue : 1;
     *     int : 7;
     *     unsigned int AmaskShift : 8;
     *     int : 16;
     *     DWORD FirstEntryRVA;
     * } *PIMAGE_ARCHITECTURE_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_ARCHITECTURE_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ImageArchitectureEntry {
     *     DWORD FixupInstRVA;
     *     DWORD NewInst;
     * } *PIMAGE_ARCHITECTURE_ENTRY
     * }
     */
    public static final AddressLayout PIMAGE_ARCHITECTURE_ENTRY = winapi.C_POINTER;
    private static final int IMPORT_OBJECT_CODE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum IMPORT_OBJECT_TYPE.IMPORT_OBJECT_CODE = 0
     * }
     */
    public static int IMPORT_OBJECT_CODE() {
        return IMPORT_OBJECT_CODE;
    }
    private static final int IMPORT_OBJECT_DATA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum IMPORT_OBJECT_TYPE.IMPORT_OBJECT_DATA = 1
     * }
     */
    public static int IMPORT_OBJECT_DATA() {
        return IMPORT_OBJECT_DATA;
    }
    private static final int IMPORT_OBJECT_CONST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum IMPORT_OBJECT_TYPE.IMPORT_OBJECT_CONST = 2
     * }
     */
    public static int IMPORT_OBJECT_CONST() {
        return IMPORT_OBJECT_CONST;
    }
    private static final int IMPORT_OBJECT_ORDINAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_ORDINAL = 0
     * }
     */
    public static int IMPORT_OBJECT_ORDINAL() {
        return IMPORT_OBJECT_ORDINAL;
    }
    private static final int IMPORT_OBJECT_NAME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME = 1
     * }
     */
    public static int IMPORT_OBJECT_NAME() {
        return IMPORT_OBJECT_NAME;
    }
    private static final int IMPORT_OBJECT_NAME_NO_PREFIX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME_NO_PREFIX = 2
     * }
     */
    public static int IMPORT_OBJECT_NAME_NO_PREFIX() {
        return IMPORT_OBJECT_NAME_NO_PREFIX;
    }
    private static final int IMPORT_OBJECT_NAME_UNDECORATE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME_UNDECORATE = 3
     * }
     */
    public static int IMPORT_OBJECT_NAME_UNDECORATE() {
        return IMPORT_OBJECT_NAME_UNDECORATE;
    }
    private static final int IMPORT_OBJECT_NAME_EXPORTAS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME_EXPORTAS = 4
     * }
     */
    public static int IMPORT_OBJECT_NAME_EXPORTAS() {
        return IMPORT_OBJECT_NAME_EXPORTAS;
    }
    private static final int COMIMAGE_FLAGS_ILONLY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
     * }
     */
    public static int COMIMAGE_FLAGS_ILONLY() {
        return COMIMAGE_FLAGS_ILONLY;
    }
    private static final int COMIMAGE_FLAGS_32BITREQUIRED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
     * }
     */
    public static int COMIMAGE_FLAGS_32BITREQUIRED() {
        return COMIMAGE_FLAGS_32BITREQUIRED;
    }
    private static final int COMIMAGE_FLAGS_IL_LIBRARY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
     * }
     */
    public static int COMIMAGE_FLAGS_IL_LIBRARY() {
        return COMIMAGE_FLAGS_IL_LIBRARY;
    }
    private static final int COMIMAGE_FLAGS_STRONGNAMESIGNED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
     * }
     */
    public static int COMIMAGE_FLAGS_STRONGNAMESIGNED() {
        return COMIMAGE_FLAGS_STRONGNAMESIGNED;
    }
    private static final int COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16
     * }
     */
    public static int COMIMAGE_FLAGS_NATIVE_ENTRYPOINT() {
        return COMIMAGE_FLAGS_NATIVE_ENTRYPOINT;
    }
    private static final int COMIMAGE_FLAGS_TRACKDEBUGDATA = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
     * }
     */
    public static int COMIMAGE_FLAGS_TRACKDEBUGDATA() {
        return COMIMAGE_FLAGS_TRACKDEBUGDATA;
    }
    private static final int COMIMAGE_FLAGS_32BITPREFERRED = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITPREFERRED = 131072
     * }
     */
    public static int COMIMAGE_FLAGS_32BITPREFERRED() {
        return COMIMAGE_FLAGS_32BITPREFERRED;
    }
    private static final int COR_VERSION_MAJOR_V2 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
     * }
     */
    public static int COR_VERSION_MAJOR_V2() {
        return COR_VERSION_MAJOR_V2;
    }
    private static final int COR_VERSION_MAJOR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
     * }
     */
    public static int COR_VERSION_MAJOR() {
        return COR_VERSION_MAJOR;
    }
    private static final int COR_VERSION_MINOR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 5
     * }
     */
    public static int COR_VERSION_MINOR() {
        return COR_VERSION_MINOR;
    }
    private static final int COR_DELETED_NAME_LENGTH = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
     * }
     */
    public static int COR_DELETED_NAME_LENGTH() {
        return COR_DELETED_NAME_LENGTH;
    }
    private static final int COR_VTABLEGAP_NAME_LENGTH = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
     * }
     */
    public static int COR_VTABLEGAP_NAME_LENGTH() {
        return COR_VTABLEGAP_NAME_LENGTH;
    }
    private static final int NATIVE_TYPE_MAX_CB = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
     * }
     */
    public static int NATIVE_TYPE_MAX_CB() {
        return NATIVE_TYPE_MAX_CB;
    }
    private static final int COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = (int)255L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
     * }
     */
    public static int COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE() {
        return COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE;
    }
    private static final int IMAGE_COR_MIH_METHODRVA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
     * }
     */
    public static int IMAGE_COR_MIH_METHODRVA() {
        return IMAGE_COR_MIH_METHODRVA;
    }
    private static final int IMAGE_COR_MIH_EHRVA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
     * }
     */
    public static int IMAGE_COR_MIH_EHRVA() {
        return IMAGE_COR_MIH_EHRVA;
    }
    private static final int IMAGE_COR_MIH_BASICBLOCK = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
     * }
     */
    public static int IMAGE_COR_MIH_BASICBLOCK() {
        return IMAGE_COR_MIH_BASICBLOCK;
    }
    private static final int COR_VTABLE_32BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
     * }
     */
    public static int COR_VTABLE_32BIT() {
        return COR_VTABLE_32BIT;
    }
    private static final int COR_VTABLE_64BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
     * }
     */
    public static int COR_VTABLE_64BIT() {
        return COR_VTABLE_64BIT;
    }
    private static final int COR_VTABLE_FROM_UNMANAGED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
     * }
     */
    public static int COR_VTABLE_FROM_UNMANAGED() {
        return COR_VTABLE_FROM_UNMANAGED;
    }
    private static final int COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8
     * }
     */
    public static int COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN() {
        return COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN;
    }
    private static final int COR_VTABLE_CALL_MOST_DERIVED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
     * }
     */
    public static int COR_VTABLE_CALL_MOST_DERIVED() {
        return COR_VTABLE_CALL_MOST_DERIVED;
    }
    private static final int IMAGE_COR_EATJ_THUNK_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
     * }
     */
    public static int IMAGE_COR_EATJ_THUNK_SIZE() {
        return IMAGE_COR_EATJ_THUNK_SIZE;
    }
    private static final int MAX_CLASS_NAME = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
     * }
     */
    public static int MAX_CLASS_NAME() {
        return MAX_CLASS_NAME;
    }
    private static final int MAX_PACKAGE_NAME = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024
     * }
     */
    public static int MAX_PACKAGE_NAME() {
        return MAX_PACKAGE_NAME;
    }
    /**
     * {@snippet lang=c :
     * typedef struct IMAGE_COR20_HEADER {
     *     DWORD cb;
     *     WORD MajorRuntimeVersion;
     *     WORD MinorRuntimeVersion;
     *     IMAGE_DATA_DIRECTORY MetaData;
     *     DWORD Flags;
     *     union {
     *         DWORD EntryPointToken;
     *         DWORD EntryPointRVA;
     *     };
     *     IMAGE_DATA_DIRECTORY Resources;
     *     IMAGE_DATA_DIRECTORY StrongNameSignature;
     *     IMAGE_DATA_DIRECTORY CodeManagerTable;
     *     IMAGE_DATA_DIRECTORY VTableFixups;
     *     IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
     *     IMAGE_DATA_DIRECTORY ManagedNativeHeader;
     * } *PIMAGE_COR20_HEADER
     * }
     */
    public static final AddressLayout PIMAGE_COR20_HEADER = winapi.C_POINTER;

    private static class RtlCaptureStackBackTrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlCaptureStackBackTrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD RtlCaptureStackBackTrace(DWORD FramesToSkip, DWORD FramesToCapture, PVOID *BackTrace, PDWORD BackTraceHash)
     * }
     */
    public static FunctionDescriptor RtlCaptureStackBackTrace$descriptor() {
        return RtlCaptureStackBackTrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD RtlCaptureStackBackTrace(DWORD FramesToSkip, DWORD FramesToCapture, PVOID *BackTrace, PDWORD BackTraceHash)
     * }
     */
    public static MethodHandle RtlCaptureStackBackTrace$handle() {
        return RtlCaptureStackBackTrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD RtlCaptureStackBackTrace(DWORD FramesToSkip, DWORD FramesToCapture, PVOID *BackTrace, PDWORD BackTraceHash)
     * }
     */
    public static MemorySegment RtlCaptureStackBackTrace$address() {
        return RtlCaptureStackBackTrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD RtlCaptureStackBackTrace(DWORD FramesToSkip, DWORD FramesToCapture, PVOID *BackTrace, PDWORD BackTraceHash)
     * }
     */
    public static short RtlCaptureStackBackTrace(int FramesToSkip, int FramesToCapture, MemorySegment BackTrace, MemorySegment BackTraceHash) {
        var mh$ = RtlCaptureStackBackTrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlCaptureStackBackTrace", FramesToSkip, FramesToCapture, BackTrace, BackTraceHash);
            }
            return (short)mh$.invokeExact(FramesToSkip, FramesToCapture, BackTrace, BackTraceHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlCaptureContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlCaptureContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlCaptureContext(PCONTEXT ContextRecord)
     * }
     */
    public static FunctionDescriptor RtlCaptureContext$descriptor() {
        return RtlCaptureContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlCaptureContext(PCONTEXT ContextRecord)
     * }
     */
    public static MethodHandle RtlCaptureContext$handle() {
        return RtlCaptureContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlCaptureContext(PCONTEXT ContextRecord)
     * }
     */
    public static MemorySegment RtlCaptureContext$address() {
        return RtlCaptureContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlCaptureContext(PCONTEXT ContextRecord)
     * }
     */
    public static void RtlCaptureContext(MemorySegment ContextRecord) {
        var mh$ = RtlCaptureContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlCaptureContext", ContextRecord);
            }
            mh$.invokeExact(ContextRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlCaptureContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlCaptureContext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlCaptureContext2(PCONTEXT ContextRecord)
     * }
     */
    public static FunctionDescriptor RtlCaptureContext2$descriptor() {
        return RtlCaptureContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlCaptureContext2(PCONTEXT ContextRecord)
     * }
     */
    public static MethodHandle RtlCaptureContext2$handle() {
        return RtlCaptureContext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlCaptureContext2(PCONTEXT ContextRecord)
     * }
     */
    public static MemorySegment RtlCaptureContext2$address() {
        return RtlCaptureContext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlCaptureContext2(PCONTEXT ContextRecord)
     * }
     */
    public static void RtlCaptureContext2(MemorySegment ContextRecord) {
        var mh$ = RtlCaptureContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlCaptureContext2", ContextRecord);
            }
            mh$.invokeExact(ContextRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
     *     ULONG_PTR ImageBase;
     *     PRUNTIME_FUNCTION FunctionEntry;
     * } *PUNWIND_HISTORY_TABLE_ENTRY
     * }
     */
    public static final AddressLayout PUNWIND_HISTORY_TABLE_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UNWIND_HISTORY_TABLE {
     *     DWORD Count;
     *     BYTE LocalHint;
     *     BYTE GlobalHint;
     *     BYTE Search;
     *     BYTE Once;
     *     ULONG_PTR LowAddress;
     *     ULONG_PTR HighAddress;
     *     UNWIND_HISTORY_TABLE_ENTRY Entry[12];
     * } *PUNWIND_HISTORY_TABLE
     * }
     */
    public static final AddressLayout PUNWIND_HISTORY_TABLE = winapi.C_POINTER;

    private static class RtlUnwind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlUnwind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)
     * }
     */
    public static FunctionDescriptor RtlUnwind$descriptor() {
        return RtlUnwind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)
     * }
     */
    public static MethodHandle RtlUnwind$handle() {
        return RtlUnwind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)
     * }
     */
    public static MemorySegment RtlUnwind$address() {
        return RtlUnwind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)
     * }
     */
    public static void RtlUnwind(MemorySegment TargetFrame, MemorySegment TargetIp, MemorySegment ExceptionRecord, MemorySegment ReturnValue) {
        var mh$ = RtlUnwind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlUnwind", TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
            }
            mh$.invokeExact(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlAddFunctionTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlAddFunctionTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN RtlAddFunctionTable(PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD64 BaseAddress)
     * }
     */
    public static FunctionDescriptor RtlAddFunctionTable$descriptor() {
        return RtlAddFunctionTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN RtlAddFunctionTable(PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD64 BaseAddress)
     * }
     */
    public static MethodHandle RtlAddFunctionTable$handle() {
        return RtlAddFunctionTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN RtlAddFunctionTable(PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD64 BaseAddress)
     * }
     */
    public static MemorySegment RtlAddFunctionTable$address() {
        return RtlAddFunctionTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN RtlAddFunctionTable(PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD64 BaseAddress)
     * }
     */
    public static byte RtlAddFunctionTable(MemorySegment FunctionTable, int EntryCount, long BaseAddress) {
        var mh$ = RtlAddFunctionTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlAddFunctionTable", FunctionTable, EntryCount, BaseAddress);
            }
            return (byte)mh$.invokeExact(FunctionTable, EntryCount, BaseAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlDeleteFunctionTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlDeleteFunctionTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN RtlDeleteFunctionTable(PRUNTIME_FUNCTION FunctionTable)
     * }
     */
    public static FunctionDescriptor RtlDeleteFunctionTable$descriptor() {
        return RtlDeleteFunctionTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN RtlDeleteFunctionTable(PRUNTIME_FUNCTION FunctionTable)
     * }
     */
    public static MethodHandle RtlDeleteFunctionTable$handle() {
        return RtlDeleteFunctionTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN RtlDeleteFunctionTable(PRUNTIME_FUNCTION FunctionTable)
     * }
     */
    public static MemorySegment RtlDeleteFunctionTable$address() {
        return RtlDeleteFunctionTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN RtlDeleteFunctionTable(PRUNTIME_FUNCTION FunctionTable)
     * }
     */
    public static byte RtlDeleteFunctionTable(MemorySegment FunctionTable) {
        var mh$ = RtlDeleteFunctionTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlDeleteFunctionTable", FunctionTable);
            }
            return (byte)mh$.invokeExact(FunctionTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlInstallFunctionTableCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlInstallFunctionTableCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN RtlInstallFunctionTableCallback(DWORD64 TableIdentifier, DWORD64 BaseAddress, DWORD Length, PGET_RUNTIME_FUNCTION_CALLBACK Callback, PVOID Context, PCWSTR OutOfProcessCallbackDll)
     * }
     */
    public static FunctionDescriptor RtlInstallFunctionTableCallback$descriptor() {
        return RtlInstallFunctionTableCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN RtlInstallFunctionTableCallback(DWORD64 TableIdentifier, DWORD64 BaseAddress, DWORD Length, PGET_RUNTIME_FUNCTION_CALLBACK Callback, PVOID Context, PCWSTR OutOfProcessCallbackDll)
     * }
     */
    public static MethodHandle RtlInstallFunctionTableCallback$handle() {
        return RtlInstallFunctionTableCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN RtlInstallFunctionTableCallback(DWORD64 TableIdentifier, DWORD64 BaseAddress, DWORD Length, PGET_RUNTIME_FUNCTION_CALLBACK Callback, PVOID Context, PCWSTR OutOfProcessCallbackDll)
     * }
     */
    public static MemorySegment RtlInstallFunctionTableCallback$address() {
        return RtlInstallFunctionTableCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN RtlInstallFunctionTableCallback(DWORD64 TableIdentifier, DWORD64 BaseAddress, DWORD Length, PGET_RUNTIME_FUNCTION_CALLBACK Callback, PVOID Context, PCWSTR OutOfProcessCallbackDll)
     * }
     */
    public static byte RtlInstallFunctionTableCallback(long TableIdentifier, long BaseAddress, int Length, MemorySegment Callback, MemorySegment Context, MemorySegment OutOfProcessCallbackDll) {
        var mh$ = RtlInstallFunctionTableCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlInstallFunctionTableCallback", TableIdentifier, BaseAddress, Length, Callback, Context, OutOfProcessCallbackDll);
            }
            return (byte)mh$.invokeExact(TableIdentifier, BaseAddress, Length, Callback, Context, OutOfProcessCallbackDll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlAddGrowableFunctionTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlAddGrowableFunctionTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlAddGrowableFunctionTable(PVOID *DynamicTable, PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD MaximumEntryCount, ULONG_PTR RangeBase, ULONG_PTR RangeEnd)
     * }
     */
    public static FunctionDescriptor RtlAddGrowableFunctionTable$descriptor() {
        return RtlAddGrowableFunctionTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlAddGrowableFunctionTable(PVOID *DynamicTable, PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD MaximumEntryCount, ULONG_PTR RangeBase, ULONG_PTR RangeEnd)
     * }
     */
    public static MethodHandle RtlAddGrowableFunctionTable$handle() {
        return RtlAddGrowableFunctionTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlAddGrowableFunctionTable(PVOID *DynamicTable, PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD MaximumEntryCount, ULONG_PTR RangeBase, ULONG_PTR RangeEnd)
     * }
     */
    public static MemorySegment RtlAddGrowableFunctionTable$address() {
        return RtlAddGrowableFunctionTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlAddGrowableFunctionTable(PVOID *DynamicTable, PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD MaximumEntryCount, ULONG_PTR RangeBase, ULONG_PTR RangeEnd)
     * }
     */
    public static int RtlAddGrowableFunctionTable(MemorySegment DynamicTable, MemorySegment FunctionTable, int EntryCount, int MaximumEntryCount, long RangeBase, long RangeEnd) {
        var mh$ = RtlAddGrowableFunctionTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlAddGrowableFunctionTable", DynamicTable, FunctionTable, EntryCount, MaximumEntryCount, RangeBase, RangeEnd);
            }
            return (int)mh$.invokeExact(DynamicTable, FunctionTable, EntryCount, MaximumEntryCount, RangeBase, RangeEnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlGrowFunctionTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlGrowFunctionTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlGrowFunctionTable(PVOID DynamicTable, DWORD NewEntryCount)
     * }
     */
    public static FunctionDescriptor RtlGrowFunctionTable$descriptor() {
        return RtlGrowFunctionTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlGrowFunctionTable(PVOID DynamicTable, DWORD NewEntryCount)
     * }
     */
    public static MethodHandle RtlGrowFunctionTable$handle() {
        return RtlGrowFunctionTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlGrowFunctionTable(PVOID DynamicTable, DWORD NewEntryCount)
     * }
     */
    public static MemorySegment RtlGrowFunctionTable$address() {
        return RtlGrowFunctionTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlGrowFunctionTable(PVOID DynamicTable, DWORD NewEntryCount)
     * }
     */
    public static void RtlGrowFunctionTable(MemorySegment DynamicTable, int NewEntryCount) {
        var mh$ = RtlGrowFunctionTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlGrowFunctionTable", DynamicTable, NewEntryCount);
            }
            mh$.invokeExact(DynamicTable, NewEntryCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlDeleteGrowableFunctionTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlDeleteGrowableFunctionTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlDeleteGrowableFunctionTable(PVOID DynamicTable)
     * }
     */
    public static FunctionDescriptor RtlDeleteGrowableFunctionTable$descriptor() {
        return RtlDeleteGrowableFunctionTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlDeleteGrowableFunctionTable(PVOID DynamicTable)
     * }
     */
    public static MethodHandle RtlDeleteGrowableFunctionTable$handle() {
        return RtlDeleteGrowableFunctionTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlDeleteGrowableFunctionTable(PVOID DynamicTable)
     * }
     */
    public static MemorySegment RtlDeleteGrowableFunctionTable$address() {
        return RtlDeleteGrowableFunctionTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlDeleteGrowableFunctionTable(PVOID DynamicTable)
     * }
     */
    public static void RtlDeleteGrowableFunctionTable(MemorySegment DynamicTable) {
        var mh$ = RtlDeleteGrowableFunctionTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlDeleteGrowableFunctionTable", DynamicTable);
            }
            mh$.invokeExact(DynamicTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlLookupFunctionEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlLookupFunctionEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PRUNTIME_FUNCTION RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable)
     * }
     */
    public static FunctionDescriptor RtlLookupFunctionEntry$descriptor() {
        return RtlLookupFunctionEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PRUNTIME_FUNCTION RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable)
     * }
     */
    public static MethodHandle RtlLookupFunctionEntry$handle() {
        return RtlLookupFunctionEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PRUNTIME_FUNCTION RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable)
     * }
     */
    public static MemorySegment RtlLookupFunctionEntry$address() {
        return RtlLookupFunctionEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PRUNTIME_FUNCTION RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable)
     * }
     */
    public static MemorySegment RtlLookupFunctionEntry(long ControlPc, MemorySegment ImageBase, MemorySegment HistoryTable) {
        var mh$ = RtlLookupFunctionEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlLookupFunctionEntry", ControlPc, ImageBase, HistoryTable);
            }
            return (MemorySegment)mh$.invokeExact(ControlPc, ImageBase, HistoryTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlRestoreContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlRestoreContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlRestoreContext(PCONTEXT ContextRecord, struct _EXCEPTION_RECORD *ExceptionRecord)
     * }
     */
    public static FunctionDescriptor RtlRestoreContext$descriptor() {
        return RtlRestoreContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlRestoreContext(PCONTEXT ContextRecord, struct _EXCEPTION_RECORD *ExceptionRecord)
     * }
     */
    public static MethodHandle RtlRestoreContext$handle() {
        return RtlRestoreContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlRestoreContext(PCONTEXT ContextRecord, struct _EXCEPTION_RECORD *ExceptionRecord)
     * }
     */
    public static MemorySegment RtlRestoreContext$address() {
        return RtlRestoreContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlRestoreContext(PCONTEXT ContextRecord, struct _EXCEPTION_RECORD *ExceptionRecord)
     * }
     */
    public static void RtlRestoreContext(MemorySegment ContextRecord, MemorySegment ExceptionRecord) {
        var mh$ = RtlRestoreContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlRestoreContext", ContextRecord, ExceptionRecord);
            }
            mh$.invokeExact(ContextRecord, ExceptionRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlUnwindEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlUnwindEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable)
     * }
     */
    public static FunctionDescriptor RtlUnwindEx$descriptor() {
        return RtlUnwindEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable)
     * }
     */
    public static MethodHandle RtlUnwindEx$handle() {
        return RtlUnwindEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable)
     * }
     */
    public static MemorySegment RtlUnwindEx$address() {
        return RtlUnwindEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable)
     * }
     */
    public static void RtlUnwindEx(MemorySegment TargetFrame, MemorySegment TargetIp, MemorySegment ExceptionRecord, MemorySegment ReturnValue, MemorySegment ContextRecord, MemorySegment HistoryTable) {
        var mh$ = RtlUnwindEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlUnwindEx", TargetFrame, TargetIp, ExceptionRecord, ReturnValue, ContextRecord, HistoryTable);
            }
            mh$.invokeExact(TargetFrame, TargetIp, ExceptionRecord, ReturnValue, ContextRecord, HistoryTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlVirtualUnwind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlVirtualUnwind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PEXCEPTION_ROUTINE RtlVirtualUnwind(DWORD HandlerType, DWORD64 ImageBase, DWORD64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PDWORD64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers)
     * }
     */
    public static FunctionDescriptor RtlVirtualUnwind$descriptor() {
        return RtlVirtualUnwind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PEXCEPTION_ROUTINE RtlVirtualUnwind(DWORD HandlerType, DWORD64 ImageBase, DWORD64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PDWORD64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers)
     * }
     */
    public static MethodHandle RtlVirtualUnwind$handle() {
        return RtlVirtualUnwind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PEXCEPTION_ROUTINE RtlVirtualUnwind(DWORD HandlerType, DWORD64 ImageBase, DWORD64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PDWORD64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers)
     * }
     */
    public static MemorySegment RtlVirtualUnwind$address() {
        return RtlVirtualUnwind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PEXCEPTION_ROUTINE RtlVirtualUnwind(DWORD HandlerType, DWORD64 ImageBase, DWORD64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PDWORD64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers)
     * }
     */
    public static MemorySegment RtlVirtualUnwind(int HandlerType, long ImageBase, long ControlPc, MemorySegment FunctionEntry, MemorySegment ContextRecord, MemorySegment HandlerData, MemorySegment EstablisherFrame, MemorySegment ContextPointers) {
        var mh$ = RtlVirtualUnwind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlVirtualUnwind", HandlerType, ImageBase, ControlPc, FunctionEntry, ContextRecord, HandlerData, EstablisherFrame, ContextPointers);
            }
            return (MemorySegment)mh$.invokeExact(HandlerType, ImageBase, ControlPc, FunctionEntry, ContextRecord, HandlerData, EstablisherFrame, ContextPointers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlRaiseException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlRaiseException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlRaiseException(PEXCEPTION_RECORD ExceptionRecord)
     * }
     */
    public static FunctionDescriptor RtlRaiseException$descriptor() {
        return RtlRaiseException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlRaiseException(PEXCEPTION_RECORD ExceptionRecord)
     * }
     */
    public static MethodHandle RtlRaiseException$handle() {
        return RtlRaiseException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlRaiseException(PEXCEPTION_RECORD ExceptionRecord)
     * }
     */
    public static MemorySegment RtlRaiseException$address() {
        return RtlRaiseException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlRaiseException(PEXCEPTION_RECORD ExceptionRecord)
     * }
     */
    public static void RtlRaiseException(MemorySegment ExceptionRecord) {
        var mh$ = RtlRaiseException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlRaiseException", ExceptionRecord);
            }
            mh$.invokeExact(ExceptionRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlPcToFileHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlPcToFileHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID RtlPcToFileHeader(PVOID PcValue, PVOID *BaseOfImage)
     * }
     */
    public static FunctionDescriptor RtlPcToFileHeader$descriptor() {
        return RtlPcToFileHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID RtlPcToFileHeader(PVOID PcValue, PVOID *BaseOfImage)
     * }
     */
    public static MethodHandle RtlPcToFileHeader$handle() {
        return RtlPcToFileHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID RtlPcToFileHeader(PVOID PcValue, PVOID *BaseOfImage)
     * }
     */
    public static MemorySegment RtlPcToFileHeader$address() {
        return RtlPcToFileHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID RtlPcToFileHeader(PVOID PcValue, PVOID *BaseOfImage)
     * }
     */
    public static MemorySegment RtlPcToFileHeader(MemorySegment PcValue, MemorySegment BaseOfImage) {
        var mh$ = RtlPcToFileHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlPcToFileHeader", PcValue, BaseOfImage);
            }
            return (MemorySegment)mh$.invokeExact(PcValue, BaseOfImage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlCompareMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlCompareMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length)
     * }
     */
    public static FunctionDescriptor RtlCompareMemory$descriptor() {
        return RtlCompareMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length)
     * }
     */
    public static MethodHandle RtlCompareMemory$handle() {
        return RtlCompareMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length)
     * }
     */
    public static MemorySegment RtlCompareMemory$address() {
        return RtlCompareMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length)
     * }
     */
    public static long RtlCompareMemory(MemorySegment Source1, MemorySegment Source2, long Length) {
        var mh$ = RtlCompareMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlCompareMemory", Source1, Source2, Length);
            }
            return (long)mh$.invokeExact(Source1, Source2, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SLIST_ENTRY {
     *     struct _SLIST_ENTRY *Next;
     * } *PSLIST_ENTRY
     * }
     */
    public static final AddressLayout PSLIST_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef union _SLIST_HEADER {
     *     struct {
     *         ULONGLONG Alignment;
     *         ULONGLONG Region;
     *     };
     *     struct {
     *         ULONGLONG Depth : 16;
     *         ULONGLONG Sequence : 48;
     *         ULONGLONG Reserved : 4;
     *         ULONGLONG NextEntry : 60;
     *     } HeaderX64;
     * } *PSLIST_HEADER
     * }
     */
    public static final AddressLayout PSLIST_HEADER = winapi.C_POINTER;

    private static class RtlInitializeSListHead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlInitializeSListHead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlInitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor RtlInitializeSListHead$descriptor() {
        return RtlInitializeSListHead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlInitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle RtlInitializeSListHead$handle() {
        return RtlInitializeSListHead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlInitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment RtlInitializeSListHead$address() {
        return RtlInitializeSListHead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlInitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static void RtlInitializeSListHead(MemorySegment ListHead) {
        var mh$ = RtlInitializeSListHead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlInitializeSListHead", ListHead);
            }
            mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlFirstEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlFirstEntrySList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlFirstEntrySList(const SLIST_HEADER *ListHead)
     * }
     */
    public static FunctionDescriptor RtlFirstEntrySList$descriptor() {
        return RtlFirstEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlFirstEntrySList(const SLIST_HEADER *ListHead)
     * }
     */
    public static MethodHandle RtlFirstEntrySList$handle() {
        return RtlFirstEntrySList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlFirstEntrySList(const SLIST_HEADER *ListHead)
     * }
     */
    public static MemorySegment RtlFirstEntrySList$address() {
        return RtlFirstEntrySList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlFirstEntrySList(const SLIST_HEADER *ListHead)
     * }
     */
    public static MemorySegment RtlFirstEntrySList(MemorySegment ListHead) {
        var mh$ = RtlFirstEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlFirstEntrySList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlInterlockedPopEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlInterlockedPopEntrySList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor RtlInterlockedPopEntrySList$descriptor() {
        return RtlInterlockedPopEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle RtlInterlockedPopEntrySList$handle() {
        return RtlInterlockedPopEntrySList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment RtlInterlockedPopEntrySList$address() {
        return RtlInterlockedPopEntrySList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment RtlInterlockedPopEntrySList(MemorySegment ListHead) {
        var mh$ = RtlInterlockedPopEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlInterlockedPopEntrySList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlInterlockedPushEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlInterlockedPushEntrySList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static FunctionDescriptor RtlInterlockedPushEntrySList$descriptor() {
        return RtlInterlockedPushEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MethodHandle RtlInterlockedPushEntrySList$handle() {
        return RtlInterlockedPushEntrySList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MemorySegment RtlInterlockedPushEntrySList$address() {
        return RtlInterlockedPushEntrySList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MemorySegment RtlInterlockedPushEntrySList(MemorySegment ListHead, MemorySegment ListEntry) {
        var mh$ = RtlInterlockedPushEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlInterlockedPushEntrySList", ListHead, ListEntry);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, ListEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlInterlockedPushListSListEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlInterlockedPushListSListEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, DWORD Count)
     * }
     */
    public static FunctionDescriptor RtlInterlockedPushListSListEx$descriptor() {
        return RtlInterlockedPushListSListEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, DWORD Count)
     * }
     */
    public static MethodHandle RtlInterlockedPushListSListEx$handle() {
        return RtlInterlockedPushListSListEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, DWORD Count)
     * }
     */
    public static MemorySegment RtlInterlockedPushListSListEx$address() {
        return RtlInterlockedPushListSListEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, DWORD Count)
     * }
     */
    public static MemorySegment RtlInterlockedPushListSListEx(MemorySegment ListHead, MemorySegment List, MemorySegment ListEnd, int Count) {
        var mh$ = RtlInterlockedPushListSListEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlInterlockedPushListSListEx", ListHead, List, ListEnd, Count);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, List, ListEnd, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlInterlockedFlushSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlInterlockedFlushSList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor RtlInterlockedFlushSList$descriptor() {
        return RtlInterlockedFlushSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle RtlInterlockedFlushSList$handle() {
        return RtlInterlockedFlushSList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment RtlInterlockedFlushSList$address() {
        return RtlInterlockedFlushSList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY RtlInterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment RtlInterlockedFlushSList(MemorySegment ListHead) {
        var mh$ = RtlInterlockedFlushSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlInterlockedFlushSList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlQueryDepthSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlQueryDepthSList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD RtlQueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor RtlQueryDepthSList$descriptor() {
        return RtlQueryDepthSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD RtlQueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle RtlQueryDepthSList$handle() {
        return RtlQueryDepthSList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD RtlQueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment RtlQueryDepthSList$address() {
        return RtlQueryDepthSList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD RtlQueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static short RtlQueryDepthSList(MemorySegment ListHead) {
        var mh$ = RtlQueryDepthSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlQueryDepthSList", ListHead);
            }
            return (short)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlGetReturnAddressHijackTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlGetReturnAddressHijackTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG_PTR RtlGetReturnAddressHijackTarget()
     * }
     */
    public static FunctionDescriptor RtlGetReturnAddressHijackTarget$descriptor() {
        return RtlGetReturnAddressHijackTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG_PTR RtlGetReturnAddressHijackTarget()
     * }
     */
    public static MethodHandle RtlGetReturnAddressHijackTarget$handle() {
        return RtlGetReturnAddressHijackTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG_PTR RtlGetReturnAddressHijackTarget()
     * }
     */
    public static MemorySegment RtlGetReturnAddressHijackTarget$address() {
        return RtlGetReturnAddressHijackTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG_PTR RtlGetReturnAddressHijackTarget()
     * }
     */
    public static long RtlGetReturnAddressHijackTarget() {
        var mh$ = RtlGetReturnAddressHijackTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlGetReturnAddressHijackTarget");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef union _RTL_RUN_ONCE {
     *     PVOID Ptr;
     * } *PRTL_RUN_ONCE
     * }
     */
    public static final AddressLayout PRTL_RUN_ONCE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_BARRIER {
     *     DWORD Reserved1;
     *     DWORD Reserved2;
     *     ULONG_PTR Reserved3[2];
     *     DWORD Reserved4;
     *     DWORD Reserved5;
     * } *PRTL_BARRIER
     * }
     */
    public static final AddressLayout PRTL_BARRIER = winapi.C_POINTER;

    private static class __fastfail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("__fastfail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __fastfail(unsigned int Code)
     * }
     */
    public static FunctionDescriptor __fastfail$descriptor() {
        return __fastfail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __fastfail(unsigned int Code)
     * }
     */
    public static MethodHandle __fastfail$handle() {
        return __fastfail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __fastfail(unsigned int Code)
     * }
     */
    public static MemorySegment __fastfail$address() {
        return __fastfail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __fastfail(unsigned int Code)
     * }
     */
    public static void __fastfail(int Code) {
        var mh$ = __fastfail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fastfail", Code);
            }
            mh$.invokeExact(Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlCopyDeviceMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlCopyDeviceMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * volatile void *RtlCopyDeviceMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static FunctionDescriptor RtlCopyDeviceMemory$descriptor() {
        return RtlCopyDeviceMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * volatile void *RtlCopyDeviceMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static MethodHandle RtlCopyDeviceMemory$handle() {
        return RtlCopyDeviceMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * volatile void *RtlCopyDeviceMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static MemorySegment RtlCopyDeviceMemory$address() {
        return RtlCopyDeviceMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * volatile void *RtlCopyDeviceMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static MemorySegment RtlCopyDeviceMemory(MemorySegment Destination, MemorySegment Source, long Length) {
        var mh$ = RtlCopyDeviceMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlCopyDeviceMemory", Destination, Source, Length);
            }
            return (MemorySegment)mh$.invokeExact(Destination, Source, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlCopyVolatileMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlCopyVolatileMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * volatile void *RtlCopyVolatileMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static FunctionDescriptor RtlCopyVolatileMemory$descriptor() {
        return RtlCopyVolatileMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * volatile void *RtlCopyVolatileMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static MethodHandle RtlCopyVolatileMemory$handle() {
        return RtlCopyVolatileMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * volatile void *RtlCopyVolatileMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static MemorySegment RtlCopyVolatileMemory$address() {
        return RtlCopyVolatileMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * volatile void *RtlCopyVolatileMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static MemorySegment RtlCopyVolatileMemory(MemorySegment Destination, MemorySegment Source, long Length) {
        var mh$ = RtlCopyVolatileMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlCopyVolatileMemory", Destination, Source, Length);
            }
            return (MemorySegment)mh$.invokeExact(Destination, Source, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlMoveVolatileMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlMoveVolatileMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * volatile void *RtlMoveVolatileMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static FunctionDescriptor RtlMoveVolatileMemory$descriptor() {
        return RtlMoveVolatileMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * volatile void *RtlMoveVolatileMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static MethodHandle RtlMoveVolatileMemory$handle() {
        return RtlMoveVolatileMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * volatile void *RtlMoveVolatileMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static MemorySegment RtlMoveVolatileMemory$address() {
        return RtlMoveVolatileMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * volatile void *RtlMoveVolatileMemory(volatile void *Destination, const volatile void *Source, size_t Length)
     * }
     */
    public static MemorySegment RtlMoveVolatileMemory(MemorySegment Destination, MemorySegment Source, long Length) {
        var mh$ = RtlMoveVolatileMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlMoveVolatileMemory", Destination, Source, Length);
            }
            return (MemorySegment)mh$.invokeExact(Destination, Source, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlSetVolatileMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlSetVolatileMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * volatile void *RtlSetVolatileMemory(volatile void *Destination, int Fill, size_t Length)
     * }
     */
    public static FunctionDescriptor RtlSetVolatileMemory$descriptor() {
        return RtlSetVolatileMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * volatile void *RtlSetVolatileMemory(volatile void *Destination, int Fill, size_t Length)
     * }
     */
    public static MethodHandle RtlSetVolatileMemory$handle() {
        return RtlSetVolatileMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * volatile void *RtlSetVolatileMemory(volatile void *Destination, int Fill, size_t Length)
     * }
     */
    public static MemorySegment RtlSetVolatileMemory$address() {
        return RtlSetVolatileMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * volatile void *RtlSetVolatileMemory(volatile void *Destination, int Fill, size_t Length)
     * }
     */
    public static MemorySegment RtlSetVolatileMemory(MemorySegment Destination, int Fill, long Length) {
        var mh$ = RtlSetVolatileMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlSetVolatileMemory", Destination, Fill, Length);
            }
            return (MemorySegment)mh$.invokeExact(Destination, Fill, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _MESSAGE_RESOURCE_ENTRY {
     *     WORD Length;
     *     WORD Flags;
     *     BYTE Text[1];
     * } *PMESSAGE_RESOURCE_ENTRY
     * }
     */
    public static final AddressLayout PMESSAGE_RESOURCE_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MESSAGE_RESOURCE_BLOCK {
     *     DWORD LowId;
     *     DWORD HighId;
     *     DWORD OffsetToEntries;
     * } *PMESSAGE_RESOURCE_BLOCK
     * }
     */
    public static final AddressLayout PMESSAGE_RESOURCE_BLOCK = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MESSAGE_RESOURCE_DATA {
     *     DWORD NumberOfBlocks;
     *     MESSAGE_RESOURCE_BLOCK Blocks[1];
     * } *PMESSAGE_RESOURCE_DATA
     * }
     */
    public static final AddressLayout PMESSAGE_RESOURCE_DATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOA {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     CHAR szCSDVersion[128];
     * } *POSVERSIONINFOA
     * }
     */
    public static final AddressLayout POSVERSIONINFOA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOA {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     CHAR szCSDVersion[128];
     * } *LPOSVERSIONINFOA
     * }
     */
    public static final AddressLayout LPOSVERSIONINFOA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOW {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     WCHAR szCSDVersion[128];
     * } *POSVERSIONINFOW
     * }
     */
    public static final AddressLayout POSVERSIONINFOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOW {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     WCHAR szCSDVersion[128];
     * } *LPOSVERSIONINFOW
     * }
     */
    public static final AddressLayout LPOSVERSIONINFOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOW {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     WCHAR szCSDVersion[128];
     * } *PRTL_OSVERSIONINFOW
     * }
     */
    public static final AddressLayout PRTL_OSVERSIONINFOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef POSVERSIONINFOA POSVERSIONINFO
     * }
     */
    public static final AddressLayout POSVERSIONINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOSVERSIONINFOA LPOSVERSIONINFO
     * }
     */
    public static final AddressLayout LPOSVERSIONINFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOEXA {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     CHAR szCSDVersion[128];
     *     WORD wServicePackMajor;
     *     WORD wServicePackMinor;
     *     WORD wSuiteMask;
     *     BYTE wProductType;
     *     BYTE wReserved;
     * } *POSVERSIONINFOEXA
     * }
     */
    public static final AddressLayout POSVERSIONINFOEXA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOEXA {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     CHAR szCSDVersion[128];
     *     WORD wServicePackMajor;
     *     WORD wServicePackMinor;
     *     WORD wSuiteMask;
     *     BYTE wProductType;
     *     BYTE wReserved;
     * } *LPOSVERSIONINFOEXA
     * }
     */
    public static final AddressLayout LPOSVERSIONINFOEXA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOEXW {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     WCHAR szCSDVersion[128];
     *     WORD wServicePackMajor;
     *     WORD wServicePackMinor;
     *     WORD wSuiteMask;
     *     BYTE wProductType;
     *     BYTE wReserved;
     * } *POSVERSIONINFOEXW
     * }
     */
    public static final AddressLayout POSVERSIONINFOEXW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOEXW {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     WCHAR szCSDVersion[128];
     *     WORD wServicePackMajor;
     *     WORD wServicePackMinor;
     *     WORD wSuiteMask;
     *     BYTE wProductType;
     *     BYTE wReserved;
     * } *LPOSVERSIONINFOEXW
     * }
     */
    public static final AddressLayout LPOSVERSIONINFOEXW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OSVERSIONINFOEXW {
     *     DWORD dwOSVersionInfoSize;
     *     DWORD dwMajorVersion;
     *     DWORD dwMinorVersion;
     *     DWORD dwBuildNumber;
     *     DWORD dwPlatformId;
     *     WCHAR szCSDVersion[128];
     *     WORD wServicePackMajor;
     *     WORD wServicePackMinor;
     *     WORD wSuiteMask;
     *     BYTE wProductType;
     *     BYTE wReserved;
     * } *PRTL_OSVERSIONINFOEXW
     * }
     */
    public static final AddressLayout PRTL_OSVERSIONINFOEXW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef POSVERSIONINFOEXA POSVERSIONINFOEX
     * }
     */
    public static final AddressLayout POSVERSIONINFOEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX
     * }
     */
    public static final AddressLayout LPOSVERSIONINFOEX = winapi.C_POINTER;

    private static class VerSetConditionMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("VerSetConditionMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONGLONG VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition)
     * }
     */
    public static FunctionDescriptor VerSetConditionMask$descriptor() {
        return VerSetConditionMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONGLONG VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition)
     * }
     */
    public static MethodHandle VerSetConditionMask$handle() {
        return VerSetConditionMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONGLONG VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition)
     * }
     */
    public static MemorySegment VerSetConditionMask$address() {
        return VerSetConditionMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONGLONG VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition)
     * }
     */
    public static long VerSetConditionMask(long ConditionMask, int TypeMask, byte Condition) {
        var mh$ = VerSetConditionMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerSetConditionMask", ConditionMask, TypeMask, Condition);
            }
            return (long)mh$.invokeExact(ConditionMask, TypeMask, Condition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlGetProductInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlGetProductInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN RtlGetProductInfo(DWORD OSMajorVersion, DWORD OSMinorVersion, DWORD SpMajorVersion, DWORD SpMinorVersion, PDWORD ReturnedProductType)
     * }
     */
    public static FunctionDescriptor RtlGetProductInfo$descriptor() {
        return RtlGetProductInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN RtlGetProductInfo(DWORD OSMajorVersion, DWORD OSMinorVersion, DWORD SpMajorVersion, DWORD SpMinorVersion, PDWORD ReturnedProductType)
     * }
     */
    public static MethodHandle RtlGetProductInfo$handle() {
        return RtlGetProductInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN RtlGetProductInfo(DWORD OSMajorVersion, DWORD OSMinorVersion, DWORD SpMajorVersion, DWORD SpMinorVersion, PDWORD ReturnedProductType)
     * }
     */
    public static MemorySegment RtlGetProductInfo$address() {
        return RtlGetProductInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN RtlGetProductInfo(DWORD OSMajorVersion, DWORD OSMinorVersion, DWORD SpMajorVersion, DWORD SpMinorVersion, PDWORD ReturnedProductType)
     * }
     */
    public static byte RtlGetProductInfo(int OSMajorVersion, int OSMinorVersion, int SpMajorVersion, int SpMinorVersion, MemorySegment ReturnedProductType) {
        var mh$ = RtlGetProductInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlGetProductInfo", OSMajorVersion, OSMinorVersion, SpMajorVersion, SpMinorVersion, ReturnedProductType);
            }
            return (byte)mh$.invokeExact(OSMajorVersion, OSMinorVersion, SpMajorVersion, SpMinorVersion, ReturnedProductType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UmsThreadInvalidInfoClass = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_THREAD_INFO_CLASS.UmsThreadInvalidInfoClass = 0
     * }
     */
    public static int UmsThreadInvalidInfoClass() {
        return UmsThreadInvalidInfoClass;
    }
    private static final int UmsThreadUserContext = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_THREAD_INFO_CLASS.UmsThreadUserContext = 1
     * }
     */
    public static int UmsThreadUserContext() {
        return UmsThreadUserContext;
    }
    private static final int UmsThreadPriority = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_THREAD_INFO_CLASS.UmsThreadPriority = 2
     * }
     */
    public static int UmsThreadPriority() {
        return UmsThreadPriority;
    }
    private static final int UmsThreadAffinity = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_THREAD_INFO_CLASS.UmsThreadAffinity = 3
     * }
     */
    public static int UmsThreadAffinity() {
        return UmsThreadAffinity;
    }
    private static final int UmsThreadTeb = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_THREAD_INFO_CLASS.UmsThreadTeb = 4
     * }
     */
    public static int UmsThreadTeb() {
        return UmsThreadTeb;
    }
    private static final int UmsThreadIsSuspended = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_THREAD_INFO_CLASS.UmsThreadIsSuspended = 5
     * }
     */
    public static int UmsThreadIsSuspended() {
        return UmsThreadIsSuspended;
    }
    private static final int UmsThreadIsTerminated = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_THREAD_INFO_CLASS.UmsThreadIsTerminated = 6
     * }
     */
    public static int UmsThreadIsTerminated() {
        return UmsThreadIsTerminated;
    }
    private static final int UmsThreadMaxInfoClass = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_THREAD_INFO_CLASS.UmsThreadMaxInfoClass = 7
     * }
     */
    public static int UmsThreadMaxInfoClass() {
        return UmsThreadMaxInfoClass;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _RTL_UMS_THREAD_INFO_CLASS {
     *     UmsThreadInvalidInfoClass = 0,
     *     UmsThreadUserContext,
     *     UmsThreadPriority,
     *     UmsThreadAffinity,
     *     UmsThreadTeb,
     *     UmsThreadIsSuspended,
     *     UmsThreadIsTerminated,
     *     UmsThreadMaxInfoClass
     * } *PRTL_UMS_THREAD_INFO_CLASS
     * }
     */
    public static final AddressLayout PRTL_UMS_THREAD_INFO_CLASS = winapi.C_POINTER;
    private static final int UmsSchedulerStartup = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_SCHEDULER_REASON.UmsSchedulerStartup = 0
     * }
     */
    public static int UmsSchedulerStartup() {
        return UmsSchedulerStartup;
    }
    private static final int UmsSchedulerThreadBlocked = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_SCHEDULER_REASON.UmsSchedulerThreadBlocked = 1
     * }
     */
    public static int UmsSchedulerThreadBlocked() {
        return UmsSchedulerThreadBlocked;
    }
    private static final int UmsSchedulerThreadYield = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _RTL_UMS_SCHEDULER_REASON.UmsSchedulerThreadYield = 2
     * }
     */
    public static int UmsSchedulerThreadYield() {
        return UmsSchedulerThreadYield;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _RTL_UMS_SCHEDULER_REASON {
     *     UmsSchedulerStartup = 0,
     *     UmsSchedulerThreadBlocked,
     *     UmsSchedulerThreadYield
     * } *PRTL_UMS_SCHEDULER_REASON
     * }
     */
    public static final AddressLayout PRTL_UMS_SCHEDULER_REASON = winapi.C_POINTER;

    private static class RtlCrc32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlCrc32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlCrc32(const void *Buffer, size_t Size, DWORD InitialCrc)
     * }
     */
    public static FunctionDescriptor RtlCrc32$descriptor() {
        return RtlCrc32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlCrc32(const void *Buffer, size_t Size, DWORD InitialCrc)
     * }
     */
    public static MethodHandle RtlCrc32$handle() {
        return RtlCrc32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlCrc32(const void *Buffer, size_t Size, DWORD InitialCrc)
     * }
     */
    public static MemorySegment RtlCrc32$address() {
        return RtlCrc32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlCrc32(const void *Buffer, size_t Size, DWORD InitialCrc)
     * }
     */
    public static int RtlCrc32(MemorySegment Buffer, long Size, int InitialCrc) {
        var mh$ = RtlCrc32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlCrc32", Buffer, Size, InitialCrc);
            }
            return (int)mh$.invokeExact(Buffer, Size, InitialCrc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlCrc64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlCrc64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONGLONG RtlCrc64(const void *Buffer, size_t Size, ULONGLONG InitialCrc)
     * }
     */
    public static FunctionDescriptor RtlCrc64$descriptor() {
        return RtlCrc64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONGLONG RtlCrc64(const void *Buffer, size_t Size, ULONGLONG InitialCrc)
     * }
     */
    public static MethodHandle RtlCrc64$handle() {
        return RtlCrc64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONGLONG RtlCrc64(const void *Buffer, size_t Size, ULONGLONG InitialCrc)
     * }
     */
    public static MemorySegment RtlCrc64$address() {
        return RtlCrc64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONGLONG RtlCrc64(const void *Buffer, size_t Size, ULONGLONG InitialCrc)
     * }
     */
    public static long RtlCrc64(MemorySegment Buffer, long Size, long InitialCrc) {
        var mh$ = RtlCrc64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlCrc64", Buffer, Size, InitialCrc);
            }
            return (long)mh$.invokeExact(Buffer, Size, InitialCrc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int OS_DEPLOYMENT_STANDARD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _OS_DEPLOYEMENT_STATE_VALUES.OS_DEPLOYMENT_STANDARD = 1
     * }
     */
    public static int OS_DEPLOYMENT_STANDARD() {
        return OS_DEPLOYMENT_STANDARD;
    }
    private static final int OS_DEPLOYMENT_COMPACT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _OS_DEPLOYEMENT_STATE_VALUES.OS_DEPLOYMENT_COMPACT = 2
     * }
     */
    public static int OS_DEPLOYMENT_COMPACT() {
        return OS_DEPLOYMENT_COMPACT;
    }

    private static class RtlOsDeploymentState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlOsDeploymentState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * OS_DEPLOYEMENT_STATE_VALUES RtlOsDeploymentState(DWORD Flags)
     * }
     */
    public static FunctionDescriptor RtlOsDeploymentState$descriptor() {
        return RtlOsDeploymentState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * OS_DEPLOYEMENT_STATE_VALUES RtlOsDeploymentState(DWORD Flags)
     * }
     */
    public static MethodHandle RtlOsDeploymentState$handle() {
        return RtlOsDeploymentState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * OS_DEPLOYEMENT_STATE_VALUES RtlOsDeploymentState(DWORD Flags)
     * }
     */
    public static MemorySegment RtlOsDeploymentState$address() {
        return RtlOsDeploymentState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * OS_DEPLOYEMENT_STATE_VALUES RtlOsDeploymentState(DWORD Flags)
     * }
     */
    public static int RtlOsDeploymentState(int Flags) {
        var mh$ = RtlOsDeploymentState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlOsDeploymentState", Flags);
            }
            return (int)mh$.invokeExact(Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NV_MEMORY_RANGE {
     *     void *BaseAddress;
     *     SIZE_T Length;
     * } *PNV_MEMORY_RANGE
     * }
     */
    public static final AddressLayout PNV_MEMORY_RANGE = winapi.C_POINTER;

    private static class RtlGetNonVolatileToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlGetNonVolatileToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlGetNonVolatileToken(PVOID NvBuffer, SIZE_T Size, PVOID *NvToken)
     * }
     */
    public static FunctionDescriptor RtlGetNonVolatileToken$descriptor() {
        return RtlGetNonVolatileToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlGetNonVolatileToken(PVOID NvBuffer, SIZE_T Size, PVOID *NvToken)
     * }
     */
    public static MethodHandle RtlGetNonVolatileToken$handle() {
        return RtlGetNonVolatileToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlGetNonVolatileToken(PVOID NvBuffer, SIZE_T Size, PVOID *NvToken)
     * }
     */
    public static MemorySegment RtlGetNonVolatileToken$address() {
        return RtlGetNonVolatileToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlGetNonVolatileToken(PVOID NvBuffer, SIZE_T Size, PVOID *NvToken)
     * }
     */
    public static int RtlGetNonVolatileToken(MemorySegment NvBuffer, long Size, MemorySegment NvToken) {
        var mh$ = RtlGetNonVolatileToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlGetNonVolatileToken", NvBuffer, Size, NvToken);
            }
            return (int)mh$.invokeExact(NvBuffer, Size, NvToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlFreeNonVolatileToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlFreeNonVolatileToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlFreeNonVolatileToken(PVOID NvToken)
     * }
     */
    public static FunctionDescriptor RtlFreeNonVolatileToken$descriptor() {
        return RtlFreeNonVolatileToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlFreeNonVolatileToken(PVOID NvToken)
     * }
     */
    public static MethodHandle RtlFreeNonVolatileToken$handle() {
        return RtlFreeNonVolatileToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlFreeNonVolatileToken(PVOID NvToken)
     * }
     */
    public static MemorySegment RtlFreeNonVolatileToken$address() {
        return RtlFreeNonVolatileToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlFreeNonVolatileToken(PVOID NvToken)
     * }
     */
    public static int RtlFreeNonVolatileToken(MemorySegment NvToken) {
        var mh$ = RtlFreeNonVolatileToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlFreeNonVolatileToken", NvToken);
            }
            return (int)mh$.invokeExact(NvToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlFlushNonVolatileMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlFlushNonVolatileMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlFlushNonVolatileMemory(PVOID NvToken, PVOID NvBuffer, SIZE_T Size, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RtlFlushNonVolatileMemory$descriptor() {
        return RtlFlushNonVolatileMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlFlushNonVolatileMemory(PVOID NvToken, PVOID NvBuffer, SIZE_T Size, DWORD Flags)
     * }
     */
    public static MethodHandle RtlFlushNonVolatileMemory$handle() {
        return RtlFlushNonVolatileMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlFlushNonVolatileMemory(PVOID NvToken, PVOID NvBuffer, SIZE_T Size, DWORD Flags)
     * }
     */
    public static MemorySegment RtlFlushNonVolatileMemory$address() {
        return RtlFlushNonVolatileMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlFlushNonVolatileMemory(PVOID NvToken, PVOID NvBuffer, SIZE_T Size, DWORD Flags)
     * }
     */
    public static int RtlFlushNonVolatileMemory(MemorySegment NvToken, MemorySegment NvBuffer, long Size, int Flags) {
        var mh$ = RtlFlushNonVolatileMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlFlushNonVolatileMemory", NvToken, NvBuffer, Size, Flags);
            }
            return (int)mh$.invokeExact(NvToken, NvBuffer, Size, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlDrainNonVolatileFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlDrainNonVolatileFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlDrainNonVolatileFlush(PVOID NvToken)
     * }
     */
    public static FunctionDescriptor RtlDrainNonVolatileFlush$descriptor() {
        return RtlDrainNonVolatileFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlDrainNonVolatileFlush(PVOID NvToken)
     * }
     */
    public static MethodHandle RtlDrainNonVolatileFlush$handle() {
        return RtlDrainNonVolatileFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlDrainNonVolatileFlush(PVOID NvToken)
     * }
     */
    public static MemorySegment RtlDrainNonVolatileFlush$address() {
        return RtlDrainNonVolatileFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlDrainNonVolatileFlush(PVOID NvToken)
     * }
     */
    public static int RtlDrainNonVolatileFlush(MemorySegment NvToken) {
        var mh$ = RtlDrainNonVolatileFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlDrainNonVolatileFlush", NvToken);
            }
            return (int)mh$.invokeExact(NvToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlWriteNonVolatileMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlWriteNonVolatileMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlWriteNonVolatileMemory(PVOID NvToken, __unaligned void *NvDestination, const __unaligned void *Source, SIZE_T Size, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RtlWriteNonVolatileMemory$descriptor() {
        return RtlWriteNonVolatileMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlWriteNonVolatileMemory(PVOID NvToken, __unaligned void *NvDestination, const __unaligned void *Source, SIZE_T Size, DWORD Flags)
     * }
     */
    public static MethodHandle RtlWriteNonVolatileMemory$handle() {
        return RtlWriteNonVolatileMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlWriteNonVolatileMemory(PVOID NvToken, __unaligned void *NvDestination, const __unaligned void *Source, SIZE_T Size, DWORD Flags)
     * }
     */
    public static MemorySegment RtlWriteNonVolatileMemory$address() {
        return RtlWriteNonVolatileMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlWriteNonVolatileMemory(PVOID NvToken, __unaligned void *NvDestination, const __unaligned void *Source, SIZE_T Size, DWORD Flags)
     * }
     */
    public static int RtlWriteNonVolatileMemory(MemorySegment NvToken, MemorySegment NvDestination, MemorySegment Source, long Size, int Flags) {
        var mh$ = RtlWriteNonVolatileMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlWriteNonVolatileMemory", NvToken, NvDestination, Source, Size, Flags);
            }
            return (int)mh$.invokeExact(NvToken, NvDestination, Source, Size, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlFillNonVolatileMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_CHAR,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlFillNonVolatileMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlFillNonVolatileMemory(PVOID NvToken, __unaligned void *NvDestination, SIZE_T Size, const BYTE Value, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RtlFillNonVolatileMemory$descriptor() {
        return RtlFillNonVolatileMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlFillNonVolatileMemory(PVOID NvToken, __unaligned void *NvDestination, SIZE_T Size, const BYTE Value, DWORD Flags)
     * }
     */
    public static MethodHandle RtlFillNonVolatileMemory$handle() {
        return RtlFillNonVolatileMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlFillNonVolatileMemory(PVOID NvToken, __unaligned void *NvDestination, SIZE_T Size, const BYTE Value, DWORD Flags)
     * }
     */
    public static MemorySegment RtlFillNonVolatileMemory$address() {
        return RtlFillNonVolatileMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlFillNonVolatileMemory(PVOID NvToken, __unaligned void *NvDestination, SIZE_T Size, const BYTE Value, DWORD Flags)
     * }
     */
    public static int RtlFillNonVolatileMemory(MemorySegment NvToken, MemorySegment NvDestination, long Size, byte Value, int Flags) {
        var mh$ = RtlFillNonVolatileMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlFillNonVolatileMemory", NvToken, NvDestination, Size, Value, Flags);
            }
            return (int)mh$.invokeExact(NvToken, NvDestination, Size, Value, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlFlushNonVolatileMemoryRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlFlushNonVolatileMemoryRanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlFlushNonVolatileMemoryRanges(PVOID NvToken, PNV_MEMORY_RANGE NvRanges, SIZE_T NumRanges, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RtlFlushNonVolatileMemoryRanges$descriptor() {
        return RtlFlushNonVolatileMemoryRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlFlushNonVolatileMemoryRanges(PVOID NvToken, PNV_MEMORY_RANGE NvRanges, SIZE_T NumRanges, DWORD Flags)
     * }
     */
    public static MethodHandle RtlFlushNonVolatileMemoryRanges$handle() {
        return RtlFlushNonVolatileMemoryRanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlFlushNonVolatileMemoryRanges(PVOID NvToken, PNV_MEMORY_RANGE NvRanges, SIZE_T NumRanges, DWORD Flags)
     * }
     */
    public static MemorySegment RtlFlushNonVolatileMemoryRanges$address() {
        return RtlFlushNonVolatileMemoryRanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlFlushNonVolatileMemoryRanges(PVOID NvToken, PNV_MEMORY_RANGE NvRanges, SIZE_T NumRanges, DWORD Flags)
     * }
     */
    public static int RtlFlushNonVolatileMemoryRanges(MemorySegment NvToken, MemorySegment NvRanges, long NumRanges, int Flags) {
        var mh$ = RtlFlushNonVolatileMemoryRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlFlushNonVolatileMemoryRanges", NvToken, NvRanges, NumRanges, Flags);
            }
            return (int)mh$.invokeExact(NvToken, NvRanges, NumRanges, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef CORRELATION_VECTOR *PCORRELATION_VECTOR
     * }
     */
    public static final AddressLayout PCORRELATION_VECTOR = winapi.C_POINTER;

    private static class RtlInitializeCorrelationVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlInitializeCorrelationVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlInitializeCorrelationVector(PCORRELATION_VECTOR CorrelationVector, int Version, const GUID *Guid)
     * }
     */
    public static FunctionDescriptor RtlInitializeCorrelationVector$descriptor() {
        return RtlInitializeCorrelationVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlInitializeCorrelationVector(PCORRELATION_VECTOR CorrelationVector, int Version, const GUID *Guid)
     * }
     */
    public static MethodHandle RtlInitializeCorrelationVector$handle() {
        return RtlInitializeCorrelationVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlInitializeCorrelationVector(PCORRELATION_VECTOR CorrelationVector, int Version, const GUID *Guid)
     * }
     */
    public static MemorySegment RtlInitializeCorrelationVector$address() {
        return RtlInitializeCorrelationVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlInitializeCorrelationVector(PCORRELATION_VECTOR CorrelationVector, int Version, const GUID *Guid)
     * }
     */
    public static int RtlInitializeCorrelationVector(MemorySegment CorrelationVector, int Version, MemorySegment Guid) {
        var mh$ = RtlInitializeCorrelationVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlInitializeCorrelationVector", CorrelationVector, Version, Guid);
            }
            return (int)mh$.invokeExact(CorrelationVector, Version, Guid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlIncrementCorrelationVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlIncrementCorrelationVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlIncrementCorrelationVector(PCORRELATION_VECTOR CorrelationVector)
     * }
     */
    public static FunctionDescriptor RtlIncrementCorrelationVector$descriptor() {
        return RtlIncrementCorrelationVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlIncrementCorrelationVector(PCORRELATION_VECTOR CorrelationVector)
     * }
     */
    public static MethodHandle RtlIncrementCorrelationVector$handle() {
        return RtlIncrementCorrelationVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlIncrementCorrelationVector(PCORRELATION_VECTOR CorrelationVector)
     * }
     */
    public static MemorySegment RtlIncrementCorrelationVector$address() {
        return RtlIncrementCorrelationVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlIncrementCorrelationVector(PCORRELATION_VECTOR CorrelationVector)
     * }
     */
    public static int RtlIncrementCorrelationVector(MemorySegment CorrelationVector) {
        var mh$ = RtlIncrementCorrelationVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlIncrementCorrelationVector", CorrelationVector);
            }
            return (int)mh$.invokeExact(CorrelationVector);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlExtendCorrelationVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlExtendCorrelationVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlExtendCorrelationVector(PCORRELATION_VECTOR CorrelationVector)
     * }
     */
    public static FunctionDescriptor RtlExtendCorrelationVector$descriptor() {
        return RtlExtendCorrelationVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlExtendCorrelationVector(PCORRELATION_VECTOR CorrelationVector)
     * }
     */
    public static MethodHandle RtlExtendCorrelationVector$handle() {
        return RtlExtendCorrelationVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlExtendCorrelationVector(PCORRELATION_VECTOR CorrelationVector)
     * }
     */
    public static MemorySegment RtlExtendCorrelationVector$address() {
        return RtlExtendCorrelationVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlExtendCorrelationVector(PCORRELATION_VECTOR CorrelationVector)
     * }
     */
    public static int RtlExtendCorrelationVector(MemorySegment CorrelationVector) {
        var mh$ = RtlExtendCorrelationVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlExtendCorrelationVector", CorrelationVector);
            }
            return (int)mh$.invokeExact(CorrelationVector);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlValidateCorrelationVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlValidateCorrelationVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlValidateCorrelationVector(PCORRELATION_VECTOR Vector)
     * }
     */
    public static FunctionDescriptor RtlValidateCorrelationVector$descriptor() {
        return RtlValidateCorrelationVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlValidateCorrelationVector(PCORRELATION_VECTOR Vector)
     * }
     */
    public static MethodHandle RtlValidateCorrelationVector$handle() {
        return RtlValidateCorrelationVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlValidateCorrelationVector(PCORRELATION_VECTOR Vector)
     * }
     */
    public static MemorySegment RtlValidateCorrelationVector$address() {
        return RtlValidateCorrelationVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlValidateCorrelationVector(PCORRELATION_VECTOR Vector)
     * }
     */
    public static int RtlValidateCorrelationVector(MemorySegment Vector) {
        var mh$ = RtlValidateCorrelationVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlValidateCorrelationVector", Vector);
            }
            return (int)mh$.invokeExact(Vector);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
     *     DWORD Size;
     *     PCWSTR TriggerId;
     * } *PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG
     * }
     */
    public static final AddressLayout PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = winapi.C_POINTER;

    private static class RtlRaiseCustomSystemEventTrigger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlRaiseCustomSystemEventTrigger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlRaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig)
     * }
     */
    public static FunctionDescriptor RtlRaiseCustomSystemEventTrigger$descriptor() {
        return RtlRaiseCustomSystemEventTrigger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlRaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig)
     * }
     */
    public static MethodHandle RtlRaiseCustomSystemEventTrigger$handle() {
        return RtlRaiseCustomSystemEventTrigger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlRaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig)
     * }
     */
    public static MemorySegment RtlRaiseCustomSystemEventTrigger$address() {
        return RtlRaiseCustomSystemEventTrigger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlRaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig)
     * }
     */
    public static int RtlRaiseCustomSystemEventTrigger(MemorySegment TriggerConfig) {
        var mh$ = RtlRaiseCustomSystemEventTrigger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlRaiseCustomSystemEventTrigger", TriggerConfig);
            }
            return (int)mh$.invokeExact(TriggerConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ImagePolicyEntryTypeNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeNone = 0
     * }
     */
    public static int ImagePolicyEntryTypeNone() {
        return ImagePolicyEntryTypeNone;
    }
    private static final int ImagePolicyEntryTypeBool = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeBool = 1
     * }
     */
    public static int ImagePolicyEntryTypeBool() {
        return ImagePolicyEntryTypeBool;
    }
    private static final int ImagePolicyEntryTypeInt8 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt8 = 2
     * }
     */
    public static int ImagePolicyEntryTypeInt8() {
        return ImagePolicyEntryTypeInt8;
    }
    private static final int ImagePolicyEntryTypeUInt8 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt8 = 3
     * }
     */
    public static int ImagePolicyEntryTypeUInt8() {
        return ImagePolicyEntryTypeUInt8;
    }
    private static final int ImagePolicyEntryTypeInt16 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt16 = 4
     * }
     */
    public static int ImagePolicyEntryTypeInt16() {
        return ImagePolicyEntryTypeInt16;
    }
    private static final int ImagePolicyEntryTypeUInt16 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt16 = 5
     * }
     */
    public static int ImagePolicyEntryTypeUInt16() {
        return ImagePolicyEntryTypeUInt16;
    }
    private static final int ImagePolicyEntryTypeInt32 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt32 = 6
     * }
     */
    public static int ImagePolicyEntryTypeInt32() {
        return ImagePolicyEntryTypeInt32;
    }
    private static final int ImagePolicyEntryTypeUInt32 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt32 = 7
     * }
     */
    public static int ImagePolicyEntryTypeUInt32() {
        return ImagePolicyEntryTypeUInt32;
    }
    private static final int ImagePolicyEntryTypeInt64 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt64 = 8
     * }
     */
    public static int ImagePolicyEntryTypeInt64() {
        return ImagePolicyEntryTypeInt64;
    }
    private static final int ImagePolicyEntryTypeUInt64 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt64 = 9
     * }
     */
    public static int ImagePolicyEntryTypeUInt64() {
        return ImagePolicyEntryTypeUInt64;
    }
    private static final int ImagePolicyEntryTypeAnsiString = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeAnsiString = 10
     * }
     */
    public static int ImagePolicyEntryTypeAnsiString() {
        return ImagePolicyEntryTypeAnsiString;
    }
    private static final int ImagePolicyEntryTypeUnicodeString = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUnicodeString = 11
     * }
     */
    public static int ImagePolicyEntryTypeUnicodeString() {
        return ImagePolicyEntryTypeUnicodeString;
    }
    private static final int ImagePolicyEntryTypeOverride = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeOverride = 12
     * }
     */
    public static int ImagePolicyEntryTypeOverride() {
        return ImagePolicyEntryTypeOverride;
    }
    private static final int ImagePolicyEntryTypeMaximum = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeMaximum = 13
     * }
     */
    public static int ImagePolicyEntryTypeMaximum() {
        return ImagePolicyEntryTypeMaximum;
    }
    private static final int ImagePolicyIdNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdNone = 0
     * }
     */
    public static int ImagePolicyIdNone() {
        return ImagePolicyIdNone;
    }
    private static final int ImagePolicyIdEtw = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdEtw = 1
     * }
     */
    public static int ImagePolicyIdEtw() {
        return ImagePolicyIdEtw;
    }
    private static final int ImagePolicyIdDebug = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdDebug = 2
     * }
     */
    public static int ImagePolicyIdDebug() {
        return ImagePolicyIdDebug;
    }
    private static final int ImagePolicyIdCrashDump = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdCrashDump = 3
     * }
     */
    public static int ImagePolicyIdCrashDump() {
        return ImagePolicyIdCrashDump;
    }
    private static final int ImagePolicyIdCrashDumpKey = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdCrashDumpKey = 4
     * }
     */
    public static int ImagePolicyIdCrashDumpKey() {
        return ImagePolicyIdCrashDumpKey;
    }
    private static final int ImagePolicyIdCrashDumpKeyGuid = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdCrashDumpKeyGuid = 5
     * }
     */
    public static int ImagePolicyIdCrashDumpKeyGuid() {
        return ImagePolicyIdCrashDumpKeyGuid;
    }
    private static final int ImagePolicyIdParentSd = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdParentSd = 6
     * }
     */
    public static int ImagePolicyIdParentSd() {
        return ImagePolicyIdParentSd;
    }
    private static final int ImagePolicyIdParentSdRev = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdParentSdRev = 7
     * }
     */
    public static int ImagePolicyIdParentSdRev() {
        return ImagePolicyIdParentSdRev;
    }
    private static final int ImagePolicyIdSvn = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdSvn = 8
     * }
     */
    public static int ImagePolicyIdSvn() {
        return ImagePolicyIdSvn;
    }
    private static final int ImagePolicyIdDeviceId = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdDeviceId = 9
     * }
     */
    public static int ImagePolicyIdDeviceId() {
        return ImagePolicyIdDeviceId;
    }
    private static final int ImagePolicyIdCapability = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdCapability = 10
     * }
     */
    public static int ImagePolicyIdCapability() {
        return ImagePolicyIdCapability;
    }
    private static final int ImagePolicyIdScenarioId = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdScenarioId = 11
     * }
     */
    public static int ImagePolicyIdScenarioId() {
        return ImagePolicyIdScenarioId;
    }
    private static final int ImagePolicyIdCapabilityOverridable = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdCapabilityOverridable = 12
     * }
     */
    public static int ImagePolicyIdCapabilityOverridable() {
        return ImagePolicyIdCapabilityOverridable;
    }
    private static final int ImagePolicyIdTrustletIdOverridable = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdTrustletIdOverridable = 13
     * }
     */
    public static int ImagePolicyIdTrustletIdOverridable() {
        return ImagePolicyIdTrustletIdOverridable;
    }
    private static final int ImagePolicyIdMaximum = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdMaximum = 14
     * }
     */
    public static int ImagePolicyIdMaximum() {
        return ImagePolicyIdMaximum;
    }
    /**
     * {@snippet lang=c :
     * typedef const IMAGE_POLICY_ENTRY *PCIMAGE_POLICY_ENTRY
     * }
     */
    public static final AddressLayout PCIMAGE_POLICY_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const IMAGE_POLICY_METADATA *PCIMAGE_POLICY_METADATA
     * }
     */
    public static final AddressLayout PCIMAGE_POLICY_METADATA = winapi.C_POINTER;

    private static class RtlIsZeroMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlIsZeroMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN RtlIsZeroMemory(PVOID Buffer, SIZE_T Length)
     * }
     */
    public static FunctionDescriptor RtlIsZeroMemory$descriptor() {
        return RtlIsZeroMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN RtlIsZeroMemory(PVOID Buffer, SIZE_T Length)
     * }
     */
    public static MethodHandle RtlIsZeroMemory$handle() {
        return RtlIsZeroMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN RtlIsZeroMemory(PVOID Buffer, SIZE_T Length)
     * }
     */
    public static MemorySegment RtlIsZeroMemory$address() {
        return RtlIsZeroMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN RtlIsZeroMemory(PVOID Buffer, SIZE_T Length)
     * }
     */
    public static byte RtlIsZeroMemory(MemorySegment Buffer, long Length) {
        var mh$ = RtlIsZeroMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlIsZeroMemory", Buffer, Length);
            }
            return (byte)mh$.invokeExact(Buffer, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlNormalizeSecurityDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_CHAR
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlNormalizeSecurityDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN RtlNormalizeSecurityDescriptor(PSECURITY_DESCRIPTOR *SecurityDescriptor, DWORD SecurityDescriptorLength, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, PDWORD NewSecurityDescriptorLength, BOOLEAN CheckOnly)
     * }
     */
    public static FunctionDescriptor RtlNormalizeSecurityDescriptor$descriptor() {
        return RtlNormalizeSecurityDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN RtlNormalizeSecurityDescriptor(PSECURITY_DESCRIPTOR *SecurityDescriptor, DWORD SecurityDescriptorLength, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, PDWORD NewSecurityDescriptorLength, BOOLEAN CheckOnly)
     * }
     */
    public static MethodHandle RtlNormalizeSecurityDescriptor$handle() {
        return RtlNormalizeSecurityDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN RtlNormalizeSecurityDescriptor(PSECURITY_DESCRIPTOR *SecurityDescriptor, DWORD SecurityDescriptorLength, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, PDWORD NewSecurityDescriptorLength, BOOLEAN CheckOnly)
     * }
     */
    public static MemorySegment RtlNormalizeSecurityDescriptor$address() {
        return RtlNormalizeSecurityDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN RtlNormalizeSecurityDescriptor(PSECURITY_DESCRIPTOR *SecurityDescriptor, DWORD SecurityDescriptorLength, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, PDWORD NewSecurityDescriptorLength, BOOLEAN CheckOnly)
     * }
     */
    public static byte RtlNormalizeSecurityDescriptor(MemorySegment SecurityDescriptor, int SecurityDescriptorLength, MemorySegment NewSecurityDescriptor, MemorySegment NewSecurityDescriptorLength, byte CheckOnly) {
        var mh$ = RtlNormalizeSecurityDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlNormalizeSecurityDescriptor", SecurityDescriptor, SecurityDescriptorLength, NewSecurityDescriptor, NewSecurityDescriptorLength, CheckOnly);
            }
            return (byte)mh$.invokeExact(SecurityDescriptor, SecurityDescriptorLength, NewSecurityDescriptor, NewSecurityDescriptorLength, CheckOnly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GlobalDataIdUnknown = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdUnknown = 0
     * }
     */
    public static int GlobalDataIdUnknown() {
        return GlobalDataIdUnknown;
    }
    private static final int GlobalDataIdRngSeedVersion = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdRngSeedVersion = 1
     * }
     */
    public static int GlobalDataIdRngSeedVersion() {
        return GlobalDataIdRngSeedVersion;
    }
    private static final int GlobalDataIdInterruptTime = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdInterruptTime = 2
     * }
     */
    public static int GlobalDataIdInterruptTime() {
        return GlobalDataIdInterruptTime;
    }
    private static final int GlobalDataIdTimeZoneBias = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdTimeZoneBias = 3
     * }
     */
    public static int GlobalDataIdTimeZoneBias() {
        return GlobalDataIdTimeZoneBias;
    }
    private static final int GlobalDataIdImageNumberLow = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdImageNumberLow = 4
     * }
     */
    public static int GlobalDataIdImageNumberLow() {
        return GlobalDataIdImageNumberLow;
    }
    private static final int GlobalDataIdImageNumberHigh = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdImageNumberHigh = 5
     * }
     */
    public static int GlobalDataIdImageNumberHigh() {
        return GlobalDataIdImageNumberHigh;
    }
    private static final int GlobalDataIdTimeZoneId = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdTimeZoneId = 6
     * }
     */
    public static int GlobalDataIdTimeZoneId() {
        return GlobalDataIdTimeZoneId;
    }
    private static final int GlobalDataIdNtMajorVersion = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdNtMajorVersion = 7
     * }
     */
    public static int GlobalDataIdNtMajorVersion() {
        return GlobalDataIdNtMajorVersion;
    }
    private static final int GlobalDataIdNtMinorVersion = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdNtMinorVersion = 8
     * }
     */
    public static int GlobalDataIdNtMinorVersion() {
        return GlobalDataIdNtMinorVersion;
    }
    private static final int GlobalDataIdSystemExpirationDate = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdSystemExpirationDate = 9
     * }
     */
    public static int GlobalDataIdSystemExpirationDate() {
        return GlobalDataIdSystemExpirationDate;
    }
    private static final int GlobalDataIdKdDebuggerEnabled = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdKdDebuggerEnabled = 10
     * }
     */
    public static int GlobalDataIdKdDebuggerEnabled() {
        return GlobalDataIdKdDebuggerEnabled;
    }
    private static final int GlobalDataIdCyclesPerYield = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdCyclesPerYield = 11
     * }
     */
    public static int GlobalDataIdCyclesPerYield() {
        return GlobalDataIdCyclesPerYield;
    }
    private static final int GlobalDataIdSafeBootMode = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdSafeBootMode = 12
     * }
     */
    public static int GlobalDataIdSafeBootMode() {
        return GlobalDataIdSafeBootMode;
    }
    private static final int GlobalDataIdLastSystemRITEventTickCount = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdLastSystemRITEventTickCount = 13
     * }
     */
    public static int GlobalDataIdLastSystemRITEventTickCount() {
        return GlobalDataIdLastSystemRITEventTickCount;
    }
    private static final int GlobalDataIdConsoleSharedDataFlags = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdConsoleSharedDataFlags = 14
     * }
     */
    public static int GlobalDataIdConsoleSharedDataFlags() {
        return GlobalDataIdConsoleSharedDataFlags;
    }
    private static final int GlobalDataIdNtSystemRootDrive = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdNtSystemRootDrive = 15
     * }
     */
    public static int GlobalDataIdNtSystemRootDrive() {
        return GlobalDataIdNtSystemRootDrive;
    }
    private static final int GlobalDataIdQpcBypassEnabled = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdQpcBypassEnabled = 16
     * }
     */
    public static int GlobalDataIdQpcBypassEnabled() {
        return GlobalDataIdQpcBypassEnabled;
    }
    private static final int GlobalDataIdQpcData = (int)17L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdQpcData = 17
     * }
     */
    public static int GlobalDataIdQpcData() {
        return GlobalDataIdQpcData;
    }
    private static final int GlobalDataIdQpcBias = (int)18L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdQpcBias = 18
     * }
     */
    public static int GlobalDataIdQpcBias() {
        return GlobalDataIdQpcBias;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _RTL_SYSTEM_GLOBAL_DATA_ID {
     *     GlobalDataIdUnknown = 0,
     *     GlobalDataIdRngSeedVersion,
     *     GlobalDataIdInterruptTime,
     *     GlobalDataIdTimeZoneBias,
     *     GlobalDataIdImageNumberLow,
     *     GlobalDataIdImageNumberHigh,
     *     GlobalDataIdTimeZoneId,
     *     GlobalDataIdNtMajorVersion,
     *     GlobalDataIdNtMinorVersion,
     *     GlobalDataIdSystemExpirationDate,
     *     GlobalDataIdKdDebuggerEnabled,
     *     GlobalDataIdCyclesPerYield,
     *     GlobalDataIdSafeBootMode,
     *     GlobalDataIdLastSystemRITEventTickCount,
     *     GlobalDataIdConsoleSharedDataFlags,
     *     GlobalDataIdNtSystemRootDrive,
     *     GlobalDataIdQpcBypassEnabled,
     *     GlobalDataIdQpcData,
     *     GlobalDataIdQpcBias
     * } *PRTL_SYSTEM_GLOBAL_DATA_ID
     * }
     */
    public static final AddressLayout PRTL_SYSTEM_GLOBAL_DATA_ID = winapi.C_POINTER;

    private static class RtlGetSystemGlobalData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlGetSystemGlobalData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlGetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static FunctionDescriptor RtlGetSystemGlobalData$descriptor() {
        return RtlGetSystemGlobalData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlGetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static MethodHandle RtlGetSystemGlobalData$handle() {
        return RtlGetSystemGlobalData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlGetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static MemorySegment RtlGetSystemGlobalData$address() {
        return RtlGetSystemGlobalData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlGetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static int RtlGetSystemGlobalData(int DataId, MemorySegment Buffer, int Size) {
        var mh$ = RtlGetSystemGlobalData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlGetSystemGlobalData", DataId, Buffer, Size);
            }
            return (int)mh$.invokeExact(DataId, Buffer, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlSetSystemGlobalData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlSetSystemGlobalData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlSetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static FunctionDescriptor RtlSetSystemGlobalData$descriptor() {
        return RtlSetSystemGlobalData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlSetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static MethodHandle RtlSetSystemGlobalData$handle() {
        return RtlSetSystemGlobalData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlSetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static MemorySegment RtlSetSystemGlobalData$address() {
        return RtlSetSystemGlobalData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlSetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static int RtlSetSystemGlobalData(int DataId, MemorySegment Buffer, int Size) {
        var mh$ = RtlSetSystemGlobalData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlSetSystemGlobalData", DataId, Buffer, Size);
            }
            return (int)mh$.invokeExact(DataId, Buffer, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_CRITICAL_SECTION_DEBUG {
     *     WORD Type;
     *     WORD CreatorBackTraceIndex;
     *     struct _RTL_CRITICAL_SECTION *CriticalSection;
     *     LIST_ENTRY ProcessLocksList;
     *     DWORD EntryCount;
     *     DWORD ContentionCount;
     *     DWORD Flags;
     *     WORD CreatorBackTraceIndexHigh;
     *     WORD Identifier;
     * } *PRTL_CRITICAL_SECTION_DEBUG
     * }
     */
    public static final AddressLayout PRTL_CRITICAL_SECTION_DEBUG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_CRITICAL_SECTION_DEBUG {
     *     WORD Type;
     *     WORD CreatorBackTraceIndex;
     *     struct _RTL_CRITICAL_SECTION *CriticalSection;
     *     LIST_ENTRY ProcessLocksList;
     *     DWORD EntryCount;
     *     DWORD ContentionCount;
     *     DWORD Flags;
     *     WORD CreatorBackTraceIndexHigh;
     *     WORD Identifier;
     * } *PRTL_RESOURCE_DEBUG
     * }
     */
    public static final AddressLayout PRTL_RESOURCE_DEBUG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_CRITICAL_SECTION {
     *     PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
     *     LONG LockCount;
     *     LONG RecursionCount;
     *     HANDLE OwningThread;
     *     HANDLE LockSemaphore;
     *     ULONG_PTR SpinCount;
     * } *PRTL_CRITICAL_SECTION
     * }
     */
    public static final AddressLayout PRTL_CRITICAL_SECTION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_SRWLOCK {
     *     PVOID Ptr;
     * } *PRTL_SRWLOCK
     * }
     */
    public static final AddressLayout PRTL_SRWLOCK = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_CONDITION_VARIABLE {
     *     PVOID Ptr;
     * } *PRTL_CONDITION_VARIABLE
     * }
     */
    public static final AddressLayout PRTL_CONDITION_VARIABLE = winapi.C_POINTER;
    private static final int HeapCompatibilityInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _HEAP_INFORMATION_CLASS.HeapCompatibilityInformation = 0
     * }
     */
    public static int HeapCompatibilityInformation() {
        return HeapCompatibilityInformation;
    }
    private static final int HeapEnableTerminationOnCorruption = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _HEAP_INFORMATION_CLASS.HeapEnableTerminationOnCorruption = 1
     * }
     */
    public static int HeapEnableTerminationOnCorruption() {
        return HeapEnableTerminationOnCorruption;
    }
    private static final int HeapOptimizeResources = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _HEAP_INFORMATION_CLASS.HeapOptimizeResources = 3
     * }
     */
    public static int HeapOptimizeResources() {
        return HeapOptimizeResources;
    }
    private static final int HeapTag = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _HEAP_INFORMATION_CLASS.HeapTag = 7
     * }
     */
    public static int HeapTag() {
        return HeapTag;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _HEAP_OPTIMIZE_RESOURCES_INFORMATION {
     *     DWORD Version;
     *     DWORD Flags;
     * } *PHEAP_OPTIMIZE_RESOURCES_INFORMATION
     * }
     */
    public static final AddressLayout PHEAP_OPTIMIZE_RESOURCES_INFORMATION = winapi.C_POINTER;
    private static final int ActivationContextBasicInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextBasicInformation = 1
     * }
     */
    public static int ActivationContextBasicInformation() {
        return ActivationContextBasicInformation;
    }
    private static final int ActivationContextDetailedInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextDetailedInformation = 2
     * }
     */
    public static int ActivationContextDetailedInformation() {
        return ActivationContextDetailedInformation;
    }
    private static final int AssemblyDetailedInformationInActivationContext = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContext = 3
     * }
     */
    public static int AssemblyDetailedInformationInActivationContext() {
        return AssemblyDetailedInformationInActivationContext;
    }
    private static final int FileInformationInAssemblyOfAssemblyInActivationContext = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContext = 4
     * }
     */
    public static int FileInformationInAssemblyOfAssemblyInActivationContext() {
        return FileInformationInAssemblyOfAssemblyInActivationContext;
    }
    private static final int RunlevelInformationInActivationContext = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.RunlevelInformationInActivationContext = 5
     * }
     */
    public static int RunlevelInformationInActivationContext() {
        return RunlevelInformationInActivationContext;
    }
    private static final int CompatibilityInformationInActivationContext = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.CompatibilityInformationInActivationContext = 6
     * }
     */
    public static int CompatibilityInformationInActivationContext() {
        return CompatibilityInformationInActivationContext;
    }
    private static final int ActivationContextManifestResourceName = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextManifestResourceName = 7
     * }
     */
    public static int ActivationContextManifestResourceName() {
        return ActivationContextManifestResourceName;
    }
    private static final int MaxActivationContextInfoClass = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.MaxActivationContextInfoClass = 8
     * }
     */
    public static int MaxActivationContextInfoClass() {
        return MaxActivationContextInfoClass;
    }
    private static final int AssemblyDetailedInformationInActivationContxt = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContxt = 3
     * }
     */
    public static int AssemblyDetailedInformationInActivationContxt() {
        return AssemblyDetailedInformationInActivationContxt;
    }
    private static final int FileInformationInAssemblyOfAssemblyInActivationContxt = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContxt = 4
     * }
     */
    public static int FileInformationInAssemblyOfAssemblyInActivationContxt() {
        return FileInformationInAssemblyOfAssemblyInActivationContxt;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
     *     DWORD ulAssemblyIndex;
     *     DWORD ulFileIndexInAssembly;
     * } *PACTIVATION_CONTEXT_QUERY_INDEX
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_QUERY_INDEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX {
     *     DWORD ulAssemblyIndex;
     *     DWORD ulFileIndexInAssembly;
     * } *PCACTIVATION_CONTEXT_QUERY_INDEX
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_QUERY_INDEX = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
     *     DWORD ulFlags;
     *     DWORD ulFilenameLength;
     *     DWORD ulPathLength;
     *     PCWSTR lpFileName;
     *     PCWSTR lpFilePath;
     * } *PASSEMBLY_FILE_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PASSEMBLY_FILE_DETAILED_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PCASSEMBLY_FILE_DETAILED_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
     *     DWORD ulFlags;
     *     DWORD ulEncodedAssemblyIdentityLength;
     *     DWORD ulManifestPathType;
     *     DWORD ulManifestPathLength;
     *     LARGE_INTEGER liManifestLastWriteTime;
     *     DWORD ulPolicyPathType;
     *     DWORD ulPolicyPathLength;
     *     LARGE_INTEGER liPolicyLastWriteTime;
     *     DWORD ulMetadataSatelliteRosterIndex;
     *     DWORD ulManifestVersionMajor;
     *     DWORD ulManifestVersionMinor;
     *     DWORD ulPolicyVersionMajor;
     *     DWORD ulPolicyVersionMinor;
     *     DWORD ulAssemblyDirectoryNameLength;
     *     PCWSTR lpAssemblyEncodedAssemblyIdentity;
     *     PCWSTR lpAssemblyManifestPath;
     *     PCWSTR lpAssemblyPolicyPath;
     *     PCWSTR lpAssemblyDirectoryName;
     *     DWORD ulFileCount;
     * } *PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
     *     DWORD ulFlags;
     *     DWORD ulEncodedAssemblyIdentityLength;
     *     DWORD ulManifestPathType;
     *     DWORD ulManifestPathLength;
     *     LARGE_INTEGER liManifestLastWriteTime;
     *     DWORD ulPolicyPathType;
     *     DWORD ulPolicyPathLength;
     *     LARGE_INTEGER liPolicyLastWriteTime;
     *     DWORD ulMetadataSatelliteRosterIndex;
     *     DWORD ulManifestVersionMajor;
     *     DWORD ulManifestVersionMinor;
     *     DWORD ulPolicyVersionMajor;
     *     DWORD ulPolicyVersionMinor;
     *     DWORD ulAssemblyDirectoryNameLength;
     *     PCWSTR lpAssemblyEncodedAssemblyIdentity;
     *     PCWSTR lpAssemblyManifestPath;
     *     PCWSTR lpAssemblyPolicyPath;
     *     PCWSTR lpAssemblyDirectoryName;
     *     DWORD ulFileCount;
     * } *PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = winapi.C_POINTER;
    private static final int ACTCTX_RUN_LEVEL_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_UNSPECIFIED = 0
     * }
     */
    public static int ACTCTX_RUN_LEVEL_UNSPECIFIED() {
        return ACTCTX_RUN_LEVEL_UNSPECIFIED;
    }
    private static final int ACTCTX_RUN_LEVEL_AS_INVOKER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_AS_INVOKER = 1
     * }
     */
    public static int ACTCTX_RUN_LEVEL_AS_INVOKER() {
        return ACTCTX_RUN_LEVEL_AS_INVOKER;
    }
    private static final int ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2
     * }
     */
    public static int ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE() {
        return ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE;
    }
    private static final int ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = 3
     * }
     */
    public static int ACTCTX_RUN_LEVEL_REQUIRE_ADMIN() {
        return ACTCTX_RUN_LEVEL_REQUIRE_ADMIN;
    }
    private static final int ACTCTX_RUN_LEVEL_NUMBERS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_NUMBERS = 4
     * }
     */
    public static int ACTCTX_RUN_LEVEL_NUMBERS() {
        return ACTCTX_RUN_LEVEL_NUMBERS;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
     *     DWORD ulFlags;
     *     ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
     *     DWORD UiAccess;
     * } *PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
     *     DWORD ulFlags;
     *     ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
     *     DWORD UiAccess;
     * } *PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = winapi.C_POINTER;
    private static final int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0
     * }
     */
    public static int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN() {
        return ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN;
    }
    private static final int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = 1
     * }
     */
    public static int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS() {
        return ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS;
    }
    private static final int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2
     * }
     */
    public static int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION() {
        return ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION;
    }
    private static final int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = 3
     * }
     */
    public static int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED() {
        return ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
     *     GUID Id;
     *     ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
     *     ULONGLONG MaxVersionTested;
     * } *PCOMPATIBILITY_CONTEXT_ELEMENT
     * }
     */
    public static final AddressLayout PCOMPATIBILITY_CONTEXT_ELEMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT {
     *     GUID Id;
     *     ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
     *     ULONGLONG MaxVersionTested;
     * } *PCCOMPATIBILITY_CONTEXT_ELEMENT
     * }
     */
    public static final AddressLayout PCCOMPATIBILITY_CONTEXT_ELEMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
     *     DWORD ElementCount;
     *     COMPATIBILITY_CONTEXT_ELEMENT Elements[];
     * } *PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
     *     DWORD ElementCount;
     *     COMPATIBILITY_CONTEXT_ELEMENT Elements[];
     * } *PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SUPPORTED_OS_INFO {
     *     WORD MajorVersion;
     *     WORD MinorVersion;
     * } *PSUPPORTED_OS_INFO
     * }
     */
    public static final AddressLayout PSUPPORTED_OS_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MAXVERSIONTESTED_INFO {
     *     ULONGLONG MaxVersionTested;
     * } *PMAXVERSIONTESTED_INFO
     * }
     */
    public static final AddressLayout PMAXVERSIONTESTED_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
     *     DWORD dwFlags;
     *     DWORD ulFormatVersion;
     *     DWORD ulAssemblyCount;
     *     DWORD ulRootManifestPathType;
     *     DWORD ulRootManifestPathChars;
     *     DWORD ulRootConfigurationPathType;
     *     DWORD ulRootConfigurationPathChars;
     *     DWORD ulAppDirPathType;
     *     DWORD ulAppDirPathChars;
     *     PCWSTR lpRootManifestPath;
     *     PCWSTR lpRootConfigurationPath;
     *     PCWSTR lpAppDirPath;
     * } *PACTIVATION_CONTEXT_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_DETAILED_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
     *     DWORD dwFlags;
     *     DWORD ulFormatVersion;
     *     DWORD ulAssemblyCount;
     *     DWORD ulRootManifestPathType;
     *     DWORD ulRootManifestPathChars;
     *     DWORD ulRootConfigurationPathType;
     *     DWORD ulRootConfigurationPathChars;
     *     DWORD ulAppDirPathType;
     *     DWORD ulAppDirPathChars;
     *     PCWSTR lpRootManifestPath;
     *     PCWSTR lpRootConfigurationPath;
     *     PCWSTR lpAppDirPath;
     * } *PCACTIVATION_CONTEXT_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_DETAILED_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _HARDWARE_COUNTER_DATA {
     *     HARDWARE_COUNTER_TYPE Type;
     *     DWORD Reserved;
     *     DWORD64 Value;
     * } *PHARDWARE_COUNTER_DATA
     * }
     */
    public static final AddressLayout PHARDWARE_COUNTER_DATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERFORMANCE_DATA {
     *     WORD Size;
     *     BYTE Version;
     *     BYTE HwCountersCount;
     *     DWORD ContextSwitchCount;
     *     DWORD64 WaitReasonBitMap;
     *     DWORD64 CycleTime;
     *     DWORD RetryCount;
     *     DWORD Reserved;
     *     HARDWARE_COUNTER_DATA HwCounters[16];
     * } *PPERFORMANCE_DATA
     * }
     */
    public static final AddressLayout PPERFORMANCE_DATA = winapi.C_POINTER;

    private static class RtlGetDeviceFamilyInfoEnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlGetDeviceFamilyInfoEnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlGetDeviceFamilyInfoEnum(ULONGLONG *pullUAPInfo, DWORD *pulDeviceFamily, DWORD *pulDeviceForm)
     * }
     */
    public static FunctionDescriptor RtlGetDeviceFamilyInfoEnum$descriptor() {
        return RtlGetDeviceFamilyInfoEnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlGetDeviceFamilyInfoEnum(ULONGLONG *pullUAPInfo, DWORD *pulDeviceFamily, DWORD *pulDeviceForm)
     * }
     */
    public static MethodHandle RtlGetDeviceFamilyInfoEnum$handle() {
        return RtlGetDeviceFamilyInfoEnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RtlGetDeviceFamilyInfoEnum(ULONGLONG *pullUAPInfo, DWORD *pulDeviceFamily, DWORD *pulDeviceForm)
     * }
     */
    public static MemorySegment RtlGetDeviceFamilyInfoEnum$address() {
        return RtlGetDeviceFamilyInfoEnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RtlGetDeviceFamilyInfoEnum(ULONGLONG *pullUAPInfo, DWORD *pulDeviceFamily, DWORD *pulDeviceForm)
     * }
     */
    public static void RtlGetDeviceFamilyInfoEnum(MemorySegment pullUAPInfo, MemorySegment pulDeviceFamily, MemorySegment pulDeviceForm) {
        var mh$ = RtlGetDeviceFamilyInfoEnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlGetDeviceFamilyInfoEnum", pullUAPInfo, pulDeviceFamily, pulDeviceForm);
            }
            mh$.invokeExact(pullUAPInfo, pulDeviceFamily, pulDeviceForm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlConvertDeviceFamilyInfoToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlConvertDeviceFamilyInfoToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlConvertDeviceFamilyInfoToString(PDWORD pulDeviceFamilyBufferSize, PDWORD pulDeviceFormBufferSize, PWSTR DeviceFamily, PWSTR DeviceForm)
     * }
     */
    public static FunctionDescriptor RtlConvertDeviceFamilyInfoToString$descriptor() {
        return RtlConvertDeviceFamilyInfoToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlConvertDeviceFamilyInfoToString(PDWORD pulDeviceFamilyBufferSize, PDWORD pulDeviceFormBufferSize, PWSTR DeviceFamily, PWSTR DeviceForm)
     * }
     */
    public static MethodHandle RtlConvertDeviceFamilyInfoToString$handle() {
        return RtlConvertDeviceFamilyInfoToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlConvertDeviceFamilyInfoToString(PDWORD pulDeviceFamilyBufferSize, PDWORD pulDeviceFormBufferSize, PWSTR DeviceFamily, PWSTR DeviceForm)
     * }
     */
    public static MemorySegment RtlConvertDeviceFamilyInfoToString$address() {
        return RtlConvertDeviceFamilyInfoToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlConvertDeviceFamilyInfoToString(PDWORD pulDeviceFamilyBufferSize, PDWORD pulDeviceFormBufferSize, PWSTR DeviceFamily, PWSTR DeviceForm)
     * }
     */
    public static int RtlConvertDeviceFamilyInfoToString(MemorySegment pulDeviceFamilyBufferSize, MemorySegment pulDeviceFormBufferSize, MemorySegment DeviceFamily, MemorySegment DeviceForm) {
        var mh$ = RtlConvertDeviceFamilyInfoToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlConvertDeviceFamilyInfoToString", pulDeviceFamilyBufferSize, pulDeviceFormBufferSize, DeviceFamily, DeviceForm);
            }
            return (int)mh$.invokeExact(pulDeviceFamilyBufferSize, pulDeviceFormBufferSize, DeviceFamily, DeviceForm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlSwitchedVVI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RtlSwitchedVVI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlSwitchedVVI(PRTL_OSVERSIONINFOEXW VersionInfo, DWORD TypeMask, ULONGLONG ConditionMask)
     * }
     */
    public static FunctionDescriptor RtlSwitchedVVI$descriptor() {
        return RtlSwitchedVVI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlSwitchedVVI(PRTL_OSVERSIONINFOEXW VersionInfo, DWORD TypeMask, ULONGLONG ConditionMask)
     * }
     */
    public static MethodHandle RtlSwitchedVVI$handle() {
        return RtlSwitchedVVI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RtlSwitchedVVI(PRTL_OSVERSIONINFOEXW VersionInfo, DWORD TypeMask, ULONGLONG ConditionMask)
     * }
     */
    public static MemorySegment RtlSwitchedVVI$address() {
        return RtlSwitchedVVI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RtlSwitchedVVI(PRTL_OSVERSIONINFOEXW VersionInfo, DWORD TypeMask, ULONGLONG ConditionMask)
     * }
     */
    public static int RtlSwitchedVVI(MemorySegment VersionInfo, int TypeMask, long ConditionMask) {
        var mh$ = RtlSwitchedVVI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlSwitchedVVI", VersionInfo, TypeMask, ConditionMask);
            }
            return (int)mh$.invokeExact(VersionInfo, TypeMask, ConditionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _EVENTLOGRECORD {
     *     DWORD Length;
     *     DWORD Reserved;
     *     DWORD RecordNumber;
     *     DWORD TimeGenerated;
     *     DWORD TimeWritten;
     *     DWORD EventID;
     *     WORD EventType;
     *     WORD NumStrings;
     *     WORD EventCategory;
     *     WORD ReservedFlags;
     *     DWORD ClosingRecordNumber;
     *     DWORD StringOffset;
     *     DWORD UserSidLength;
     *     DWORD UserSidOffset;
     *     DWORD DataLength;
     *     DWORD DataOffset;
     * } *PEVENTLOGRECORD
     * }
     */
    public static final AddressLayout PEVENTLOGRECORD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EVENTSFORLOGFILE {
     *     DWORD ulSize;
     *     WCHAR szLogicalLogFile[256];
     *     DWORD ulNumRecords;
     *     EVENTLOGRECORD pEventLogRecords[];
     * } *PEVENTSFORLOGFILE
     * }
     */
    public static final AddressLayout PEVENTSFORLOGFILE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PACKEDEVENTINFO {
     *     DWORD ulSize;
     *     DWORD ulNumEventsForLogFile;
     *     DWORD ulOffsets[];
     * } *PPACKEDEVENTINFO
     * }
     */
    public static final AddressLayout PPACKEDEVENTINFO = winapi.C_POINTER;
    private static final int DriverType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.DriverType = 1
     * }
     */
    public static int DriverType() {
        return DriverType;
    }
    private static final int FileSystemType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.FileSystemType = 2
     * }
     */
    public static int FileSystemType() {
        return FileSystemType;
    }
    private static final int Win32ServiceOwnProcess = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.Win32ServiceOwnProcess = 16
     * }
     */
    public static int Win32ServiceOwnProcess() {
        return Win32ServiceOwnProcess;
    }
    private static final int Win32ServiceShareProcess = (int)32L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.Win32ServiceShareProcess = 32
     * }
     */
    public static int Win32ServiceShareProcess() {
        return Win32ServiceShareProcess;
    }
    private static final int AdapterType = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.AdapterType = 4
     * }
     */
    public static int AdapterType() {
        return AdapterType;
    }
    private static final int RecognizerType = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.RecognizerType = 8
     * }
     */
    public static int RecognizerType() {
        return RecognizerType;
    }
    private static final int BootLoad = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.BootLoad = 0
     * }
     */
    public static int BootLoad() {
        return BootLoad;
    }
    private static final int SystemLoad = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.SystemLoad = 1
     * }
     */
    public static int SystemLoad() {
        return SystemLoad;
    }
    private static final int AutoLoad = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.AutoLoad = 2
     * }
     */
    public static int AutoLoad() {
        return AutoLoad;
    }
    private static final int DemandLoad = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.DemandLoad = 3
     * }
     */
    public static int DemandLoad() {
        return DemandLoad;
    }
    private static final int DisableLoad = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.DisableLoad = 4
     * }
     */
    public static int DisableLoad() {
        return DisableLoad;
    }
    private static final int IgnoreError = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _CM_ERROR_CONTROL_TYPE.IgnoreError = 0
     * }
     */
    public static int IgnoreError() {
        return IgnoreError;
    }
    private static final int NormalError = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _CM_ERROR_CONTROL_TYPE.NormalError = 1
     * }
     */
    public static int NormalError() {
        return NormalError;
    }
    private static final int SevereError = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _CM_ERROR_CONTROL_TYPE.SevereError = 2
     * }
     */
    public static int SevereError() {
        return SevereError;
    }
    private static final int CriticalError = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _CM_ERROR_CONTROL_TYPE.CriticalError = 3
     * }
     */
    public static int CriticalError() {
        return CriticalError;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_ERASE {
     *     DWORD Type;
     *     BOOLEAN Immediate;
     * } *PTAPE_ERASE
     * }
     */
    public static final AddressLayout PTAPE_ERASE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_PREPARE {
     *     DWORD Operation;
     *     BOOLEAN Immediate;
     * } *PTAPE_PREPARE
     * }
     */
    public static final AddressLayout PTAPE_PREPARE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_WRITE_MARKS {
     *     DWORD Type;
     *     DWORD Count;
     *     BOOLEAN Immediate;
     * } *PTAPE_WRITE_MARKS
     * }
     */
    public static final AddressLayout PTAPE_WRITE_MARKS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_GET_POSITION {
     *     DWORD Type;
     *     DWORD Partition;
     *     LARGE_INTEGER Offset;
     * } *PTAPE_GET_POSITION
     * }
     */
    public static final AddressLayout PTAPE_GET_POSITION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_SET_POSITION {
     *     DWORD Method;
     *     DWORD Partition;
     *     LARGE_INTEGER Offset;
     *     BOOLEAN Immediate;
     * } *PTAPE_SET_POSITION
     * }
     */
    public static final AddressLayout PTAPE_SET_POSITION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_GET_DRIVE_PARAMETERS {
     *     BOOLEAN ECC;
     *     BOOLEAN Compression;
     *     BOOLEAN DataPadding;
     *     BOOLEAN ReportSetmarks;
     *     DWORD DefaultBlockSize;
     *     DWORD MaximumBlockSize;
     *     DWORD MinimumBlockSize;
     *     DWORD MaximumPartitionCount;
     *     DWORD FeaturesLow;
     *     DWORD FeaturesHigh;
     *     DWORD EOTWarningZoneSize;
     * } *PTAPE_GET_DRIVE_PARAMETERS
     * }
     */
    public static final AddressLayout PTAPE_GET_DRIVE_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_SET_DRIVE_PARAMETERS {
     *     BOOLEAN ECC;
     *     BOOLEAN Compression;
     *     BOOLEAN DataPadding;
     *     BOOLEAN ReportSetmarks;
     *     DWORD EOTWarningZoneSize;
     * } *PTAPE_SET_DRIVE_PARAMETERS
     * }
     */
    public static final AddressLayout PTAPE_SET_DRIVE_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_GET_MEDIA_PARAMETERS {
     *     LARGE_INTEGER Capacity;
     *     LARGE_INTEGER Remaining;
     *     DWORD BlockSize;
     *     DWORD PartitionCount;
     *     BOOLEAN WriteProtected;
     * } *PTAPE_GET_MEDIA_PARAMETERS
     * }
     */
    public static final AddressLayout PTAPE_GET_MEDIA_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_SET_MEDIA_PARAMETERS {
     *     DWORD BlockSize;
     * } *PTAPE_SET_MEDIA_PARAMETERS
     * }
     */
    public static final AddressLayout PTAPE_SET_MEDIA_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_CREATE_PARTITION {
     *     DWORD Method;
     *     DWORD Count;
     *     DWORD Size;
     * } *PTAPE_CREATE_PARTITION
     * }
     */
    public static final AddressLayout PTAPE_CREATE_PARTITION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_WMI_OPERATIONS {
     *     DWORD Method;
     *     DWORD DataBufferSize;
     *     PVOID DataBuffer;
     * } *PTAPE_WMI_OPERATIONS
     * }
     */
    public static final AddressLayout PTAPE_WMI_OPERATIONS = winapi.C_POINTER;
    private static final int TapeDriveProblemNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveProblemNone = 0
     * }
     */
    public static int TapeDriveProblemNone() {
        return TapeDriveProblemNone;
    }
    private static final int TapeDriveReadWriteWarning = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWriteWarning = 1
     * }
     */
    public static int TapeDriveReadWriteWarning() {
        return TapeDriveReadWriteWarning;
    }
    private static final int TapeDriveReadWriteError = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWriteError = 2
     * }
     */
    public static int TapeDriveReadWriteError() {
        return TapeDriveReadWriteError;
    }
    private static final int TapeDriveReadWarning = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWarning = 3
     * }
     */
    public static int TapeDriveReadWarning() {
        return TapeDriveReadWarning;
    }
    private static final int TapeDriveWriteWarning = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveWriteWarning = 4
     * }
     */
    public static int TapeDriveWriteWarning() {
        return TapeDriveWriteWarning;
    }
    private static final int TapeDriveReadError = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadError = 5
     * }
     */
    public static int TapeDriveReadError() {
        return TapeDriveReadError;
    }
    private static final int TapeDriveWriteError = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveWriteError = 6
     * }
     */
    public static int TapeDriveWriteError() {
        return TapeDriveWriteError;
    }
    private static final int TapeDriveHardwareError = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveHardwareError = 7
     * }
     */
    public static int TapeDriveHardwareError() {
        return TapeDriveHardwareError;
    }
    private static final int TapeDriveUnsupportedMedia = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveUnsupportedMedia = 8
     * }
     */
    public static int TapeDriveUnsupportedMedia() {
        return TapeDriveUnsupportedMedia;
    }
    private static final int TapeDriveScsiConnectionError = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveScsiConnectionError = 9
     * }
     */
    public static int TapeDriveScsiConnectionError() {
        return TapeDriveScsiConnectionError;
    }
    private static final int TapeDriveTimetoClean = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveTimetoClean = 10
     * }
     */
    public static int TapeDriveTimetoClean() {
        return TapeDriveTimetoClean;
    }
    private static final int TapeDriveCleanDriveNow = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveCleanDriveNow = 11
     * }
     */
    public static int TapeDriveCleanDriveNow() {
        return TapeDriveCleanDriveNow;
    }
    private static final int TapeDriveMediaLifeExpired = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveMediaLifeExpired = 12
     * }
     */
    public static int TapeDriveMediaLifeExpired() {
        return TapeDriveMediaLifeExpired;
    }
    private static final int TapeDriveSnappedTape = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveSnappedTape = 13
     * }
     */
    public static int TapeDriveSnappedTape() {
        return TapeDriveSnappedTape;
    }
    /**
     * {@snippet lang=c :
     * typedef GUID *PUOW
     * }
     */
    public static final AddressLayout PUOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GUID *PCRM_PROTOCOL_ID
     * }
     */
    public static final AddressLayout PCRM_PROTOCOL_ID = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG NOTIFICATION_MASK
     * }
     */
    public static final OfInt NOTIFICATION_MASK = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION {
     *     PVOID TransactionKey;
     *     ULONG TransactionNotification;
     *     LARGE_INTEGER TmVirtualClock;
     *     ULONG ArgumentLength;
     * } *PTRANSACTION_NOTIFICATION
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
     *     GUID EnlistmentId;
     *     UOW UOW;
     * } *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
     *     GUID TmIdentity;
     *     ULONG Flags;
     * } *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG SAVEPOINT_ID
     * }
     */
    public static final OfInt SAVEPOINT_ID = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG *PSAVEPOINT_ID
     * }
     */
    public static final AddressLayout PSAVEPOINT_ID = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
     *     SAVEPOINT_ID SavepointId;
     * } *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
     *     ULONG PropagationCookie;
     *     GUID UOW;
     *     GUID TmIdentity;
     *     ULONG BufferLength;
     * } *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
     *     ULONG MarshalCookie;
     *     GUID UOW;
     * } *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_MARSHAL_HEADER {
     *     ULONG VersionMajor;
     *     ULONG VersionMinor;
     *     ULONG NumProtocols;
     *     ULONG Unused;
     * } *PKCRM_MARSHAL_HEADER
     * }
     */
    public static final AddressLayout PKCRM_MARSHAL_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_MARSHAL_HEADER {
     *     ULONG VersionMajor;
     *     ULONG VersionMinor;
     *     ULONG NumProtocols;
     *     ULONG Unused;
     * } *PRKCRM_MARSHAL_HEADER
     * }
     */
    public static final AddressLayout PRKCRM_MARSHAL_HEADER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_TRANSACTION_BLOB {
     *     UOW UOW;
     *     GUID TmIdentity;
     *     ULONG IsolationLevel;
     *     ULONG IsolationFlags;
     *     ULONG Timeout;
     *     WCHAR Description[64];
     * } *PKCRM_TRANSACTION_BLOB
     * }
     */
    public static final AddressLayout PKCRM_TRANSACTION_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_TRANSACTION_BLOB {
     *     UOW UOW;
     *     GUID TmIdentity;
     *     ULONG IsolationLevel;
     *     ULONG IsolationFlags;
     *     ULONG Timeout;
     *     WCHAR Description[64];
     * } *PRKCRM_TRANSACTION_BLOB
     * }
     */
    public static final AddressLayout PRKCRM_TRANSACTION_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_PROTOCOL_BLOB {
     *     CRM_PROTOCOL_ID ProtocolId;
     *     ULONG StaticInfoLength;
     *     ULONG TransactionIdInfoLength;
     *     ULONG Unused1;
     *     ULONG Unused2;
     * } *PKCRM_PROTOCOL_BLOB
     * }
     */
    public static final AddressLayout PKCRM_PROTOCOL_BLOB = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_PROTOCOL_BLOB {
     *     CRM_PROTOCOL_ID ProtocolId;
     *     ULONG StaticInfoLength;
     *     ULONG TransactionIdInfoLength;
     *     ULONG Unused1;
     *     ULONG Unused2;
     * } *PRKCRM_PROTOCOL_BLOB
     * }
     */
    public static final AddressLayout PRKCRM_PROTOCOL_BLOB = winapi.C_POINTER;
    private static final int TransactionOutcomeUndetermined = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_OUTCOME.TransactionOutcomeUndetermined = 1
     * }
     */
    public static int TransactionOutcomeUndetermined() {
        return TransactionOutcomeUndetermined;
    }
    private static final int TransactionOutcomeCommitted = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_OUTCOME.TransactionOutcomeCommitted = 2
     * }
     */
    public static int TransactionOutcomeCommitted() {
        return TransactionOutcomeCommitted;
    }
    private static final int TransactionOutcomeAborted = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_OUTCOME.TransactionOutcomeAborted = 3
     * }
     */
    public static int TransactionOutcomeAborted() {
        return TransactionOutcomeAborted;
    }
    private static final int TransactionStateNormal = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_STATE.TransactionStateNormal = 1
     * }
     */
    public static int TransactionStateNormal() {
        return TransactionStateNormal;
    }
    private static final int TransactionStateIndoubt = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_STATE.TransactionStateIndoubt = 2
     * }
     */
    public static int TransactionStateIndoubt() {
        return TransactionStateIndoubt;
    }
    private static final int TransactionStateCommittedNotify = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_STATE.TransactionStateCommittedNotify = 3
     * }
     */
    public static int TransactionStateCommittedNotify() {
        return TransactionStateCommittedNotify;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_BASIC_INFORMATION {
     *     GUID TransactionId;
     *     DWORD State;
     *     DWORD Outcome;
     * } *PTRANSACTION_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_BASIC_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
     *     GUID TmIdentity;
     *     LARGE_INTEGER VirtualClock;
     * } *PTRANSACTIONMANAGER_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_BASIC_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
     *     GUID LogIdentity;
     * } *PTRANSACTIONMANAGER_LOG_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_LOG_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
     *     DWORD LogPathLength;
     *     WCHAR LogPath[1];
     * } *PTRANSACTIONMANAGER_LOGPATH_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_LOGPATH_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
     *     ULONGLONG LastRecoveredLsn;
     * } *PTRANSACTIONMANAGER_RECOVERY_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_RECOVERY_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
     *     GUID OldestTransactionGuid;
     * } *PTRANSACTIONMANAGER_OLDEST_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_OLDEST_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
     *     DWORD IsolationLevel;
     *     DWORD IsolationFlags;
     *     LARGE_INTEGER Timeout;
     *     DWORD Outcome;
     *     DWORD DescriptionLength;
     *     WCHAR Description[1];
     * } *PTRANSACTION_PROPERTIES_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_PROPERTIES_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_BIND_INFORMATION {
     *     HANDLE TmHandle;
     * } *PTRANSACTION_BIND_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_BIND_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_ENLISTMENT_PAIR {
     *     GUID EnlistmentId;
     *     GUID ResourceManagerId;
     * } *PTRANSACTION_ENLISTMENT_PAIR
     * }
     */
    public static final AddressLayout PTRANSACTION_ENLISTMENT_PAIR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
     *     DWORD NumberOfEnlistments;
     *     TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1];
     * } *PTRANSACTION_ENLISTMENTS_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_ENLISTMENTS_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
     *     TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
     * } *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
     *     GUID ResourceManagerId;
     *     DWORD DescriptionLength;
     *     WCHAR Description[1];
     * } *PRESOURCEMANAGER_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PRESOURCEMANAGER_BASIC_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
     *     HANDLE IoCompletionPortHandle;
     *     ULONG_PTR CompletionKey;
     * } *PRESOURCEMANAGER_COMPLETION_INFORMATION
     * }
     */
    public static final AddressLayout PRESOURCEMANAGER_COMPLETION_INFORMATION = winapi.C_POINTER;
    private static final int TransactionBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionBasicInformation = 0
     * }
     */
    public static int TransactionBasicInformation() {
        return TransactionBasicInformation;
    }
    private static final int TransactionPropertiesInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionPropertiesInformation = 1
     * }
     */
    public static int TransactionPropertiesInformation() {
        return TransactionPropertiesInformation;
    }
    private static final int TransactionEnlistmentInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionEnlistmentInformation = 2
     * }
     */
    public static int TransactionEnlistmentInformation() {
        return TransactionEnlistmentInformation;
    }
    private static final int TransactionSuperiorEnlistmentInformation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionSuperiorEnlistmentInformation = 3
     * }
     */
    public static int TransactionSuperiorEnlistmentInformation() {
        return TransactionSuperiorEnlistmentInformation;
    }
    private static final int TransactionBindInformation = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionBindInformation = 4
     * }
     */
    public static int TransactionBindInformation() {
        return TransactionBindInformation;
    }
    private static final int TransactionDTCPrivateInformation = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionDTCPrivateInformation = 5
     * }
     */
    public static int TransactionDTCPrivateInformation() {
        return TransactionDTCPrivateInformation;
    }
    private static final int TransactionManagerBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerBasicInformation = 0
     * }
     */
    public static int TransactionManagerBasicInformation() {
        return TransactionManagerBasicInformation;
    }
    private static final int TransactionManagerLogInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogInformation = 1
     * }
     */
    public static int TransactionManagerLogInformation() {
        return TransactionManagerLogInformation;
    }
    private static final int TransactionManagerLogPathInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogPathInformation = 2
     * }
     */
    public static int TransactionManagerLogPathInformation() {
        return TransactionManagerLogPathInformation;
    }
    private static final int TransactionManagerRecoveryInformation = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerRecoveryInformation = 4
     * }
     */
    public static int TransactionManagerRecoveryInformation() {
        return TransactionManagerRecoveryInformation;
    }
    private static final int TransactionManagerOnlineProbeInformation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOnlineProbeInformation = 3
     * }
     */
    public static int TransactionManagerOnlineProbeInformation() {
        return TransactionManagerOnlineProbeInformation;
    }
    private static final int TransactionManagerOldestTransactionInformation = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOldestTransactionInformation = 5
     * }
     */
    public static int TransactionManagerOldestTransactionInformation() {
        return TransactionManagerOldestTransactionInformation;
    }
    private static final int ResourceManagerBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerBasicInformation = 0
     * }
     */
    public static int ResourceManagerBasicInformation() {
        return ResourceManagerBasicInformation;
    }
    private static final int ResourceManagerCompletionInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerCompletionInformation = 1
     * }
     */
    public static int ResourceManagerCompletionInformation() {
        return ResourceManagerCompletionInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ENLISTMENT_BASIC_INFORMATION {
     *     GUID EnlistmentId;
     *     GUID TransactionId;
     *     GUID ResourceManagerId;
     * } *PENLISTMENT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PENLISTMENT_BASIC_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENLISTMENT_CRM_INFORMATION {
     *     GUID CrmTransactionManagerId;
     *     GUID CrmResourceManagerId;
     *     GUID CrmEnlistmentId;
     * } *PENLISTMENT_CRM_INFORMATION
     * }
     */
    public static final AddressLayout PENLISTMENT_CRM_INFORMATION = winapi.C_POINTER;
    private static final int EnlistmentBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _ENLISTMENT_INFORMATION_CLASS.EnlistmentBasicInformation = 0
     * }
     */
    public static int EnlistmentBasicInformation() {
        return EnlistmentBasicInformation;
    }
    private static final int EnlistmentRecoveryInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _ENLISTMENT_INFORMATION_CLASS.EnlistmentRecoveryInformation = 1
     * }
     */
    public static int EnlistmentRecoveryInformation() {
        return EnlistmentRecoveryInformation;
    }
    private static final int EnlistmentCrmInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _ENLISTMENT_INFORMATION_CLASS.EnlistmentCrmInformation = 2
     * }
     */
    public static int EnlistmentCrmInformation() {
        return EnlistmentCrmInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_LIST_ENTRY {
     *     UOW UOW;
     * } *PTRANSACTION_LIST_ENTRY
     * }
     */
    public static final AddressLayout PTRANSACTION_LIST_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_LIST_INFORMATION {
     *     DWORD NumberOfTransactions;
     *     TRANSACTION_LIST_ENTRY TransactionInformation[1];
     * } *PTRANSACTION_LIST_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_LIST_INFORMATION = winapi.C_POINTER;
    private static final int KTMOBJECT_TRANSACTION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION = 0
     * }
     */
    public static int KTMOBJECT_TRANSACTION() {
        return KTMOBJECT_TRANSACTION;
    }
    private static final int KTMOBJECT_TRANSACTION_MANAGER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION_MANAGER = 1
     * }
     */
    public static int KTMOBJECT_TRANSACTION_MANAGER() {
        return KTMOBJECT_TRANSACTION_MANAGER;
    }
    private static final int KTMOBJECT_RESOURCE_MANAGER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_RESOURCE_MANAGER = 2
     * }
     */
    public static int KTMOBJECT_RESOURCE_MANAGER() {
        return KTMOBJECT_RESOURCE_MANAGER;
    }
    private static final int KTMOBJECT_ENLISTMENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_ENLISTMENT = 3
     * }
     */
    public static int KTMOBJECT_ENLISTMENT() {
        return KTMOBJECT_ENLISTMENT;
    }
    private static final int KTMOBJECT_INVALID = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_INVALID = 4
     * }
     */
    public static int KTMOBJECT_INVALID() {
        return KTMOBJECT_INVALID;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _KTMOBJECT_TYPE {
     *     KTMOBJECT_TRANSACTION,
     *     KTMOBJECT_TRANSACTION_MANAGER,
     *     KTMOBJECT_RESOURCE_MANAGER,
     *     KTMOBJECT_ENLISTMENT,
     *     KTMOBJECT_INVALID
     * } *PKTMOBJECT_TYPE
     * }
     */
    public static final AddressLayout PKTMOBJECT_TYPE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KTMOBJECT_CURSOR {
     *     GUID LastQuery;
     *     DWORD ObjectIdCount;
     *     GUID ObjectIds[1];
     * } *PKTMOBJECT_CURSOR
     * }
     */
    public static final AddressLayout PKTMOBJECT_CURSOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD TP_VERSION
     * }
     */
    public static final OfInt TP_VERSION = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD *PTP_VERSION
     * }
     */
    public static final AddressLayout PTP_VERSION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_CALLBACK_INSTANCE *PTP_CALLBACK_INSTANCE
     * }
     */
    public static final AddressLayout PTP_CALLBACK_INSTANCE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_POOL *PTP_POOL
     * }
     */
    public static final AddressLayout PTP_POOL = winapi.C_POINTER;
    private static final int TP_CALLBACK_PRIORITY_HIGH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
     * }
     */
    public static int TP_CALLBACK_PRIORITY_HIGH() {
        return TP_CALLBACK_PRIORITY_HIGH;
    }
    private static final int TP_CALLBACK_PRIORITY_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
     * }
     */
    public static int TP_CALLBACK_PRIORITY_NORMAL() {
        return TP_CALLBACK_PRIORITY_NORMAL;
    }
    private static final int TP_CALLBACK_PRIORITY_LOW = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
     * }
     */
    public static int TP_CALLBACK_PRIORITY_LOW() {
        return TP_CALLBACK_PRIORITY_LOW;
    }
    private static final int TP_CALLBACK_PRIORITY_INVALID = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3
     * }
     */
    public static int TP_CALLBACK_PRIORITY_INVALID() {
        return TP_CALLBACK_PRIORITY_INVALID;
    }
    private static final int TP_CALLBACK_PRIORITY_COUNT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_COUNT = 3
     * }
     */
    public static int TP_CALLBACK_PRIORITY_COUNT() {
        return TP_CALLBACK_PRIORITY_COUNT;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TP_POOL_STACK_INFORMATION {
     *     SIZE_T StackReserve;
     *     SIZE_T StackCommit;
     * } *PTP_POOL_STACK_INFORMATION
     * }
     */
    public static final AddressLayout PTP_POOL_STACK_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_CLEANUP_GROUP *PTP_CLEANUP_GROUP
     * }
     */
    public static final AddressLayout PTP_CLEANUP_GROUP = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef TP_CALLBACK_ENVIRON_V3 *PTP_CALLBACK_ENVIRON
     * }
     */
    public static final AddressLayout PTP_CALLBACK_ENVIRON = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_WORK *PTP_WORK
     * }
     */
    public static final AddressLayout PTP_WORK = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_TIMER *PTP_TIMER
     * }
     */
    public static final AddressLayout PTP_TIMER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD TP_WAIT_RESULT
     * }
     */
    public static final OfInt TP_WAIT_RESULT = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_WAIT *PTP_WAIT
     * }
     */
    public static final AddressLayout PTP_WAIT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_IO *PTP_IO
     * }
     */
    public static final AddressLayout PTP_IO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef UINT_PTR WPARAM
     * }
     */
    public static final OfLong WPARAM = winapi.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR LPARAM
     * }
     */
    public static final OfLong LPARAM = winapi.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR LRESULT
     * }
     */
    public static final OfLong LRESULT = winapi.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef HANDLE *SPHANDLE
     * }
     */
    public static final AddressLayout SPHANDLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE *LPHANDLE
     * }
     */
    public static final AddressLayout LPHANDLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE HGLOBAL
     * }
     */
    public static final AddressLayout HGLOBAL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE HLOCAL
     * }
     */
    public static final AddressLayout HLOCAL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE GLOBALHANDLE
     * }
     */
    public static final AddressLayout GLOBALHANDLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE LOCALHANDLE
     * }
     */
    public static final AddressLayout LOCALHANDLE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WORD ATOM
     * }
     */
    public static final OfShort ATOM = winapi.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct HKEY__ {
     *     int unused;
     * } *HKEY
     * }
     */
    public static final AddressLayout HKEY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HKEY *PHKEY
     * }
     */
    public static final AddressLayout PHKEY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMETAFILE__ {
     *     int unused;
     * } *HMETAFILE
     * }
     */
    public static final AddressLayout HMETAFILE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HINSTANCE__ {
     *     int unused;
     * } *HINSTANCE
     * }
     */
    public static final AddressLayout HINSTANCE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HINSTANCE HMODULE
     * }
     */
    public static final AddressLayout HMODULE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HRGN__ {
     *     int unused;
     * } *HRGN
     * }
     */
    public static final AddressLayout HRGN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HRSRC__ {
     *     int unused;
     * } *HRSRC
     * }
     */
    public static final AddressLayout HRSRC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HSPRITE__ {
     *     int unused;
     * } *HSPRITE
     * }
     */
    public static final AddressLayout HSPRITE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HLSURF__ {
     *     int unused;
     * } *HLSURF
     * }
     */
    public static final AddressLayout HLSURF = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HSTR__ {
     *     int unused;
     * } *HSTR
     * }
     */
    public static final AddressLayout HSTR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HTASK__ {
     *     int unused;
     * } *HTASK
     * }
     */
    public static final AddressLayout HTASK = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWINSTA__ {
     *     int unused;
     * } *HWINSTA
     * }
     */
    public static final AddressLayout HWINSTA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HKL__ {
     *     int unused;
     * } *HKL
     * }
     */
    public static final AddressLayout HKL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int HFILE
     * }
     */
    public static final OfInt HFILE = winapi.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct _FILETIME {
     *     DWORD dwLowDateTime;
     *     DWORD dwHighDateTime;
     * } *PFILETIME
     * }
     */
    public static final AddressLayout PFILETIME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILETIME {
     *     DWORD dwLowDateTime;
     *     DWORD dwHighDateTime;
     * } *LPFILETIME
     * }
     */
    public static final AddressLayout LPFILETIME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWND__ {
     *     int unused;
     * } *HWND
     * }
     */
    public static final AddressLayout HWND = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HHOOK__ {
     *     int unused;
     * } *HHOOK
     * }
     */
    public static final AddressLayout HHOOK = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HGDIOBJ
     * }
     */
    public static final AddressLayout HGDIOBJ = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HACCEL__ {
     *     int unused;
     * } *HACCEL
     * }
     */
    public static final AddressLayout HACCEL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HBITMAP__ {
     *     int unused;
     * } *HBITMAP
     * }
     */
    public static final AddressLayout HBITMAP = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HBRUSH__ {
     *     int unused;
     * } *HBRUSH
     * }
     */
    public static final AddressLayout HBRUSH = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HCOLORSPACE__ {
     *     int unused;
     * } *HCOLORSPACE
     * }
     */
    public static final AddressLayout HCOLORSPACE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HDC__ {
     *     int unused;
     * } *HDC
     * }
     */
    public static final AddressLayout HDC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HGLRC__ {
     *     int unused;
     * } *HGLRC
     * }
     */
    public static final AddressLayout HGLRC = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HDESK__ {
     *     int unused;
     * } *HDESK
     * }
     */
    public static final AddressLayout HDESK = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HENHMETAFILE__ {
     *     int unused;
     * } *HENHMETAFILE
     * }
     */
    public static final AddressLayout HENHMETAFILE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HFONT__ {
     *     int unused;
     * } *HFONT
     * }
     */
    public static final AddressLayout HFONT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HICON__ {
     *     int unused;
     * } *HICON
     * }
     */
    public static final AddressLayout HICON = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMENU__ {
     *     int unused;
     * } *HMENU
     * }
     */
    public static final AddressLayout HMENU = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HPALETTE__ {
     *     int unused;
     * } *HPALETTE
     * }
     */
    public static final AddressLayout HPALETTE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HPEN__ {
     *     int unused;
     * } *HPEN
     * }
     */
    public static final AddressLayout HPEN = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWINEVENTHOOK__ {
     *     int unused;
     * } *HWINEVENTHOOK
     * }
     */
    public static final AddressLayout HWINEVENTHOOK = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMONITOR__ {
     *     int unused;
     * } *HMONITOR
     * }
     */
    public static final AddressLayout HMONITOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HUMPD__ {
     *     int unused;
     * } *HUMPD
     * }
     */
    public static final AddressLayout HUMPD = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HICON HCURSOR
     * }
     */
    public static final AddressLayout HCURSOR = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD COLORREF
     * }
     */
    public static final OfInt COLORREF = winapi.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD *LPCOLORREF
     * }
     */
    public static final AddressLayout LPCOLORREF = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECT {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *PRECT
     * }
     */
    public static final AddressLayout PRECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECT {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *NPRECT
     * }
     */
    public static final AddressLayout NPRECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECT {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *LPRECT
     * }
     */
    public static final AddressLayout LPRECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const RECT *LPCRECT
     * }
     */
    public static final AddressLayout LPCRECT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RECTL {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *PRECTL
     * }
     */
    public static final AddressLayout PRECTL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RECTL {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *LPRECTL
     * }
     */
    public static final AddressLayout LPRECTL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const RECTL *LPCRECTL
     * }
     */
    public static final AddressLayout LPCRECTL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINT {
     *     LONG x;
     *     LONG y;
     * } *PPOINT
     * }
     */
    public static final AddressLayout PPOINT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINT {
     *     LONG x;
     *     LONG y;
     * } *NPPOINT
     * }
     */
    public static final AddressLayout NPPOINT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINT {
     *     LONG x;
     *     LONG y;
     * } *LPPOINT
     * }
     */
    public static final AddressLayout LPPOINT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _POINTL {
     *     LONG x;
     *     LONG y;
     * } *PPOINTL
     * }
     */
    public static final AddressLayout PPOINTL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSIZE {
     *     LONG cx;
     *     LONG cy;
     * } *PSIZE
     * }
     */
    public static final AddressLayout PSIZE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSIZE {
     *     LONG cx;
     *     LONG cy;
     * } *LPSIZE
     * }
     */
    public static final AddressLayout LPSIZE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SIZE *PSIZEL
     * }
     */
    public static final AddressLayout PSIZEL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SIZE *LPSIZEL
     * }
     */
    public static final AddressLayout LPSIZEL = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTS {
     *     SHORT x;
     *     SHORT y;
     * } *PPOINTS
     * }
     */
    public static final AddressLayout PPOINTS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTS {
     *     SHORT x;
     *     SHORT y;
     * } *LPPOINTS
     * }
     */
    public static final AddressLayout LPPOINTS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct DPI_AWARENESS_CONTEXT__ {
     *     int unused;
     * } *DPI_AWARENESS_CONTEXT
     * }
     */
    public static final AddressLayout DPI_AWARENESS_CONTEXT = winapi.C_POINTER;
    private static final int DPI_AWARENESS_INVALID = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_INVALID = -1
     * }
     */
    public static int DPI_AWARENESS_INVALID() {
        return DPI_AWARENESS_INVALID;
    }
    private static final int DPI_AWARENESS_UNAWARE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_UNAWARE = 0
     * }
     */
    public static int DPI_AWARENESS_UNAWARE() {
        return DPI_AWARENESS_UNAWARE;
    }
    private static final int DPI_AWARENESS_SYSTEM_AWARE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_SYSTEM_AWARE = 1
     * }
     */
    public static int DPI_AWARENESS_SYSTEM_AWARE() {
        return DPI_AWARENESS_SYSTEM_AWARE;
    }
    private static final int DPI_AWARENESS_PER_MONITOR_AWARE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_PER_MONITOR_AWARE = 2
     * }
     */
    public static int DPI_AWARENESS_PER_MONITOR_AWARE() {
        return DPI_AWARENESS_PER_MONITOR_AWARE;
    }
    private static final int DPI_HOSTING_BEHAVIOR_INVALID = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_INVALID = -1
     * }
     */
    public static int DPI_HOSTING_BEHAVIOR_INVALID() {
        return DPI_HOSTING_BEHAVIOR_INVALID;
    }
    private static final int DPI_HOSTING_BEHAVIOR_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_DEFAULT = 0
     * }
     */
    public static int DPI_HOSTING_BEHAVIOR_DEFAULT() {
        return DPI_HOSTING_BEHAVIOR_DEFAULT;
    }
    private static final int DPI_HOSTING_BEHAVIOR_MIXED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_MIXED = 1
     * }
     */
    public static int DPI_HOSTING_BEHAVIOR_MIXED() {
        return DPI_HOSTING_BEHAVIOR_MIXED;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_ATTRIBUTES {
     *     DWORD nLength;
     *     LPVOID lpSecurityDescriptor;
     *     BOOL bInheritHandle;
     * } *PSECURITY_ATTRIBUTES
     * }
     */
    public static final AddressLayout PSECURITY_ATTRIBUTES = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_ATTRIBUTES {
     *     DWORD nLength;
     *     LPVOID lpSecurityDescriptor;
     *     BOOL bInheritHandle;
     * } *LPSECURITY_ATTRIBUTES
     * }
     */
    public static final AddressLayout LPSECURITY_ATTRIBUTES = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OVERLAPPED {
     *     ULONG_PTR Internal;
     *     ULONG_PTR InternalHigh;
     *     union {
     *         struct {
     *             DWORD Offset;
     *             DWORD OffsetHigh;
     *         };
     *         PVOID Pointer;
     *     };
     *     HANDLE hEvent;
     * } *LPOVERLAPPED
     * }
     */
    public static final AddressLayout LPOVERLAPPED = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OVERLAPPED_ENTRY {
     *     ULONG_PTR lpCompletionKey;
     *     LPOVERLAPPED lpOverlapped;
     *     ULONG_PTR Internal;
     *     DWORD dwNumberOfBytesTransferred;
     * } *LPOVERLAPPED_ENTRY
     * }
     */
    public static final AddressLayout LPOVERLAPPED_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEMTIME {
     *     WORD wYear;
     *     WORD wMonth;
     *     WORD wDayOfWeek;
     *     WORD wDay;
     *     WORD wHour;
     *     WORD wMinute;
     *     WORD wSecond;
     *     WORD wMilliseconds;
     * } *PSYSTEMTIME
     * }
     */
    public static final AddressLayout PSYSTEMTIME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEMTIME {
     *     WORD wYear;
     *     WORD wMonth;
     *     WORD wDayOfWeek;
     *     WORD wDay;
     *     WORD wHour;
     *     WORD wMinute;
     *     WORD wSecond;
     *     WORD wMilliseconds;
     * } *LPSYSTEMTIME
     * }
     */
    public static final AddressLayout LPSYSTEMTIME = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     CHAR cFileName[260];
     *     CHAR cAlternateFileName[14];
     * } *PWIN32_FIND_DATAA
     * }
     */
    public static final AddressLayout PWIN32_FIND_DATAA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     CHAR cFileName[260];
     *     CHAR cAlternateFileName[14];
     * } *LPWIN32_FIND_DATAA
     * }
     */
    public static final AddressLayout LPWIN32_FIND_DATAA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAW {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     WCHAR cFileName[260];
     *     WCHAR cAlternateFileName[14];
     * } *PWIN32_FIND_DATAW
     * }
     */
    public static final AddressLayout PWIN32_FIND_DATAW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAW {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     WCHAR cFileName[260];
     *     WCHAR cAlternateFileName[14];
     * } *LPWIN32_FIND_DATAW
     * }
     */
    public static final AddressLayout LPWIN32_FIND_DATAW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA
     * }
     */
    public static final AddressLayout PWIN32_FIND_DATA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA
     * }
     */
    public static final AddressLayout LPWIN32_FIND_DATA = winapi.C_POINTER;
    private static final int FindExInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_INFO_LEVELS.FindExInfoStandard = 0
     * }
     */
    public static int FindExInfoStandard() {
        return FindExInfoStandard;
    }
    private static final int FindExInfoBasic = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_INFO_LEVELS.FindExInfoBasic = 1
     * }
     */
    public static int FindExInfoBasic() {
        return FindExInfoBasic;
    }
    private static final int FindExInfoMaxInfoLevel = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_INFO_LEVELS.FindExInfoMaxInfoLevel = 2
     * }
     */
    public static int FindExInfoMaxInfoLevel() {
        return FindExInfoMaxInfoLevel;
    }
    private static final int FindExSearchNameMatch = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchNameMatch = 0
     * }
     */
    public static int FindExSearchNameMatch() {
        return FindExSearchNameMatch;
    }
    private static final int FindExSearchLimitToDirectories = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchLimitToDirectories = 1
     * }
     */
    public static int FindExSearchLimitToDirectories() {
        return FindExSearchLimitToDirectories;
    }
    private static final int FindExSearchLimitToDevices = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchLimitToDevices = 2
     * }
     */
    public static int FindExSearchLimitToDevices() {
        return FindExSearchLimitToDevices;
    }
    private static final int FindExSearchMaxSearchOp = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchMaxSearchOp = 3
     * }
     */
    public static int FindExSearchMaxSearchOp() {
        return FindExSearchMaxSearchOp;
    }
    private static final int ReadDirectoryNotifyInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyInformation = 1
     * }
     */
    public static int ReadDirectoryNotifyInformation() {
        return ReadDirectoryNotifyInformation;
    }
    private static final int ReadDirectoryNotifyExtendedInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyExtendedInformation = 2
     * }
     */
    public static int ReadDirectoryNotifyExtendedInformation() {
        return ReadDirectoryNotifyExtendedInformation;
    }
    private static final int ReadDirectoryNotifyFullInformation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyFullInformation = 3
     * }
     */
    public static int ReadDirectoryNotifyFullInformation() {
        return ReadDirectoryNotifyFullInformation;
    }
    private static final int ReadDirectoryNotifyMaximumInformation = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyMaximumInformation = 4
     * }
     */
    public static int ReadDirectoryNotifyMaximumInformation() {
        return ReadDirectoryNotifyMaximumInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS {
     *     ReadDirectoryNotifyInformation = 1,
     *     ReadDirectoryNotifyExtendedInformation,
     *     ReadDirectoryNotifyFullInformation,
     *     ReadDirectoryNotifyMaximumInformation
     * } *PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS
     * }
     */
    public static final AddressLayout PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS = winapi.C_POINTER;
    private static final int GetFileExInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _GET_FILEEX_INFO_LEVELS.GetFileExInfoStandard = 0
     * }
     */
    public static int GetFileExInfoStandard() {
        return GetFileExInfoStandard;
    }
    private static final int GetFileExMaxInfoLevel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _GET_FILEEX_INFO_LEVELS.GetFileExMaxInfoLevel = 1
     * }
     */
    public static int GetFileExMaxInfoLevel() {
        return GetFileExMaxInfoLevel;
    }
    private static final int FileBasicInfo = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileBasicInfo = 0
     * }
     */
    public static int FileBasicInfo() {
        return FileBasicInfo;
    }
    private static final int FileStandardInfo = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileStandardInfo = 1
     * }
     */
    public static int FileStandardInfo() {
        return FileStandardInfo;
    }
    private static final int FileNameInfo = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileNameInfo = 2
     * }
     */
    public static int FileNameInfo() {
        return FileNameInfo;
    }
    private static final int FileRenameInfo = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileRenameInfo = 3
     * }
     */
    public static int FileRenameInfo() {
        return FileRenameInfo;
    }
    private static final int FileDispositionInfo = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfo = 4
     * }
     */
    public static int FileDispositionInfo() {
        return FileDispositionInfo;
    }
    private static final int FileAllocationInfo = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileAllocationInfo = 5
     * }
     */
    public static int FileAllocationInfo() {
        return FileAllocationInfo;
    }
    private static final int FileEndOfFileInfo = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileEndOfFileInfo = 6
     * }
     */
    public static int FileEndOfFileInfo() {
        return FileEndOfFileInfo;
    }
    private static final int FileStreamInfo = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileStreamInfo = 7
     * }
     */
    public static int FileStreamInfo() {
        return FileStreamInfo;
    }
    private static final int FileCompressionInfo = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileCompressionInfo = 8
     * }
     */
    public static int FileCompressionInfo() {
        return FileCompressionInfo;
    }
    private static final int FileAttributeTagInfo = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileAttributeTagInfo = 9
     * }
     */
    public static int FileAttributeTagInfo() {
        return FileAttributeTagInfo;
    }
    private static final int FileIdBothDirectoryInfo = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryInfo = 10
     * }
     */
    public static int FileIdBothDirectoryInfo() {
        return FileIdBothDirectoryInfo;
    }
    private static final int FileIdBothDirectoryRestartInfo = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryRestartInfo = 11
     * }
     */
    public static int FileIdBothDirectoryRestartInfo() {
        return FileIdBothDirectoryRestartInfo;
    }
    private static final int FileIoPriorityHintInfo = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIoPriorityHintInfo = 12
     * }
     */
    public static int FileIoPriorityHintInfo() {
        return FileIoPriorityHintInfo;
    }
    private static final int FileRemoteProtocolInfo = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileRemoteProtocolInfo = 13
     * }
     */
    public static int FileRemoteProtocolInfo() {
        return FileRemoteProtocolInfo;
    }
    private static final int FileFullDirectoryInfo = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryInfo = 14
     * }
     */
    public static int FileFullDirectoryInfo() {
        return FileFullDirectoryInfo;
    }
    private static final int FileFullDirectoryRestartInfo = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryRestartInfo = 15
     * }
     */
    public static int FileFullDirectoryRestartInfo() {
        return FileFullDirectoryRestartInfo;
    }
    private static final int FileStorageInfo = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileStorageInfo = 16
     * }
     */
    public static int FileStorageInfo() {
        return FileStorageInfo;
    }
    private static final int FileAlignmentInfo = (int)17L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileAlignmentInfo = 17
     * }
     */
    public static int FileAlignmentInfo() {
        return FileAlignmentInfo;
    }
    private static final int FileIdInfo = (int)18L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdInfo = 18
     * }
     */
    public static int FileIdInfo() {
        return FileIdInfo;
    }
    private static final int FileIdExtdDirectoryInfo = (int)19L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryInfo = 19
     * }
     */
    public static int FileIdExtdDirectoryInfo() {
        return FileIdExtdDirectoryInfo;
    }
    private static final int FileIdExtdDirectoryRestartInfo = (int)20L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryRestartInfo = 20
     * }
     */
    public static int FileIdExtdDirectoryRestartInfo() {
        return FileIdExtdDirectoryRestartInfo;
    }
    private static final int FileDispositionInfoEx = (int)21L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfoEx = 21
     * }
     */
    public static int FileDispositionInfoEx() {
        return FileDispositionInfoEx;
    }
    private static final int FileRenameInfoEx = (int)22L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileRenameInfoEx = 22
     * }
     */
    public static int FileRenameInfoEx() {
        return FileRenameInfoEx;
    }
    private static final int FileCaseSensitiveInfo = (int)23L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileCaseSensitiveInfo = 23
     * }
     */
    public static int FileCaseSensitiveInfo() {
        return FileCaseSensitiveInfo;
    }
    private static final int FileNormalizedNameInfo = (int)24L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileNormalizedNameInfo = 24
     * }
     */
    public static int FileNormalizedNameInfo() {
        return FileNormalizedNameInfo;
    }
    private static final int MaximumFileInfoByHandleClass = (int)25L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.MaximumFileInfoByHandleClass = 25
     * }
     */
    public static int MaximumFileInfoByHandleClass() {
        return MaximumFileInfoByHandleClass;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _FILE_INFO_BY_HANDLE_CLASS {
     *     FileBasicInfo,
     *     FileStandardInfo,
     *     FileNameInfo,
     *     FileRenameInfo,
     *     FileDispositionInfo,
     *     FileAllocationInfo,
     *     FileEndOfFileInfo,
     *     FileStreamInfo,
     *     FileCompressionInfo,
     *     FileAttributeTagInfo,
     *     FileIdBothDirectoryInfo,
     *     FileIdBothDirectoryRestartInfo,
     *     FileIoPriorityHintInfo,
     *     FileRemoteProtocolInfo,
     *     FileFullDirectoryInfo,
     *     FileFullDirectoryRestartInfo,
     *     FileStorageInfo,
     *     FileAlignmentInfo,
     *     FileIdInfo,
     *     FileIdExtdDirectoryInfo,
     *     FileIdExtdDirectoryRestartInfo,
     *     FileDispositionInfoEx,
     *     FileRenameInfoEx,
     *     FileCaseSensitiveInfo,
     *     FileNormalizedNameInfo,
     *     MaximumFileInfoByHandleClass
     * } *PFILE_INFO_BY_HANDLE_CLASS
     * }
     */
    public static final AddressLayout PFILE_INFO_BY_HANDLE_CLASS = winapi.C_POINTER;
    private static final int FileStatByNameInfo = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_NAME_CLASS.FileStatByNameInfo = 0
     * }
     */
    public static int FileStatByNameInfo() {
        return FileStatByNameInfo;
    }
    private static final int FileStatLxByNameInfo = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_NAME_CLASS.FileStatLxByNameInfo = 1
     * }
     */
    public static int FileStatLxByNameInfo() {
        return FileStatLxByNameInfo;
    }
    private static final int FileCaseSensitiveByNameInfo = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_NAME_CLASS.FileCaseSensitiveByNameInfo = 2
     * }
     */
    public static int FileCaseSensitiveByNameInfo() {
        return FileCaseSensitiveByNameInfo;
    }
    private static final int FileStatBasicByNameInfo = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_NAME_CLASS.FileStatBasicByNameInfo = 3
     * }
     */
    public static int FileStatBasicByNameInfo() {
        return FileStatBasicByNameInfo;
    }
    private static final int MaximumFileInfoByNameClass = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_NAME_CLASS.MaximumFileInfoByNameClass = 4
     * }
     */
    public static int MaximumFileInfoByNameClass() {
        return MaximumFileInfoByNameClass;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _FILE_INFO_BY_NAME_CLASS {
     *     FileStatByNameInfo,
     *     FileStatLxByNameInfo,
     *     FileCaseSensitiveByNameInfo,
     *     FileStatBasicByNameInfo,
     *     MaximumFileInfoByNameClass
     * } *PFILE_INFO_BY_NAME_CLASS
     * }
     */
    public static final AddressLayout PFILE_INFO_BY_NAME_CLASS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION
     * }
     */
    public static final AddressLayout PCRITICAL_SECTION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION
     * }
     */
    public static final AddressLayout LPCRITICAL_SECTION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG
     * }
     */
    public static final AddressLayout PCRITICAL_SECTION_DEBUG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG
     * }
     */
    public static final AddressLayout LPCRITICAL_SECTION_DEBUG = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_HEAP_ENTRY {
     *     PVOID lpData;
     *     DWORD cbData;
     *     BYTE cbOverhead;
     *     BYTE iRegionIndex;
     *     WORD wFlags;
     *     union {
     *         struct {
     *             HANDLE hMem;
     *             DWORD dwReserved[3];
     *         } Block;
     *         struct {
     *             DWORD dwCommittedSize;
     *             DWORD dwUnCommittedSize;
     *             LPVOID lpFirstBlock;
     *             LPVOID lpLastBlock;
     *         } Region;
     *     };
     * } *LPPROCESS_HEAP_ENTRY
     * }
     */
    public static final AddressLayout LPPROCESS_HEAP_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_HEAP_ENTRY {
     *     PVOID lpData;
     *     DWORD cbData;
     *     BYTE cbOverhead;
     *     BYTE iRegionIndex;
     *     WORD wFlags;
     *     union {
     *         struct {
     *             HANDLE hMem;
     *             DWORD dwReserved[3];
     *         } Block;
     *         struct {
     *             DWORD dwCommittedSize;
     *             DWORD dwUnCommittedSize;
     *             LPVOID lpFirstBlock;
     *             LPVOID lpLastBlock;
     *         } Region;
     *     };
     * } *PPROCESS_HEAP_ENTRY
     * }
     */
    public static final AddressLayout PPROCESS_HEAP_ENTRY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REASON_CONTEXT {
     *     ULONG Version;
     *     DWORD Flags;
     *     union {
     *         struct {
     *             HMODULE LocalizedReasonModule;
     *             ULONG LocalizedReasonId;
     *             ULONG ReasonStringCount;
     *             LPWSTR *ReasonStrings;
     *         } Detailed;
     *         LPWSTR SimpleReasonString;
     *     } Reason;
     * } *PREASON_CONTEXT
     * }
     */
    public static final AddressLayout PREASON_CONTEXT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXCEPTION_DEBUG_INFO {
     *     EXCEPTION_RECORD ExceptionRecord;
     *     DWORD dwFirstChance;
     * } *LPEXCEPTION_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPEXCEPTION_DEBUG_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATE_THREAD_DEBUG_INFO {
     *     HANDLE hThread;
     *     LPVOID lpThreadLocalBase;
     *     LPTHREAD_START_ROUTINE lpStartAddress;
     * } *LPCREATE_THREAD_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPCREATE_THREAD_DEBUG_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATE_PROCESS_DEBUG_INFO {
     *     HANDLE hFile;
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     LPVOID lpBaseOfImage;
     *     DWORD dwDebugInfoFileOffset;
     *     DWORD nDebugInfoSize;
     *     LPVOID lpThreadLocalBase;
     *     LPTHREAD_START_ROUTINE lpStartAddress;
     *     LPVOID lpImageName;
     *     WORD fUnicode;
     * } *LPCREATE_PROCESS_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPCREATE_PROCESS_DEBUG_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXIT_THREAD_DEBUG_INFO {
     *     DWORD dwExitCode;
     * } *LPEXIT_THREAD_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPEXIT_THREAD_DEBUG_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXIT_PROCESS_DEBUG_INFO {
     *     DWORD dwExitCode;
     * } *LPEXIT_PROCESS_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPEXIT_PROCESS_DEBUG_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _LOAD_DLL_DEBUG_INFO {
     *     HANDLE hFile;
     *     LPVOID lpBaseOfDll;
     *     DWORD dwDebugInfoFileOffset;
     *     DWORD nDebugInfoSize;
     *     LPVOID lpImageName;
     *     WORD fUnicode;
     * } *LPLOAD_DLL_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPLOAD_DLL_DEBUG_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UNLOAD_DLL_DEBUG_INFO {
     *     LPVOID lpBaseOfDll;
     * } *LPUNLOAD_DLL_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPUNLOAD_DLL_DEBUG_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTPUT_DEBUG_STRING_INFO {
     *     LPSTR lpDebugStringData;
     *     WORD fUnicode;
     *     WORD nDebugStringLength;
     * } *LPOUTPUT_DEBUG_STRING_INFO
     * }
     */
    public static final AddressLayout LPOUTPUT_DEBUG_STRING_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RIP_INFO {
     *     DWORD dwError;
     *     DWORD dwType;
     * } *LPRIP_INFO
     * }
     */
    public static final AddressLayout LPRIP_INFO = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DEBUG_EVENT {
     *     DWORD dwDebugEventCode;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     *     union {
     *         EXCEPTION_DEBUG_INFO Exception;
     *         CREATE_THREAD_DEBUG_INFO CreateThread;
     *         CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
     *         EXIT_THREAD_DEBUG_INFO ExitThread;
     *         EXIT_PROCESS_DEBUG_INFO ExitProcess;
     *         LOAD_DLL_DEBUG_INFO LoadDll;
     *         UNLOAD_DLL_DEBUG_INFO UnloadDll;
     *         OUTPUT_DEBUG_STRING_INFO DebugString;
     *         RIP_INFO RipInfo;
     *     } u;
     * } *LPDEBUG_EVENT
     * }
     */
    public static final AddressLayout LPDEBUG_EVENT = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCONTEXT LPCONTEXT
     * }
     */
    public static final AddressLayout LPCONTEXT = winapi.C_POINTER;

    private static class IsApiSetImplemented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsApiSetImplemented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static FunctionDescriptor IsApiSetImplemented$descriptor() {
        return IsApiSetImplemented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static MethodHandle IsApiSetImplemented$handle() {
        return IsApiSetImplemented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static MemorySegment IsApiSetImplemented$address() {
        return IsApiSetImplemented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static int IsApiSetImplemented(MemorySegment Contract) {
        var mh$ = IsApiSetImplemented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsApiSetImplemented", Contract);
            }
            return (int)mh$.invokeExact(Contract);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetEnvironmentStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static FunctionDescriptor SetEnvironmentStringsW$descriptor() {
        return SetEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static MethodHandle SetEnvironmentStringsW$handle() {
        return SetEnvironmentStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static MemorySegment SetEnvironmentStringsW$address() {
        return SetEnvironmentStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static int SetEnvironmentStringsW(MemorySegment NewEnvironment) {
        var mh$ = SetEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentStringsW", NewEnvironment);
            }
            return (int)mh$.invokeExact(NewEnvironment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStdHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetStdHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static FunctionDescriptor GetStdHandle$descriptor() {
        return GetStdHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static MethodHandle GetStdHandle$handle() {
        return GetStdHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static MemorySegment GetStdHandle$address() {
        return GetStdHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static MemorySegment GetStdHandle(int nStdHandle) {
        var mh$ = GetStdHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStdHandle", nStdHandle);
            }
            return (MemorySegment)mh$.invokeExact(nStdHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStdHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetStdHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static FunctionDescriptor SetStdHandle$descriptor() {
        return SetStdHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static MethodHandle SetStdHandle$handle() {
        return SetStdHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static MemorySegment SetStdHandle$address() {
        return SetStdHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static int SetStdHandle(int nStdHandle, MemorySegment hHandle) {
        var mh$ = SetStdHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStdHandle", nStdHandle, hHandle);
            }
            return (int)mh$.invokeExact(nStdHandle, hHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStdHandleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetStdHandleEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static FunctionDescriptor SetStdHandleEx$descriptor() {
        return SetStdHandleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static MethodHandle SetStdHandleEx$handle() {
        return SetStdHandleEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static MemorySegment SetStdHandleEx$address() {
        return SetStdHandleEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static int SetStdHandleEx(int nStdHandle, MemorySegment hHandle, MemorySegment phPrevValue) {
        var mh$ = SetStdHandleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStdHandleEx", nStdHandle, hHandle, phPrevValue);
            }
            return (int)mh$.invokeExact(nStdHandle, hHandle, phPrevValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommandLineA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCommandLineA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static FunctionDescriptor GetCommandLineA$descriptor() {
        return GetCommandLineA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static MethodHandle GetCommandLineA$handle() {
        return GetCommandLineA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static MemorySegment GetCommandLineA$address() {
        return GetCommandLineA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static MemorySegment GetCommandLineA() {
        var mh$ = GetCommandLineA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommandLineA");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommandLineW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCommandLineW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static FunctionDescriptor GetCommandLineW$descriptor() {
        return GetCommandLineW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static MethodHandle GetCommandLineW$handle() {
        return GetCommandLineW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static MemorySegment GetCommandLineW$address() {
        return GetCommandLineW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static MemorySegment GetCommandLineW() {
        var mh$ = GetCommandLineW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommandLineW");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentStrings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnvironmentStrings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static FunctionDescriptor GetEnvironmentStrings$descriptor() {
        return GetEnvironmentStrings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static MethodHandle GetEnvironmentStrings$handle() {
        return GetEnvironmentStrings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static MemorySegment GetEnvironmentStrings$address() {
        return GetEnvironmentStrings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static MemorySegment GetEnvironmentStrings() {
        var mh$ = GetEnvironmentStrings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentStrings");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnvironmentStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static FunctionDescriptor GetEnvironmentStringsW$descriptor() {
        return GetEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static MethodHandle GetEnvironmentStringsW$handle() {
        return GetEnvironmentStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static MemorySegment GetEnvironmentStringsW$address() {
        return GetEnvironmentStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static MemorySegment GetEnvironmentStringsW() {
        var mh$ = GetEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentStringsW");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEnvironmentStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FreeEnvironmentStringsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static FunctionDescriptor FreeEnvironmentStringsA$descriptor() {
        return FreeEnvironmentStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static MethodHandle FreeEnvironmentStringsA$handle() {
        return FreeEnvironmentStringsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static MemorySegment FreeEnvironmentStringsA$address() {
        return FreeEnvironmentStringsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static int FreeEnvironmentStringsA(MemorySegment penv) {
        var mh$ = FreeEnvironmentStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEnvironmentStringsA", penv);
            }
            return (int)mh$.invokeExact(penv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FreeEnvironmentStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static FunctionDescriptor FreeEnvironmentStringsW$descriptor() {
        return FreeEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static MethodHandle FreeEnvironmentStringsW$handle() {
        return FreeEnvironmentStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static MemorySegment FreeEnvironmentStringsW$address() {
        return FreeEnvironmentStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static int FreeEnvironmentStringsW(MemorySegment penv) {
        var mh$ = FreeEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEnvironmentStringsW", penv);
            }
            return (int)mh$.invokeExact(penv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnvironmentVariableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetEnvironmentVariableA$descriptor() {
        return GetEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetEnvironmentVariableA$handle() {
        return GetEnvironmentVariableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetEnvironmentVariableA$address() {
        return GetEnvironmentVariableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static int GetEnvironmentVariableA(MemorySegment lpName, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentVariableA", lpName, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetEnvironmentVariableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetEnvironmentVariableW$descriptor() {
        return GetEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetEnvironmentVariableW$handle() {
        return GetEnvironmentVariableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetEnvironmentVariableW$address() {
        return GetEnvironmentVariableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static int GetEnvironmentVariableW(MemorySegment lpName, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentVariableW", lpName, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetEnvironmentVariableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static FunctionDescriptor SetEnvironmentVariableA$descriptor() {
        return SetEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static MethodHandle SetEnvironmentVariableA$handle() {
        return SetEnvironmentVariableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static MemorySegment SetEnvironmentVariableA$address() {
        return SetEnvironmentVariableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static int SetEnvironmentVariableA(MemorySegment lpName, MemorySegment lpValue) {
        var mh$ = SetEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentVariableA", lpName, lpValue);
            }
            return (int)mh$.invokeExact(lpName, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetEnvironmentVariableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static FunctionDescriptor SetEnvironmentVariableW$descriptor() {
        return SetEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static MethodHandle SetEnvironmentVariableW$handle() {
        return SetEnvironmentVariableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static MemorySegment SetEnvironmentVariableW$address() {
        return SetEnvironmentVariableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static int SetEnvironmentVariableW(MemorySegment lpName, MemorySegment lpValue) {
        var mh$ = SetEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentVariableW", lpName, lpValue);
            }
            return (int)mh$.invokeExact(lpName, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpandEnvironmentStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExpandEnvironmentStringsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static FunctionDescriptor ExpandEnvironmentStringsA$descriptor() {
        return ExpandEnvironmentStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static MethodHandle ExpandEnvironmentStringsA$handle() {
        return ExpandEnvironmentStringsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static MemorySegment ExpandEnvironmentStringsA$address() {
        return ExpandEnvironmentStringsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static int ExpandEnvironmentStringsA(MemorySegment lpSrc, MemorySegment lpDst, int nSize) {
        var mh$ = ExpandEnvironmentStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpandEnvironmentStringsA", lpSrc, lpDst, nSize);
            }
            return (int)mh$.invokeExact(lpSrc, lpDst, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpandEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExpandEnvironmentStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static FunctionDescriptor ExpandEnvironmentStringsW$descriptor() {
        return ExpandEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static MethodHandle ExpandEnvironmentStringsW$handle() {
        return ExpandEnvironmentStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static MemorySegment ExpandEnvironmentStringsW$address() {
        return ExpandEnvironmentStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static int ExpandEnvironmentStringsW(MemorySegment lpSrc, MemorySegment lpDst, int nSize) {
        var mh$ = ExpandEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpandEnvironmentStringsW", lpSrc, lpDst, nSize);
            }
            return (int)mh$.invokeExact(lpSrc, lpDst, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCurrentDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetCurrentDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetCurrentDirectoryA$descriptor() {
        return SetCurrentDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle SetCurrentDirectoryA$handle() {
        return SetCurrentDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MemorySegment SetCurrentDirectoryA$address() {
        return SetCurrentDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int SetCurrentDirectoryA(MemorySegment lpPathName) {
        var mh$ = SetCurrentDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCurrentDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCurrentDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetCurrentDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetCurrentDirectoryW$descriptor() {
        return SetCurrentDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle SetCurrentDirectoryW$handle() {
        return SetCurrentDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment SetCurrentDirectoryW$address() {
        return SetCurrentDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int SetCurrentDirectoryW(MemorySegment lpPathName) {
        var mh$ = SetCurrentDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCurrentDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrentDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCurrentDirectoryA$descriptor() {
        return GetCurrentDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetCurrentDirectoryA$handle() {
        return GetCurrentDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MemorySegment GetCurrentDirectoryA$address() {
        return GetCurrentDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetCurrentDirectoryA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetCurrentDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentDirectoryA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrentDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCurrentDirectoryW$descriptor() {
        return GetCurrentDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetCurrentDirectoryW$handle() {
        return GetCurrentDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetCurrentDirectoryW$address() {
        return GetCurrentDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetCurrentDirectoryW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetCurrentDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentDirectoryW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SearchPathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SearchPathW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor SearchPathW$descriptor() {
        return SearchPathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MethodHandle SearchPathW$handle() {
        return SearchPathW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MemorySegment SearchPathW$address() {
        return SearchPathW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static int SearchPathW(MemorySegment lpPath, MemorySegment lpFileName, MemorySegment lpExtension, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = SearchPathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SearchPathW", lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SearchPathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SearchPathA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor SearchPathA$descriptor() {
        return SearchPathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MethodHandle SearchPathA$handle() {
        return SearchPathA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MemorySegment SearchPathA$address() {
        return SearchPathA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static int SearchPathA(MemorySegment lpPath, MemorySegment lpFileName, MemorySegment lpExtension, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = SearchPathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SearchPathA", lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NeedCurrentDirectoryForExePathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NeedCurrentDirectoryForExePathA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static FunctionDescriptor NeedCurrentDirectoryForExePathA$descriptor() {
        return NeedCurrentDirectoryForExePathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static MethodHandle NeedCurrentDirectoryForExePathA$handle() {
        return NeedCurrentDirectoryForExePathA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static MemorySegment NeedCurrentDirectoryForExePathA$address() {
        return NeedCurrentDirectoryForExePathA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static int NeedCurrentDirectoryForExePathA(MemorySegment ExeName) {
        var mh$ = NeedCurrentDirectoryForExePathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NeedCurrentDirectoryForExePathA", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NeedCurrentDirectoryForExePathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("NeedCurrentDirectoryForExePathW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static FunctionDescriptor NeedCurrentDirectoryForExePathW$descriptor() {
        return NeedCurrentDirectoryForExePathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static MethodHandle NeedCurrentDirectoryForExePathW$handle() {
        return NeedCurrentDirectoryForExePathW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static MemorySegment NeedCurrentDirectoryForExePathW$address() {
        return NeedCurrentDirectoryForExePathW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static int NeedCurrentDirectoryForExePathW(MemorySegment ExeName) {
        var mh$ = NeedCurrentDirectoryForExePathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NeedCurrentDirectoryForExePathW", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CompareFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static FunctionDescriptor CompareFileTime$descriptor() {
        return CompareFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static MethodHandle CompareFileTime$handle() {
        return CompareFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static MemorySegment CompareFileTime$address() {
        return CompareFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static int CompareFileTime(MemorySegment lpFileTime1, MemorySegment lpFileTime2) {
        var mh$ = CompareFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareFileTime", lpFileTime1, lpFileTime2);
            }
            return (int)mh$.invokeExact(lpFileTime1, lpFileTime2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryA$descriptor() {
        return CreateDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryA$handle() {
        return CreateDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryA$address() {
        return CreateDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryA(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryA", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryW$descriptor() {
        return CreateDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryW$handle() {
        return CreateDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryW$address() {
        return CreateDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryW(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryW", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileA$descriptor() {
        return CreateFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileA$handle() {
        return CreateFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileA$address() {
        return CreateFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileA(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileA", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileW$descriptor() {
        return CreateFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileW$handle() {
        return CreateFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileW$address() {
        return CreateFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefineDosDeviceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DefineDosDeviceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static FunctionDescriptor DefineDosDeviceW$descriptor() {
        return DefineDosDeviceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static MethodHandle DefineDosDeviceW$handle() {
        return DefineDosDeviceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static MemorySegment DefineDosDeviceW$address() {
        return DefineDosDeviceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static int DefineDosDeviceW(int dwFlags, MemorySegment lpDeviceName, MemorySegment lpTargetPath) {
        var mh$ = DefineDosDeviceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefineDosDeviceW", dwFlags, lpDeviceName, lpTargetPath);
            }
            return (int)mh$.invokeExact(dwFlags, lpDeviceName, lpTargetPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileA$descriptor() {
        return DeleteFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileA$handle() {
        return DeleteFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment DeleteFileA$address() {
        return DeleteFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static int DeleteFileA(MemorySegment lpFileName) {
        var mh$ = DeleteFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileW$descriptor() {
        return DeleteFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileW$handle() {
        return DeleteFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment DeleteFileW$address() {
        return DeleteFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static int DeleteFileW(MemorySegment lpFileName) {
        var mh$ = DeleteFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor DeleteVolumeMountPointW$descriptor() {
        return DeleteVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static MethodHandle DeleteVolumeMountPointW$handle() {
        return DeleteVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static MemorySegment DeleteVolumeMountPointW$address() {
        return DeleteVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static int DeleteVolumeMountPointW(MemorySegment lpszVolumeMountPoint) {
        var mh$ = DeleteVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteVolumeMountPointW", lpszVolumeMountPoint);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileTimeToLocalFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FileTimeToLocalFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static FunctionDescriptor FileTimeToLocalFileTime$descriptor() {
        return FileTimeToLocalFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static MethodHandle FileTimeToLocalFileTime$handle() {
        return FileTimeToLocalFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static MemorySegment FileTimeToLocalFileTime$address() {
        return FileTimeToLocalFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static int FileTimeToLocalFileTime(MemorySegment lpFileTime, MemorySegment lpLocalFileTime) {
        var mh$ = FileTimeToLocalFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileTimeToLocalFileTime", lpFileTime, lpLocalFileTime);
            }
            return (int)mh$.invokeExact(lpFileTime, lpLocalFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static FunctionDescriptor FindClose$descriptor() {
        return FindClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static MethodHandle FindClose$handle() {
        return FindClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static MemorySegment FindClose$address() {
        return FindClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static int FindClose(MemorySegment hFindFile) {
        var mh$ = FindClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindClose", hFindFile);
            }
            return (int)mh$.invokeExact(hFindFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindCloseChangeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindCloseChangeNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static FunctionDescriptor FindCloseChangeNotification$descriptor() {
        return FindCloseChangeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MethodHandle FindCloseChangeNotification$handle() {
        return FindCloseChangeNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MemorySegment FindCloseChangeNotification$address() {
        return FindCloseChangeNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static int FindCloseChangeNotification(MemorySegment hChangeHandle) {
        var mh$ = FindCloseChangeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindCloseChangeNotification", hChangeHandle);
            }
            return (int)mh$.invokeExact(hChangeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstChangeNotificationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstChangeNotificationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static FunctionDescriptor FindFirstChangeNotificationA$descriptor() {
        return FindFirstChangeNotificationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MethodHandle FindFirstChangeNotificationA$handle() {
        return FindFirstChangeNotificationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationA$address() {
        return FindFirstChangeNotificationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationA(MemorySegment lpPathName, int bWatchSubtree, int dwNotifyFilter) {
        var mh$ = FindFirstChangeNotificationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstChangeNotificationA", lpPathName, bWatchSubtree, dwNotifyFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpPathName, bWatchSubtree, dwNotifyFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstChangeNotificationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstChangeNotificationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static FunctionDescriptor FindFirstChangeNotificationW$descriptor() {
        return FindFirstChangeNotificationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MethodHandle FindFirstChangeNotificationW$handle() {
        return FindFirstChangeNotificationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationW$address() {
        return FindFirstChangeNotificationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationW(MemorySegment lpPathName, int bWatchSubtree, int dwNotifyFilter) {
        var mh$ = FindFirstChangeNotificationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstChangeNotificationW", lpPathName, bWatchSubtree, dwNotifyFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpPathName, bWatchSubtree, dwNotifyFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindFirstFileA$descriptor() {
        return FindFirstFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MethodHandle FindFirstFileA$handle() {
        return FindFirstFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileA$address() {
        return FindFirstFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileA(MemorySegment lpFileName, MemorySegment lpFindFileData) {
        var mh$ = FindFirstFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileA", lpFileName, lpFindFileData);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindFirstFileW$descriptor() {
        return FindFirstFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MethodHandle FindFirstFileW$handle() {
        return FindFirstFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileW$address() {
        return FindFirstFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileW(MemorySegment lpFileName, MemorySegment lpFindFileData) {
        var mh$ = FindFirstFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileW", lpFileName, lpFindFileData);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstFileExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExA$descriptor() {
        return FindFirstFileExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExA$handle() {
        return FindFirstFileExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExA$address() {
        return FindFirstFileExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExA", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstFileExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExW$descriptor() {
        return FindFirstFileExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExW$handle() {
        return FindFirstFileExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExW$address() {
        return FindFirstFileExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstVolumeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeW$descriptor() {
        return FindFirstVolumeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeW$handle() {
        return FindFirstVolumeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeW$address() {
        return FindFirstVolumeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeW(MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindFirstVolumeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeW", lpszVolumeName, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextChangeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNextChangeNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static FunctionDescriptor FindNextChangeNotification$descriptor() {
        return FindNextChangeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MethodHandle FindNextChangeNotification$handle() {
        return FindNextChangeNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MemorySegment FindNextChangeNotification$address() {
        return FindNextChangeNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static int FindNextChangeNotification(MemorySegment hChangeHandle) {
        var mh$ = FindNextChangeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextChangeNotification", hChangeHandle);
            }
            return (int)mh$.invokeExact(hChangeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNextFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindNextFileA$descriptor() {
        return FindNextFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MethodHandle FindNextFileA$handle() {
        return FindNextFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MemorySegment FindNextFileA$address() {
        return FindNextFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static int FindNextFileA(MemorySegment hFindFile, MemorySegment lpFindFileData) {
        var mh$ = FindNextFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileA", hFindFile, lpFindFileData);
            }
            return (int)mh$.invokeExact(hFindFile, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNextFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindNextFileW$descriptor() {
        return FindNextFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MethodHandle FindNextFileW$handle() {
        return FindNextFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MemorySegment FindNextFileW$address() {
        return FindNextFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static int FindNextFileW(MemorySegment hFindFile, MemorySegment lpFindFileData) {
        var mh$ = FindNextFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileW", hFindFile, lpFindFileData);
            }
            return (int)mh$.invokeExact(hFindFile, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNextVolumeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeW$descriptor() {
        return FindNextVolumeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeW$handle() {
        return FindNextVolumeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeW$address() {
        return FindNextVolumeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeW(MemorySegment hFindVolume, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindNextVolumeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeW", hFindVolume, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolume, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindVolumeClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindVolumeClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static FunctionDescriptor FindVolumeClose$descriptor() {
        return FindVolumeClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static MethodHandle FindVolumeClose$handle() {
        return FindVolumeClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static MemorySegment FindVolumeClose$address() {
        return FindVolumeClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static int FindVolumeClose(MemorySegment hFindVolume) {
        var mh$ = FindVolumeClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindVolumeClose", hFindVolume);
            }
            return (int)mh$.invokeExact(hFindVolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushFileBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FlushFileBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor FlushFileBuffers$descriptor() {
        return FlushFileBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static MethodHandle FlushFileBuffers$handle() {
        return FlushFileBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static MemorySegment FlushFileBuffers$address() {
        return FlushFileBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static int FlushFileBuffers(MemorySegment hFile) {
        var mh$ = FlushFileBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushFileBuffers", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDiskFreeSpaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceA$descriptor() {
        return GetDiskFreeSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceA$handle() {
        return GetDiskFreeSpaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MemorySegment GetDiskFreeSpaceA$address() {
        return GetDiskFreeSpaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static int GetDiskFreeSpaceA(MemorySegment lpRootPathName, MemorySegment lpSectorsPerCluster, MemorySegment lpBytesPerSector, MemorySegment lpNumberOfFreeClusters, MemorySegment lpTotalNumberOfClusters) {
        var mh$ = GetDiskFreeSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceA", lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDiskFreeSpaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceW$descriptor() {
        return GetDiskFreeSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceW$handle() {
        return GetDiskFreeSpaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MemorySegment GetDiskFreeSpaceW$address() {
        return GetDiskFreeSpaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static int GetDiskFreeSpaceW(MemorySegment lpRootPathName, MemorySegment lpSectorsPerCluster, MemorySegment lpBytesPerSector, MemorySegment lpNumberOfFreeClusters, MemorySegment lpTotalNumberOfClusters) {
        var mh$ = GetDiskFreeSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceW", lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDiskFreeSpaceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceExA$descriptor() {
        return GetDiskFreeSpaceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceExA$handle() {
        return GetDiskFreeSpaceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MemorySegment GetDiskFreeSpaceExA$address() {
        return GetDiskFreeSpaceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static int GetDiskFreeSpaceExA(MemorySegment lpDirectoryName, MemorySegment lpFreeBytesAvailableToCaller, MemorySegment lpTotalNumberOfBytes, MemorySegment lpTotalNumberOfFreeBytes) {
        var mh$ = GetDiskFreeSpaceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceExA", lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDiskFreeSpaceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceExW$descriptor() {
        return GetDiskFreeSpaceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceExW$handle() {
        return GetDiskFreeSpaceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MemorySegment GetDiskFreeSpaceExW$address() {
        return GetDiskFreeSpaceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static int GetDiskFreeSpaceExW(MemorySegment lpDirectoryName, MemorySegment lpFreeBytesAvailableToCaller, MemorySegment lpTotalNumberOfBytes, MemorySegment lpTotalNumberOfFreeBytes) {
        var mh$ = GetDiskFreeSpaceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceExW", lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskSpaceInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDiskSpaceInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static FunctionDescriptor GetDiskSpaceInformationA$descriptor() {
        return GetDiskSpaceInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MethodHandle GetDiskSpaceInformationA$handle() {
        return GetDiskSpaceInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MemorySegment GetDiskSpaceInformationA$address() {
        return GetDiskSpaceInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static int GetDiskSpaceInformationA(MemorySegment rootPath, MemorySegment diskSpaceInfo) {
        var mh$ = GetDiskSpaceInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskSpaceInformationA", rootPath, diskSpaceInfo);
            }
            return (int)mh$.invokeExact(rootPath, diskSpaceInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskSpaceInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDiskSpaceInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static FunctionDescriptor GetDiskSpaceInformationW$descriptor() {
        return GetDiskSpaceInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MethodHandle GetDiskSpaceInformationW$handle() {
        return GetDiskSpaceInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MemorySegment GetDiskSpaceInformationW$address() {
        return GetDiskSpaceInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static int GetDiskSpaceInformationW(MemorySegment rootPath, MemorySegment diskSpaceInfo) {
        var mh$ = GetDiskSpaceInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskSpaceInformationW", rootPath, diskSpaceInfo);
            }
            return (int)mh$.invokeExact(rootPath, diskSpaceInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDriveTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDriveTypeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static FunctionDescriptor GetDriveTypeA$descriptor() {
        return GetDriveTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static MethodHandle GetDriveTypeA$handle() {
        return GetDriveTypeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static MemorySegment GetDriveTypeA$address() {
        return GetDriveTypeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static int GetDriveTypeA(MemorySegment lpRootPathName) {
        var mh$ = GetDriveTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDriveTypeA", lpRootPathName);
            }
            return (int)mh$.invokeExact(lpRootPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDriveTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetDriveTypeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static FunctionDescriptor GetDriveTypeW$descriptor() {
        return GetDriveTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static MethodHandle GetDriveTypeW$handle() {
        return GetDriveTypeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static MemorySegment GetDriveTypeW$address() {
        return GetDriveTypeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static int GetDriveTypeW(MemorySegment lpRootPathName) {
        var mh$ = GetDriveTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDriveTypeW", lpRootPathName);
            }
            return (int)mh$.invokeExact(lpRootPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     * } *LPWIN32_FILE_ATTRIBUTE_DATA
     * }
     */
    public static final AddressLayout LPWIN32_FILE_ATTRIBUTE_DATA = winapi.C_POINTER;

    private static class GetFileAttributesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileAttributesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetFileAttributesA$descriptor() {
        return GetFileAttributesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetFileAttributesA$handle() {
        return GetFileAttributesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetFileAttributesA$address() {
        return GetFileAttributesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static int GetFileAttributesA(MemorySegment lpFileName) {
        var mh$ = GetFileAttributesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileAttributesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetFileAttributesW$descriptor() {
        return GetFileAttributesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetFileAttributesW$handle() {
        return GetFileAttributesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetFileAttributesW$address() {
        return GetFileAttributesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static int GetFileAttributesW(MemorySegment lpFileName) {
        var mh$ = GetFileAttributesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileAttributesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExA$descriptor() {
        return GetFileAttributesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExA$handle() {
        return GetFileAttributesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MemorySegment GetFileAttributesExA$address() {
        return GetFileAttributesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExA", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileAttributesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExW$descriptor() {
        return GetFileAttributesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExW$handle() {
        return GetFileAttributesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MemorySegment GetFileAttributesExW$address() {
        return GetFileAttributesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExW", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BY_HANDLE_FILE_INFORMATION {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD dwVolumeSerialNumber;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD nNumberOfLinks;
     *     DWORD nFileIndexHigh;
     *     DWORD nFileIndexLow;
     * } *PBY_HANDLE_FILE_INFORMATION
     * }
     */
    public static final AddressLayout PBY_HANDLE_FILE_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BY_HANDLE_FILE_INFORMATION {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD dwVolumeSerialNumber;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD nNumberOfLinks;
     *     DWORD nFileIndexHigh;
     *     DWORD nFileIndexLow;
     * } *LPBY_HANDLE_FILE_INFORMATION
     * }
     */
    public static final AddressLayout LPBY_HANDLE_FILE_INFORMATION = winapi.C_POINTER;

    private static class GetFileInformationByHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileInformationByHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileInformationByHandle$descriptor() {
        return GetFileInformationByHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static MethodHandle GetFileInformationByHandle$handle() {
        return GetFileInformationByHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static MemorySegment GetFileInformationByHandle$address() {
        return GetFileInformationByHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static int GetFileInformationByHandle(MemorySegment hFile, MemorySegment lpFileInformation) {
        var mh$ = GetFileInformationByHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileInformationByHandle", hFile, lpFileInformation);
            }
            return (int)mh$.invokeExact(hFile, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetFileSize$descriptor() {
        return GetFileSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetFileSize$handle() {
        return GetFileSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MemorySegment GetFileSize$address() {
        return GetFileSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetFileSize(MemorySegment hFile, MemorySegment lpFileSizeHigh) {
        var mh$ = GetFileSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSize", hFile, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(hFile, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileSizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static FunctionDescriptor GetFileSizeEx$descriptor() {
        return GetFileSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static MethodHandle GetFileSizeEx$handle() {
        return GetFileSizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static MemorySegment GetFileSizeEx$address() {
        return GetFileSizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static int GetFileSizeEx(MemorySegment hFile, MemorySegment lpFileSize) {
        var mh$ = GetFileSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSizeEx", hFile, lpFileSize);
            }
            return (int)mh$.invokeExact(hFile, lpFileSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor GetFileType$descriptor() {
        return GetFileType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static MethodHandle GetFileType$handle() {
        return GetFileType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static MemorySegment GetFileType$address() {
        return GetFileType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static int GetFileType(MemorySegment hFile) {
        var mh$ = GetFileType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileType", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFinalPathNameByHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFinalPathNameByHandleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetFinalPathNameByHandleA$descriptor() {
        return GetFinalPathNameByHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetFinalPathNameByHandleA$handle() {
        return GetFinalPathNameByHandleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetFinalPathNameByHandleA$address() {
        return GetFinalPathNameByHandleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static int GetFinalPathNameByHandleA(MemorySegment hFile, MemorySegment lpszFilePath, int cchFilePath, int dwFlags) {
        var mh$ = GetFinalPathNameByHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFinalPathNameByHandleA", hFile, lpszFilePath, cchFilePath, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, lpszFilePath, cchFilePath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFinalPathNameByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFinalPathNameByHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetFinalPathNameByHandleW$descriptor() {
        return GetFinalPathNameByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetFinalPathNameByHandleW$handle() {
        return GetFinalPathNameByHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetFinalPathNameByHandleW$address() {
        return GetFinalPathNameByHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static int GetFinalPathNameByHandleW(MemorySegment hFile, MemorySegment lpszFilePath, int cchFilePath, int dwFlags) {
        var mh$ = GetFinalPathNameByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFinalPathNameByHandleW", hFile, lpszFilePath, cchFilePath, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, lpszFilePath, cchFilePath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static FunctionDescriptor GetFileTime$descriptor() {
        return GetFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static MethodHandle GetFileTime$handle() {
        return GetFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static MemorySegment GetFileTime$address() {
        return GetFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static int GetFileTime(MemorySegment hFile, MemorySegment lpCreationTime, MemorySegment lpLastAccessTime, MemorySegment lpLastWriteTime) {
        var mh$ = GetFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileTime", hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
            }
            return (int)mh$.invokeExact(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFullPathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor GetFullPathNameW$descriptor() {
        return GetFullPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MethodHandle GetFullPathNameW$handle() {
        return GetFullPathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MemorySegment GetFullPathNameW$address() {
        return GetFullPathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static int GetFullPathNameW(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = GetFullPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameW", lpFileName, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFullPathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor GetFullPathNameA$descriptor() {
        return GetFullPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MethodHandle GetFullPathNameA$handle() {
        return GetFullPathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MemorySegment GetFullPathNameA$address() {
        return GetFullPathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static int GetFullPathNameA(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = GetFullPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameA", lpFileName, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDrives {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLogicalDrives");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static FunctionDescriptor GetLogicalDrives$descriptor() {
        return GetLogicalDrives.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static MethodHandle GetLogicalDrives$handle() {
        return GetLogicalDrives.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static MemorySegment GetLogicalDrives$address() {
        return GetLogicalDrives.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static int GetLogicalDrives() {
        var mh$ = GetLogicalDrives.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDrives");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDriveStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLogicalDriveStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetLogicalDriveStringsW$descriptor() {
        return GetLogicalDriveStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetLogicalDriveStringsW$handle() {
        return GetLogicalDriveStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetLogicalDriveStringsW$address() {
        return GetLogicalDriveStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetLogicalDriveStringsW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetLogicalDriveStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDriveStringsW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLongPathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetLongPathNameA$descriptor() {
        return GetLongPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetLongPathNameA$handle() {
        return GetLongPathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetLongPathNameA$address() {
        return GetLongPathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static int GetLongPathNameA(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer) {
        var mh$ = GetLongPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameA", lpszShortPath, lpszLongPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLongPathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetLongPathNameW$descriptor() {
        return GetLongPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetLongPathNameW$handle() {
        return GetLongPathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetLongPathNameW$address() {
        return GetLongPathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static int GetLongPathNameW(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer) {
        var mh$ = GetLongPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameW", lpszShortPath, lpszLongPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreShortNamesEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AreShortNamesEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreShortNamesEnabled(HANDLE Handle, BOOL *Enabled)
     * }
     */
    public static FunctionDescriptor AreShortNamesEnabled$descriptor() {
        return AreShortNamesEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreShortNamesEnabled(HANDLE Handle, BOOL *Enabled)
     * }
     */
    public static MethodHandle AreShortNamesEnabled$handle() {
        return AreShortNamesEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AreShortNamesEnabled(HANDLE Handle, BOOL *Enabled)
     * }
     */
    public static MemorySegment AreShortNamesEnabled$address() {
        return AreShortNamesEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AreShortNamesEnabled(HANDLE Handle, BOOL *Enabled)
     * }
     */
    public static int AreShortNamesEnabled(MemorySegment Handle, MemorySegment Enabled) {
        var mh$ = AreShortNamesEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreShortNamesEnabled", Handle, Enabled);
            }
            return (int)mh$.invokeExact(Handle, Enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShortPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetShortPathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetShortPathNameW$descriptor() {
        return GetShortPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetShortPathNameW$handle() {
        return GetShortPathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetShortPathNameW$address() {
        return GetShortPathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static int GetShortPathNameW(MemorySegment lpszLongPath, MemorySegment lpszShortPath, int cchBuffer) {
        var mh$ = GetShortPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShortPathNameW", lpszLongPath, lpszShortPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszLongPath, lpszShortPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTempFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static FunctionDescriptor GetTempFileNameW$descriptor() {
        return GetTempFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static MethodHandle GetTempFileNameW$handle() {
        return GetTempFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static MemorySegment GetTempFileNameW$address() {
        return GetTempFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static int GetTempFileNameW(MemorySegment lpPathName, MemorySegment lpPrefixString, int uUnique, MemorySegment lpTempFileName) {
        var mh$ = GetTempFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempFileNameW", lpPathName, lpPrefixString, uUnique, lpTempFileName);
            }
            return (int)mh$.invokeExact(lpPathName, lpPrefixString, uUnique, lpTempFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetVolumeInformationByHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationByHandleW$descriptor() {
        return GetVolumeInformationByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationByHandleW$handle() {
        return GetVolumeInformationByHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MemorySegment GetVolumeInformationByHandleW$address() {
        return GetVolumeInformationByHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationByHandleW(MemorySegment hFile, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationByHandleW", hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetVolumeInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationW$descriptor() {
        return GetVolumeInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationW$handle() {
        return GetVolumeInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MemorySegment GetVolumeInformationW$address() {
        return GetVolumeInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationW(MemorySegment lpRootPathName, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationW", lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetVolumePathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNameW$descriptor() {
        return GetVolumePathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumePathNameW$handle() {
        return GetVolumePathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumePathNameW$address() {
        return GetVolumePathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumePathNameW(MemorySegment lpszFileName, MemorySegment lpszVolumePathName, int cchBufferLength) {
        var mh$ = GetVolumePathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNameW", lpszFileName, lpszVolumePathName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszFileName, lpszVolumePathName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFileTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LocalFileTimeToFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor LocalFileTimeToFileTime$descriptor() {
        return LocalFileTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle LocalFileTimeToFileTime$handle() {
        return LocalFileTimeToFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static MemorySegment LocalFileTimeToFileTime$address() {
        return LocalFileTimeToFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static int LocalFileTimeToFileTime(MemorySegment lpLocalFileTime, MemorySegment lpFileTime) {
        var mh$ = LocalFileTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFileTimeToFileTime", lpLocalFileTime, lpFileTime);
            }
            return (int)mh$.invokeExact(lpLocalFileTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LockFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static FunctionDescriptor LockFile$descriptor() {
        return LockFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static MethodHandle LockFile$handle() {
        return LockFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static MemorySegment LockFile$address() {
        return LockFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static int LockFile(MemorySegment hFile, int dwFileOffsetLow, int dwFileOffsetHigh, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh) {
        var mh$ = LockFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockFile", hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
            }
            return (int)mh$.invokeExact(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LockFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor LockFileEx$descriptor() {
        return LockFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle LockFileEx$handle() {
        return LockFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment LockFileEx$address() {
        return LockFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int LockFileEx(MemorySegment hFile, int dwFlags, int dwReserved, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh, MemorySegment lpOverlapped) {
        var mh$ = LockFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockFileEx", hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDosDeviceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueryDosDeviceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static FunctionDescriptor QueryDosDeviceW$descriptor() {
        return QueryDosDeviceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MethodHandle QueryDosDeviceW$handle() {
        return QueryDosDeviceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MemorySegment QueryDosDeviceW$address() {
        return QueryDosDeviceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static int QueryDosDeviceW(MemorySegment lpDeviceName, MemorySegment lpTargetPath, int ucchMax) {
        var mh$ = QueryDosDeviceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDosDeviceW", lpDeviceName, lpTargetPath, ucchMax);
            }
            return (int)mh$.invokeExact(lpDeviceName, lpTargetPath, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ReadFile$descriptor() {
        return ReadFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ReadFile$handle() {
        return ReadFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ReadFile$address() {
        return ReadFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, MemorySegment lpOverlapped) {
        var mh$ = ReadFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFile", hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor ReadFileEx$descriptor() {
        return ReadFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle ReadFileEx$handle() {
        return ReadFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment ReadFileEx$address() {
        return ReadFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int ReadFileEx(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = ReadFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFileEx", hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFileScatter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReadFileScatter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ReadFileScatter$descriptor() {
        return ReadFileScatter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ReadFileScatter$handle() {
        return ReadFileScatter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ReadFileScatter$address() {
        return ReadFileScatter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFileScatter(MemorySegment hFile, MemorySegment aSegmentArray, int nNumberOfBytesToRead, MemorySegment lpReserved, MemorySegment lpOverlapped) {
        var mh$ = ReadFileScatter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFileScatter", hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryA$descriptor() {
        return RemoveDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryA$handle() {
        return RemoveDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MemorySegment RemoveDirectoryA$address() {
        return RemoveDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryA(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryW$descriptor() {
        return RemoveDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryW$handle() {
        return RemoveDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment RemoveDirectoryW$address() {
        return RemoveDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryW(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEndOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetEndOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor SetEndOfFile$descriptor() {
        return SetEndOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static MethodHandle SetEndOfFile$handle() {
        return SetEndOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static MemorySegment SetEndOfFile$address() {
        return SetEndOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static int SetEndOfFile(MemorySegment hFile) {
        var mh$ = SetEndOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEndOfFile", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFileAttributesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesA$descriptor() {
        return SetFileAttributesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesA$handle() {
        return SetFileAttributesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MemorySegment SetFileAttributesA$address() {
        return SetFileAttributesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesA(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesA", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFileAttributesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesW$descriptor() {
        return SetFileAttributesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesW$handle() {
        return SetFileAttributesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MemorySegment SetFileAttributesW$address() {
        return SetFileAttributesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesW(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesW", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileInformationByHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFileInformationByHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static FunctionDescriptor SetFileInformationByHandle$descriptor() {
        return SetFileInformationByHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MethodHandle SetFileInformationByHandle$handle() {
        return SetFileInformationByHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MemorySegment SetFileInformationByHandle$address() {
        return SetFileInformationByHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static int SetFileInformationByHandle(MemorySegment hFile, int FileInformationClass, MemorySegment lpFileInformation, int dwBufferSize) {
        var mh$ = SetFileInformationByHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileInformationByHandle", hFile, FileInformationClass, lpFileInformation, dwBufferSize);
            }
            return (int)mh$.invokeExact(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFilePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFilePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static FunctionDescriptor SetFilePointer$descriptor() {
        return SetFilePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static MethodHandle SetFilePointer$handle() {
        return SetFilePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static MemorySegment SetFilePointer$address() {
        return SetFilePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static int SetFilePointer(MemorySegment hFile, int lDistanceToMove, MemorySegment lpDistanceToMoveHigh, int dwMoveMethod) {
        var mh$ = SetFilePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFilePointer", hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
            }
            return (int)mh$.invokeExact(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFilePointerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            _LARGE_INTEGER.layout(),
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFilePointerEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static FunctionDescriptor SetFilePointerEx$descriptor() {
        return SetFilePointerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static MethodHandle SetFilePointerEx$handle() {
        return SetFilePointerEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static MemorySegment SetFilePointerEx$address() {
        return SetFilePointerEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static int SetFilePointerEx(MemorySegment hFile, MemorySegment liDistanceToMove, MemorySegment lpNewFilePointer, int dwMoveMethod) {
        var mh$ = SetFilePointerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFilePointerEx", hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
            }
            return (int)mh$.invokeExact(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static FunctionDescriptor SetFileTime$descriptor() {
        return SetFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static MethodHandle SetFileTime$handle() {
        return SetFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static MemorySegment SetFileTime$address() {
        return SetFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static int SetFileTime(MemorySegment hFile, MemorySegment lpCreationTime, MemorySegment lpLastAccessTime, MemorySegment lpLastWriteTime) {
        var mh$ = SetFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileTime", hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
            }
            return (int)mh$.invokeExact(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileValidData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFileValidData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static FunctionDescriptor SetFileValidData$descriptor() {
        return SetFileValidData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static MethodHandle SetFileValidData$handle() {
        return SetFileValidData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static MemorySegment SetFileValidData$address() {
        return SetFileValidData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static int SetFileValidData(MemorySegment hFile, long ValidDataLength) {
        var mh$ = SetFileValidData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileValidData", hFile, ValidDataLength);
            }
            return (int)mh$.invokeExact(hFile, ValidDataLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("UnlockFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static FunctionDescriptor UnlockFile$descriptor() {
        return UnlockFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static MethodHandle UnlockFile$handle() {
        return UnlockFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static MemorySegment UnlockFile$address() {
        return UnlockFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static int UnlockFile(MemorySegment hFile, int dwFileOffsetLow, int dwFileOffsetHigh, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh) {
        var mh$ = UnlockFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockFile", hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
            }
            return (int)mh$.invokeExact(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("UnlockFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor UnlockFileEx$descriptor() {
        return UnlockFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle UnlockFileEx$handle() {
        return UnlockFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment UnlockFileEx$address() {
        return UnlockFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int UnlockFileEx(MemorySegment hFile, int dwReserved, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh, MemorySegment lpOverlapped) {
        var mh$ = UnlockFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockFileEx", hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WriteFile$descriptor() {
        return WriteFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WriteFile$handle() {
        return WriteFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WriteFile$address() {
        return WriteFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, MemorySegment lpOverlapped) {
        var mh$ = WriteFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFile", hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor WriteFileEx$descriptor() {
        return WriteFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle WriteFileEx$handle() {
        return WriteFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment WriteFileEx$address() {
        return WriteFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int WriteFileEx(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = WriteFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFileEx", hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFileGather {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WriteFileGather");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WriteFileGather$descriptor() {
        return WriteFileGather.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WriteFileGather$handle() {
        return WriteFileGather.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WriteFileGather$address() {
        return WriteFileGather.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFileGather(MemorySegment hFile, MemorySegment aSegmentArray, int nNumberOfBytesToWrite, MemorySegment lpReserved, MemorySegment lpOverlapped) {
        var mh$ = WriteFileGather.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFileGather", hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTempPathW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetTempPathW$descriptor() {
        return GetTempPathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetTempPathW$handle() {
        return GetTempPathW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetTempPathW$address() {
        return GetTempPathW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetTempPathW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetTempPathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPathW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeNameForVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetVolumeNameForVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumeNameForVolumeMountPointW$descriptor() {
        return GetVolumeNameForVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumeNameForVolumeMountPointW$handle() {
        return GetVolumeNameForVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumeNameForVolumeMountPointW$address() {
        return GetVolumeNameForVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumeNameForVolumeMountPointW(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = GetVolumeNameForVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeNameForVolumeMountPointW", lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNamesForVolumeNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetVolumePathNamesForVolumeNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNamesForVolumeNameW$descriptor() {
        return GetVolumePathNamesForVolumeNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MethodHandle GetVolumePathNamesForVolumeNameW$handle() {
        return GetVolumePathNamesForVolumeNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MemorySegment GetVolumePathNamesForVolumeNameW$address() {
        return GetVolumePathNamesForVolumeNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static int GetVolumePathNamesForVolumeNameW(MemorySegment lpszVolumeName, MemorySegment lpszVolumePathNames, int cchBufferLength, MemorySegment lpcchReturnLength) {
        var mh$ = GetVolumePathNamesForVolumeNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNamesForVolumeNameW", lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
            }
            return (int)mh$.invokeExact(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *PCREATEFILE2_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout PCREATEFILE2_EXTENDED_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *LPCREATEFILE2_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout LPCREATEFILE2_EXTENDED_PARAMETERS = winapi.C_POINTER;

    private static class CreateFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFile2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static FunctionDescriptor CreateFile2$descriptor() {
        return CreateFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MethodHandle CreateFile2$handle() {
        return CreateFile2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2$address() {
        return CreateFile2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, int dwCreationDisposition, MemorySegment pCreateExParams) {
        var mh$ = CreateFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFile2", lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileIoOverlappedRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFileIoOverlappedRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static FunctionDescriptor SetFileIoOverlappedRange$descriptor() {
        return SetFileIoOverlappedRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static MethodHandle SetFileIoOverlappedRange$handle() {
        return SetFileIoOverlappedRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static MemorySegment SetFileIoOverlappedRange$address() {
        return SetFileIoOverlappedRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static int SetFileIoOverlappedRange(MemorySegment FileHandle, MemorySegment OverlappedRangeStart, int Length) {
        var mh$ = SetFileIoOverlappedRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileIoOverlappedRange", FileHandle, OverlappedRangeStart, Length);
            }
            return (int)mh$.invokeExact(FileHandle, OverlappedRangeStart, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCompressedFileSizeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeA$descriptor() {
        return GetCompressedFileSizeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetCompressedFileSizeA$handle() {
        return GetCompressedFileSizeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MemorySegment GetCompressedFileSizeA$address() {
        return GetCompressedFileSizeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetCompressedFileSizeA(MemorySegment lpFileName, MemorySegment lpFileSizeHigh) {
        var mh$ = GetCompressedFileSizeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeA", lpFileName, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCompressedFileSizeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeW$descriptor() {
        return GetCompressedFileSizeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetCompressedFileSizeW$handle() {
        return GetCompressedFileSizeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MemorySegment GetCompressedFileSizeW$address() {
        return GetCompressedFileSizeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetCompressedFileSizeW(MemorySegment lpFileName, MemorySegment lpFileSizeHigh) {
        var mh$ = GetCompressedFileSizeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeW", lpFileName, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FindStreamInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _STREAM_INFO_LEVELS.FindStreamInfoStandard = 0
     * }
     */
    public static int FindStreamInfoStandard() {
        return FindStreamInfoStandard;
    }
    private static final int FindStreamInfoMaxInfoLevel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _STREAM_INFO_LEVELS.FindStreamInfoMaxInfoLevel = 1
     * }
     */
    public static int FindStreamInfoMaxInfoLevel() {
        return FindStreamInfoMaxInfoLevel;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_STREAM_DATA {
     *     LARGE_INTEGER StreamSize;
     *     WCHAR cStreamName[296];
     * } *PWIN32_FIND_STREAM_DATA
     * }
     */
    public static final AddressLayout PWIN32_FIND_STREAM_DATA = winapi.C_POINTER;

    private static class FindFirstStreamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstStreamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor FindFirstStreamW$descriptor() {
        return FindFirstStreamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MethodHandle FindFirstStreamW$handle() {
        return FindFirstStreamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MemorySegment FindFirstStreamW$address() {
        return FindFirstStreamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MemorySegment FindFirstStreamW(MemorySegment lpFileName, int InfoLevel, MemorySegment lpFindStreamData, int dwFlags) {
        var mh$ = FindFirstStreamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstStreamW", lpFileName, InfoLevel, lpFindStreamData, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, InfoLevel, lpFindStreamData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextStreamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNextStreamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static FunctionDescriptor FindNextStreamW$descriptor() {
        return FindNextStreamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static MethodHandle FindNextStreamW$handle() {
        return FindNextStreamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static MemorySegment FindNextStreamW$address() {
        return FindNextStreamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static int FindNextStreamW(MemorySegment hFindStream, MemorySegment lpFindStreamData) {
        var mh$ = FindNextStreamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextStreamW", hFindStream, lpFindStreamData);
            }
            return (int)mh$.invokeExact(hFindStream, lpFindStreamData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreFileApisANSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("AreFileApisANSI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static FunctionDescriptor AreFileApisANSI$descriptor() {
        return AreFileApisANSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static MethodHandle AreFileApisANSI$handle() {
        return AreFileApisANSI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static MemorySegment AreFileApisANSI$address() {
        return AreFileApisANSI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static int AreFileApisANSI() {
        var mh$ = AreFileApisANSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreFileApisANSI");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTempPathA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetTempPathA$descriptor() {
        return GetTempPathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetTempPathA$handle() {
        return GetTempPathA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MemorySegment GetTempPathA$address() {
        return GetTempPathA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetTempPathA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetTempPathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPathA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static FunctionDescriptor FindFirstFileNameW$descriptor() {
        return FindFirstFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MethodHandle FindFirstFileNameW$handle() {
        return FindFirstFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindFirstFileNameW$address() {
        return FindFirstFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindFirstFileNameW(MemorySegment lpFileName, int dwFlags, MemorySegment StringLength, MemorySegment LinkName) {
        var mh$ = FindFirstFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileNameW", lpFileName, dwFlags, StringLength, LinkName);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwFlags, StringLength, LinkName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindNextFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static FunctionDescriptor FindNextFileNameW$descriptor() {
        return FindNextFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MethodHandle FindNextFileNameW$handle() {
        return FindNextFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindNextFileNameW$address() {
        return FindNextFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static int FindNextFileNameW(MemorySegment hFindStream, MemorySegment StringLength, MemorySegment LinkName) {
        var mh$ = FindNextFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileNameW", hFindStream, StringLength, LinkName);
            }
            return (int)mh$.invokeExact(hFindStream, StringLength, LinkName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetVolumeInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationA$descriptor() {
        return GetVolumeInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationA$handle() {
        return GetVolumeInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MemorySegment GetVolumeInformationA$address() {
        return GetVolumeInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationA(MemorySegment lpRootPathName, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationA", lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTempFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static FunctionDescriptor GetTempFileNameA$descriptor() {
        return GetTempFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static MethodHandle GetTempFileNameA$handle() {
        return GetTempFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static MemorySegment GetTempFileNameA$address() {
        return GetTempFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static int GetTempFileNameA(MemorySegment lpPathName, MemorySegment lpPrefixString, int uUnique, MemorySegment lpTempFileName) {
        var mh$ = GetTempFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempFileNameA", lpPathName, lpPrefixString, uUnique, lpTempFileName);
            }
            return (int)mh$.invokeExact(lpPathName, lpPrefixString, uUnique, lpTempFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileApisToOEM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFileApisToOEM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static FunctionDescriptor SetFileApisToOEM$descriptor() {
        return SetFileApisToOEM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static MethodHandle SetFileApisToOEM$handle() {
        return SetFileApisToOEM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static MemorySegment SetFileApisToOEM$address() {
        return SetFileApisToOEM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static void SetFileApisToOEM() {
        var mh$ = SetFileApisToOEM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileApisToOEM");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileApisToANSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFileApisToANSI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static FunctionDescriptor SetFileApisToANSI$descriptor() {
        return SetFileApisToANSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static MethodHandle SetFileApisToANSI$handle() {
        return SetFileApisToANSI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static MemorySegment SetFileApisToANSI$address() {
        return SetFileApisToANSI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static void SetFileApisToANSI() {
        var mh$ = SetFileApisToANSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileApisToANSI");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPath2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTempPath2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPath2W(DWORD BufferLength, LPWSTR Buffer)
     * }
     */
    public static FunctionDescriptor GetTempPath2W$descriptor() {
        return GetTempPath2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPath2W(DWORD BufferLength, LPWSTR Buffer)
     * }
     */
    public static MethodHandle GetTempPath2W$handle() {
        return GetTempPath2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTempPath2W(DWORD BufferLength, LPWSTR Buffer)
     * }
     */
    public static MemorySegment GetTempPath2W$address() {
        return GetTempPath2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTempPath2W(DWORD BufferLength, LPWSTR Buffer)
     * }
     */
    public static int GetTempPath2W(int BufferLength, MemorySegment Buffer) {
        var mh$ = GetTempPath2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPath2W", BufferLength, Buffer);
            }
            return (int)mh$.invokeExact(BufferLength, Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPath2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetTempPath2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPath2A(DWORD BufferLength, LPSTR Buffer)
     * }
     */
    public static FunctionDescriptor GetTempPath2A$descriptor() {
        return GetTempPath2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPath2A(DWORD BufferLength, LPSTR Buffer)
     * }
     */
    public static MethodHandle GetTempPath2A$handle() {
        return GetTempPath2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTempPath2A(DWORD BufferLength, LPSTR Buffer)
     * }
     */
    public static MemorySegment GetTempPath2A$address() {
        return GetTempPath2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTempPath2A(DWORD BufferLength, LPSTR Buffer)
     * }
     */
    public static int GetTempPath2A(int BufferLength, MemorySegment Buffer) {
        var mh$ = GetTempPath2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPath2A", BufferLength, Buffer);
            }
            return (int)mh$.invokeExact(BufferLength, Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE3_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *PCREATEFILE3_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout PCREATEFILE3_EXTENDED_PARAMETERS = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE3_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *LPCREATEFILE3_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout LPCREATEFILE3_EXTENDED_PARAMETERS = winapi.C_POINTER;
    private static final int DIRECTORY_FLAGS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DIRECTORY_FLAGS.DIRECTORY_FLAGS_NONE = 0
     * }
     */
    public static int DIRECTORY_FLAGS_NONE() {
        return DIRECTORY_FLAGS_NONE;
    }
    private static final int DIRECTORY_FLAGS_DISALLOW_PATH_REDIRECTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DIRECTORY_FLAGS.DIRECTORY_FLAGS_DISALLOW_PATH_REDIRECTS = 1
     * }
     */
    public static int DIRECTORY_FLAGS_DISALLOW_PATH_REDIRECTS() {
        return DIRECTORY_FLAGS_DISALLOW_PATH_REDIRECTS;
    }

    private static class CreateFile3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFile3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFile3(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE3_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static FunctionDescriptor CreateFile3$descriptor() {
        return CreateFile3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFile3(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE3_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MethodHandle CreateFile3$handle() {
        return CreateFile3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFile3(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE3_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile3$address() {
        return CreateFile3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFile3(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE3_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile3(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, int dwCreationDisposition, MemorySegment pCreateExParams) {
        var mh$ = CreateFile3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFile3", lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectory2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDirectory2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateDirectory2A(LPCSTR lpPathName, DWORD dwDesiredAccess, DWORD dwShareMode, DIRECTORY_FLAGS DirectoryFlags, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectory2A$descriptor() {
        return CreateDirectory2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateDirectory2A(LPCSTR lpPathName, DWORD dwDesiredAccess, DWORD dwShareMode, DIRECTORY_FLAGS DirectoryFlags, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectory2A$handle() {
        return CreateDirectory2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateDirectory2A(LPCSTR lpPathName, DWORD dwDesiredAccess, DWORD dwShareMode, DIRECTORY_FLAGS DirectoryFlags, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectory2A$address() {
        return CreateDirectory2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateDirectory2A(LPCSTR lpPathName, DWORD dwDesiredAccess, DWORD dwShareMode, DIRECTORY_FLAGS DirectoryFlags, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectory2A(MemorySegment lpPathName, int dwDesiredAccess, int dwShareMode, int DirectoryFlags, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectory2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectory2A", lpPathName, dwDesiredAccess, dwShareMode, DirectoryFlags, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpPathName, dwDesiredAccess, dwShareMode, DirectoryFlags, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectory2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDirectory2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateDirectory2W(LPCWSTR lpPathName, DWORD dwDesiredAccess, DWORD dwShareMode, DIRECTORY_FLAGS DirectoryFlags, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectory2W$descriptor() {
        return CreateDirectory2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateDirectory2W(LPCWSTR lpPathName, DWORD dwDesiredAccess, DWORD dwShareMode, DIRECTORY_FLAGS DirectoryFlags, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectory2W$handle() {
        return CreateDirectory2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateDirectory2W(LPCWSTR lpPathName, DWORD dwDesiredAccess, DWORD dwShareMode, DIRECTORY_FLAGS DirectoryFlags, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectory2W$address() {
        return CreateDirectory2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateDirectory2W(LPCWSTR lpPathName, DWORD dwDesiredAccess, DWORD dwShareMode, DIRECTORY_FLAGS DirectoryFlags, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectory2W(MemorySegment lpPathName, int dwDesiredAccess, int dwShareMode, int DirectoryFlags, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectory2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectory2W", lpPathName, dwDesiredAccess, dwShareMode, DirectoryFlags, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpPathName, dwDesiredAccess, dwShareMode, DirectoryFlags, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectory2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveDirectory2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectory2A(LPCSTR lpPathName, DIRECTORY_FLAGS DirectoryFlags)
     * }
     */
    public static FunctionDescriptor RemoveDirectory2A$descriptor() {
        return RemoveDirectory2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectory2A(LPCSTR lpPathName, DIRECTORY_FLAGS DirectoryFlags)
     * }
     */
    public static MethodHandle RemoveDirectory2A$handle() {
        return RemoveDirectory2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectory2A(LPCSTR lpPathName, DIRECTORY_FLAGS DirectoryFlags)
     * }
     */
    public static MemorySegment RemoveDirectory2A$address() {
        return RemoveDirectory2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectory2A(LPCSTR lpPathName, DIRECTORY_FLAGS DirectoryFlags)
     * }
     */
    public static int RemoveDirectory2A(MemorySegment lpPathName, int DirectoryFlags) {
        var mh$ = RemoveDirectory2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectory2A", lpPathName, DirectoryFlags);
            }
            return (int)mh$.invokeExact(lpPathName, DirectoryFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectory2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveDirectory2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectory2W(LPCWSTR lpPathName, DIRECTORY_FLAGS DirectoryFlags)
     * }
     */
    public static FunctionDescriptor RemoveDirectory2W$descriptor() {
        return RemoveDirectory2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectory2W(LPCWSTR lpPathName, DIRECTORY_FLAGS DirectoryFlags)
     * }
     */
    public static MethodHandle RemoveDirectory2W$handle() {
        return RemoveDirectory2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectory2W(LPCWSTR lpPathName, DIRECTORY_FLAGS DirectoryFlags)
     * }
     */
    public static MemorySegment RemoveDirectory2W$address() {
        return RemoveDirectory2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectory2W(LPCWSTR lpPathName, DIRECTORY_FLAGS DirectoryFlags)
     * }
     */
    public static int RemoveDirectory2W(MemorySegment lpPathName, int DirectoryFlags) {
        var mh$ = RemoveDirectory2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectory2W", lpPathName, DirectoryFlags);
            }
            return (int)mh$.invokeExact(lpPathName, DirectoryFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFile2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteFile2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFile2A(LPCSTR lpFileName, DWORD Flags)
     * }
     */
    public static FunctionDescriptor DeleteFile2A$descriptor() {
        return DeleteFile2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFile2A(LPCSTR lpFileName, DWORD Flags)
     * }
     */
    public static MethodHandle DeleteFile2A$handle() {
        return DeleteFile2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFile2A(LPCSTR lpFileName, DWORD Flags)
     * }
     */
    public static MemorySegment DeleteFile2A$address() {
        return DeleteFile2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFile2A(LPCSTR lpFileName, DWORD Flags)
     * }
     */
    public static int DeleteFile2A(MemorySegment lpFileName, int Flags) {
        var mh$ = DeleteFile2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFile2A", lpFileName, Flags);
            }
            return (int)mh$.invokeExact(lpFileName, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFile2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteFile2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFile2W(LPCWSTR lpFileName, DWORD Flags)
     * }
     */
    public static FunctionDescriptor DeleteFile2W$descriptor() {
        return DeleteFile2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFile2W(LPCWSTR lpFileName, DWORD Flags)
     * }
     */
    public static MethodHandle DeleteFile2W$handle() {
        return DeleteFile2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFile2W(LPCWSTR lpFileName, DWORD Flags)
     * }
     */
    public static MemorySegment DeleteFile2W$address() {
        return DeleteFile2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFile2W(LPCWSTR lpFileName, DWORD Flags)
     * }
     */
    public static int DeleteFile2W(MemorySegment lpFileName, int Flags) {
        var mh$ = DeleteFile2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFile2W", lpFileName, Flags);
            }
            return (int)mh$.invokeExact(lpFileName, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CopyFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileFromAppW$descriptor() {
        return CopyFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileFromAppW$handle() {
        return CopyFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MemorySegment CopyFileFromAppW$address() {
        return CopyFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileFromAppW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileFromAppW", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateDirectoryFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryFromAppW$descriptor() {
        return CreateDirectoryFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryFromAppW$handle() {
        return CreateDirectoryFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryFromAppW$address() {
        return CreateDirectoryFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryFromAppW(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryFromAppW", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileFromAppW$descriptor() {
        return CreateFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileFromAppW$handle() {
        return CreateFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileFromAppW$address() {
        return CreateFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileFromAppW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileFromAppW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFile2FromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateFile2FromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static FunctionDescriptor CreateFile2FromAppW$descriptor() {
        return CreateFile2FromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MethodHandle CreateFile2FromAppW$handle() {
        return CreateFile2FromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2FromAppW$address() {
        return CreateFile2FromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2FromAppW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, int dwCreationDisposition, MemorySegment pCreateExParams) {
        var mh$ = CreateFile2FromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFile2FromAppW", lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileFromAppW$descriptor() {
        return DeleteFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileFromAppW$handle() {
        return DeleteFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment DeleteFileFromAppW$address() {
        return DeleteFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static int DeleteFileFromAppW(MemorySegment lpFileName) {
        var mh$ = DeleteFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileFromAppW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FindFirstFileExFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExFromAppW$descriptor() {
        return FindFirstFileExFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExFromAppW$handle() {
        return FindFirstFileExFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExFromAppW$address() {
        return FindFirstFileExFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExFromAppW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExFromAppW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetFileAttributesExFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExFromAppW$descriptor() {
        return GetFileAttributesExFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExFromAppW$handle() {
        return GetFileAttributesExFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MemorySegment GetFileAttributesExFromAppW$address() {
        return GetFileAttributesExFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExFromAppW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExFromAppW", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("MoveFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileFromAppW$descriptor() {
        return MoveFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileFromAppW$handle() {
        return MoveFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MemorySegment MoveFileFromAppW$address() {
        return MoveFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static int MoveFileFromAppW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileFromAppW", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveDirectoryFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryFromAppW$descriptor() {
        return RemoveDirectoryFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryFromAppW$handle() {
        return RemoveDirectoryFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment RemoveDirectoryFromAppW$address() {
        return RemoveDirectoryFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryFromAppW(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryFromAppW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReplaceFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileFromAppW$descriptor() {
        return ReplaceFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileFromAppW$handle() {
        return ReplaceFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MemorySegment ReplaceFileFromAppW$address() {
        return ReplaceFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileFromAppW(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileFromAppW", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetFileAttributesFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesFromAppW$descriptor() {
        return SetFileAttributesFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesFromAppW$handle() {
        return SetFileAttributesFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MemorySegment SetFileAttributesFromAppW$address() {
        return SetFileAttributesFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesFromAppW(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesFromAppW", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDebuggerPresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsDebuggerPresent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static FunctionDescriptor IsDebuggerPresent$descriptor() {
        return IsDebuggerPresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static MethodHandle IsDebuggerPresent$handle() {
        return IsDebuggerPresent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static MemorySegment IsDebuggerPresent$address() {
        return IsDebuggerPresent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static int IsDebuggerPresent() {
        var mh$ = IsDebuggerPresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDebuggerPresent");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = winapi.findOrThrow("DebugBreak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static FunctionDescriptor DebugBreak$descriptor() {
        return DebugBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static MethodHandle DebugBreak$handle() {
        return DebugBreak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static MemorySegment DebugBreak$address() {
        return DebugBreak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static void DebugBreak() {
        var mh$ = DebugBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugBreak");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OutputDebugStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OutputDebugStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static FunctionDescriptor OutputDebugStringA$descriptor() {
        return OutputDebugStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static MethodHandle OutputDebugStringA$handle() {
        return OutputDebugStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static MemorySegment OutputDebugStringA$address() {
        return OutputDebugStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static void OutputDebugStringA(MemorySegment lpOutputString) {
        var mh$ = OutputDebugStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OutputDebugStringA", lpOutputString);
            }
            mh$.invokeExact(lpOutputString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OutputDebugStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OutputDebugStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static FunctionDescriptor OutputDebugStringW$descriptor() {
        return OutputDebugStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static MethodHandle OutputDebugStringW$handle() {
        return OutputDebugStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static MemorySegment OutputDebugStringW$address() {
        return OutputDebugStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static void OutputDebugStringW(MemorySegment lpOutputString) {
        var mh$ = OutputDebugStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OutputDebugStringW", lpOutputString);
            }
            mh$.invokeExact(lpOutputString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ContinueDebugEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ContinueDebugEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static FunctionDescriptor ContinueDebugEvent$descriptor() {
        return ContinueDebugEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static MethodHandle ContinueDebugEvent$handle() {
        return ContinueDebugEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static MemorySegment ContinueDebugEvent$address() {
        return ContinueDebugEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static int ContinueDebugEvent(int dwProcessId, int dwThreadId, int dwContinueStatus) {
        var mh$ = ContinueDebugEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ContinueDebugEvent", dwProcessId, dwThreadId, dwContinueStatus);
            }
            return (int)mh$.invokeExact(dwProcessId, dwThreadId, dwContinueStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForDebugEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WaitForDebugEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForDebugEvent$descriptor() {
        return WaitForDebugEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForDebugEvent$handle() {
        return WaitForDebugEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForDebugEvent$address() {
        return WaitForDebugEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForDebugEvent(MemorySegment lpDebugEvent, int dwMilliseconds) {
        var mh$ = WaitForDebugEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForDebugEvent", lpDebugEvent, dwMilliseconds);
            }
            return (int)mh$.invokeExact(lpDebugEvent, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugActiveProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DebugActiveProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor DebugActiveProcess$descriptor() {
        return DebugActiveProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static MethodHandle DebugActiveProcess$handle() {
        return DebugActiveProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static MemorySegment DebugActiveProcess$address() {
        return DebugActiveProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static int DebugActiveProcess(int dwProcessId) {
        var mh$ = DebugActiveProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugActiveProcess", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugActiveProcessStop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DebugActiveProcessStop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor DebugActiveProcessStop$descriptor() {
        return DebugActiveProcessStop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static MethodHandle DebugActiveProcessStop$handle() {
        return DebugActiveProcessStop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static MemorySegment DebugActiveProcessStop$address() {
        return DebugActiveProcessStop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static int DebugActiveProcessStop(int dwProcessId) {
        var mh$ = DebugActiveProcessStop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugActiveProcessStop", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckRemoteDebuggerPresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CheckRemoteDebuggerPresent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static FunctionDescriptor CheckRemoteDebuggerPresent$descriptor() {
        return CheckRemoteDebuggerPresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static MethodHandle CheckRemoteDebuggerPresent$handle() {
        return CheckRemoteDebuggerPresent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static MemorySegment CheckRemoteDebuggerPresent$address() {
        return CheckRemoteDebuggerPresent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static int CheckRemoteDebuggerPresent(MemorySegment hProcess, MemorySegment pbDebuggerPresent) {
        var mh$ = CheckRemoteDebuggerPresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckRemoteDebuggerPresent", hProcess, pbDebuggerPresent);
            }
            return (int)mh$.invokeExact(hProcess, pbDebuggerPresent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForDebugEventEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WaitForDebugEventEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForDebugEventEx$descriptor() {
        return WaitForDebugEventEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForDebugEventEx$handle() {
        return WaitForDebugEventEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForDebugEventEx$address() {
        return WaitForDebugEventEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForDebugEventEx(MemorySegment lpDebugEvent, int dwMilliseconds) {
        var mh$ = WaitForDebugEventEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForDebugEventEx", lpDebugEvent, dwMilliseconds);
            }
            return (int)mh$.invokeExact(lpDebugEvent, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EncodePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor EncodePointer$descriptor() {
        return EncodePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MethodHandle EncodePointer$handle() {
        return EncodePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodePointer$address() {
        return EncodePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodePointer(MemorySegment Ptr) {
        var mh$ = EncodePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodePointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DecodePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor DecodePointer$descriptor() {
        return DecodePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MethodHandle DecodePointer$handle() {
        return DecodePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodePointer$address() {
        return DecodePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodePointer(MemorySegment Ptr) {
        var mh$ = DecodePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodePointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodeSystemPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EncodeSystemPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor EncodeSystemPointer$descriptor() {
        return EncodeSystemPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MethodHandle EncodeSystemPointer$handle() {
        return EncodeSystemPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodeSystemPointer$address() {
        return EncodeSystemPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodeSystemPointer(MemorySegment Ptr) {
        var mh$ = EncodeSystemPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodeSystemPointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodeSystemPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DecodeSystemPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor DecodeSystemPointer$descriptor() {
        return DecodeSystemPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MethodHandle DecodeSystemPointer$handle() {
        return DecodeSystemPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodeSystemPointer$address() {
        return DecodeSystemPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodeSystemPointer(MemorySegment Ptr) {
        var mh$ = DecodeSystemPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodeSystemPointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodeRemotePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EncodeRemotePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static FunctionDescriptor EncodeRemotePointer$descriptor() {
        return EncodeRemotePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static MethodHandle EncodeRemotePointer$handle() {
        return EncodeRemotePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static MemorySegment EncodeRemotePointer$address() {
        return EncodeRemotePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static int EncodeRemotePointer(MemorySegment ProcessHandle_, MemorySegment Ptr, MemorySegment EncodedPtr) {
        var mh$ = EncodeRemotePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodeRemotePointer", ProcessHandle_, Ptr, EncodedPtr);
            }
            return (int)mh$.invokeExact(ProcessHandle_, Ptr, EncodedPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodeRemotePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DecodeRemotePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static FunctionDescriptor DecodeRemotePointer$descriptor() {
        return DecodeRemotePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static MethodHandle DecodeRemotePointer$handle() {
        return DecodeRemotePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static MemorySegment DecodeRemotePointer$address() {
        return DecodeRemotePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static int DecodeRemotePointer(MemorySegment ProcessHandle_, MemorySegment Ptr, MemorySegment DecodedPtr) {
        var mh$ = DecodeRemotePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodeRemotePointer", ProcessHandle_, Ptr, DecodedPtr);
            }
            return (int)mh$.invokeExact(ProcessHandle_, Ptr, DecodedPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Beep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static FunctionDescriptor Beep$descriptor() {
        return Beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static MethodHandle Beep$handle() {
        return Beep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static MemorySegment Beep$address() {
        return Beep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static int Beep(int dwFreq, int dwDuration) {
        var mh$ = Beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Beep", dwFreq, dwDuration);
            }
            return (int)mh$.invokeExact(dwFreq, dwDuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CloseHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static FunctionDescriptor CloseHandle$descriptor() {
        return CloseHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MethodHandle CloseHandle$handle() {
        return CloseHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MemorySegment CloseHandle$address() {
        return CloseHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static int CloseHandle(MemorySegment hObject) {
        var mh$ = CloseHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseHandle", hObject);
            }
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DuplicateHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static FunctionDescriptor DuplicateHandle$descriptor() {
        return DuplicateHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static MethodHandle DuplicateHandle$handle() {
        return DuplicateHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static MemorySegment DuplicateHandle$address() {
        return DuplicateHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static int DuplicateHandle(MemorySegment hSourceProcessHandle, MemorySegment hSourceHandle, MemorySegment hTargetProcessHandle, MemorySegment lpTargetHandle, int dwDesiredAccess, int bInheritHandle, int dwOptions) {
        var mh$ = DuplicateHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateHandle", hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions);
            }
            return (int)mh$.invokeExact(hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareObjectHandles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CompareObjectHandles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static FunctionDescriptor CompareObjectHandles$descriptor() {
        return CompareObjectHandles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static MethodHandle CompareObjectHandles$handle() {
        return CompareObjectHandles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static MemorySegment CompareObjectHandles$address() {
        return CompareObjectHandles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static int CompareObjectHandles(MemorySegment hFirstObjectHandle, MemorySegment hSecondObjectHandle) {
        var mh$ = CompareObjectHandles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareObjectHandles", hFirstObjectHandle, hSecondObjectHandle);
            }
            return (int)mh$.invokeExact(hFirstObjectHandle, hSecondObjectHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetHandleInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetHandleInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor GetHandleInformation$descriptor() {
        return GetHandleInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle GetHandleInformation$handle() {
        return GetHandleInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static MemorySegment GetHandleInformation$address() {
        return GetHandleInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static int GetHandleInformation(MemorySegment hObject, MemorySegment lpdwFlags) {
        var mh$ = GetHandleInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetHandleInformation", hObject, lpdwFlags);
            }
            return (int)mh$.invokeExact(hObject, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetHandleInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetHandleInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetHandleInformation$descriptor() {
        return SetHandleInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetHandleInformation$handle() {
        return SetHandleInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetHandleInformation$address() {
        return SetHandleInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static int SetHandleInformation(MemorySegment hObject, int dwMask, int dwFlags) {
        var mh$ = SetHandleInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetHandleInformation", hObject, dwMask, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, dwMask, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RaiseException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static FunctionDescriptor RaiseException$descriptor() {
        return RaiseException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static MethodHandle RaiseException$handle() {
        return RaiseException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static MemorySegment RaiseException$address() {
        return RaiseException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static void RaiseException(int dwExceptionCode, int dwExceptionFlags, int nNumberOfArguments, MemorySegment lpArguments) {
        var mh$ = RaiseException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseException", dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
            }
            mh$.invokeExact(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhandledExceptionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("UnhandledExceptionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static FunctionDescriptor UnhandledExceptionFilter$descriptor() {
        return UnhandledExceptionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static MethodHandle UnhandledExceptionFilter$handle() {
        return UnhandledExceptionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static MemorySegment UnhandledExceptionFilter$address() {
        return UnhandledExceptionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static int UnhandledExceptionFilter(MemorySegment ExceptionInfo) {
        var mh$ = UnhandledExceptionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhandledExceptionFilter", ExceptionInfo);
            }
            return (int)mh$.invokeExact(ExceptionInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUnhandledExceptionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetUnhandledExceptionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static FunctionDescriptor SetUnhandledExceptionFilter$descriptor() {
        return SetUnhandledExceptionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MethodHandle SetUnhandledExceptionFilter$handle() {
        return SetUnhandledExceptionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MemorySegment SetUnhandledExceptionFilter$address() {
        return SetUnhandledExceptionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MemorySegment SetUnhandledExceptionFilter(MemorySegment lpTopLevelExceptionFilter) {
        var mh$ = SetUnhandledExceptionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUnhandledExceptionFilter", lpTopLevelExceptionFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpTopLevelExceptionFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static FunctionDescriptor GetLastError$descriptor() {
        return GetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static MethodHandle GetLastError$handle() {
        return GetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static MemorySegment GetLastError$address() {
        return GetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static int GetLastError() {
        var mh$ = GetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static FunctionDescriptor SetLastError$descriptor() {
        return SetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static MethodHandle SetLastError$handle() {
        return SetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static MemorySegment SetLastError$address() {
        return SetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static void SetLastError(int dwErrCode) {
        var mh$ = SetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLastError", dwErrCode);
            }
            mh$.invokeExact(dwErrCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static FunctionDescriptor GetErrorMode$descriptor() {
        return GetErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static MethodHandle GetErrorMode$handle() {
        return GetErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static MemorySegment GetErrorMode$address() {
        return GetErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static int GetErrorMode() {
        var mh$ = GetErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetErrorMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static FunctionDescriptor SetErrorMode$descriptor() {
        return SetErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static MethodHandle SetErrorMode$handle() {
        return SetErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static MemorySegment SetErrorMode$address() {
        return SetErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static int SetErrorMode(int uMode) {
        var mh$ = SetErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetErrorMode", uMode);
            }
            return (int)mh$.invokeExact(uMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddVectoredExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddVectoredExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static FunctionDescriptor AddVectoredExceptionHandler$descriptor() {
        return AddVectoredExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MethodHandle AddVectoredExceptionHandler$handle() {
        return AddVectoredExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredExceptionHandler$address() {
        return AddVectoredExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredExceptionHandler(int First, MemorySegment Handler) {
        var mh$ = AddVectoredExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddVectoredExceptionHandler", First, Handler);
            }
            return (MemorySegment)mh$.invokeExact(First, Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveVectoredExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveVectoredExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static FunctionDescriptor RemoveVectoredExceptionHandler$descriptor() {
        return RemoveVectoredExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static MethodHandle RemoveVectoredExceptionHandler$handle() {
        return RemoveVectoredExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static MemorySegment RemoveVectoredExceptionHandler$address() {
        return RemoveVectoredExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static int RemoveVectoredExceptionHandler(MemorySegment Handle) {
        var mh$ = RemoveVectoredExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveVectoredExceptionHandler", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddVectoredContinueHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AddVectoredContinueHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static FunctionDescriptor AddVectoredContinueHandler$descriptor() {
        return AddVectoredContinueHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MethodHandle AddVectoredContinueHandler$handle() {
        return AddVectoredContinueHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredContinueHandler$address() {
        return AddVectoredContinueHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredContinueHandler(int First, MemorySegment Handler) {
        var mh$ = AddVectoredContinueHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddVectoredContinueHandler", First, Handler);
            }
            return (MemorySegment)mh$.invokeExact(First, Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveVectoredContinueHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RemoveVectoredContinueHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static FunctionDescriptor RemoveVectoredContinueHandler$descriptor() {
        return RemoveVectoredContinueHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static MethodHandle RemoveVectoredContinueHandler$handle() {
        return RemoveVectoredContinueHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static MemorySegment RemoveVectoredContinueHandler$address() {
        return RemoveVectoredContinueHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static int RemoveVectoredContinueHandler(MemorySegment Handle) {
        var mh$ = RemoveVectoredContinueHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveVectoredContinueHandler", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseFailFastException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("RaiseFailFastException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RaiseFailFastException$descriptor() {
        return RaiseFailFastException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static MethodHandle RaiseFailFastException$handle() {
        return RaiseFailFastException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static MemorySegment RaiseFailFastException$address() {
        return RaiseFailFastException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static void RaiseFailFastException(MemorySegment pExceptionRecord, MemorySegment pContextRecord, int dwFlags) {
        var mh$ = RaiseFailFastException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseFailFastException", pExceptionRecord, pContextRecord, dwFlags);
            }
            mh$.invokeExact(pExceptionRecord, pContextRecord, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalAppExitA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FatalAppExitA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static FunctionDescriptor FatalAppExitA$descriptor() {
        return FatalAppExitA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static MethodHandle FatalAppExitA$handle() {
        return FatalAppExitA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static MemorySegment FatalAppExitA$address() {
        return FatalAppExitA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static void FatalAppExitA(int uAction, MemorySegment lpMessageText) {
        var mh$ = FatalAppExitA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalAppExitA", uAction, lpMessageText);
            }
            mh$.invokeExact(uAction, lpMessageText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalAppExitW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FatalAppExitW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static FunctionDescriptor FatalAppExitW$descriptor() {
        return FatalAppExitW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static MethodHandle FatalAppExitW$handle() {
        return FatalAppExitW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static MemorySegment FatalAppExitW$address() {
        return FatalAppExitW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static void FatalAppExitW(int uAction, MemorySegment lpMessageText) {
        var mh$ = FatalAppExitW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalAppExitW", uAction, lpMessageText);
            }
            mh$.invokeExact(uAction, lpMessageText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetThreadErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static FunctionDescriptor GetThreadErrorMode$descriptor() {
        return GetThreadErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static MethodHandle GetThreadErrorMode$handle() {
        return GetThreadErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static MemorySegment GetThreadErrorMode$address() {
        return GetThreadErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static int GetThreadErrorMode() {
        var mh$ = GetThreadErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadErrorMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetThreadErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static FunctionDescriptor SetThreadErrorMode$descriptor() {
        return SetThreadErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static MethodHandle SetThreadErrorMode$handle() {
        return SetThreadErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static MemorySegment SetThreadErrorMode$address() {
        return SetThreadErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static int SetThreadErrorMode(int dwNewMode, MemorySegment lpOldMode) {
        var mh$ = SetThreadErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadErrorMode", dwNewMode, lpOldMode);
            }
            return (int)mh$.invokeExact(dwNewMode, lpOldMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateProcessOnMemoryExhaustion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TerminateProcessOnMemoryExhaustion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static FunctionDescriptor TerminateProcessOnMemoryExhaustion$descriptor() {
        return TerminateProcessOnMemoryExhaustion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static MethodHandle TerminateProcessOnMemoryExhaustion$handle() {
        return TerminateProcessOnMemoryExhaustion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static MemorySegment TerminateProcessOnMemoryExhaustion$address() {
        return TerminateProcessOnMemoryExhaustion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static void TerminateProcessOnMemoryExhaustion(long FailedAllocationSize) {
        var mh$ = TerminateProcessOnMemoryExhaustion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateProcessOnMemoryExhaustion", FailedAllocationSize);
            }
            mh$.invokeExact(FailedAllocationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FlsAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static FunctionDescriptor FlsAlloc$descriptor() {
        return FlsAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static MethodHandle FlsAlloc$handle() {
        return FlsAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static MemorySegment FlsAlloc$address() {
        return FlsAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static int FlsAlloc(MemorySegment lpCallback) {
        var mh$ = FlsAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsAlloc", lpCallback);
            }
            return (int)mh$.invokeExact(lpCallback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsGetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FlsGetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static FunctionDescriptor FlsGetValue$descriptor() {
        return FlsGetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MethodHandle FlsGetValue$handle() {
        return FlsGetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsGetValue$address() {
        return FlsGetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsGetValue(int dwFlsIndex) {
        var mh$ = FlsGetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsGetValue", dwFlsIndex);
            }
            return (MemorySegment)mh$.invokeExact(dwFlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsSetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FlsSetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static FunctionDescriptor FlsSetValue$descriptor() {
        return FlsSetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static MethodHandle FlsSetValue$handle() {
        return FlsSetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static MemorySegment FlsSetValue$address() {
        return FlsSetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static int FlsSetValue(int dwFlsIndex, MemorySegment lpFlsData) {
        var mh$ = FlsSetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsSetValue", dwFlsIndex, lpFlsData);
            }
            return (int)mh$.invokeExact(dwFlsIndex, lpFlsData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FlsFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static FunctionDescriptor FlsFree$descriptor() {
        return FlsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static MethodHandle FlsFree$handle() {
        return FlsFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsFree$address() {
        return FlsFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static int FlsFree(int dwFlsIndex) {
        var mh$ = FlsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsFree", dwFlsIndex);
            }
            return (int)mh$.invokeExact(dwFlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsThreadAFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("IsThreadAFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static FunctionDescriptor IsThreadAFiber$descriptor() {
        return IsThreadAFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static MethodHandle IsThreadAFiber$handle() {
        return IsThreadAFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static MemorySegment IsThreadAFiber$address() {
        return IsThreadAFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static int IsThreadAFiber() {
        var mh$ = IsThreadAFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsThreadAFiber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsGetValue2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("FlsGetValue2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID FlsGetValue2(DWORD dwTlsIndex)
     * }
     */
    public static FunctionDescriptor FlsGetValue2$descriptor() {
        return FlsGetValue2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID FlsGetValue2(DWORD dwTlsIndex)
     * }
     */
    public static MethodHandle FlsGetValue2$handle() {
        return FlsGetValue2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID FlsGetValue2(DWORD dwTlsIndex)
     * }
     */
    public static MemorySegment FlsGetValue2$address() {
        return FlsGetValue2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID FlsGetValue2(DWORD dwTlsIndex)
     * }
     */
    public static MemorySegment FlsGetValue2(int dwTlsIndex) {
        var mh$ = FlsGetValue2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsGetValue2", dwTlsIndex);
            }
            return (MemorySegment)mh$.invokeExact(dwTlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreatePipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static FunctionDescriptor CreatePipe$descriptor() {
        return CreatePipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static MethodHandle CreatePipe$handle() {
        return CreatePipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static MemorySegment CreatePipe$address() {
        return CreatePipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static int CreatePipe(MemorySegment hReadPipe, MemorySegment hWritePipe, MemorySegment lpPipeAttributes, int nSize) {
        var mh$ = CreatePipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePipe", hReadPipe, hWritePipe, lpPipeAttributes, nSize);
            }
            return (int)mh$.invokeExact(hReadPipe, hWritePipe, lpPipeAttributes, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConnectNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ConnectNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ConnectNamedPipe$descriptor() {
        return ConnectNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ConnectNamedPipe$handle() {
        return ConnectNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ConnectNamedPipe$address() {
        return ConnectNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ConnectNamedPipe(MemorySegment hNamedPipe, MemorySegment lpOverlapped) {
        var mh$ = ConnectNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConnectNamedPipe", hNamedPipe, lpOverlapped);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisconnectNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DisconnectNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static FunctionDescriptor DisconnectNamedPipe$descriptor() {
        return DisconnectNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static MethodHandle DisconnectNamedPipe$handle() {
        return DisconnectNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static MemorySegment DisconnectNamedPipe$address() {
        return DisconnectNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static int DisconnectNamedPipe(MemorySegment hNamedPipe) {
        var mh$ = DisconnectNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisconnectNamedPipe", hNamedPipe);
            }
            return (int)mh$.invokeExact(hNamedPipe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetNamedPipeHandleState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetNamedPipeHandleState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static FunctionDescriptor SetNamedPipeHandleState$descriptor() {
        return SetNamedPipeHandleState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static MethodHandle SetNamedPipeHandleState$handle() {
        return SetNamedPipeHandleState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static MemorySegment SetNamedPipeHandleState$address() {
        return SetNamedPipeHandleState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static int SetNamedPipeHandleState(MemorySegment hNamedPipe, MemorySegment lpMode, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout) {
        var mh$ = SetNamedPipeHandleState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetNamedPipeHandleState", hNamedPipe, lpMode, lpMaxCollectionCount, lpCollectDataTimeout);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpMode, lpMaxCollectionCount, lpCollectDataTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PeekNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static FunctionDescriptor PeekNamedPipe$descriptor() {
        return PeekNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static MethodHandle PeekNamedPipe$handle() {
        return PeekNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static MemorySegment PeekNamedPipe$address() {
        return PeekNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static int PeekNamedPipe(MemorySegment hNamedPipe, MemorySegment lpBuffer, int nBufferSize, MemorySegment lpBytesRead, MemorySegment lpTotalBytesAvail, MemorySegment lpBytesLeftThisMessage) {
        var mh$ = PeekNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekNamedPipe", hNamedPipe, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransactNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TransactNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor TransactNamedPipe$descriptor() {
        return TransactNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle TransactNamedPipe$handle() {
        return TransactNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment TransactNamedPipe$address() {
        return TransactNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int TransactNamedPipe(MemorySegment hNamedPipe, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, MemorySegment lpOverlapped) {
        var mh$ = TransactNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransactNamedPipe", hNamedPipe, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, lpOverlapped);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateNamedPipeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateNamedPipeW$descriptor() {
        return CreateNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateNamedPipeW$handle() {
        return CreateNamedPipeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeW$address() {
        return CreateNamedPipeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeW(MemorySegment lpName, int dwOpenMode, int dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateNamedPipeW", lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WaitNamedPipeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor WaitNamedPipeW$descriptor() {
        return WaitNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MethodHandle WaitNamedPipeW$handle() {
        return WaitNamedPipeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MemorySegment WaitNamedPipeW$address() {
        return WaitNamedPipeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static int WaitNamedPipeW(MemorySegment lpNamedPipeName, int nTimeOut) {
        var mh$ = WaitNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitNamedPipeW", lpNamedPipeName, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNamedPipeClientComputerNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientComputerNameW$descriptor() {
        return GetNamedPipeClientComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MethodHandle GetNamedPipeClientComputerNameW$handle() {
        return GetNamedPipeClientComputerNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MemorySegment GetNamedPipeClientComputerNameW$address() {
        return GetNamedPipeClientComputerNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static int GetNamedPipeClientComputerNameW(MemorySegment Pipe, MemorySegment ClientComputerName, int ClientComputerNameLength) {
        var mh$ = GetNamedPipeClientComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientComputerNameW", Pipe, ClientComputerName, ClientComputerNameLength);
            }
            return (int)mh$.invokeExact(Pipe, ClientComputerName, ClientComputerNameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateNamedPipeClient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ImpersonateNamedPipeClient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static FunctionDescriptor ImpersonateNamedPipeClient$descriptor() {
        return ImpersonateNamedPipeClient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static MethodHandle ImpersonateNamedPipeClient$handle() {
        return ImpersonateNamedPipeClient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static MemorySegment ImpersonateNamedPipeClient$address() {
        return ImpersonateNamedPipeClient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static int ImpersonateNamedPipeClient(MemorySegment hNamedPipe) {
        var mh$ = ImpersonateNamedPipeClient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateNamedPipeClient", hNamedPipe);
            }
            return (int)mh$.invokeExact(hNamedPipe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNamedPipeInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static FunctionDescriptor GetNamedPipeInfo$descriptor() {
        return GetNamedPipeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static MethodHandle GetNamedPipeInfo$handle() {
        return GetNamedPipeInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static MemorySegment GetNamedPipeInfo$address() {
        return GetNamedPipeInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static int GetNamedPipeInfo(MemorySegment hNamedPipe, MemorySegment lpFlags, MemorySegment lpOutBufferSize, MemorySegment lpInBufferSize, MemorySegment lpMaxInstances) {
        var mh$ = GetNamedPipeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeInfo", hNamedPipe, lpFlags, lpOutBufferSize, lpInBufferSize, lpMaxInstances);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpFlags, lpOutBufferSize, lpInBufferSize, lpMaxInstances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeHandleStateW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetNamedPipeHandleStateW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static FunctionDescriptor GetNamedPipeHandleStateW$descriptor() {
        return GetNamedPipeHandleStateW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MethodHandle GetNamedPipeHandleStateW$handle() {
        return GetNamedPipeHandleStateW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MemorySegment GetNamedPipeHandleStateW$address() {
        return GetNamedPipeHandleStateW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static int GetNamedPipeHandleStateW(MemorySegment hNamedPipe, MemorySegment lpState, MemorySegment lpCurInstances, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout, MemorySegment lpUserName, int nMaxUserNameSize) {
        var mh$ = GetNamedPipeHandleStateW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeHandleStateW", hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CallNamedPipeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor CallNamedPipeW$descriptor() {
        return CallNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MethodHandle CallNamedPipeW$handle() {
        return CallNamedPipeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MemorySegment CallNamedPipeW$address() {
        return CallNamedPipeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static int CallNamedPipeW(MemorySegment lpNamedPipeName, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, int nTimeOut) {
        var mh$ = CallNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallNamedPipeW", lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryPerformanceCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueryPerformanceCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static FunctionDescriptor QueryPerformanceCounter$descriptor() {
        return QueryPerformanceCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static MethodHandle QueryPerformanceCounter$handle() {
        return QueryPerformanceCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static MemorySegment QueryPerformanceCounter$address() {
        return QueryPerformanceCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static int QueryPerformanceCounter(MemorySegment lpPerformanceCount) {
        var mh$ = QueryPerformanceCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryPerformanceCounter", lpPerformanceCount);
            }
            return (int)mh$.invokeExact(lpPerformanceCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryPerformanceFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueryPerformanceFrequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static FunctionDescriptor QueryPerformanceFrequency$descriptor() {
        return QueryPerformanceFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static MethodHandle QueryPerformanceFrequency$handle() {
        return QueryPerformanceFrequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static MemorySegment QueryPerformanceFrequency$address() {
        return QueryPerformanceFrequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static int QueryPerformanceFrequency(MemorySegment lpFrequency) {
        var mh$ = QueryPerformanceFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryPerformanceFrequency", lpFrequency);
            }
            return (int)mh$.invokeExact(lpFrequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _HEAP_SUMMARY {
     *     DWORD cb;
     *     SIZE_T cbAllocated;
     *     SIZE_T cbCommitted;
     *     SIZE_T cbReserved;
     *     SIZE_T cbMaxReserve;
     * } *PHEAP_SUMMARY
     * }
     */
    public static final AddressLayout PHEAP_SUMMARY = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PHEAP_SUMMARY LPHEAP_SUMMARY
     * }
     */
    public static final AddressLayout LPHEAP_SUMMARY = winapi.C_POINTER;

    private static class HeapCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static FunctionDescriptor HeapCreate$descriptor() {
        return HeapCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MethodHandle HeapCreate$handle() {
        return HeapCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MemorySegment HeapCreate$address() {
        return HeapCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MemorySegment HeapCreate(int flOptions, long dwInitialSize, long dwMaximumSize) {
        var mh$ = HeapCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapCreate", flOptions, dwInitialSize, dwMaximumSize);
            }
            return (MemorySegment)mh$.invokeExact(flOptions, dwInitialSize, dwMaximumSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapDestroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapDestroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapDestroy$descriptor() {
        return HeapDestroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapDestroy$handle() {
        return HeapDestroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static MemorySegment HeapDestroy$address() {
        return HeapDestroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static int HeapDestroy(MemorySegment hHeap) {
        var mh$ = HeapDestroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapDestroy", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor HeapAlloc$descriptor() {
        return HeapAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle HeapAlloc$handle() {
        return HeapAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapAlloc$address() {
        return HeapAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapAlloc(MemorySegment hHeap, int dwFlags, long dwBytes) {
        var mh$ = HeapAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapAlloc", hHeap, dwFlags, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(hHeap, dwFlags, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapReAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor HeapReAlloc$descriptor() {
        return HeapReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle HeapReAlloc$handle() {
        return HeapReAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapReAlloc$address() {
        return HeapReAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapReAlloc(MemorySegment hHeap, int dwFlags, MemorySegment lpMem, long dwBytes) {
        var mh$ = HeapReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapReAlloc", hHeap, dwFlags, lpMem, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(hHeap, dwFlags, lpMem, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapFree$descriptor() {
        return HeapFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static MethodHandle HeapFree$handle() {
        return HeapFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static MemorySegment HeapFree$address() {
        return HeapFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static int HeapFree(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapFree", hHeap, dwFlags, lpMem);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapSize$descriptor() {
        return HeapSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MethodHandle HeapSize$handle() {
        return HeapSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MemorySegment HeapSize$address() {
        return HeapSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static long HeapSize(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSize", hHeap, dwFlags, lpMem);
            }
            return (long)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHeap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetProcessHeap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static FunctionDescriptor GetProcessHeap$descriptor() {
        return GetProcessHeap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MethodHandle GetProcessHeap$handle() {
        return GetProcessHeap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MemorySegment GetProcessHeap$address() {
        return GetProcessHeap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MemorySegment GetProcessHeap() {
        var mh$ = GetProcessHeap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHeap");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapCompact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor HeapCompact$descriptor() {
        return HeapCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static MethodHandle HeapCompact$handle() {
        return HeapCompact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static MemorySegment HeapCompact$address() {
        return HeapCompact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static long HeapCompact(MemorySegment hHeap, int dwFlags) {
        var mh$ = HeapCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapCompact", hHeap, dwFlags);
            }
            return (long)mh$.invokeExact(hHeap, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSetInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapSetInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static FunctionDescriptor HeapSetInformation$descriptor() {
        return HeapSetInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static MethodHandle HeapSetInformation$handle() {
        return HeapSetInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static MemorySegment HeapSetInformation$address() {
        return HeapSetInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static int HeapSetInformation(MemorySegment HeapHandle, int HeapInformationClass, MemorySegment HeapInformation, long HeapInformationLength) {
        var mh$ = HeapSetInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSetInformation", HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength);
            }
            return (int)mh$.invokeExact(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapValidate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapValidate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapValidate$descriptor() {
        return HeapValidate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MethodHandle HeapValidate$handle() {
        return HeapValidate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MemorySegment HeapValidate$address() {
        return HeapValidate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static int HeapValidate(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapValidate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapValidate", hHeap, dwFlags, lpMem);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSummary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapSummary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static FunctionDescriptor HeapSummary$descriptor() {
        return HeapSummary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static MethodHandle HeapSummary$handle() {
        return HeapSummary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static MemorySegment HeapSummary$address() {
        return HeapSummary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static int HeapSummary(MemorySegment hHeap, int dwFlags, MemorySegment lpSummary) {
        var mh$ = HeapSummary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSummary", hHeap, dwFlags, lpSummary);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpSummary);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHeaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetProcessHeaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static FunctionDescriptor GetProcessHeaps$descriptor() {
        return GetProcessHeaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static MethodHandle GetProcessHeaps$handle() {
        return GetProcessHeaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static MemorySegment GetProcessHeaps$address() {
        return GetProcessHeaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static int GetProcessHeaps(int NumberOfHeaps, MemorySegment ProcessHeaps) {
        var mh$ = GetProcessHeaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHeaps", NumberOfHeaps, ProcessHeaps);
            }
            return (int)mh$.invokeExact(NumberOfHeaps, ProcessHeaps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapLock$descriptor() {
        return HeapLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapLock$handle() {
        return HeapLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static MemorySegment HeapLock$address() {
        return HeapLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static int HeapLock(MemorySegment hHeap) {
        var mh$ = HeapLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapLock", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapUnlock$descriptor() {
        return HeapUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapUnlock$handle() {
        return HeapUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static MemorySegment HeapUnlock$address() {
        return HeapUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static int HeapUnlock(MemorySegment hHeap) {
        var mh$ = HeapUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapUnlock", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapWalk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapWalk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static FunctionDescriptor HeapWalk$descriptor() {
        return HeapWalk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static MethodHandle HeapWalk$handle() {
        return HeapWalk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static MemorySegment HeapWalk$address() {
        return HeapWalk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static int HeapWalk(MemorySegment hHeap, MemorySegment lpEntry) {
        var mh$ = HeapWalk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapWalk", hHeap, lpEntry);
            }
            return (int)mh$.invokeExact(hHeap, lpEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapQueryInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("HeapQueryInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static FunctionDescriptor HeapQueryInformation$descriptor() {
        return HeapQueryInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static MethodHandle HeapQueryInformation$handle() {
        return HeapQueryInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static MemorySegment HeapQueryInformation$address() {
        return HeapQueryInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static int HeapQueryInformation(MemorySegment HeapHandle, int HeapInformationClass, MemorySegment HeapInformation, long HeapInformationLength, MemorySegment ReturnLength) {
        var mh$ = HeapQueryInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapQueryInformation", HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIoCompletionPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateIoCompletionPort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static FunctionDescriptor CreateIoCompletionPort$descriptor() {
        return CreateIoCompletionPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MethodHandle CreateIoCompletionPort$handle() {
        return CreateIoCompletionPort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MemorySegment CreateIoCompletionPort$address() {
        return CreateIoCompletionPort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MemorySegment CreateIoCompletionPort(MemorySegment FileHandle, MemorySegment ExistingCompletionPort, long CompletionKey, int NumberOfConcurrentThreads) {
        var mh$ = CreateIoCompletionPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIoCompletionPort", FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
            }
            return (MemorySegment)mh$.invokeExact(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetQueuedCompletionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatus$descriptor() {
        return GetQueuedCompletionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatus$handle() {
        return GetQueuedCompletionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment GetQueuedCompletionStatus$address() {
        return GetQueuedCompletionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static int GetQueuedCompletionStatus(MemorySegment CompletionPort, MemorySegment lpNumberOfBytesTransferred, MemorySegment lpCompletionKey, MemorySegment lpOverlapped, int dwMilliseconds) {
        var mh$ = GetQueuedCompletionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatus", CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
            }
            return (int)mh$.invokeExact(CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetQueuedCompletionStatusEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatusEx$descriptor() {
        return GetQueuedCompletionStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatusEx$handle() {
        return GetQueuedCompletionStatusEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static MemorySegment GetQueuedCompletionStatusEx$address() {
        return GetQueuedCompletionStatusEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static int GetQueuedCompletionStatusEx(MemorySegment CompletionPort, MemorySegment lpCompletionPortEntries, int ulCount, MemorySegment ulNumEntriesRemoved, int dwMilliseconds, int fAlertable) {
        var mh$ = GetQueuedCompletionStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatusEx", CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
            }
            return (int)mh$.invokeExact(CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostQueuedCompletionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("PostQueuedCompletionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor PostQueuedCompletionStatus$descriptor() {
        return PostQueuedCompletionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle PostQueuedCompletionStatus$handle() {
        return PostQueuedCompletionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment PostQueuedCompletionStatus$address() {
        return PostQueuedCompletionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int PostQueuedCompletionStatus(MemorySegment CompletionPort, int dwNumberOfBytesTransferred, long dwCompletionKey, MemorySegment lpOverlapped) {
        var mh$ = PostQueuedCompletionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostQueuedCompletionStatus", CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);
            }
            return (int)mh$.invokeExact(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceIoControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeviceIoControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor DeviceIoControl$descriptor() {
        return DeviceIoControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle DeviceIoControl$handle() {
        return DeviceIoControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment DeviceIoControl$address() {
        return DeviceIoControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int DeviceIoControl(MemorySegment hDevice, int dwIoControlCode, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesReturned, MemorySegment lpOverlapped) {
        var mh$ = DeviceIoControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceIoControl", hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
            }
            return (int)mh$.invokeExact(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetOverlappedResult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static FunctionDescriptor GetOverlappedResult$descriptor() {
        return GetOverlappedResult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MethodHandle GetOverlappedResult$handle() {
        return GetOverlappedResult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MemorySegment GetOverlappedResult$address() {
        return GetOverlappedResult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static int GetOverlappedResult(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int bWait) {
        var mh$ = GetOverlappedResult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResult", hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelIoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CancelIoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor CancelIoEx$descriptor() {
        return CancelIoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle CancelIoEx$handle() {
        return CancelIoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment CancelIoEx$address() {
        return CancelIoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int CancelIoEx(MemorySegment hFile, MemorySegment lpOverlapped) {
        var mh$ = CancelIoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelIoEx", hFile, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CancelIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor CancelIo$descriptor() {
        return CancelIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static MethodHandle CancelIo$handle() {
        return CancelIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static MemorySegment CancelIo$address() {
        return CancelIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static int CancelIo(MemorySegment hFile) {
        var mh$ = CancelIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelIo", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResultEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetOverlappedResultEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor GetOverlappedResultEx$descriptor() {
        return GetOverlappedResultEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle GetOverlappedResultEx$handle() {
        return GetOverlappedResultEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment GetOverlappedResultEx$address() {
        return GetOverlappedResultEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int GetOverlappedResultEx(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int dwMilliseconds, int bAlertable) {
        var mh$ = GetOverlappedResultEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResultEx", hFile, lpOverlapped, lpNumberOfBytesTransferred, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelSynchronousIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CancelSynchronousIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor CancelSynchronousIo$descriptor() {
        return CancelSynchronousIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static MethodHandle CancelSynchronousIo$handle() {
        return CancelSynchronousIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static MemorySegment CancelSynchronousIo$address() {
        return CancelSynchronousIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static int CancelSynchronousIo(MemorySegment hThread) {
        var mh$ = CancelSynchronousIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelSynchronousIo", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef RTL_SRWLOCK *PSRWLOCK
     * }
     */
    public static final AddressLayout PSRWLOCK = winapi.C_POINTER;

    private static class InitializeSRWLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitializeSRWLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor InitializeSRWLock$descriptor() {
        return InitializeSRWLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle InitializeSRWLock$handle() {
        return InitializeSRWLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment InitializeSRWLock$address() {
        return InitializeSRWLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static void InitializeSRWLock(MemorySegment SRWLock) {
        var mh$ = InitializeSRWLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSRWLock", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReleaseSRWLockExclusive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor ReleaseSRWLockExclusive$descriptor() {
        return ReleaseSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle ReleaseSRWLockExclusive$handle() {
        return ReleaseSRWLockExclusive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment ReleaseSRWLockExclusive$address() {
        return ReleaseSRWLockExclusive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static void ReleaseSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = ReleaseSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSRWLockExclusive", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReleaseSRWLockShared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor ReleaseSRWLockShared$descriptor() {
        return ReleaseSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle ReleaseSRWLockShared$handle() {
        return ReleaseSRWLockShared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment ReleaseSRWLockShared$address() {
        return ReleaseSRWLockShared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static void ReleaseSRWLockShared(MemorySegment SRWLock) {
        var mh$ = ReleaseSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSRWLockShared", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AcquireSRWLockExclusive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor AcquireSRWLockExclusive$descriptor() {
        return AcquireSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle AcquireSRWLockExclusive$handle() {
        return AcquireSRWLockExclusive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment AcquireSRWLockExclusive$address() {
        return AcquireSRWLockExclusive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static void AcquireSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = AcquireSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireSRWLockExclusive", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("AcquireSRWLockShared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor AcquireSRWLockShared$descriptor() {
        return AcquireSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle AcquireSRWLockShared$handle() {
        return AcquireSRWLockShared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment AcquireSRWLockShared$address() {
        return AcquireSRWLockShared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static void AcquireSRWLockShared(MemorySegment SRWLock) {
        var mh$ = AcquireSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireSRWLockShared", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryAcquireSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TryAcquireSRWLockExclusive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor TryAcquireSRWLockExclusive$descriptor() {
        return TryAcquireSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle TryAcquireSRWLockExclusive$handle() {
        return TryAcquireSRWLockExclusive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment TryAcquireSRWLockExclusive$address() {
        return TryAcquireSRWLockExclusive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static byte TryAcquireSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = TryAcquireSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryAcquireSRWLockExclusive", SRWLock);
            }
            return (byte)mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryAcquireSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_CHAR,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TryAcquireSRWLockShared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor TryAcquireSRWLockShared$descriptor() {
        return TryAcquireSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle TryAcquireSRWLockShared$handle() {
        return TryAcquireSRWLockShared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment TryAcquireSRWLockShared$address() {
        return TryAcquireSRWLockShared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static byte TryAcquireSRWLockShared(MemorySegment SRWLock) {
        var mh$ = TryAcquireSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryAcquireSRWLockShared", SRWLock);
            }
            return (byte)mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitializeCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSection$descriptor() {
        return InitializeCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle InitializeCriticalSection$handle() {
        return InitializeCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment InitializeCriticalSection$address() {
        return InitializeCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void InitializeCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = InitializeCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnterCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnterCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor EnterCriticalSection$descriptor() {
        return EnterCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle EnterCriticalSection$handle() {
        return EnterCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment EnterCriticalSection$address() {
        return EnterCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void EnterCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = EnterCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LeaveCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("LeaveCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor LeaveCriticalSection$descriptor() {
        return LeaveCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle LeaveCriticalSection$handle() {
        return LeaveCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment LeaveCriticalSection$address() {
        return LeaveCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void LeaveCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = LeaveCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LeaveCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSectionAndSpinCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitializeCriticalSectionAndSpinCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSectionAndSpinCount$descriptor() {
        return InitializeCriticalSectionAndSpinCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MethodHandle InitializeCriticalSectionAndSpinCount$handle() {
        return InitializeCriticalSectionAndSpinCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MemorySegment InitializeCriticalSectionAndSpinCount$address() {
        return InitializeCriticalSectionAndSpinCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static int InitializeCriticalSectionAndSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
        var mh$ = InitializeCriticalSectionAndSpinCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSectionAndSpinCount", lpCriticalSection, dwSpinCount);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSectionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitializeCriticalSectionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSectionEx$descriptor() {
        return InitializeCriticalSectionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static MethodHandle InitializeCriticalSectionEx$handle() {
        return InitializeCriticalSectionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static MemorySegment InitializeCriticalSectionEx$address() {
        return InitializeCriticalSectionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static int InitializeCriticalSectionEx(MemorySegment lpCriticalSection, int dwSpinCount, int Flags) {
        var mh$ = InitializeCriticalSectionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSectionEx", lpCriticalSection, dwSpinCount, Flags);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCriticalSectionSpinCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetCriticalSectionSpinCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static FunctionDescriptor SetCriticalSectionSpinCount$descriptor() {
        return SetCriticalSectionSpinCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MethodHandle SetCriticalSectionSpinCount$handle() {
        return SetCriticalSectionSpinCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MemorySegment SetCriticalSectionSpinCount$address() {
        return SetCriticalSectionSpinCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static int SetCriticalSectionSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
        var mh$ = SetCriticalSectionSpinCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCriticalSectionSpinCount", lpCriticalSection, dwSpinCount);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryEnterCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TryEnterCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor TryEnterCriticalSection$descriptor() {
        return TryEnterCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle TryEnterCriticalSection$handle() {
        return TryEnterCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment TryEnterCriticalSection$address() {
        return TryEnterCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static int TryEnterCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = TryEnterCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryEnterCriticalSection", lpCriticalSection);
            }
            return (int)mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor DeleteCriticalSection$descriptor() {
        return DeleteCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle DeleteCriticalSection$handle() {
        return DeleteCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment DeleteCriticalSection$address() {
        return DeleteCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void DeleteCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = DeleteCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PRTL_RUN_ONCE PINIT_ONCE
     * }
     */
    public static final AddressLayout PINIT_ONCE = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_RUN_ONCE LPINIT_ONCE
     * }
     */
    public static final AddressLayout LPINIT_ONCE = winapi.C_POINTER;

    private static class InitOnceInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitOnceInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static FunctionDescriptor InitOnceInitialize$descriptor() {
        return InitOnceInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static MethodHandle InitOnceInitialize$handle() {
        return InitOnceInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static MemorySegment InitOnceInitialize$address() {
        return InitOnceInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static void InitOnceInitialize(MemorySegment InitOnce) {
        var mh$ = InitOnceInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceInitialize", InitOnce);
            }
            mh$.invokeExact(InitOnce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceExecuteOnce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitOnceExecuteOnce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static FunctionDescriptor InitOnceExecuteOnce$descriptor() {
        return InitOnceExecuteOnce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static MethodHandle InitOnceExecuteOnce$handle() {
        return InitOnceExecuteOnce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static MemorySegment InitOnceExecuteOnce$address() {
        return InitOnceExecuteOnce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static int InitOnceExecuteOnce(MemorySegment InitOnce, MemorySegment InitFn, MemorySegment Parameter, MemorySegment Context) {
        var mh$ = InitOnceExecuteOnce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceExecuteOnce", InitOnce, InitFn, Parameter, Context);
            }
            return (int)mh$.invokeExact(InitOnce, InitFn, Parameter, Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceBeginInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitOnceBeginInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor InitOnceBeginInitialize$descriptor() {
        return InitOnceBeginInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static MethodHandle InitOnceBeginInitialize$handle() {
        return InitOnceBeginInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static MemorySegment InitOnceBeginInitialize$address() {
        return InitOnceBeginInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static int InitOnceBeginInitialize(MemorySegment lpInitOnce, int dwFlags, MemorySegment fPending, MemorySegment lpContext) {
        var mh$ = InitOnceBeginInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceBeginInitialize", lpInitOnce, dwFlags, fPending, lpContext);
            }
            return (int)mh$.invokeExact(lpInitOnce, dwFlags, fPending, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceComplete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitOnceComplete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static FunctionDescriptor InitOnceComplete$descriptor() {
        return InitOnceComplete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static MethodHandle InitOnceComplete$handle() {
        return InitOnceComplete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static MemorySegment InitOnceComplete$address() {
        return InitOnceComplete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static int InitOnceComplete(MemorySegment lpInitOnce, int dwFlags, MemorySegment lpContext) {
        var mh$ = InitOnceComplete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceComplete", lpInitOnce, dwFlags, lpContext);
            }
            return (int)mh$.invokeExact(lpInitOnce, dwFlags, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef RTL_CONDITION_VARIABLE *PCONDITION_VARIABLE
     * }
     */
    public static final AddressLayout PCONDITION_VARIABLE = winapi.C_POINTER;

    private static class InitializeConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitializeConditionVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor InitializeConditionVariable$descriptor() {
        return InitializeConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle InitializeConditionVariable$handle() {
        return InitializeConditionVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MemorySegment InitializeConditionVariable$address() {
        return InitializeConditionVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void InitializeConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = InitializeConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WakeConditionVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor WakeConditionVariable$descriptor() {
        return WakeConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle WakeConditionVariable$handle() {
        return WakeConditionVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MemorySegment WakeConditionVariable$address() {
        return WakeConditionVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void WakeConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = WakeConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeAllConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WakeAllConditionVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor WakeAllConditionVariable$descriptor() {
        return WakeAllConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle WakeAllConditionVariable$handle() {
        return WakeAllConditionVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MemorySegment WakeAllConditionVariable$address() {
        return WakeAllConditionVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void WakeAllConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = WakeAllConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeAllConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepConditionVariableCS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SleepConditionVariableCS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor SleepConditionVariableCS$descriptor() {
        return SleepConditionVariableCS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle SleepConditionVariableCS$handle() {
        return SleepConditionVariableCS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment SleepConditionVariableCS$address() {
        return SleepConditionVariableCS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static int SleepConditionVariableCS(MemorySegment ConditionVariable, MemorySegment CriticalSection, int dwMilliseconds) {
        var mh$ = SleepConditionVariableCS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepConditionVariableCS", ConditionVariable, CriticalSection, dwMilliseconds);
            }
            return (int)mh$.invokeExact(ConditionVariable, CriticalSection, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepConditionVariableSRW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SleepConditionVariableSRW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static FunctionDescriptor SleepConditionVariableSRW$descriptor() {
        return SleepConditionVariableSRW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static MethodHandle SleepConditionVariableSRW$handle() {
        return SleepConditionVariableSRW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static MemorySegment SleepConditionVariableSRW$address() {
        return SleepConditionVariableSRW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static int SleepConditionVariableSRW(MemorySegment ConditionVariable, MemorySegment SRWLock, int dwMilliseconds, int Flags) {
        var mh$ = SleepConditionVariableSRW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepConditionVariableSRW", ConditionVariable, SRWLock, dwMilliseconds, Flags);
            }
            return (int)mh$.invokeExact(ConditionVariable, SRWLock, dwMilliseconds, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor SetEvent$descriptor() {
        return SetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle SetEvent$handle() {
        return SetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static MemorySegment SetEvent$address() {
        return SetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static int SetEvent(MemorySegment hEvent) {
        var mh$ = SetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ResetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor ResetEvent$descriptor() {
        return ResetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle ResetEvent$handle() {
        return ResetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static MemorySegment ResetEvent$address() {
        return ResetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static int ResetEvent(MemorySegment hEvent) {
        var mh$ = ResetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSemaphore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReleaseSemaphore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static FunctionDescriptor ReleaseSemaphore$descriptor() {
        return ReleaseSemaphore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static MethodHandle ReleaseSemaphore$handle() {
        return ReleaseSemaphore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static MemorySegment ReleaseSemaphore$address() {
        return ReleaseSemaphore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static int ReleaseSemaphore(MemorySegment hSemaphore, int lReleaseCount, MemorySegment lpPreviousCount) {
        var mh$ = ReleaseSemaphore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSemaphore", hSemaphore, lReleaseCount, lpPreviousCount);
            }
            return (int)mh$.invokeExact(hSemaphore, lReleaseCount, lpPreviousCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseMutex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ReleaseMutex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static FunctionDescriptor ReleaseMutex$descriptor() {
        return ReleaseMutex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static MethodHandle ReleaseMutex$handle() {
        return ReleaseMutex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static MemorySegment ReleaseMutex$address() {
        return ReleaseMutex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static int ReleaseMutex(MemorySegment hMutex) {
        var mh$ = ReleaseMutex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseMutex", hMutex);
            }
            return (int)mh$.invokeExact(hMutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForSingleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WaitForSingleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForSingleObject$descriptor() {
        return WaitForSingleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForSingleObject$handle() {
        return WaitForSingleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForSingleObject$address() {
        return WaitForSingleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForSingleObject(MemorySegment hHandle, int dwMilliseconds) {
        var mh$ = WaitForSingleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObject", hHandle, dwMilliseconds);
            }
            return (int)mh$.invokeExact(hHandle, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SleepEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor SleepEx$descriptor() {
        return SleepEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle SleepEx$handle() {
        return SleepEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment SleepEx$address() {
        return SleepEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int SleepEx(int dwMilliseconds, int bAlertable) {
        var mh$ = SleepEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepEx", dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForSingleObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WaitForSingleObjectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor WaitForSingleObjectEx$descriptor() {
        return WaitForSingleObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle WaitForSingleObjectEx$handle() {
        return WaitForSingleObjectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment WaitForSingleObjectEx$address() {
        return WaitForSingleObjectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int WaitForSingleObjectEx(MemorySegment hHandle, int dwMilliseconds, int bAlertable) {
        var mh$ = WaitForSingleObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObjectEx", hHandle, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hHandle, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForMultipleObjectsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WaitForMultipleObjectsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor WaitForMultipleObjectsEx$descriptor() {
        return WaitForMultipleObjectsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle WaitForMultipleObjectsEx$handle() {
        return WaitForMultipleObjectsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment WaitForMultipleObjectsEx$address() {
        return WaitForMultipleObjectsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int WaitForMultipleObjectsEx(int nCount, MemorySegment lpHandles, int bWaitAll, int dwMilliseconds, int bAlertable) {
        var mh$ = WaitForMultipleObjectsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForMultipleObjectsEx", nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateMutexA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateMutexA$descriptor() {
        return CreateMutexA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateMutexA$handle() {
        return CreateMutexA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexA$address() {
        return CreateMutexA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexA(MemorySegment lpMutexAttributes, int bInitialOwner, MemorySegment lpName) {
        var mh$ = CreateMutexA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexA", lpMutexAttributes, bInitialOwner, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, bInitialOwner, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateMutexW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateMutexW$descriptor() {
        return CreateMutexW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateMutexW$handle() {
        return CreateMutexW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexW$address() {
        return CreateMutexW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexW(MemorySegment lpMutexAttributes, int bInitialOwner, MemorySegment lpName) {
        var mh$ = CreateMutexW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexW", lpMutexAttributes, bInitialOwner, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, bInitialOwner, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenMutexW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenMutexW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenMutexW$descriptor() {
        return OpenMutexW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenMutexW$handle() {
        return OpenMutexW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexW$address() {
        return OpenMutexW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenMutexW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenMutexW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateEventA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateEventA$descriptor() {
        return CreateEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateEventA$handle() {
        return CreateEventA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA$address() {
        return CreateEventA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventA", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateEventW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateEventW$descriptor() {
        return CreateEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateEventW$handle() {
        return CreateEventW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateEventW$address() {
        return CreateEventW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateEventW(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventW", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenEventA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenEventA$descriptor() {
        return OpenEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenEventA$handle() {
        return OpenEventA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenEventA$address() {
        return OpenEventA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenEventA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenEventW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenEventW$descriptor() {
        return OpenEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenEventW$handle() {
        return OpenEventW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenEventW$address() {
        return OpenEventW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenEventW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSemaphoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenSemaphoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenSemaphoreW$descriptor() {
        return OpenSemaphoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenSemaphoreW$handle() {
        return OpenSemaphoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreW$address() {
        return OpenSemaphoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenSemaphoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSemaphoreW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWaitableTimerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("OpenWaitableTimerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor OpenWaitableTimerW$descriptor() {
        return OpenWaitableTimerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MethodHandle OpenWaitableTimerW$handle() {
        return OpenWaitableTimerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerW$address() {
        return OpenWaitableTimerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpTimerName) {
        var mh$ = OpenWaitableTimerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWaitableTimerW", dwDesiredAccess, bInheritHandle, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWaitableTimerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetWaitableTimerEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static FunctionDescriptor SetWaitableTimerEx$descriptor() {
        return SetWaitableTimerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static MethodHandle SetWaitableTimerEx$handle() {
        return SetWaitableTimerEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static MemorySegment SetWaitableTimerEx$address() {
        return SetWaitableTimerEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static int SetWaitableTimerEx(MemorySegment hTimer, MemorySegment lpDueTime, int lPeriod, MemorySegment pfnCompletionRoutine, MemorySegment lpArgToCompletionRoutine, MemorySegment WakeContext, int TolerableDelay) {
        var mh$ = SetWaitableTimerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWaitableTimerEx", hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, WakeContext, TolerableDelay);
            }
            return (int)mh$.invokeExact(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, WakeContext, TolerableDelay);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWaitableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SetWaitableTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static FunctionDescriptor SetWaitableTimer$descriptor() {
        return SetWaitableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static MethodHandle SetWaitableTimer$handle() {
        return SetWaitableTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static MemorySegment SetWaitableTimer$address() {
        return SetWaitableTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static int SetWaitableTimer(MemorySegment hTimer, MemorySegment lpDueTime, int lPeriod, MemorySegment pfnCompletionRoutine, MemorySegment lpArgToCompletionRoutine, int fResume) {
        var mh$ = SetWaitableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWaitableTimer", hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
            }
            return (int)mh$.invokeExact(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelWaitableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CancelWaitableTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static FunctionDescriptor CancelWaitableTimer$descriptor() {
        return CancelWaitableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static MethodHandle CancelWaitableTimer$handle() {
        return CancelWaitableTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static MemorySegment CancelWaitableTimer$address() {
        return CancelWaitableTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static int CancelWaitableTimer(MemorySegment hTimer) {
        var mh$ = CancelWaitableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelWaitableTimer", hTimer);
            }
            return (int)mh$.invokeExact(hTimer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateMutexExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateMutexExA$descriptor() {
        return CreateMutexExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateMutexExA$handle() {
        return CreateMutexExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExA$address() {
        return CreateMutexExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExA(MemorySegment lpMutexAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateMutexExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexExA", lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateMutexExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateMutexExW$descriptor() {
        return CreateMutexExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateMutexExW$handle() {
        return CreateMutexExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExW$address() {
        return CreateMutexExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExW(MemorySegment lpMutexAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateMutexExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexExW", lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateEventExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateEventExA$descriptor() {
        return CreateEventExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateEventExA$handle() {
        return CreateEventExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExA$address() {
        return CreateEventExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExA(MemorySegment lpEventAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateEventExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventExA", lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateEventExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateEventExW$descriptor() {
        return CreateEventExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateEventExW$handle() {
        return CreateEventExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExW$address() {
        return CreateEventExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExW(MemorySegment lpEventAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateEventExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventExW", lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateSemaphoreExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreExW$descriptor() {
        return CreateSemaphoreExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateSemaphoreExW$handle() {
        return CreateSemaphoreExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExW$address() {
        return CreateSemaphoreExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExW(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateSemaphoreExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreExW", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateWaitableTimerExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerExW$descriptor() {
        return CreateWaitableTimerExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateWaitableTimerExW$handle() {
        return CreateWaitableTimerExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExW$address() {
        return CreateWaitableTimerExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExW(MemorySegment lpTimerAttributes, MemorySegment lpTimerName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateWaitableTimerExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerExW", lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER
     * }
     */
    public static final AddressLayout PSYNCHRONIZATION_BARRIER = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER
     * }
     */
    public static final AddressLayout LPSYNCHRONIZATION_BARRIER = winapi.C_POINTER;

    private static class EnterSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("EnterSynchronizationBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnterSynchronizationBarrier$descriptor() {
        return EnterSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnterSynchronizationBarrier$handle() {
        return EnterSynchronizationBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnterSynchronizationBarrier$address() {
        return EnterSynchronizationBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static int EnterSynchronizationBarrier(MemorySegment lpBarrier, int dwFlags) {
        var mh$ = EnterSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterSynchronizationBarrier", lpBarrier, dwFlags);
            }
            return (int)mh$.invokeExact(lpBarrier, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitializeSynchronizationBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static FunctionDescriptor InitializeSynchronizationBarrier$descriptor() {
        return InitializeSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static MethodHandle InitializeSynchronizationBarrier$handle() {
        return InitializeSynchronizationBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static MemorySegment InitializeSynchronizationBarrier$address() {
        return InitializeSynchronizationBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static int InitializeSynchronizationBarrier(MemorySegment lpBarrier, int lTotalThreads, int lSpinCount) {
        var mh$ = InitializeSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSynchronizationBarrier", lpBarrier, lTotalThreads, lSpinCount);
            }
            return (int)mh$.invokeExact(lpBarrier, lTotalThreads, lSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("DeleteSynchronizationBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static FunctionDescriptor DeleteSynchronizationBarrier$descriptor() {
        return DeleteSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static MethodHandle DeleteSynchronizationBarrier$handle() {
        return DeleteSynchronizationBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static MemorySegment DeleteSynchronizationBarrier$address() {
        return DeleteSynchronizationBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static int DeleteSynchronizationBarrier(MemorySegment lpBarrier) {
        var mh$ = DeleteSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteSynchronizationBarrier", lpBarrier);
            }
            return (int)mh$.invokeExact(lpBarrier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("Sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor Sleep$descriptor() {
        return Sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle Sleep$handle() {
        return Sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment Sleep$address() {
        return Sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static void Sleep(int dwMilliseconds) {
        var mh$ = Sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Sleep", dwMilliseconds);
            }
            mh$.invokeExact(dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WaitOnAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitOnAddress$descriptor() {
        return WaitOnAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitOnAddress$handle() {
        return WaitOnAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitOnAddress$address() {
        return WaitOnAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static int WaitOnAddress(MemorySegment Address, MemorySegment CompareAddress, long AddressSize, int dwMilliseconds) {
        var mh$ = WaitOnAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnAddress", Address, CompareAddress, AddressSize, dwMilliseconds);
            }
            return (int)mh$.invokeExact(Address, CompareAddress, AddressSize, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeByAddressSingle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WakeByAddressSingle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static FunctionDescriptor WakeByAddressSingle$descriptor() {
        return WakeByAddressSingle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static MethodHandle WakeByAddressSingle$handle() {
        return WakeByAddressSingle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static MemorySegment WakeByAddressSingle$address() {
        return WakeByAddressSingle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static void WakeByAddressSingle(MemorySegment Address) {
        var mh$ = WakeByAddressSingle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeByAddressSingle", Address);
            }
            mh$.invokeExact(Address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeByAddressAll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WakeByAddressAll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static FunctionDescriptor WakeByAddressAll$descriptor() {
        return WakeByAddressAll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static MethodHandle WakeByAddressAll$handle() {
        return WakeByAddressAll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static MemorySegment WakeByAddressAll$address() {
        return WakeByAddressAll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static void WakeByAddressAll(MemorySegment Address) {
        var mh$ = WakeByAddressAll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeByAddressAll", Address);
            }
            mh$.invokeExact(Address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SignalObjectAndWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("SignalObjectAndWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor SignalObjectAndWait$descriptor() {
        return SignalObjectAndWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle SignalObjectAndWait$handle() {
        return SignalObjectAndWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment SignalObjectAndWait$address() {
        return SignalObjectAndWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int SignalObjectAndWait(MemorySegment hObjectToSignal, MemorySegment hObjectToWaitOn, int dwMilliseconds, int bAlertable) {
        var mh$ = SignalObjectAndWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SignalObjectAndWait", hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForMultipleObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("WaitForMultipleObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForMultipleObjects$descriptor() {
        return WaitForMultipleObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForMultipleObjects$handle() {
        return WaitForMultipleObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForMultipleObjects$address() {
        return WaitForMultipleObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForMultipleObjects(int nCount, MemorySegment lpHandles, int bWaitAll, int dwMilliseconds) {
        var mh$ = WaitForMultipleObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForMultipleObjects", nCount, lpHandles, bWaitAll, dwMilliseconds);
            }
            return (int)mh$.invokeExact(nCount, lpHandles, bWaitAll, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateSemaphoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreW$descriptor() {
        return CreateSemaphoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateSemaphoreW$handle() {
        return CreateSemaphoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreW$address() {
        return CreateSemaphoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreW(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName) {
        var mh$ = CreateSemaphoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreW", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_INT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateWaitableTimerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerW$descriptor() {
        return CreateWaitableTimerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MethodHandle CreateWaitableTimerW$handle() {
        return CreateWaitableTimerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerW$address() {
        return CreateWaitableTimerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerW(MemorySegment lpTimerAttributes, int bManualReset, MemorySegment lpTimerName) {
        var mh$ = CreateWaitableTimerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerW", lpTimerAttributes, bManualReset, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, bManualReset, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSListHead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InitializeSListHead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InitializeSListHead$descriptor() {
        return InitializeSListHead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InitializeSListHead$handle() {
        return InitializeSListHead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InitializeSListHead$address() {
        return InitializeSListHead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static void InitializeSListHead(MemorySegment ListHead) {
        var mh$ = InitializeSListHead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSListHead", ListHead);
            }
            mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPopEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InterlockedPopEntrySList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InterlockedPopEntrySList$descriptor() {
        return InterlockedPopEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InterlockedPopEntrySList$handle() {
        return InterlockedPopEntrySList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedPopEntrySList$address() {
        return InterlockedPopEntrySList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedPopEntrySList(MemorySegment ListHead) {
        var mh$ = InterlockedPopEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPopEntrySList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPushEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InterlockedPushEntrySList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static FunctionDescriptor InterlockedPushEntrySList$descriptor() {
        return InterlockedPushEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MethodHandle InterlockedPushEntrySList$handle() {
        return InterlockedPushEntrySList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MemorySegment InterlockedPushEntrySList$address() {
        return InterlockedPushEntrySList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MemorySegment InterlockedPushEntrySList(MemorySegment ListHead, MemorySegment ListEntry) {
        var mh$ = InterlockedPushEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPushEntrySList", ListHead, ListEntry);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, ListEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPushListSListEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InterlockedPushListSListEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static FunctionDescriptor InterlockedPushListSListEx$descriptor() {
        return InterlockedPushListSListEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MethodHandle InterlockedPushListSListEx$handle() {
        return InterlockedPushListSListEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MemorySegment InterlockedPushListSListEx$address() {
        return InterlockedPushListSListEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MemorySegment InterlockedPushListSListEx(MemorySegment ListHead, MemorySegment List, MemorySegment ListEnd, int Count) {
        var mh$ = InterlockedPushListSListEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPushListSListEx", ListHead, List, ListEnd, Count);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, List, ListEnd, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedFlushSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("InterlockedFlushSList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InterlockedFlushSList$descriptor() {
        return InterlockedFlushSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InterlockedFlushSList$handle() {
        return InterlockedFlushSList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedFlushSList$address() {
        return InterlockedFlushSList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedFlushSList(MemorySegment ListHead) {
        var mh$ = InterlockedFlushSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedFlushSList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDepthSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_SHORT,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueryDepthSList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor QueryDepthSList$descriptor() {
        return QueryDepthSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle QueryDepthSList$handle() {
        return QueryDepthSList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment QueryDepthSList$address() {
        return QueryDepthSList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static short QueryDepthSList(MemorySegment ListHead) {
        var mh$ = QueryDepthSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDepthSList", ListHead);
            }
            return (short)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_INFORMATION {
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     * } *PPROCESS_INFORMATION
     * }
     */
    public static final AddressLayout PPROCESS_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_INFORMATION {
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     * } *LPPROCESS_INFORMATION
     * }
     */
    public static final AddressLayout LPPROCESS_INFORMATION = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOA {
     *     DWORD cb;
     *     LPSTR lpReserved;
     *     LPSTR lpDesktop;
     *     LPSTR lpTitle;
     *     DWORD dwX;
     *     DWORD dwY;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwXCountChars;
     *     DWORD dwYCountChars;
     *     DWORD dwFillAttribute;
     *     DWORD dwFlags;
     *     WORD wShowWindow;
     *     WORD cbReserved2;
     *     LPBYTE lpReserved2;
     *     HANDLE hStdInput;
     *     HANDLE hStdOutput;
     *     HANDLE hStdError;
     * } *LPSTARTUPINFOA
     * }
     */
    public static final AddressLayout LPSTARTUPINFOA = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOW {
     *     DWORD cb;
     *     LPWSTR lpReserved;
     *     LPWSTR lpDesktop;
     *     LPWSTR lpTitle;
     *     DWORD dwX;
     *     DWORD dwY;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwXCountChars;
     *     DWORD dwYCountChars;
     *     DWORD dwFillAttribute;
     *     DWORD dwFlags;
     *     WORD wShowWindow;
     *     WORD cbReserved2;
     *     LPBYTE lpReserved2;
     *     HANDLE hStdInput;
     *     HANDLE hStdOutput;
     *     HANDLE hStdError;
     * } *LPSTARTUPINFOW
     * }
     */
    public static final AddressLayout LPSTARTUPINFOW = winapi.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTARTUPINFOA LPSTARTUPINFO
     * }
     */
    public static final AddressLayout LPSTARTUPINFO = winapi.C_POINTER;

    private static class QueueUserAPC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueueUserAPC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor QueueUserAPC$descriptor() {
        return QueueUserAPC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle QueueUserAPC$handle() {
        return QueueUserAPC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static MemorySegment QueueUserAPC$address() {
        return QueueUserAPC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static int QueueUserAPC(MemorySegment pfnAPC, MemorySegment hThread, long dwData) {
        var mh$ = QueueUserAPC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueueUserAPC", pfnAPC, hThread, dwData);
            }
            return (int)mh$.invokeExact(pfnAPC, hThread, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int QUEUE_USER_APC_FLAGS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _QUEUE_USER_APC_FLAGS.QUEUE_USER_APC_FLAGS_NONE = 0
     * }
     */
    public static int QUEUE_USER_APC_FLAGS_NONE() {
        return QUEUE_USER_APC_FLAGS_NONE;
    }
    private static final int QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _QUEUE_USER_APC_FLAGS.QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC = 1
     * }
     */
    public static int QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC() {
        return QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC;
    }
    private static final int QUEUE_USER_APC_CALLBACK_DATA_CONTEXT = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum _QUEUE_USER_APC_FLAGS.QUEUE_USER_APC_CALLBACK_DATA_CONTEXT = 65536
     * }
     */
    public static int QUEUE_USER_APC_CALLBACK_DATA_CONTEXT() {
        return QUEUE_USER_APC_CALLBACK_DATA_CONTEXT;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _APC_CALLBACK_DATA {
     *     ULONG_PTR Parameter;
     *     PCONTEXT ContextRecord;
     *     ULONG_PTR Reserved0;
     *     ULONG_PTR Reserved1;
     * } *PAPC_CALLBACK_DATA
     * }
     */
    public static final AddressLayout PAPC_CALLBACK_DATA = winapi.C_POINTER;

    private static class QueueUserAPC2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("QueueUserAPC2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueueUserAPC2(PAPCFUNC ApcRoutine, HANDLE Thread, ULONG_PTR Data, QUEUE_USER_APC_FLAGS Flags)
     * }
     */
    public static FunctionDescriptor QueueUserAPC2$descriptor() {
        return QueueUserAPC2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueueUserAPC2(PAPCFUNC ApcRoutine, HANDLE Thread, ULONG_PTR Data, QUEUE_USER_APC_FLAGS Flags)
     * }
     */
    public static MethodHandle QueueUserAPC2$handle() {
        return QueueUserAPC2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueueUserAPC2(PAPCFUNC ApcRoutine, HANDLE Thread, ULONG_PTR Data, QUEUE_USER_APC_FLAGS Flags)
     * }
     */
    public static MemorySegment QueueUserAPC2$address() {
        return QueueUserAPC2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueueUserAPC2(PAPCFUNC ApcRoutine, HANDLE Thread, ULONG_PTR Data, QUEUE_USER_APC_FLAGS Flags)
     * }
     */
    public static int QueueUserAPC2(MemorySegment ApcRoutine, MemorySegment Thread_, long Data, int Flags) {
        var mh$ = QueueUserAPC2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueueUserAPC2", ApcRoutine, Thread_, Data, Flags);
            }
            return (int)mh$.invokeExact(ApcRoutine, Thread_, Data, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetProcessTimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetProcessTimes$descriptor() {
        return GetProcessTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetProcessTimes$handle() {
        return GetProcessTimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MemorySegment GetProcessTimes$address() {
        return GetProcessTimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static int GetProcessTimes(MemorySegment hProcess, MemorySegment lpCreationTime, MemorySegment lpExitTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetProcessTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessTimes", hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrentProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static FunctionDescriptor GetCurrentProcess$descriptor() {
        return GetCurrentProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MethodHandle GetCurrentProcess$handle() {
        return GetCurrentProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MemorySegment GetCurrentProcess$address() {
        return GetCurrentProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MemorySegment GetCurrentProcess() {
        var mh$ = GetCurrentProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcess");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_LONG    );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetCurrentProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static FunctionDescriptor GetCurrentProcessId$descriptor() {
        return GetCurrentProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static MethodHandle GetCurrentProcessId$handle() {
        return GetCurrentProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static MemorySegment GetCurrentProcessId$address() {
        return GetCurrentProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static int GetCurrentProcessId() {
        var mh$ = GetCurrentProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("ExitProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static FunctionDescriptor ExitProcess$descriptor() {
        return ExitProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static MethodHandle ExitProcess$handle() {
        return ExitProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static MemorySegment ExitProcess$address() {
        return ExitProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static void ExitProcess(int uExitCode) {
        var mh$ = ExitProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitProcess", uExitCode);
            }
            mh$.invokeExact(uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_INT
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("TerminateProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static FunctionDescriptor TerminateProcess$descriptor() {
        return TerminateProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static MethodHandle TerminateProcess$handle() {
        return TerminateProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static MemorySegment TerminateProcess$address() {
        return TerminateProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static int TerminateProcess(MemorySegment hProcess, int uExitCode) {
        var mh$ = TerminateProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateProcess", hProcess, uExitCode);
            }
            return (int)mh$.invokeExact(hProcess, uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExitCodeProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT,
            winapi.C_POINTER,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("GetExitCodeProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static FunctionDescriptor GetExitCodeProcess$descriptor() {
        return GetExitCodeProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static MethodHandle GetExitCodeProcess$handle() {
        return GetExitCodeProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static MemorySegment GetExitCodeProcess$address() {
        return GetExitCodeProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static int GetExitCodeProcess(MemorySegment hProcess, MemorySegment lpExitCode) {
        var mh$ = GetExitCodeProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExitCodeProcess", hProcess, lpExitCode);
            }
            return (int)mh$.invokeExact(hProcess, lpExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_INT    );

        public static final MemorySegment ADDR = winapi.findOrThrow("SwitchToThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static FunctionDescriptor SwitchToThread$descriptor() {
        return SwitchToThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static MethodHandle SwitchToThread$handle() {
        return SwitchToThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static MemorySegment SwitchToThread$address() {
        return SwitchToThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static int SwitchToThread() {
        var mh$ = SwitchToThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG_LONG,
            winapi.C_POINTER,
            winapi.C_POINTER,
            winapi.C_LONG,
            winapi.C_POINTER
        );

        public static final MemorySegment ADDR = winapi.findOrThrow("CreateThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateThread$descriptor() {
        return CreateThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateThread$handle() {
        return CreateThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateThread$address() {
        return CreateThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateThread(MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpThreadId) {
        var mh$ = CreateThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThread", lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

